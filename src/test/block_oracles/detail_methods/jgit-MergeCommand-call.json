{
  "origin": "codeshovel",
  "repositoryName": "jgit",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/jgit/.git",
  "startCommitName": "bd1a82502680b5de5bf86f6c4470185fd1602386",
  "sourceFileName": "MergeCommand.java",
  "functionName": "call",
  "functionId": "call",
  "sourceFilePath": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
  "functionAnnotation": "@Override,@SuppressWarnings(\"boxing\")",
  "functionDoc": "@inheritDoc}\n\u003cp\u003e\nExecute the {@code Merge} command with all the options and parameters\ncollected by the setter methods (e.g. {@link #include(Ref)}) of this\nclass. Each instance of this class should only be used for one invocation\nof the command. Don\u0027t call this method twice on an instance.\n",
  "functionStartLine": 235,
  "functionEndLine": 444,
  "numCommitsSeen": 53,
  "timeTaken": 2911,
  "changeHistory": [
    "f6c4a492d06e0dd345679bfba3399dabbf778f41",
    "42e69409d796421bb1353279cfae463b19a43fe9",
    "2c29af786763c0c8d74741c86edbeff4e5140e35",
    "1c43af8b9794abcad7a4ac77c352626063aa1f05",
    "0210e0e299bed69176e0a929d0b67f3cf9fb1e37",
    "b13a285098305149b34924bce2679a0cd98d9b2c",
    "7ac182f4e427e0d5a986b8ca67a56fc22828b1a0",
    "64a404803eaccc88d7d57567c5cd86b88c342bec",
    "4c236ff4bbf664fd177a33f42517b0eef52510c8",
    "1e1fb9fc596603a44b0fff6d19eeba2b005d659d",
    "0e73d395061d1bfee365acaa2f79c392175d13bf",
    "46f3007b52a5d12c5a973957128ac38680b20ab8",
    "48e36d8cb335382b99ec829d0dfe34be71ed49bb",
    "7dc8a4f089c1ca4762cf6fbf2e77898607a5820a",
    "545358577376bec8fc140a76ce0f72bf81cc0a94",
    "3a4ebc0c24b7732a57064299153794084fbfae59",
    "eb6093293022e468c2aea93a11f63b366e0d3891",
    "642ff2cd7dd6ae361e4993255ade89a32e20601f",
    "c310fa0c802f40a774edb58641de3ac5bfad0e2c",
    "318f3d464307e3efd8342852310c17e71a7282fe",
    "2656ac1b5acb9b73c6b47e2cf8830a0a0b2cc214",
    "4e1454ded6e2fcf6cb789c004756883c3ea5f77e",
    "26b573862912b2faf3824bb18dfeb44a3b700014",
    "39ad503fcb0c293e9c6d47d653a0d52456d4760b",
    "4f4e468f6f344ed7c106b86b850d2c9171dd1a0f",
    "c580c56c4def9639b603553b3d4cbc7117a30938",
    "5dbef3fa51053b37f68b44ed390cab6dc8336dcc",
    "dcf7bd9a8f7acafbd1461dc0414aded2db030983",
    "85f69c286b6c3225dcff05aba42910daefb28da0",
    "e43887b69e27672b80e55391e0ee255efe715ab9",
    "6290ca3a638d1ac999da6c11628f904b31972067",
    "fb1e500adc011dfaad1a6e68b23a9b254a77bf43",
    "67263e2056108e471d684c3cef9e719724b51220",
    "45e79a526c7ffebaf8e4758a6cb6b7af05716707",
    "5fc990130bbd3cf3a0d505c0e12132ec0ecd6b75",
    "75c9b2438594dc6ac125ff1bdf97022c7f429b78",
    "515deaf7e503738b4c53c3c2dfd6d7acab3bef18",
    "5b0e73b849d19c9f072c4c6738a5d5adae413112"
  ],
  "changeHistoryShort": {
    "f6c4a492d06e0dd345679bfba3399dabbf778f41": "Ybodychange",
    "42e69409d796421bb1353279cfae463b19a43fe9": "Ybodychange",
    "2c29af786763c0c8d74741c86edbeff4e5140e35": "Ybodychange",
    "1c43af8b9794abcad7a4ac77c352626063aa1f05": "Ybodychange",
    "0210e0e299bed69176e0a929d0b67f3cf9fb1e37": "Ydocchange",
    "b13a285098305149b34924bce2679a0cd98d9b2c": "Ybodychange",
    "7ac182f4e427e0d5a986b8ca67a56fc22828b1a0": "Yannotationchange",
    "64a404803eaccc88d7d57567c5cd86b88c342bec": "Ybodychange",
    "4c236ff4bbf664fd177a33f42517b0eef52510c8": "Ybodychange",
    "1e1fb9fc596603a44b0fff6d19eeba2b005d659d": "Ybodychange",
    "0e73d395061d1bfee365acaa2f79c392175d13bf": "Ybodychange",
    "46f3007b52a5d12c5a973957128ac38680b20ab8": "Ybodychange",
    "48e36d8cb335382b99ec829d0dfe34be71ed49bb": "Ymultichange(Ybodychange,Yannotationchange)",
    "7dc8a4f089c1ca4762cf6fbf2e77898607a5820a": "Ybodychange",
    "545358577376bec8fc140a76ce0f72bf81cc0a94": "Ybodychange",
    "3a4ebc0c24b7732a57064299153794084fbfae59": "Ybodychange",
    "eb6093293022e468c2aea93a11f63b366e0d3891": "Ybodychange",
    "642ff2cd7dd6ae361e4993255ade89a32e20601f": "Ybodychange",
    "c310fa0c802f40a774edb58641de3ac5bfad0e2c": "Ybodychange",
    "318f3d464307e3efd8342852310c17e71a7282fe": "Ybodychange",
    "2656ac1b5acb9b73c6b47e2cf8830a0a0b2cc214": "Ybodychange",
    "4e1454ded6e2fcf6cb789c004756883c3ea5f77e": "Yexceptionschange",
    "26b573862912b2faf3824bb18dfeb44a3b700014": "Ybodychange",
    "39ad503fcb0c293e9c6d47d653a0d52456d4760b": "Ybodychange",
    "4f4e468f6f344ed7c106b86b850d2c9171dd1a0f": "Ybodychange",
    "c580c56c4def9639b603553b3d4cbc7117a30938": "Ybodychange",
    "5dbef3fa51053b37f68b44ed390cab6dc8336dcc": "Ybodychange",
    "dcf7bd9a8f7acafbd1461dc0414aded2db030983": "Ybodychange",
    "85f69c286b6c3225dcff05aba42910daefb28da0": "Ybodychange",
    "e43887b69e27672b80e55391e0ee255efe715ab9": "Ybodychange",
    "6290ca3a638d1ac999da6c11628f904b31972067": "Ybodychange",
    "fb1e500adc011dfaad1a6e68b23a9b254a77bf43": "Ybodychange",
    "67263e2056108e471d684c3cef9e719724b51220": "Ybodychange",
    "45e79a526c7ffebaf8e4758a6cb6b7af05716707": "Ymultichange(Yexceptionschange,Ybodychange)",
    "5fc990130bbd3cf3a0d505c0e12132ec0ecd6b75": "Ybodychange",
    "75c9b2438594dc6ac125ff1bdf97022c7f429b78": "Ybodychange",
    "515deaf7e503738b4c53c3c2dfd6d7acab3bef18": "Ybodychange",
    "5b0e73b849d19c9f072c4c6738a5d5adae413112": "Yintroduced"
  },
  "changeHistoryDetails": {
    "f6c4a492d06e0dd345679bfba3399dabbf778f41": {
      "type": "Ybodychange",
      "commitMessage": "Repository: Deprecate #peel method\n\nCallers should use getRefDatabase().peel(ref) instead since it\ndoesn\u0027t swallow the IOException.\n\nAdapt all trivial callers to user the alternative.\n\nDescribeCommand still uses the deprecated method and is not adapted in\nthis change since it will require more refactoring to add handling of\nthe IOException.\n\nChange-Id: I14d4a95a5e0570548753b9fc5c03d024dc3ff832\nSigned-off-by: David Pursehouse \u003cdavid.pursehouse@gmail.com\u003e\n",
      "commitDate": "2018/5/22 上午10:49",
      "commitName": "f6c4a492d06e0dd345679bfba3399dabbf778f41",
      "commitAuthor": "David Pursehouse",
      "commitDateOld": "2018/4/19 上午5:33",
      "commitNameOld": "42e69409d796421bb1353279cfae463b19a43fe9",
      "commitAuthorOld": "Thomas Wolf",
      "daysBetweenCommits": 33.22,
      "commitsBetweenForRepo": 53,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"boxing\")\npublic MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    fallBackToConfiguration();\n    checkParameters();\n    DirCacheCheckout dco \u003d null;\n    try (RevWalk revWalk \u003d new RevWalk(repo)) {\n        Ref head \u003d repo.exactRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n        Ref ref \u003d commits.get(0);\n        refLogMessage.append(ref.getName());\n        ref \u003d repo.getRefDatabase().peel(ref);\n        ObjectId objectId \u003d ref.getPeeledObjectId();\n        if (objectId \u003d\u003d null)\n            objectId \u003d ref.getObjectId();\n        RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n        ObjectId headId \u003d head.getObjectId();\n        if (headId \u003d\u003d null) {\n            revWalk.parseHeaders(srcCommit);\n            dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.setProgressMonitor(monitor);\n            dco.checkout();\n            RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() !\u003d Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit) \u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setProgressMonitor(monitor);\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            String msg \u003d null;\n            ObjectId newHead, base \u003d null;\n            MergeStatus mergeStatus \u003d null;\n            if (!squash) {\n                updateHead(refLogMessage, srcCommit, headId);\n                newHead \u003d base \u003d srcCommit;\n                mergeStatus \u003d MergeStatus.FAST_FORWARD;\n            } else {\n                msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                newHead \u003d base \u003d headId;\n                mergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n                List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            setCallable(false);\n            return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n        } else {\n            if (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n                return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n            }\n            String mergeMessage \u003d \"\";\n            if (!squash) {\n                if (message !\u003d null)\n                    mergeMessage \u003d message;\n                else\n                    mergeMessage \u003d new MergeMessageFormatter().format(commits, head);\n                repo.writeMergeCommitMsg(mergeMessage);\n                repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            } else {\n                List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            Merger merger \u003d mergeStrategy.newMerger(repo);\n            merger.setProgressMonitor(monitor);\n            boolean noProblems;\n            Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n            Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n            List\u003cString\u003e unmergedPaths \u003d null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n                lowLevelResults \u003d resolveMerger.getMergeResults();\n                failingPaths \u003d resolveMerger.getFailingPaths();\n                unmergedPaths \u003d resolveMerger.getUnmergedPaths();\n                if (!resolveMerger.getModifiedFiles().isEmpty()) {\n                    repo.fireEvent(new WorkingTreeModifiedEvent(resolveMerger.getModifiedFiles(), null));\n                }\n            } else\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n            refLogMessage.append(\": Merge made by \");\n            if (!revWalk.isMergedInto(headCommit, srcCommit))\n                refLogMessage.append(mergeStrategy.getName());\n            else\n                refLogMessage.append(\"recursive\");\n            refLogMessage.append(\u0027.\u0027);\n            if (noProblems) {\n                dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.setProgressMonitor(monitor);\n                dco.checkout();\n                String msg \u003d null;\n                ObjectId newHeadId \u003d null;\n                MergeStatus mergeStatus \u003d null;\n                if (!commit \u0026\u0026 squash) {\n                    mergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n                }\n                if (!commit \u0026\u0026 !squash) {\n                    mergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n                }\n                if (commit \u0026\u0026 !squash) {\n                    try (Git git \u003d new Git(getRepository())) {\n                        newHeadId \u003d git.commit().setReflogComment(refLogMessage.toString()).setInsertChangeId(insertChangeId).call().getId();\n                    }\n                    mergeStatus \u003d MergeStatus.MERGED;\n                    getRepository().autoGC(monitor);\n                }\n                if (commit \u0026\u0026 squash) {\n                    msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                    newHeadId \u003d headCommit.getId();\n                    mergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n                }\n                return new MergeResult(newHeadId, null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n            } else {\n                if (failingPaths !\u003d null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else {\n                    String mergeMessageWithConflicts \u003d new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                    repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                }\n            }\n        }\n    } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n        List\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections.\u003cString\u003eemptyList() : dco.getConflicts();\n        throw new CheckoutConflictException(conflicts, e);\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 235,
      "functionName": "call",
      "functionAnnotation": "@Override,@SuppressWarnings(\"boxing\")",
      "functionDoc": "@inheritDoc}\n\u003cp\u003e\nExecute the {@code Merge} command with all the options and parameters\ncollected by the setter methods (e.g. {@link #include(Ref)}) of this\nclass. Each instance of this class should only be used for one invocation\nof the command. Don\u0027t call this method twice on an instance.\n",
      "diff": "@@ -1,150 +1,150 @@\n @Override\n @SuppressWarnings(\"boxing\")\n public MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n     checkCallable();\n     fallBackToConfiguration();\n     checkParameters();\n     DirCacheCheckout dco \u003d null;\n     try (RevWalk revWalk \u003d new RevWalk(repo)) {\n         Ref head \u003d repo.exactRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n         Ref ref \u003d commits.get(0);\n         refLogMessage.append(ref.getName());\n-        ref \u003d repo.peel(ref);\n+        ref \u003d repo.getRefDatabase().peel(ref);\n         ObjectId objectId \u003d ref.getPeeledObjectId();\n         if (objectId \u003d\u003d null)\n             objectId \u003d ref.getObjectId();\n         RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n         ObjectId headId \u003d head.getObjectId();\n         if (headId \u003d\u003d null) {\n             revWalk.parseHeaders(srcCommit);\n             dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n             dco.setFailOnConflict(true);\n             dco.setProgressMonitor(monitor);\n             dco.checkout();\n             RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n             refUpdate.setNewObjectId(objectId);\n             refUpdate.setExpectedOldObjectId(null);\n             refUpdate.setRefLogMessage(\"initial pull\", false);\n             if (refUpdate.update() !\u003d Result.NEW)\n                 throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n             setCallable(false);\n             return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n         }\n         RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n         if (revWalk.isMergedInto(srcCommit, headCommit)) {\n             setCallable(false);\n             return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n         } else if (revWalk.isMergedInto(headCommit, srcCommit) \u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n             refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n             dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n             dco.setProgressMonitor(monitor);\n             dco.setFailOnConflict(true);\n             dco.checkout();\n             String msg \u003d null;\n             ObjectId newHead, base \u003d null;\n             MergeStatus mergeStatus \u003d null;\n             if (!squash) {\n                 updateHead(refLogMessage, srcCommit, headId);\n                 newHead \u003d base \u003d srcCommit;\n                 mergeStatus \u003d MergeStatus.FAST_FORWARD;\n             } else {\n                 msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                 newHead \u003d base \u003d headId;\n                 mergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n                 List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                 String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                 repo.writeSquashCommitMsg(squashMessage);\n             }\n             setCallable(false);\n             return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n         } else {\n             if (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n                 return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n             }\n             String mergeMessage \u003d \"\";\n             if (!squash) {\n                 if (message !\u003d null)\n                     mergeMessage \u003d message;\n                 else\n                     mergeMessage \u003d new MergeMessageFormatter().format(commits, head);\n                 repo.writeMergeCommitMsg(mergeMessage);\n                 repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n             } else {\n                 List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                 String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                 repo.writeSquashCommitMsg(squashMessage);\n             }\n             Merger merger \u003d mergeStrategy.newMerger(repo);\n             merger.setProgressMonitor(monitor);\n             boolean noProblems;\n             Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n             Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n             List\u003cString\u003e unmergedPaths \u003d null;\n             if (merger instanceof ResolveMerger) {\n                 ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                 resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                 resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n                 lowLevelResults \u003d resolveMerger.getMergeResults();\n                 failingPaths \u003d resolveMerger.getFailingPaths();\n                 unmergedPaths \u003d resolveMerger.getUnmergedPaths();\n                 if (!resolveMerger.getModifiedFiles().isEmpty()) {\n                     repo.fireEvent(new WorkingTreeModifiedEvent(resolveMerger.getModifiedFiles(), null));\n                 }\n             } else\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n             refLogMessage.append(\": Merge made by \");\n             if (!revWalk.isMergedInto(headCommit, srcCommit))\n                 refLogMessage.append(mergeStrategy.getName());\n             else\n                 refLogMessage.append(\"recursive\");\n             refLogMessage.append(\u0027.\u0027);\n             if (noProblems) {\n                 dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                 dco.setFailOnConflict(true);\n                 dco.setProgressMonitor(monitor);\n                 dco.checkout();\n                 String msg \u003d null;\n                 ObjectId newHeadId \u003d null;\n                 MergeStatus mergeStatus \u003d null;\n                 if (!commit \u0026\u0026 squash) {\n                     mergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n                 }\n                 if (!commit \u0026\u0026 !squash) {\n                     mergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n                 }\n                 if (commit \u0026\u0026 !squash) {\n                     try (Git git \u003d new Git(getRepository())) {\n                         newHeadId \u003d git.commit().setReflogComment(refLogMessage.toString()).setInsertChangeId(insertChangeId).call().getId();\n                     }\n                     mergeStatus \u003d MergeStatus.MERGED;\n                     getRepository().autoGC(monitor);\n                 }\n                 if (commit \u0026\u0026 squash) {\n                     msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                     newHeadId \u003d headCommit.getId();\n                     mergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n                 }\n                 return new MergeResult(newHeadId, null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n             } else {\n                 if (failingPaths !\u003d null) {\n                     repo.writeMergeCommitMsg(null);\n                     repo.writeMergeHeads(null);\n                     return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                 } else {\n                     String mergeMessageWithConflicts \u003d new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                     repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                     return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                 }\n             }\n         }\n     } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n         List\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections.\u003cString\u003eemptyList() : dco.getConflicts();\n         throw new CheckoutConflictException(conflicts, e);\n     } catch (IOException e) {\n         throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "42e69409d796421bb1353279cfae463b19a43fe9": {
      "type": "Ybodychange",
      "commitMessage": "Handle Gerrit Change-Ids for merge commits\n\nOtherwise successful, non-conflicting merges will never get a\nGerrit Change-Id.\n\nBug: 358206\nChange-Id: I9b599ad01d9f7332200c1d81a1ba6ce5ef990ab5\nSigned-off-by: Thomas Wolf \u003cthomas.wolf@paranor.ch\u003e",
      "commitDate": "2018/4/19 上午5:33",
      "commitName": "42e69409d796421bb1353279cfae463b19a43fe9",
      "commitAuthor": "Thomas Wolf",
      "commitDateOld": "2018/3/7 下午1:46",
      "commitNameOld": "2c29af786763c0c8d74741c86edbeff4e5140e35",
      "commitAuthorOld": "David Pursehouse",
      "daysBetweenCommits": 42.66,
      "commitsBetweenForRepo": 91,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"boxing\")\npublic MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    fallBackToConfiguration();\n    checkParameters();\n    DirCacheCheckout dco \u003d null;\n    try (RevWalk revWalk \u003d new RevWalk(repo)) {\n        Ref head \u003d repo.exactRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n        Ref ref \u003d commits.get(0);\n        refLogMessage.append(ref.getName());\n        ref \u003d repo.peel(ref);\n        ObjectId objectId \u003d ref.getPeeledObjectId();\n        if (objectId \u003d\u003d null)\n            objectId \u003d ref.getObjectId();\n        RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n        ObjectId headId \u003d head.getObjectId();\n        if (headId \u003d\u003d null) {\n            revWalk.parseHeaders(srcCommit);\n            dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.setProgressMonitor(monitor);\n            dco.checkout();\n            RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() !\u003d Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit) \u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setProgressMonitor(monitor);\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            String msg \u003d null;\n            ObjectId newHead, base \u003d null;\n            MergeStatus mergeStatus \u003d null;\n            if (!squash) {\n                updateHead(refLogMessage, srcCommit, headId);\n                newHead \u003d base \u003d srcCommit;\n                mergeStatus \u003d MergeStatus.FAST_FORWARD;\n            } else {\n                msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                newHead \u003d base \u003d headId;\n                mergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n                List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            setCallable(false);\n            return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n        } else {\n            if (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n                return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n            }\n            String mergeMessage \u003d \"\";\n            if (!squash) {\n                if (message !\u003d null)\n                    mergeMessage \u003d message;\n                else\n                    mergeMessage \u003d new MergeMessageFormatter().format(commits, head);\n                repo.writeMergeCommitMsg(mergeMessage);\n                repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            } else {\n                List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            Merger merger \u003d mergeStrategy.newMerger(repo);\n            merger.setProgressMonitor(monitor);\n            boolean noProblems;\n            Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n            Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n            List\u003cString\u003e unmergedPaths \u003d null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n                lowLevelResults \u003d resolveMerger.getMergeResults();\n                failingPaths \u003d resolveMerger.getFailingPaths();\n                unmergedPaths \u003d resolveMerger.getUnmergedPaths();\n                if (!resolveMerger.getModifiedFiles().isEmpty()) {\n                    repo.fireEvent(new WorkingTreeModifiedEvent(resolveMerger.getModifiedFiles(), null));\n                }\n            } else\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n            refLogMessage.append(\": Merge made by \");\n            if (!revWalk.isMergedInto(headCommit, srcCommit))\n                refLogMessage.append(mergeStrategy.getName());\n            else\n                refLogMessage.append(\"recursive\");\n            refLogMessage.append(\u0027.\u0027);\n            if (noProblems) {\n                dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.setProgressMonitor(monitor);\n                dco.checkout();\n                String msg \u003d null;\n                ObjectId newHeadId \u003d null;\n                MergeStatus mergeStatus \u003d null;\n                if (!commit \u0026\u0026 squash) {\n                    mergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n                }\n                if (!commit \u0026\u0026 !squash) {\n                    mergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n                }\n                if (commit \u0026\u0026 !squash) {\n                    try (Git git \u003d new Git(getRepository())) {\n                        newHeadId \u003d git.commit().setReflogComment(refLogMessage.toString()).setInsertChangeId(insertChangeId).call().getId();\n                    }\n                    mergeStatus \u003d MergeStatus.MERGED;\n                    getRepository().autoGC(monitor);\n                }\n                if (commit \u0026\u0026 squash) {\n                    msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                    newHeadId \u003d headCommit.getId();\n                    mergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n                }\n                return new MergeResult(newHeadId, null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n            } else {\n                if (failingPaths !\u003d null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else {\n                    String mergeMessageWithConflicts \u003d new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                    repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                }\n            }\n        }\n    } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n        List\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections.\u003cString\u003eemptyList() : dco.getConflicts();\n        throw new CheckoutConflictException(conflicts, e);\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 235,
      "functionName": "call",
      "functionAnnotation": "@Override,@SuppressWarnings(\"boxing\")",
      "functionDoc": "@inheritDoc}\n\u003cp\u003e\nExecute the {@code Merge} command with all the options and parameters\ncollected by the setter methods (e.g. {@link #include(Ref)}) of this\nclass. Each instance of this class should only be used for one invocation\nof the command. Don\u0027t call this method twice on an instance.\n",
      "diff": "@@ -1,150 +1,150 @@\n @Override\n @SuppressWarnings(\"boxing\")\n public MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n     checkCallable();\n     fallBackToConfiguration();\n     checkParameters();\n     DirCacheCheckout dco \u003d null;\n     try (RevWalk revWalk \u003d new RevWalk(repo)) {\n         Ref head \u003d repo.exactRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n         Ref ref \u003d commits.get(0);\n         refLogMessage.append(ref.getName());\n         ref \u003d repo.peel(ref);\n         ObjectId objectId \u003d ref.getPeeledObjectId();\n         if (objectId \u003d\u003d null)\n             objectId \u003d ref.getObjectId();\n         RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n         ObjectId headId \u003d head.getObjectId();\n         if (headId \u003d\u003d null) {\n             revWalk.parseHeaders(srcCommit);\n             dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n             dco.setFailOnConflict(true);\n             dco.setProgressMonitor(monitor);\n             dco.checkout();\n             RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n             refUpdate.setNewObjectId(objectId);\n             refUpdate.setExpectedOldObjectId(null);\n             refUpdate.setRefLogMessage(\"initial pull\", false);\n             if (refUpdate.update() !\u003d Result.NEW)\n                 throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n             setCallable(false);\n             return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n         }\n         RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n         if (revWalk.isMergedInto(srcCommit, headCommit)) {\n             setCallable(false);\n             return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n         } else if (revWalk.isMergedInto(headCommit, srcCommit) \u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n             refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n             dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n             dco.setProgressMonitor(monitor);\n             dco.setFailOnConflict(true);\n             dco.checkout();\n             String msg \u003d null;\n             ObjectId newHead, base \u003d null;\n             MergeStatus mergeStatus \u003d null;\n             if (!squash) {\n                 updateHead(refLogMessage, srcCommit, headId);\n                 newHead \u003d base \u003d srcCommit;\n                 mergeStatus \u003d MergeStatus.FAST_FORWARD;\n             } else {\n                 msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                 newHead \u003d base \u003d headId;\n                 mergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n                 List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                 String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                 repo.writeSquashCommitMsg(squashMessage);\n             }\n             setCallable(false);\n             return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n         } else {\n             if (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n                 return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n             }\n             String mergeMessage \u003d \"\";\n             if (!squash) {\n                 if (message !\u003d null)\n                     mergeMessage \u003d message;\n                 else\n                     mergeMessage \u003d new MergeMessageFormatter().format(commits, head);\n                 repo.writeMergeCommitMsg(mergeMessage);\n                 repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n             } else {\n                 List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                 String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                 repo.writeSquashCommitMsg(squashMessage);\n             }\n             Merger merger \u003d mergeStrategy.newMerger(repo);\n             merger.setProgressMonitor(monitor);\n             boolean noProblems;\n             Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n             Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n             List\u003cString\u003e unmergedPaths \u003d null;\n             if (merger instanceof ResolveMerger) {\n                 ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                 resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                 resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n                 lowLevelResults \u003d resolveMerger.getMergeResults();\n                 failingPaths \u003d resolveMerger.getFailingPaths();\n                 unmergedPaths \u003d resolveMerger.getUnmergedPaths();\n                 if (!resolveMerger.getModifiedFiles().isEmpty()) {\n                     repo.fireEvent(new WorkingTreeModifiedEvent(resolveMerger.getModifiedFiles(), null));\n                 }\n             } else\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n             refLogMessage.append(\": Merge made by \");\n             if (!revWalk.isMergedInto(headCommit, srcCommit))\n                 refLogMessage.append(mergeStrategy.getName());\n             else\n                 refLogMessage.append(\"recursive\");\n             refLogMessage.append(\u0027.\u0027);\n             if (noProblems) {\n                 dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                 dco.setFailOnConflict(true);\n                 dco.setProgressMonitor(monitor);\n                 dco.checkout();\n                 String msg \u003d null;\n                 ObjectId newHeadId \u003d null;\n                 MergeStatus mergeStatus \u003d null;\n                 if (!commit \u0026\u0026 squash) {\n                     mergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n                 }\n                 if (!commit \u0026\u0026 !squash) {\n                     mergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n                 }\n                 if (commit \u0026\u0026 !squash) {\n                     try (Git git \u003d new Git(getRepository())) {\n-                        newHeadId \u003d git.commit().setReflogComment(refLogMessage.toString()).call().getId();\n+                        newHeadId \u003d git.commit().setReflogComment(refLogMessage.toString()).setInsertChangeId(insertChangeId).call().getId();\n                     }\n                     mergeStatus \u003d MergeStatus.MERGED;\n                     getRepository().autoGC(monitor);\n                 }\n                 if (commit \u0026\u0026 squash) {\n                     msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                     newHeadId \u003d headCommit.getId();\n                     mergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n                 }\n                 return new MergeResult(newHeadId, null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n             } else {\n                 if (failingPaths !\u003d null) {\n                     repo.writeMergeCommitMsg(null);\n                     repo.writeMergeHeads(null);\n                     return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                 } else {\n                     String mergeMessageWithConflicts \u003d new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                     repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                     return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                 }\n             }\n         }\n     } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n         List\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections.\u003cString\u003eemptyList() : dco.getConflicts();\n         throw new CheckoutConflictException(conflicts, e);\n     } catch (IOException e) {\n         throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2c29af786763c0c8d74741c86edbeff4e5140e35": {
      "type": "Ybodychange",
      "commitMessage": "MergeCommand: Open RevWalk in try-with-resource\n\nChange-Id: I45ce481cc198b8dc78e9c46b433504840597e982\nSigned-off-by: David Pursehouse \u003cdavid.pursehouse@gmail.com\u003e\n",
      "commitDate": "2018/3/7 下午1:46",
      "commitName": "2c29af786763c0c8d74741c86edbeff4e5140e35",
      "commitAuthor": "David Pursehouse",
      "commitDateOld": "2018/1/23 上午7:48",
      "commitNameOld": "1c43af8b9794abcad7a4ac77c352626063aa1f05",
      "commitAuthorOld": "Markus Duft",
      "daysBetweenCommits": 43.25,
      "commitsBetweenForRepo": 139,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"boxing\")\npublic MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    fallBackToConfiguration();\n    checkParameters();\n    DirCacheCheckout dco \u003d null;\n    try (RevWalk revWalk \u003d new RevWalk(repo)) {\n        Ref head \u003d repo.exactRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n        Ref ref \u003d commits.get(0);\n        refLogMessage.append(ref.getName());\n        ref \u003d repo.peel(ref);\n        ObjectId objectId \u003d ref.getPeeledObjectId();\n        if (objectId \u003d\u003d null)\n            objectId \u003d ref.getObjectId();\n        RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n        ObjectId headId \u003d head.getObjectId();\n        if (headId \u003d\u003d null) {\n            revWalk.parseHeaders(srcCommit);\n            dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.setProgressMonitor(monitor);\n            dco.checkout();\n            RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() !\u003d Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit) \u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setProgressMonitor(monitor);\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            String msg \u003d null;\n            ObjectId newHead, base \u003d null;\n            MergeStatus mergeStatus \u003d null;\n            if (!squash) {\n                updateHead(refLogMessage, srcCommit, headId);\n                newHead \u003d base \u003d srcCommit;\n                mergeStatus \u003d MergeStatus.FAST_FORWARD;\n            } else {\n                msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                newHead \u003d base \u003d headId;\n                mergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n                List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            setCallable(false);\n            return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n        } else {\n            if (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n                return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n            }\n            String mergeMessage \u003d \"\";\n            if (!squash) {\n                if (message !\u003d null)\n                    mergeMessage \u003d message;\n                else\n                    mergeMessage \u003d new MergeMessageFormatter().format(commits, head);\n                repo.writeMergeCommitMsg(mergeMessage);\n                repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            } else {\n                List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            Merger merger \u003d mergeStrategy.newMerger(repo);\n            merger.setProgressMonitor(monitor);\n            boolean noProblems;\n            Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n            Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n            List\u003cString\u003e unmergedPaths \u003d null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n                lowLevelResults \u003d resolveMerger.getMergeResults();\n                failingPaths \u003d resolveMerger.getFailingPaths();\n                unmergedPaths \u003d resolveMerger.getUnmergedPaths();\n                if (!resolveMerger.getModifiedFiles().isEmpty()) {\n                    repo.fireEvent(new WorkingTreeModifiedEvent(resolveMerger.getModifiedFiles(), null));\n                }\n            } else\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n            refLogMessage.append(\": Merge made by \");\n            if (!revWalk.isMergedInto(headCommit, srcCommit))\n                refLogMessage.append(mergeStrategy.getName());\n            else\n                refLogMessage.append(\"recursive\");\n            refLogMessage.append(\u0027.\u0027);\n            if (noProblems) {\n                dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.setProgressMonitor(monitor);\n                dco.checkout();\n                String msg \u003d null;\n                ObjectId newHeadId \u003d null;\n                MergeStatus mergeStatus \u003d null;\n                if (!commit \u0026\u0026 squash) {\n                    mergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n                }\n                if (!commit \u0026\u0026 !squash) {\n                    mergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n                }\n                if (commit \u0026\u0026 !squash) {\n                    try (Git git \u003d new Git(getRepository())) {\n                        newHeadId \u003d git.commit().setReflogComment(refLogMessage.toString()).call().getId();\n                    }\n                    mergeStatus \u003d MergeStatus.MERGED;\n                    getRepository().autoGC(monitor);\n                }\n                if (commit \u0026\u0026 squash) {\n                    msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                    newHeadId \u003d headCommit.getId();\n                    mergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n                }\n                return new MergeResult(newHeadId, null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n            } else {\n                if (failingPaths !\u003d null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else {\n                    String mergeMessageWithConflicts \u003d new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                    repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                }\n            }\n        }\n    } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n        List\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections.\u003cString\u003eemptyList() : dco.getConflicts();\n        throw new CheckoutConflictException(conflicts, e);\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 233,
      "functionName": "call",
      "functionAnnotation": "@Override,@SuppressWarnings(\"boxing\")",
      "functionDoc": "@inheritDoc}\n\u003cp\u003e\nExecute the {@code Merge} command with all the options and parameters\ncollected by the setter methods (e.g. {@link #include(Ref)}) of this\nclass. Each instance of this class should only be used for one invocation\nof the command. Don\u0027t call this method twice on an instance.\n",
      "diff": "@@ -1,155 +1,150 @@\n @Override\n @SuppressWarnings(\"boxing\")\n public MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n     checkCallable();\n     fallBackToConfiguration();\n     checkParameters();\n-    RevWalk revWalk \u003d null;\n     DirCacheCheckout dco \u003d null;\n-    try {\n+    try (RevWalk revWalk \u003d new RevWalk(repo)) {\n         Ref head \u003d repo.exactRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n-        revWalk \u003d new RevWalk(repo);\n         Ref ref \u003d commits.get(0);\n         refLogMessage.append(ref.getName());\n         ref \u003d repo.peel(ref);\n         ObjectId objectId \u003d ref.getPeeledObjectId();\n         if (objectId \u003d\u003d null)\n             objectId \u003d ref.getObjectId();\n         RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n         ObjectId headId \u003d head.getObjectId();\n         if (headId \u003d\u003d null) {\n             revWalk.parseHeaders(srcCommit);\n             dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n             dco.setFailOnConflict(true);\n             dco.setProgressMonitor(monitor);\n             dco.checkout();\n             RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n             refUpdate.setNewObjectId(objectId);\n             refUpdate.setExpectedOldObjectId(null);\n             refUpdate.setRefLogMessage(\"initial pull\", false);\n             if (refUpdate.update() !\u003d Result.NEW)\n                 throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n             setCallable(false);\n             return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n         }\n         RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n         if (revWalk.isMergedInto(srcCommit, headCommit)) {\n             setCallable(false);\n             return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n         } else if (revWalk.isMergedInto(headCommit, srcCommit) \u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n             refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n             dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n             dco.setProgressMonitor(monitor);\n             dco.setFailOnConflict(true);\n             dco.checkout();\n             String msg \u003d null;\n             ObjectId newHead, base \u003d null;\n             MergeStatus mergeStatus \u003d null;\n             if (!squash) {\n                 updateHead(refLogMessage, srcCommit, headId);\n                 newHead \u003d base \u003d srcCommit;\n                 mergeStatus \u003d MergeStatus.FAST_FORWARD;\n             } else {\n                 msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                 newHead \u003d base \u003d headId;\n                 mergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n                 List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                 String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                 repo.writeSquashCommitMsg(squashMessage);\n             }\n             setCallable(false);\n             return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n         } else {\n             if (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n                 return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n             }\n             String mergeMessage \u003d \"\";\n             if (!squash) {\n                 if (message !\u003d null)\n                     mergeMessage \u003d message;\n                 else\n                     mergeMessage \u003d new MergeMessageFormatter().format(commits, head);\n                 repo.writeMergeCommitMsg(mergeMessage);\n                 repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n             } else {\n                 List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                 String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                 repo.writeSquashCommitMsg(squashMessage);\n             }\n             Merger merger \u003d mergeStrategy.newMerger(repo);\n             merger.setProgressMonitor(monitor);\n             boolean noProblems;\n             Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n             Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n             List\u003cString\u003e unmergedPaths \u003d null;\n             if (merger instanceof ResolveMerger) {\n                 ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                 resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                 resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n                 lowLevelResults \u003d resolveMerger.getMergeResults();\n                 failingPaths \u003d resolveMerger.getFailingPaths();\n                 unmergedPaths \u003d resolveMerger.getUnmergedPaths();\n                 if (!resolveMerger.getModifiedFiles().isEmpty()) {\n                     repo.fireEvent(new WorkingTreeModifiedEvent(resolveMerger.getModifiedFiles(), null));\n                 }\n             } else\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n             refLogMessage.append(\": Merge made by \");\n             if (!revWalk.isMergedInto(headCommit, srcCommit))\n                 refLogMessage.append(mergeStrategy.getName());\n             else\n                 refLogMessage.append(\"recursive\");\n             refLogMessage.append(\u0027.\u0027);\n             if (noProblems) {\n                 dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                 dco.setFailOnConflict(true);\n                 dco.setProgressMonitor(monitor);\n                 dco.checkout();\n                 String msg \u003d null;\n                 ObjectId newHeadId \u003d null;\n                 MergeStatus mergeStatus \u003d null;\n                 if (!commit \u0026\u0026 squash) {\n                     mergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n                 }\n                 if (!commit \u0026\u0026 !squash) {\n                     mergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n                 }\n                 if (commit \u0026\u0026 !squash) {\n                     try (Git git \u003d new Git(getRepository())) {\n                         newHeadId \u003d git.commit().setReflogComment(refLogMessage.toString()).call().getId();\n                     }\n                     mergeStatus \u003d MergeStatus.MERGED;\n                     getRepository().autoGC(monitor);\n                 }\n                 if (commit \u0026\u0026 squash) {\n                     msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                     newHeadId \u003d headCommit.getId();\n                     mergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n                 }\n                 return new MergeResult(newHeadId, null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n             } else {\n                 if (failingPaths !\u003d null) {\n                     repo.writeMergeCommitMsg(null);\n                     repo.writeMergeHeads(null);\n                     return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                 } else {\n                     String mergeMessageWithConflicts \u003d new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                     repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                     return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                 }\n             }\n         }\n     } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n         List\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections.\u003cString\u003eemptyList() : dco.getConflicts();\n         throw new CheckoutConflictException(conflicts, e);\n     } catch (IOException e) {\n         throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n-    } finally {\n-        if (revWalk !\u003d null)\n-            revWalk.close();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1c43af8b9794abcad7a4ac77c352626063aa1f05": {
      "type": "Ybodychange",
      "commitMessage": "Progress reporting for checkout\n\nThe reason for the change is LFS: when using a lot of LFS files,\ncheckout can take quite some time on larger repositories. To avoid\n\"hanging\" UI, provide progress reporting.\n\nAlso implement (partial) progress reporting for cherry-pick, reset,\nrevert which are using checkout internally.\n\nThe feature is also useful without LFS, so it is independent of it.\n\nChange-Id: I021e764241f3c107eaf2771f6b5785245b146b42\nSigned-off-by: Markus Duft \u003cmarkus.duft@ssi-schaefer.com\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2018/1/23 上午7:48",
      "commitName": "1c43af8b9794abcad7a4ac77c352626063aa1f05",
      "commitAuthor": "Markus Duft",
      "commitDateOld": "2017/12/18 下午5:45",
      "commitNameOld": "0210e0e299bed69176e0a929d0b67f3cf9fb1e37",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 35.58,
      "commitsBetweenForRepo": 83,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"boxing\")\npublic MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    fallBackToConfiguration();\n    checkParameters();\n    RevWalk revWalk \u003d null;\n    DirCacheCheckout dco \u003d null;\n    try {\n        Ref head \u003d repo.exactRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n        revWalk \u003d new RevWalk(repo);\n        Ref ref \u003d commits.get(0);\n        refLogMessage.append(ref.getName());\n        ref \u003d repo.peel(ref);\n        ObjectId objectId \u003d ref.getPeeledObjectId();\n        if (objectId \u003d\u003d null)\n            objectId \u003d ref.getObjectId();\n        RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n        ObjectId headId \u003d head.getObjectId();\n        if (headId \u003d\u003d null) {\n            revWalk.parseHeaders(srcCommit);\n            dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.setProgressMonitor(monitor);\n            dco.checkout();\n            RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() !\u003d Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit) \u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setProgressMonitor(monitor);\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            String msg \u003d null;\n            ObjectId newHead, base \u003d null;\n            MergeStatus mergeStatus \u003d null;\n            if (!squash) {\n                updateHead(refLogMessage, srcCommit, headId);\n                newHead \u003d base \u003d srcCommit;\n                mergeStatus \u003d MergeStatus.FAST_FORWARD;\n            } else {\n                msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                newHead \u003d base \u003d headId;\n                mergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n                List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            setCallable(false);\n            return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n        } else {\n            if (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n                return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n            }\n            String mergeMessage \u003d \"\";\n            if (!squash) {\n                if (message !\u003d null)\n                    mergeMessage \u003d message;\n                else\n                    mergeMessage \u003d new MergeMessageFormatter().format(commits, head);\n                repo.writeMergeCommitMsg(mergeMessage);\n                repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            } else {\n                List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            Merger merger \u003d mergeStrategy.newMerger(repo);\n            merger.setProgressMonitor(monitor);\n            boolean noProblems;\n            Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n            Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n            List\u003cString\u003e unmergedPaths \u003d null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n                lowLevelResults \u003d resolveMerger.getMergeResults();\n                failingPaths \u003d resolveMerger.getFailingPaths();\n                unmergedPaths \u003d resolveMerger.getUnmergedPaths();\n                if (!resolveMerger.getModifiedFiles().isEmpty()) {\n                    repo.fireEvent(new WorkingTreeModifiedEvent(resolveMerger.getModifiedFiles(), null));\n                }\n            } else\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n            refLogMessage.append(\": Merge made by \");\n            if (!revWalk.isMergedInto(headCommit, srcCommit))\n                refLogMessage.append(mergeStrategy.getName());\n            else\n                refLogMessage.append(\"recursive\");\n            refLogMessage.append(\u0027.\u0027);\n            if (noProblems) {\n                dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.setProgressMonitor(monitor);\n                dco.checkout();\n                String msg \u003d null;\n                ObjectId newHeadId \u003d null;\n                MergeStatus mergeStatus \u003d null;\n                if (!commit \u0026\u0026 squash) {\n                    mergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n                }\n                if (!commit \u0026\u0026 !squash) {\n                    mergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n                }\n                if (commit \u0026\u0026 !squash) {\n                    try (Git git \u003d new Git(getRepository())) {\n                        newHeadId \u003d git.commit().setReflogComment(refLogMessage.toString()).call().getId();\n                    }\n                    mergeStatus \u003d MergeStatus.MERGED;\n                    getRepository().autoGC(monitor);\n                }\n                if (commit \u0026\u0026 squash) {\n                    msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                    newHeadId \u003d headCommit.getId();\n                    mergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n                }\n                return new MergeResult(newHeadId, null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n            } else {\n                if (failingPaths !\u003d null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else {\n                    String mergeMessageWithConflicts \u003d new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                    repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                }\n            }\n        }\n    } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n        List\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections.\u003cString\u003eemptyList() : dco.getConflicts();\n        throw new CheckoutConflictException(conflicts, e);\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk !\u003d null)\n            revWalk.close();\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 233,
      "functionName": "call",
      "functionAnnotation": "@Override,@SuppressWarnings(\"boxing\")",
      "functionDoc": "@inheritDoc}\n\u003cp\u003e\nExecute the {@code Merge} command with all the options and parameters\ncollected by the setter methods (e.g. {@link #include(Ref)}) of this\nclass. Each instance of this class should only be used for one invocation\nof the command. Don\u0027t call this method twice on an instance.\n",
      "diff": "@@ -1,152 +1,155 @@\n @Override\n @SuppressWarnings(\"boxing\")\n public MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n     checkCallable();\n     fallBackToConfiguration();\n     checkParameters();\n     RevWalk revWalk \u003d null;\n     DirCacheCheckout dco \u003d null;\n     try {\n         Ref head \u003d repo.exactRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n         revWalk \u003d new RevWalk(repo);\n         Ref ref \u003d commits.get(0);\n         refLogMessage.append(ref.getName());\n         ref \u003d repo.peel(ref);\n         ObjectId objectId \u003d ref.getPeeledObjectId();\n         if (objectId \u003d\u003d null)\n             objectId \u003d ref.getObjectId();\n         RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n         ObjectId headId \u003d head.getObjectId();\n         if (headId \u003d\u003d null) {\n             revWalk.parseHeaders(srcCommit);\n             dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n             dco.setFailOnConflict(true);\n+            dco.setProgressMonitor(monitor);\n             dco.checkout();\n             RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n             refUpdate.setNewObjectId(objectId);\n             refUpdate.setExpectedOldObjectId(null);\n             refUpdate.setRefLogMessage(\"initial pull\", false);\n             if (refUpdate.update() !\u003d Result.NEW)\n                 throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n             setCallable(false);\n             return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n         }\n         RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n         if (revWalk.isMergedInto(srcCommit, headCommit)) {\n             setCallable(false);\n             return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n         } else if (revWalk.isMergedInto(headCommit, srcCommit) \u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n             refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n             dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n+            dco.setProgressMonitor(monitor);\n             dco.setFailOnConflict(true);\n             dco.checkout();\n             String msg \u003d null;\n             ObjectId newHead, base \u003d null;\n             MergeStatus mergeStatus \u003d null;\n             if (!squash) {\n                 updateHead(refLogMessage, srcCommit, headId);\n                 newHead \u003d base \u003d srcCommit;\n                 mergeStatus \u003d MergeStatus.FAST_FORWARD;\n             } else {\n                 msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                 newHead \u003d base \u003d headId;\n                 mergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n                 List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                 String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                 repo.writeSquashCommitMsg(squashMessage);\n             }\n             setCallable(false);\n             return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n         } else {\n             if (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n                 return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n             }\n             String mergeMessage \u003d \"\";\n             if (!squash) {\n                 if (message !\u003d null)\n                     mergeMessage \u003d message;\n                 else\n                     mergeMessage \u003d new MergeMessageFormatter().format(commits, head);\n                 repo.writeMergeCommitMsg(mergeMessage);\n                 repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n             } else {\n                 List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                 String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                 repo.writeSquashCommitMsg(squashMessage);\n             }\n             Merger merger \u003d mergeStrategy.newMerger(repo);\n             merger.setProgressMonitor(monitor);\n             boolean noProblems;\n             Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n             Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n             List\u003cString\u003e unmergedPaths \u003d null;\n             if (merger instanceof ResolveMerger) {\n                 ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                 resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                 resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n                 lowLevelResults \u003d resolveMerger.getMergeResults();\n                 failingPaths \u003d resolveMerger.getFailingPaths();\n                 unmergedPaths \u003d resolveMerger.getUnmergedPaths();\n                 if (!resolveMerger.getModifiedFiles().isEmpty()) {\n                     repo.fireEvent(new WorkingTreeModifiedEvent(resolveMerger.getModifiedFiles(), null));\n                 }\n             } else\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n             refLogMessage.append(\": Merge made by \");\n             if (!revWalk.isMergedInto(headCommit, srcCommit))\n                 refLogMessage.append(mergeStrategy.getName());\n             else\n                 refLogMessage.append(\"recursive\");\n             refLogMessage.append(\u0027.\u0027);\n             if (noProblems) {\n                 dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                 dco.setFailOnConflict(true);\n+                dco.setProgressMonitor(monitor);\n                 dco.checkout();\n                 String msg \u003d null;\n                 ObjectId newHeadId \u003d null;\n                 MergeStatus mergeStatus \u003d null;\n                 if (!commit \u0026\u0026 squash) {\n                     mergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n                 }\n                 if (!commit \u0026\u0026 !squash) {\n                     mergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n                 }\n                 if (commit \u0026\u0026 !squash) {\n                     try (Git git \u003d new Git(getRepository())) {\n                         newHeadId \u003d git.commit().setReflogComment(refLogMessage.toString()).call().getId();\n                     }\n                     mergeStatus \u003d MergeStatus.MERGED;\n                     getRepository().autoGC(monitor);\n                 }\n                 if (commit \u0026\u0026 squash) {\n                     msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                     newHeadId \u003d headCommit.getId();\n                     mergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n                 }\n                 return new MergeResult(newHeadId, null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n             } else {\n                 if (failingPaths !\u003d null) {\n                     repo.writeMergeCommitMsg(null);\n                     repo.writeMergeHeads(null);\n                     return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                 } else {\n                     String mergeMessageWithConflicts \u003d new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                     repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                     return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                 }\n             }\n         }\n     } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n         List\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections.\u003cString\u003eemptyList() : dco.getConflicts();\n         throw new CheckoutConflictException(conflicts, e);\n     } catch (IOException e) {\n         throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n     } finally {\n         if (revWalk !\u003d null)\n             revWalk.close();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0210e0e299bed69176e0a929d0b67f3cf9fb1e37": {
      "type": "Ydocchange",
      "commitMessage": "Fix javadoc in org.eclipse.jgit annotations and api packages\n\nChange-Id: I2761ea91f8dfed16ea54e7a6646af03a30c15ec9\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2017/12/18 下午5:45",
      "commitName": "0210e0e299bed69176e0a929d0b67f3cf9fb1e37",
      "commitAuthor": "Matthias Sohn",
      "commitDateOld": "2017/8/16 上午4:52",
      "commitNameOld": "b13a285098305149b34924bce2679a0cd98d9b2c",
      "commitAuthorOld": "Thomas Wolf",
      "daysBetweenCommits": 124.54,
      "commitsBetweenForRepo": 233,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"boxing\")\npublic MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    fallBackToConfiguration();\n    checkParameters();\n    RevWalk revWalk \u003d null;\n    DirCacheCheckout dco \u003d null;\n    try {\n        Ref head \u003d repo.exactRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n        revWalk \u003d new RevWalk(repo);\n        Ref ref \u003d commits.get(0);\n        refLogMessage.append(ref.getName());\n        ref \u003d repo.peel(ref);\n        ObjectId objectId \u003d ref.getPeeledObjectId();\n        if (objectId \u003d\u003d null)\n            objectId \u003d ref.getObjectId();\n        RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n        ObjectId headId \u003d head.getObjectId();\n        if (headId \u003d\u003d null) {\n            revWalk.parseHeaders(srcCommit);\n            dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() !\u003d Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit) \u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            String msg \u003d null;\n            ObjectId newHead, base \u003d null;\n            MergeStatus mergeStatus \u003d null;\n            if (!squash) {\n                updateHead(refLogMessage, srcCommit, headId);\n                newHead \u003d base \u003d srcCommit;\n                mergeStatus \u003d MergeStatus.FAST_FORWARD;\n            } else {\n                msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                newHead \u003d base \u003d headId;\n                mergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n                List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            setCallable(false);\n            return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n        } else {\n            if (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n                return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n            }\n            String mergeMessage \u003d \"\";\n            if (!squash) {\n                if (message !\u003d null)\n                    mergeMessage \u003d message;\n                else\n                    mergeMessage \u003d new MergeMessageFormatter().format(commits, head);\n                repo.writeMergeCommitMsg(mergeMessage);\n                repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            } else {\n                List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            Merger merger \u003d mergeStrategy.newMerger(repo);\n            merger.setProgressMonitor(monitor);\n            boolean noProblems;\n            Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n            Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n            List\u003cString\u003e unmergedPaths \u003d null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n                lowLevelResults \u003d resolveMerger.getMergeResults();\n                failingPaths \u003d resolveMerger.getFailingPaths();\n                unmergedPaths \u003d resolveMerger.getUnmergedPaths();\n                if (!resolveMerger.getModifiedFiles().isEmpty()) {\n                    repo.fireEvent(new WorkingTreeModifiedEvent(resolveMerger.getModifiedFiles(), null));\n                }\n            } else\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n            refLogMessage.append(\": Merge made by \");\n            if (!revWalk.isMergedInto(headCommit, srcCommit))\n                refLogMessage.append(mergeStrategy.getName());\n            else\n                refLogMessage.append(\"recursive\");\n            refLogMessage.append(\u0027.\u0027);\n            if (noProblems) {\n                dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                String msg \u003d null;\n                ObjectId newHeadId \u003d null;\n                MergeStatus mergeStatus \u003d null;\n                if (!commit \u0026\u0026 squash) {\n                    mergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n                }\n                if (!commit \u0026\u0026 !squash) {\n                    mergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n                }\n                if (commit \u0026\u0026 !squash) {\n                    try (Git git \u003d new Git(getRepository())) {\n                        newHeadId \u003d git.commit().setReflogComment(refLogMessage.toString()).call().getId();\n                    }\n                    mergeStatus \u003d MergeStatus.MERGED;\n                    getRepository().autoGC(monitor);\n                }\n                if (commit \u0026\u0026 squash) {\n                    msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                    newHeadId \u003d headCommit.getId();\n                    mergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n                }\n                return new MergeResult(newHeadId, null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n            } else {\n                if (failingPaths !\u003d null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else {\n                    String mergeMessageWithConflicts \u003d new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                    repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                }\n            }\n        }\n    } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n        List\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections.\u003cString\u003eemptyList() : dco.getConflicts();\n        throw new CheckoutConflictException(conflicts, e);\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk !\u003d null)\n            revWalk.close();\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 233,
      "functionName": "call",
      "functionAnnotation": "@Override,@SuppressWarnings(\"boxing\")",
      "functionDoc": "@inheritDoc}\n\u003cp\u003e\nExecute the {@code Merge} command with all the options and parameters\ncollected by the setter methods (e.g. {@link #include(Ref)}) of this\nclass. Each instance of this class should only be used for one invocation\nof the command. Don\u0027t call this method twice on an instance.\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "Executes the {@code Merge} command with all the options and parameters\ncollected by the setter methods (e.g. {@link #include(Ref)}) of this\nclass. Each instance of this class should only be used for one invocation\nof the command. Don\u0027t call this method twice on an instance.\n\n@return the result of the merge\n",
        "newValue": "@inheritDoc}\n\u003cp\u003e\nExecute the {@code Merge} command with all the options and parameters\ncollected by the setter methods (e.g. {@link #include(Ref)}) of this\nclass. Each instance of this class should only be used for one invocation\nof the command. Don\u0027t call this method twice on an instance.\n"
      }
    },
    "b13a285098305149b34924bce2679a0cd98d9b2c": {
      "type": "Ybodychange",
      "commitMessage": "Send a detailed event on working tree modifications\n\nCurrently there is no way to determine the precise changes done\nto the working tree by a JGit command. Only the CheckoutCommand\nactually provides access to the lists of modified, deleted, and\nto-be-deleted files, but those lists may be inaccurate (since they\nare determined up-front before the working tree is modified) if\nthe actual checkout then fails halfway through. Moreover, other\nJGit commands that modify the working tree do not offer any way to\nfigure out which files were changed.\n\nThis poses problems for EGit, which may need to refresh parts of the\nEclipse workspace when JGit has done java.io file operations.\n\nProvide the foundations for better file change tracking: the working\ntree is modified exclusively in DirCacheCheckout. Make it emit a new\ntype of RepositoryEvent that lists all files that were modified or\ndeleted, even if the checkout failed halfway through. We update the\n\u0027updated\u0027 and \u0027removed\u0027 lists determined up-front in case of file\nsystem problems to reflect the actual state of changes made.\n\nEGit thus can register a listener for these events and then knows\nexactly which parts of the Eclipse workspace may need to be refreshed.\n\nTwo commands manage checking out individual DirCacheEntries themselves:\ncheckout specific paths, and applying a stash with untracked files.\nMake those two also emit such a new WorkingTreeModifiedEvent.\n\nFurthermore, merges may modify files, and clean, rm, and stash create\nmay delete files.\n\nCQ: 13969\nBug: 500106\nChange-Id: I7a100aee315791fa1201f43bbad61fbae60b35cb\nSigned-off-by: Thomas Wolf \u003cthomas.wolf@paranor.ch\u003e",
      "commitDate": "2017/8/16 上午4:52",
      "commitName": "b13a285098305149b34924bce2679a0cd98d9b2c",
      "commitAuthor": "Thomas Wolf",
      "commitDateOld": "2017/6/16 上午5:11",
      "commitNameOld": "a45b045c7378c3685d7b0a39173b69c87efe7371",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 60.99,
      "commitsBetweenForRepo": 75,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"boxing\")\npublic MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    fallBackToConfiguration();\n    checkParameters();\n    RevWalk revWalk \u003d null;\n    DirCacheCheckout dco \u003d null;\n    try {\n        Ref head \u003d repo.exactRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n        revWalk \u003d new RevWalk(repo);\n        Ref ref \u003d commits.get(0);\n        refLogMessage.append(ref.getName());\n        ref \u003d repo.peel(ref);\n        ObjectId objectId \u003d ref.getPeeledObjectId();\n        if (objectId \u003d\u003d null)\n            objectId \u003d ref.getObjectId();\n        RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n        ObjectId headId \u003d head.getObjectId();\n        if (headId \u003d\u003d null) {\n            revWalk.parseHeaders(srcCommit);\n            dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() !\u003d Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit) \u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            String msg \u003d null;\n            ObjectId newHead, base \u003d null;\n            MergeStatus mergeStatus \u003d null;\n            if (!squash) {\n                updateHead(refLogMessage, srcCommit, headId);\n                newHead \u003d base \u003d srcCommit;\n                mergeStatus \u003d MergeStatus.FAST_FORWARD;\n            } else {\n                msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                newHead \u003d base \u003d headId;\n                mergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n                List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            setCallable(false);\n            return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n        } else {\n            if (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n                return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n            }\n            String mergeMessage \u003d \"\";\n            if (!squash) {\n                if (message !\u003d null)\n                    mergeMessage \u003d message;\n                else\n                    mergeMessage \u003d new MergeMessageFormatter().format(commits, head);\n                repo.writeMergeCommitMsg(mergeMessage);\n                repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            } else {\n                List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            Merger merger \u003d mergeStrategy.newMerger(repo);\n            merger.setProgressMonitor(monitor);\n            boolean noProblems;\n            Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n            Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n            List\u003cString\u003e unmergedPaths \u003d null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n                lowLevelResults \u003d resolveMerger.getMergeResults();\n                failingPaths \u003d resolveMerger.getFailingPaths();\n                unmergedPaths \u003d resolveMerger.getUnmergedPaths();\n                if (!resolveMerger.getModifiedFiles().isEmpty()) {\n                    repo.fireEvent(new WorkingTreeModifiedEvent(resolveMerger.getModifiedFiles(), null));\n                }\n            } else\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n            refLogMessage.append(\": Merge made by \");\n            if (!revWalk.isMergedInto(headCommit, srcCommit))\n                refLogMessage.append(mergeStrategy.getName());\n            else\n                refLogMessage.append(\"recursive\");\n            refLogMessage.append(\u0027.\u0027);\n            if (noProblems) {\n                dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                String msg \u003d null;\n                ObjectId newHeadId \u003d null;\n                MergeStatus mergeStatus \u003d null;\n                if (!commit \u0026\u0026 squash) {\n                    mergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n                }\n                if (!commit \u0026\u0026 !squash) {\n                    mergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n                }\n                if (commit \u0026\u0026 !squash) {\n                    try (Git git \u003d new Git(getRepository())) {\n                        newHeadId \u003d git.commit().setReflogComment(refLogMessage.toString()).call().getId();\n                    }\n                    mergeStatus \u003d MergeStatus.MERGED;\n                    getRepository().autoGC(monitor);\n                }\n                if (commit \u0026\u0026 squash) {\n                    msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                    newHeadId \u003d headCommit.getId();\n                    mergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n                }\n                return new MergeResult(newHeadId, null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n            } else {\n                if (failingPaths !\u003d null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else {\n                    String mergeMessageWithConflicts \u003d new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                    repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                }\n            }\n        }\n    } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n        List\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections.\u003cString\u003eemptyList() : dco.getConflicts();\n        throw new CheckoutConflictException(conflicts, e);\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk !\u003d null)\n            revWalk.close();\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 230,
      "functionName": "call",
      "functionAnnotation": "@Override,@SuppressWarnings(\"boxing\")",
      "functionDoc": "Executes the {@code Merge} command with all the options and parameters\ncollected by the setter methods (e.g. {@link #include(Ref)}) of this\nclass. Each instance of this class should only be used for one invocation\nof the command. Don\u0027t call this method twice on an instance.\n\n@return the result of the merge\n",
      "diff": "@@ -1,149 +1,152 @@\n @Override\n @SuppressWarnings(\"boxing\")\n public MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n     checkCallable();\n     fallBackToConfiguration();\n     checkParameters();\n     RevWalk revWalk \u003d null;\n     DirCacheCheckout dco \u003d null;\n     try {\n         Ref head \u003d repo.exactRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n         revWalk \u003d new RevWalk(repo);\n         Ref ref \u003d commits.get(0);\n         refLogMessage.append(ref.getName());\n         ref \u003d repo.peel(ref);\n         ObjectId objectId \u003d ref.getPeeledObjectId();\n         if (objectId \u003d\u003d null)\n             objectId \u003d ref.getObjectId();\n         RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n         ObjectId headId \u003d head.getObjectId();\n         if (headId \u003d\u003d null) {\n             revWalk.parseHeaders(srcCommit);\n             dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n             dco.setFailOnConflict(true);\n             dco.checkout();\n             RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n             refUpdate.setNewObjectId(objectId);\n             refUpdate.setExpectedOldObjectId(null);\n             refUpdate.setRefLogMessage(\"initial pull\", false);\n             if (refUpdate.update() !\u003d Result.NEW)\n                 throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n             setCallable(false);\n             return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n         }\n         RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n         if (revWalk.isMergedInto(srcCommit, headCommit)) {\n             setCallable(false);\n             return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n         } else if (revWalk.isMergedInto(headCommit, srcCommit) \u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n             refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n             dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n             dco.setFailOnConflict(true);\n             dco.checkout();\n             String msg \u003d null;\n             ObjectId newHead, base \u003d null;\n             MergeStatus mergeStatus \u003d null;\n             if (!squash) {\n                 updateHead(refLogMessage, srcCommit, headId);\n                 newHead \u003d base \u003d srcCommit;\n                 mergeStatus \u003d MergeStatus.FAST_FORWARD;\n             } else {\n                 msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                 newHead \u003d base \u003d headId;\n                 mergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n                 List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                 String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                 repo.writeSquashCommitMsg(squashMessage);\n             }\n             setCallable(false);\n             return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n         } else {\n             if (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n                 return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n             }\n             String mergeMessage \u003d \"\";\n             if (!squash) {\n                 if (message !\u003d null)\n                     mergeMessage \u003d message;\n                 else\n                     mergeMessage \u003d new MergeMessageFormatter().format(commits, head);\n                 repo.writeMergeCommitMsg(mergeMessage);\n                 repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n             } else {\n                 List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                 String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                 repo.writeSquashCommitMsg(squashMessage);\n             }\n             Merger merger \u003d mergeStrategy.newMerger(repo);\n             merger.setProgressMonitor(monitor);\n             boolean noProblems;\n             Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n             Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n             List\u003cString\u003e unmergedPaths \u003d null;\n             if (merger instanceof ResolveMerger) {\n                 ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                 resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                 resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n                 lowLevelResults \u003d resolveMerger.getMergeResults();\n                 failingPaths \u003d resolveMerger.getFailingPaths();\n                 unmergedPaths \u003d resolveMerger.getUnmergedPaths();\n+                if (!resolveMerger.getModifiedFiles().isEmpty()) {\n+                    repo.fireEvent(new WorkingTreeModifiedEvent(resolveMerger.getModifiedFiles(), null));\n+                }\n             } else\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n             refLogMessage.append(\": Merge made by \");\n             if (!revWalk.isMergedInto(headCommit, srcCommit))\n                 refLogMessage.append(mergeStrategy.getName());\n             else\n                 refLogMessage.append(\"recursive\");\n             refLogMessage.append(\u0027.\u0027);\n             if (noProblems) {\n                 dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                 dco.setFailOnConflict(true);\n                 dco.checkout();\n                 String msg \u003d null;\n                 ObjectId newHeadId \u003d null;\n                 MergeStatus mergeStatus \u003d null;\n                 if (!commit \u0026\u0026 squash) {\n                     mergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n                 }\n                 if (!commit \u0026\u0026 !squash) {\n                     mergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n                 }\n                 if (commit \u0026\u0026 !squash) {\n                     try (Git git \u003d new Git(getRepository())) {\n                         newHeadId \u003d git.commit().setReflogComment(refLogMessage.toString()).call().getId();\n                     }\n                     mergeStatus \u003d MergeStatus.MERGED;\n                     getRepository().autoGC(monitor);\n                 }\n                 if (commit \u0026\u0026 squash) {\n                     msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                     newHeadId \u003d headCommit.getId();\n                     mergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n                 }\n                 return new MergeResult(newHeadId, null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n             } else {\n                 if (failingPaths !\u003d null) {\n                     repo.writeMergeCommitMsg(null);\n                     repo.writeMergeHeads(null);\n                     return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                 } else {\n                     String mergeMessageWithConflicts \u003d new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                     repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                     return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                 }\n             }\n         }\n     } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n         List\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections.\u003cString\u003eemptyList() : dco.getConflicts();\n         throw new CheckoutConflictException(conflicts, e);\n     } catch (IOException e) {\n         throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n     } finally {\n         if (revWalk !\u003d null)\n             revWalk.close();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7ac182f4e427e0d5a986b8ca67a56fc22828b1a0": {
      "type": "Yannotationchange",
      "commitMessage": "Enable and fix \u0027Should be tagged with @Override\u0027 warning\n\nSet missingOverrideAnnotation\u003dwarning in Eclipse compiler preferences\nwhich enables the warning:\n\n  The method \u003cmethod\u003e of type \u003ctype\u003e should be tagged with @Override\n  since it actually overrides a superclass method\n\nJustification for this warning is described in:\n\n  http://stackoverflow.com/a/94411/381622\n\nEnabling this causes in excess of 1000 warnings across the entire\ncode-base. They are very easy to fix automatically with Eclipse\u0027s\n\"Quick Fix\" tool.\n\nFix all of them except 2 which cause compilation failure when the\nproject is built with mvn; add TODO comments on those for further\ninvestigation.\n\nChange-Id: I5772061041fd361fe93137fd8b0ad356e748a29c\nSigned-off-by: David Pursehouse \u003cdavid.pursehouse@gmail.com\u003e\n",
      "commitDate": "2017/2/20 上午8:05",
      "commitName": "7ac182f4e427e0d5a986b8ca67a56fc22828b1a0",
      "commitAuthor": "David Pursehouse",
      "commitDateOld": "2017/1/28 下午10:06",
      "commitNameOld": "a4feeb01945e039b39a246f96a1a91b0e4836f01",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 22.42,
      "commitsBetweenForRepo": 49,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"boxing\")\npublic MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    fallBackToConfiguration();\n    checkParameters();\n    RevWalk revWalk \u003d null;\n    DirCacheCheckout dco \u003d null;\n    try {\n        Ref head \u003d repo.exactRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n        revWalk \u003d new RevWalk(repo);\n        Ref ref \u003d commits.get(0);\n        refLogMessage.append(ref.getName());\n        ref \u003d repo.peel(ref);\n        ObjectId objectId \u003d ref.getPeeledObjectId();\n        if (objectId \u003d\u003d null)\n            objectId \u003d ref.getObjectId();\n        RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n        ObjectId headId \u003d head.getObjectId();\n        if (headId \u003d\u003d null) {\n            revWalk.parseHeaders(srcCommit);\n            dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() !\u003d Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit) \u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            String msg \u003d null;\n            ObjectId newHead, base \u003d null;\n            MergeStatus mergeStatus \u003d null;\n            if (!squash) {\n                updateHead(refLogMessage, srcCommit, headId);\n                newHead \u003d base \u003d srcCommit;\n                mergeStatus \u003d MergeStatus.FAST_FORWARD;\n            } else {\n                msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                newHead \u003d base \u003d headId;\n                mergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n                List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            setCallable(false);\n            return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n        } else {\n            if (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n                return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n            }\n            String mergeMessage \u003d \"\";\n            if (!squash) {\n                if (message !\u003d null)\n                    mergeMessage \u003d message;\n                else\n                    mergeMessage \u003d new MergeMessageFormatter().format(commits, head);\n                repo.writeMergeCommitMsg(mergeMessage);\n                repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            } else {\n                List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            Merger merger \u003d mergeStrategy.newMerger(repo);\n            merger.setProgressMonitor(monitor);\n            boolean noProblems;\n            Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n            Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n            List\u003cString\u003e unmergedPaths \u003d null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n                lowLevelResults \u003d resolveMerger.getMergeResults();\n                failingPaths \u003d resolveMerger.getFailingPaths();\n                unmergedPaths \u003d resolveMerger.getUnmergedPaths();\n            } else\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n            refLogMessage.append(\": Merge made by \");\n            if (!revWalk.isMergedInto(headCommit, srcCommit))\n                refLogMessage.append(mergeStrategy.getName());\n            else\n                refLogMessage.append(\"recursive\");\n            refLogMessage.append(\u0027.\u0027);\n            if (noProblems) {\n                dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                String msg \u003d null;\n                ObjectId newHeadId \u003d null;\n                MergeStatus mergeStatus \u003d null;\n                if (!commit \u0026\u0026 squash) {\n                    mergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n                }\n                if (!commit \u0026\u0026 !squash) {\n                    mergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n                }\n                if (commit \u0026\u0026 !squash) {\n                    try (Git git \u003d new Git(getRepository())) {\n                        newHeadId \u003d git.commit().setReflogComment(refLogMessage.toString()).call().getId();\n                    }\n                    mergeStatus \u003d MergeStatus.MERGED;\n                    getRepository().autoGC(monitor);\n                }\n                if (commit \u0026\u0026 squash) {\n                    msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                    newHeadId \u003d headCommit.getId();\n                    mergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n                }\n                return new MergeResult(newHeadId, null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n            } else {\n                if (failingPaths !\u003d null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else {\n                    String mergeMessageWithConflicts \u003d new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                    repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                }\n            }\n        }\n    } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n        List\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections.\u003cString\u003eemptyList() : dco.getConflicts();\n        throw new CheckoutConflictException(conflicts, e);\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk !\u003d null)\n            revWalk.close();\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 228,
      "functionName": "call",
      "functionAnnotation": "@Override,@SuppressWarnings(\"boxing\")",
      "functionDoc": "Executes the {@code Merge} command with all the options and parameters\ncollected by the setter methods (e.g. {@link #include(Ref)}) of this\nclass. Each instance of this class should only be used for one invocation\nof the command. Don\u0027t call this method twice on an instance.\n\n@return the result of the merge\n",
      "diff": "@@ -1,148 +1,149 @@\n+@Override\n @SuppressWarnings(\"boxing\")\n public MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n     checkCallable();\n     fallBackToConfiguration();\n     checkParameters();\n     RevWalk revWalk \u003d null;\n     DirCacheCheckout dco \u003d null;\n     try {\n         Ref head \u003d repo.exactRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n         revWalk \u003d new RevWalk(repo);\n         Ref ref \u003d commits.get(0);\n         refLogMessage.append(ref.getName());\n         ref \u003d repo.peel(ref);\n         ObjectId objectId \u003d ref.getPeeledObjectId();\n         if (objectId \u003d\u003d null)\n             objectId \u003d ref.getObjectId();\n         RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n         ObjectId headId \u003d head.getObjectId();\n         if (headId \u003d\u003d null) {\n             revWalk.parseHeaders(srcCommit);\n             dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n             dco.setFailOnConflict(true);\n             dco.checkout();\n             RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n             refUpdate.setNewObjectId(objectId);\n             refUpdate.setExpectedOldObjectId(null);\n             refUpdate.setRefLogMessage(\"initial pull\", false);\n             if (refUpdate.update() !\u003d Result.NEW)\n                 throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n             setCallable(false);\n             return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n         }\n         RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n         if (revWalk.isMergedInto(srcCommit, headCommit)) {\n             setCallable(false);\n             return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n         } else if (revWalk.isMergedInto(headCommit, srcCommit) \u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n             refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n             dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n             dco.setFailOnConflict(true);\n             dco.checkout();\n             String msg \u003d null;\n             ObjectId newHead, base \u003d null;\n             MergeStatus mergeStatus \u003d null;\n             if (!squash) {\n                 updateHead(refLogMessage, srcCommit, headId);\n                 newHead \u003d base \u003d srcCommit;\n                 mergeStatus \u003d MergeStatus.FAST_FORWARD;\n             } else {\n                 msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                 newHead \u003d base \u003d headId;\n                 mergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n                 List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                 String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                 repo.writeSquashCommitMsg(squashMessage);\n             }\n             setCallable(false);\n             return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n         } else {\n             if (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n                 return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n             }\n             String mergeMessage \u003d \"\";\n             if (!squash) {\n                 if (message !\u003d null)\n                     mergeMessage \u003d message;\n                 else\n                     mergeMessage \u003d new MergeMessageFormatter().format(commits, head);\n                 repo.writeMergeCommitMsg(mergeMessage);\n                 repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n             } else {\n                 List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                 String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                 repo.writeSquashCommitMsg(squashMessage);\n             }\n             Merger merger \u003d mergeStrategy.newMerger(repo);\n             merger.setProgressMonitor(monitor);\n             boolean noProblems;\n             Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n             Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n             List\u003cString\u003e unmergedPaths \u003d null;\n             if (merger instanceof ResolveMerger) {\n                 ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                 resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                 resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n                 lowLevelResults \u003d resolveMerger.getMergeResults();\n                 failingPaths \u003d resolveMerger.getFailingPaths();\n                 unmergedPaths \u003d resolveMerger.getUnmergedPaths();\n             } else\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n             refLogMessage.append(\": Merge made by \");\n             if (!revWalk.isMergedInto(headCommit, srcCommit))\n                 refLogMessage.append(mergeStrategy.getName());\n             else\n                 refLogMessage.append(\"recursive\");\n             refLogMessage.append(\u0027.\u0027);\n             if (noProblems) {\n                 dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                 dco.setFailOnConflict(true);\n                 dco.checkout();\n                 String msg \u003d null;\n                 ObjectId newHeadId \u003d null;\n                 MergeStatus mergeStatus \u003d null;\n                 if (!commit \u0026\u0026 squash) {\n                     mergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n                 }\n                 if (!commit \u0026\u0026 !squash) {\n                     mergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n                 }\n                 if (commit \u0026\u0026 !squash) {\n                     try (Git git \u003d new Git(getRepository())) {\n                         newHeadId \u003d git.commit().setReflogComment(refLogMessage.toString()).call().getId();\n                     }\n                     mergeStatus \u003d MergeStatus.MERGED;\n                     getRepository().autoGC(monitor);\n                 }\n                 if (commit \u0026\u0026 squash) {\n                     msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                     newHeadId \u003d headCommit.getId();\n                     mergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n                 }\n                 return new MergeResult(newHeadId, null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n             } else {\n                 if (failingPaths !\u003d null) {\n                     repo.writeMergeCommitMsg(null);\n                     repo.writeMergeHeads(null);\n                     return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                 } else {\n                     String mergeMessageWithConflicts \u003d new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                     repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                     return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                 }\n             }\n         }\n     } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n         List\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections.\u003cString\u003eemptyList() : dco.getConflicts();\n         throw new CheckoutConflictException(conflicts, e);\n     } catch (IOException e) {\n         throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n     } finally {\n         if (revWalk !\u003d null)\n             revWalk.close();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "@SuppressWarnings(\"boxing\")",
        "newValue": "@Override,@SuppressWarnings(\"boxing\")"
      }
    },
    "64a404803eaccc88d7d57567c5cd86b88c342bec": {
      "type": "Ybodychange",
      "commitMessage": "Implement auto gc\n\nWith the auto option, gc checks whether any housekeeping is required; if\nnot, it exits without performing any work. Some JGit commands run gc\n--auto after performing operations that could create many loose objects.\nHousekeeping is required if there are too many loose objects or too many\npacks in the repository.\n\nIf the number of loose objects exceeds the value of the gc.auto option\njgit\u0027s GC consolidates all existing packs into a single pack (equivalent\nto -A option), whereas git-core would combine all loose objects into a\nsingle pack using repack -d -l. Setting the value of gc.auto to 0\ndisables automatic packing of loose objects.\n\nIf the number of packs exceeds the value of gc.autoPackLimit, then\nexisting packs (except those marked with a .keep file) are consolidated\ninto a single pack by using the -A option of repack. Setting\ngc.autoPackLimit to 0 disables automatic consolidation of packs.\n\nLike git the following jgit commands run auto gc:\n- fetch\n- merge\n- rebase\n- receive-pack\n\nThe auto gc for receive-pack can be suppressed by setting the config\noption receive.autogc \u003d false\n\nChange-Id: I68a2a051b39ec2c53cb7c4b8f6c596ba65eeba5d\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2016/10/23 上午7:34",
      "commitName": "64a404803eaccc88d7d57567c5cd86b88c342bec",
      "commitAuthor": "Matthias Sohn",
      "commitDateOld": "2016/5/31 上午6:11",
      "commitNameOld": "4c236ff4bbf664fd177a33f42517b0eef52510c8",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 145.06,
      "commitsBetweenForRepo": 198,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"boxing\")\npublic MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    fallBackToConfiguration();\n    checkParameters();\n    RevWalk revWalk \u003d null;\n    DirCacheCheckout dco \u003d null;\n    try {\n        Ref head \u003d repo.exactRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n        revWalk \u003d new RevWalk(repo);\n        Ref ref \u003d commits.get(0);\n        refLogMessage.append(ref.getName());\n        ref \u003d repo.peel(ref);\n        ObjectId objectId \u003d ref.getPeeledObjectId();\n        if (objectId \u003d\u003d null)\n            objectId \u003d ref.getObjectId();\n        RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n        ObjectId headId \u003d head.getObjectId();\n        if (headId \u003d\u003d null) {\n            revWalk.parseHeaders(srcCommit);\n            dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() !\u003d Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit) \u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            String msg \u003d null;\n            ObjectId newHead, base \u003d null;\n            MergeStatus mergeStatus \u003d null;\n            if (!squash) {\n                updateHead(refLogMessage, srcCommit, headId);\n                newHead \u003d base \u003d srcCommit;\n                mergeStatus \u003d MergeStatus.FAST_FORWARD;\n            } else {\n                msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                newHead \u003d base \u003d headId;\n                mergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n                List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            setCallable(false);\n            return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n        } else {\n            if (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n                return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n            }\n            String mergeMessage \u003d \"\";\n            if (!squash) {\n                if (message !\u003d null)\n                    mergeMessage \u003d message;\n                else\n                    mergeMessage \u003d new MergeMessageFormatter().format(commits, head);\n                repo.writeMergeCommitMsg(mergeMessage);\n                repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            } else {\n                List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            Merger merger \u003d mergeStrategy.newMerger(repo);\n            merger.setProgressMonitor(monitor);\n            boolean noProblems;\n            Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n            Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n            List\u003cString\u003e unmergedPaths \u003d null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n                lowLevelResults \u003d resolveMerger.getMergeResults();\n                failingPaths \u003d resolveMerger.getFailingPaths();\n                unmergedPaths \u003d resolveMerger.getUnmergedPaths();\n            } else\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n            refLogMessage.append(\": Merge made by \");\n            if (!revWalk.isMergedInto(headCommit, srcCommit))\n                refLogMessage.append(mergeStrategy.getName());\n            else\n                refLogMessage.append(\"recursive\");\n            refLogMessage.append(\u0027.\u0027);\n            if (noProblems) {\n                dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                String msg \u003d null;\n                ObjectId newHeadId \u003d null;\n                MergeStatus mergeStatus \u003d null;\n                if (!commit \u0026\u0026 squash) {\n                    mergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n                }\n                if (!commit \u0026\u0026 !squash) {\n                    mergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n                }\n                if (commit \u0026\u0026 !squash) {\n                    try (Git git \u003d new Git(getRepository())) {\n                        newHeadId \u003d git.commit().setReflogComment(refLogMessage.toString()).call().getId();\n                    }\n                    mergeStatus \u003d MergeStatus.MERGED;\n                    getRepository().autoGC(monitor);\n                }\n                if (commit \u0026\u0026 squash) {\n                    msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                    newHeadId \u003d headCommit.getId();\n                    mergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n                }\n                return new MergeResult(newHeadId, null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n            } else {\n                if (failingPaths !\u003d null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else {\n                    String mergeMessageWithConflicts \u003d new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                    repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                }\n            }\n        }\n    } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n        List\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections.\u003cString\u003eemptyList() : dco.getConflicts();\n        throw new CheckoutConflictException(conflicts, e);\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk !\u003d null)\n            revWalk.close();\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 224,
      "functionName": "call",
      "functionAnnotation": "@SuppressWarnings(\"boxing\")",
      "functionDoc": "Executes the {@code Merge} command with all the options and parameters\ncollected by the setter methods (e.g. {@link #include(Ref)}) of this\nclass. Each instance of this class should only be used for one invocation\nof the command. Don\u0027t call this method twice on an instance.\n\n@return the result of the merge\n",
      "diff": "@@ -1,147 +1,148 @@\n @SuppressWarnings(\"boxing\")\n public MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n     checkCallable();\n     fallBackToConfiguration();\n     checkParameters();\n     RevWalk revWalk \u003d null;\n     DirCacheCheckout dco \u003d null;\n     try {\n         Ref head \u003d repo.exactRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n         revWalk \u003d new RevWalk(repo);\n         Ref ref \u003d commits.get(0);\n         refLogMessage.append(ref.getName());\n         ref \u003d repo.peel(ref);\n         ObjectId objectId \u003d ref.getPeeledObjectId();\n         if (objectId \u003d\u003d null)\n             objectId \u003d ref.getObjectId();\n         RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n         ObjectId headId \u003d head.getObjectId();\n         if (headId \u003d\u003d null) {\n             revWalk.parseHeaders(srcCommit);\n             dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n             dco.setFailOnConflict(true);\n             dco.checkout();\n             RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n             refUpdate.setNewObjectId(objectId);\n             refUpdate.setExpectedOldObjectId(null);\n             refUpdate.setRefLogMessage(\"initial pull\", false);\n             if (refUpdate.update() !\u003d Result.NEW)\n                 throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n             setCallable(false);\n             return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n         }\n         RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n         if (revWalk.isMergedInto(srcCommit, headCommit)) {\n             setCallable(false);\n             return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n         } else if (revWalk.isMergedInto(headCommit, srcCommit) \u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n             refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n             dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n             dco.setFailOnConflict(true);\n             dco.checkout();\n             String msg \u003d null;\n             ObjectId newHead, base \u003d null;\n             MergeStatus mergeStatus \u003d null;\n             if (!squash) {\n                 updateHead(refLogMessage, srcCommit, headId);\n                 newHead \u003d base \u003d srcCommit;\n                 mergeStatus \u003d MergeStatus.FAST_FORWARD;\n             } else {\n                 msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                 newHead \u003d base \u003d headId;\n                 mergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n                 List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                 String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                 repo.writeSquashCommitMsg(squashMessage);\n             }\n             setCallable(false);\n             return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n         } else {\n             if (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n                 return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n             }\n             String mergeMessage \u003d \"\";\n             if (!squash) {\n                 if (message !\u003d null)\n                     mergeMessage \u003d message;\n                 else\n                     mergeMessage \u003d new MergeMessageFormatter().format(commits, head);\n                 repo.writeMergeCommitMsg(mergeMessage);\n                 repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n             } else {\n                 List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                 String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                 repo.writeSquashCommitMsg(squashMessage);\n             }\n             Merger merger \u003d mergeStrategy.newMerger(repo);\n             merger.setProgressMonitor(monitor);\n             boolean noProblems;\n             Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n             Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n             List\u003cString\u003e unmergedPaths \u003d null;\n             if (merger instanceof ResolveMerger) {\n                 ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                 resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                 resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n                 lowLevelResults \u003d resolveMerger.getMergeResults();\n                 failingPaths \u003d resolveMerger.getFailingPaths();\n                 unmergedPaths \u003d resolveMerger.getUnmergedPaths();\n             } else\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n             refLogMessage.append(\": Merge made by \");\n             if (!revWalk.isMergedInto(headCommit, srcCommit))\n                 refLogMessage.append(mergeStrategy.getName());\n             else\n                 refLogMessage.append(\"recursive\");\n             refLogMessage.append(\u0027.\u0027);\n             if (noProblems) {\n                 dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                 dco.setFailOnConflict(true);\n                 dco.checkout();\n                 String msg \u003d null;\n                 ObjectId newHeadId \u003d null;\n                 MergeStatus mergeStatus \u003d null;\n                 if (!commit \u0026\u0026 squash) {\n                     mergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n                 }\n                 if (!commit \u0026\u0026 !squash) {\n                     mergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n                 }\n                 if (commit \u0026\u0026 !squash) {\n                     try (Git git \u003d new Git(getRepository())) {\n                         newHeadId \u003d git.commit().setReflogComment(refLogMessage.toString()).call().getId();\n                     }\n                     mergeStatus \u003d MergeStatus.MERGED;\n+                    getRepository().autoGC(monitor);\n                 }\n                 if (commit \u0026\u0026 squash) {\n                     msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                     newHeadId \u003d headCommit.getId();\n                     mergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n                 }\n                 return new MergeResult(newHeadId, null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n             } else {\n                 if (failingPaths !\u003d null) {\n                     repo.writeMergeCommitMsg(null);\n                     repo.writeMergeHeads(null);\n                     return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                 } else {\n                     String mergeMessageWithConflicts \u003d new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                     repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                     return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                 }\n             }\n         }\n     } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n         List\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections.\u003cString\u003eemptyList() : dco.getConflicts();\n         throw new CheckoutConflictException(conflicts, e);\n     } catch (IOException e) {\n         throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n     } finally {\n         if (revWalk !\u003d null)\n             revWalk.close();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4c236ff4bbf664fd177a33f42517b0eef52510c8": {
      "type": "Ybodychange",
      "commitMessage": "Replace use of deprecated method Repository.getRef()\n\nChange-Id: Iecf2b8deafc4991cc3333702fb9fa0638be7b914\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2016/5/31 上午6:11",
      "commitName": "4c236ff4bbf664fd177a33f42517b0eef52510c8",
      "commitAuthor": "Matthias Sohn",
      "commitDateOld": "2016/1/21 下午6:37",
      "commitNameOld": "1e1fb9fc596603a44b0fff6d19eeba2b005d659d",
      "commitAuthorOld": "Laurent Delaigue",
      "daysBetweenCommits": 130.48,
      "commitsBetweenForRepo": 181,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"boxing\")\npublic MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    fallBackToConfiguration();\n    checkParameters();\n    RevWalk revWalk \u003d null;\n    DirCacheCheckout dco \u003d null;\n    try {\n        Ref head \u003d repo.exactRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n        revWalk \u003d new RevWalk(repo);\n        Ref ref \u003d commits.get(0);\n        refLogMessage.append(ref.getName());\n        ref \u003d repo.peel(ref);\n        ObjectId objectId \u003d ref.getPeeledObjectId();\n        if (objectId \u003d\u003d null)\n            objectId \u003d ref.getObjectId();\n        RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n        ObjectId headId \u003d head.getObjectId();\n        if (headId \u003d\u003d null) {\n            revWalk.parseHeaders(srcCommit);\n            dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() !\u003d Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit) \u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            String msg \u003d null;\n            ObjectId newHead, base \u003d null;\n            MergeStatus mergeStatus \u003d null;\n            if (!squash) {\n                updateHead(refLogMessage, srcCommit, headId);\n                newHead \u003d base \u003d srcCommit;\n                mergeStatus \u003d MergeStatus.FAST_FORWARD;\n            } else {\n                msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                newHead \u003d base \u003d headId;\n                mergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n                List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            setCallable(false);\n            return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n        } else {\n            if (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n                return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n            }\n            String mergeMessage \u003d \"\";\n            if (!squash) {\n                if (message !\u003d null)\n                    mergeMessage \u003d message;\n                else\n                    mergeMessage \u003d new MergeMessageFormatter().format(commits, head);\n                repo.writeMergeCommitMsg(mergeMessage);\n                repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            } else {\n                List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            Merger merger \u003d mergeStrategy.newMerger(repo);\n            merger.setProgressMonitor(monitor);\n            boolean noProblems;\n            Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n            Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n            List\u003cString\u003e unmergedPaths \u003d null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n                lowLevelResults \u003d resolveMerger.getMergeResults();\n                failingPaths \u003d resolveMerger.getFailingPaths();\n                unmergedPaths \u003d resolveMerger.getUnmergedPaths();\n            } else\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n            refLogMessage.append(\": Merge made by \");\n            if (!revWalk.isMergedInto(headCommit, srcCommit))\n                refLogMessage.append(mergeStrategy.getName());\n            else\n                refLogMessage.append(\"recursive\");\n            refLogMessage.append(\u0027.\u0027);\n            if (noProblems) {\n                dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                String msg \u003d null;\n                ObjectId newHeadId \u003d null;\n                MergeStatus mergeStatus \u003d null;\n                if (!commit \u0026\u0026 squash) {\n                    mergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n                }\n                if (!commit \u0026\u0026 !squash) {\n                    mergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n                }\n                if (commit \u0026\u0026 !squash) {\n                    try (Git git \u003d new Git(getRepository())) {\n                        newHeadId \u003d git.commit().setReflogComment(refLogMessage.toString()).call().getId();\n                    }\n                    mergeStatus \u003d MergeStatus.MERGED;\n                }\n                if (commit \u0026\u0026 squash) {\n                    msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                    newHeadId \u003d headCommit.getId();\n                    mergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n                }\n                return new MergeResult(newHeadId, null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n            } else {\n                if (failingPaths !\u003d null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else {\n                    String mergeMessageWithConflicts \u003d new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                    repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                }\n            }\n        }\n    } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n        List\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections.\u003cString\u003eemptyList() : dco.getConflicts();\n        throw new CheckoutConflictException(conflicts, e);\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk !\u003d null)\n            revWalk.close();\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 224,
      "functionName": "call",
      "functionAnnotation": "@SuppressWarnings(\"boxing\")",
      "functionDoc": "Executes the {@code Merge} command with all the options and parameters\ncollected by the setter methods (e.g. {@link #include(Ref)}) of this\nclass. Each instance of this class should only be used for one invocation\nof the command. Don\u0027t call this method twice on an instance.\n\n@return the result of the merge\n",
      "diff": "@@ -1,147 +1,147 @@\n @SuppressWarnings(\"boxing\")\n public MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n     checkCallable();\n     fallBackToConfiguration();\n     checkParameters();\n     RevWalk revWalk \u003d null;\n     DirCacheCheckout dco \u003d null;\n     try {\n-        Ref head \u003d repo.getRef(Constants.HEAD);\n+        Ref head \u003d repo.exactRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n         revWalk \u003d new RevWalk(repo);\n         Ref ref \u003d commits.get(0);\n         refLogMessage.append(ref.getName());\n         ref \u003d repo.peel(ref);\n         ObjectId objectId \u003d ref.getPeeledObjectId();\n         if (objectId \u003d\u003d null)\n             objectId \u003d ref.getObjectId();\n         RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n         ObjectId headId \u003d head.getObjectId();\n         if (headId \u003d\u003d null) {\n             revWalk.parseHeaders(srcCommit);\n             dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n             dco.setFailOnConflict(true);\n             dco.checkout();\n             RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n             refUpdate.setNewObjectId(objectId);\n             refUpdate.setExpectedOldObjectId(null);\n             refUpdate.setRefLogMessage(\"initial pull\", false);\n             if (refUpdate.update() !\u003d Result.NEW)\n                 throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n             setCallable(false);\n             return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n         }\n         RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n         if (revWalk.isMergedInto(srcCommit, headCommit)) {\n             setCallable(false);\n             return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n         } else if (revWalk.isMergedInto(headCommit, srcCommit) \u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n             refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n             dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n             dco.setFailOnConflict(true);\n             dco.checkout();\n             String msg \u003d null;\n             ObjectId newHead, base \u003d null;\n             MergeStatus mergeStatus \u003d null;\n             if (!squash) {\n                 updateHead(refLogMessage, srcCommit, headId);\n                 newHead \u003d base \u003d srcCommit;\n                 mergeStatus \u003d MergeStatus.FAST_FORWARD;\n             } else {\n                 msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                 newHead \u003d base \u003d headId;\n                 mergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n                 List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                 String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                 repo.writeSquashCommitMsg(squashMessage);\n             }\n             setCallable(false);\n             return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n         } else {\n             if (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n                 return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n             }\n             String mergeMessage \u003d \"\";\n             if (!squash) {\n                 if (message !\u003d null)\n                     mergeMessage \u003d message;\n                 else\n                     mergeMessage \u003d new MergeMessageFormatter().format(commits, head);\n                 repo.writeMergeCommitMsg(mergeMessage);\n                 repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n             } else {\n                 List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                 String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                 repo.writeSquashCommitMsg(squashMessage);\n             }\n             Merger merger \u003d mergeStrategy.newMerger(repo);\n             merger.setProgressMonitor(monitor);\n             boolean noProblems;\n             Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n             Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n             List\u003cString\u003e unmergedPaths \u003d null;\n             if (merger instanceof ResolveMerger) {\n                 ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                 resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                 resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n                 lowLevelResults \u003d resolveMerger.getMergeResults();\n                 failingPaths \u003d resolveMerger.getFailingPaths();\n                 unmergedPaths \u003d resolveMerger.getUnmergedPaths();\n             } else\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n             refLogMessage.append(\": Merge made by \");\n             if (!revWalk.isMergedInto(headCommit, srcCommit))\n                 refLogMessage.append(mergeStrategy.getName());\n             else\n                 refLogMessage.append(\"recursive\");\n             refLogMessage.append(\u0027.\u0027);\n             if (noProblems) {\n                 dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                 dco.setFailOnConflict(true);\n                 dco.checkout();\n                 String msg \u003d null;\n                 ObjectId newHeadId \u003d null;\n                 MergeStatus mergeStatus \u003d null;\n                 if (!commit \u0026\u0026 squash) {\n                     mergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n                 }\n                 if (!commit \u0026\u0026 !squash) {\n                     mergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n                 }\n                 if (commit \u0026\u0026 !squash) {\n                     try (Git git \u003d new Git(getRepository())) {\n                         newHeadId \u003d git.commit().setReflogComment(refLogMessage.toString()).call().getId();\n                     }\n                     mergeStatus \u003d MergeStatus.MERGED;\n                 }\n                 if (commit \u0026\u0026 squash) {\n                     msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                     newHeadId \u003d headCommit.getId();\n                     mergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n                 }\n                 return new MergeResult(newHeadId, null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n             } else {\n                 if (failingPaths !\u003d null) {\n                     repo.writeMergeCommitMsg(null);\n                     repo.writeMergeHeads(null);\n                     return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                 } else {\n                     String mergeMessageWithConflicts \u003d new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                     repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                     return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                 }\n             }\n         }\n     } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n         List\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections.\u003cString\u003eemptyList() : dco.getConflicts();\n         throw new CheckoutConflictException(conflicts, e);\n     } catch (IOException e) {\n         throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n     } finally {\n         if (revWalk !\u003d null)\n             revWalk.close();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1e1fb9fc596603a44b0fff6d19eeba2b005d659d": {
      "type": "Ybodychange",
      "commitMessage": "Add progress monitor to Merger\n\nMonitoring progress of merges can be useful for users for large\nrepositories or complex merge processes that take some time.\n\nThis enables setting a monitor. Existing merge implementations in jgit\ndo not yet report progress if a monitor is set. This will be added in a\nlater change.\n\nChange-Id: I17b978b3fc91750dd88649638b90a46820a0877c\nSigned-off-by: Laurent Delaigue \u003claurent.delaigue@obeo.fr\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2016/1/21 下午6:37",
      "commitName": "1e1fb9fc596603a44b0fff6d19eeba2b005d659d",
      "commitAuthor": "Laurent Delaigue",
      "commitDateOld": "2015/5/21 上午6:01",
      "commitNameOld": "0e73d395061d1bfee365acaa2f79c392175d13bf",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 245.52,
      "commitsBetweenForRepo": 444,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"boxing\")\npublic MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    fallBackToConfiguration();\n    checkParameters();\n    RevWalk revWalk \u003d null;\n    DirCacheCheckout dco \u003d null;\n    try {\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n        revWalk \u003d new RevWalk(repo);\n        Ref ref \u003d commits.get(0);\n        refLogMessage.append(ref.getName());\n        ref \u003d repo.peel(ref);\n        ObjectId objectId \u003d ref.getPeeledObjectId();\n        if (objectId \u003d\u003d null)\n            objectId \u003d ref.getObjectId();\n        RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n        ObjectId headId \u003d head.getObjectId();\n        if (headId \u003d\u003d null) {\n            revWalk.parseHeaders(srcCommit);\n            dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() !\u003d Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit) \u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            String msg \u003d null;\n            ObjectId newHead, base \u003d null;\n            MergeStatus mergeStatus \u003d null;\n            if (!squash) {\n                updateHead(refLogMessage, srcCommit, headId);\n                newHead \u003d base \u003d srcCommit;\n                mergeStatus \u003d MergeStatus.FAST_FORWARD;\n            } else {\n                msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                newHead \u003d base \u003d headId;\n                mergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n                List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            setCallable(false);\n            return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n        } else {\n            if (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n                return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n            }\n            String mergeMessage \u003d \"\";\n            if (!squash) {\n                if (message !\u003d null)\n                    mergeMessage \u003d message;\n                else\n                    mergeMessage \u003d new MergeMessageFormatter().format(commits, head);\n                repo.writeMergeCommitMsg(mergeMessage);\n                repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            } else {\n                List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            Merger merger \u003d mergeStrategy.newMerger(repo);\n            merger.setProgressMonitor(monitor);\n            boolean noProblems;\n            Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n            Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n            List\u003cString\u003e unmergedPaths \u003d null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n                lowLevelResults \u003d resolveMerger.getMergeResults();\n                failingPaths \u003d resolveMerger.getFailingPaths();\n                unmergedPaths \u003d resolveMerger.getUnmergedPaths();\n            } else\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n            refLogMessage.append(\": Merge made by \");\n            if (!revWalk.isMergedInto(headCommit, srcCommit))\n                refLogMessage.append(mergeStrategy.getName());\n            else\n                refLogMessage.append(\"recursive\");\n            refLogMessage.append(\u0027.\u0027);\n            if (noProblems) {\n                dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                String msg \u003d null;\n                ObjectId newHeadId \u003d null;\n                MergeStatus mergeStatus \u003d null;\n                if (!commit \u0026\u0026 squash) {\n                    mergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n                }\n                if (!commit \u0026\u0026 !squash) {\n                    mergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n                }\n                if (commit \u0026\u0026 !squash) {\n                    try (Git git \u003d new Git(getRepository())) {\n                        newHeadId \u003d git.commit().setReflogComment(refLogMessage.toString()).call().getId();\n                    }\n                    mergeStatus \u003d MergeStatus.MERGED;\n                }\n                if (commit \u0026\u0026 squash) {\n                    msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                    newHeadId \u003d headCommit.getId();\n                    mergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n                }\n                return new MergeResult(newHeadId, null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n            } else {\n                if (failingPaths !\u003d null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else {\n                    String mergeMessageWithConflicts \u003d new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                    repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                }\n            }\n        }\n    } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n        List\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections.\u003cString\u003eemptyList() : dco.getConflicts();\n        throw new CheckoutConflictException(conflicts, e);\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk !\u003d null)\n            revWalk.close();\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 224,
      "functionName": "call",
      "functionAnnotation": "@SuppressWarnings(\"boxing\")",
      "functionDoc": "Executes the {@code Merge} command with all the options and parameters\ncollected by the setter methods (e.g. {@link #include(Ref)}) of this\nclass. Each instance of this class should only be used for one invocation\nof the command. Don\u0027t call this method twice on an instance.\n\n@return the result of the merge\n",
      "diff": "@@ -1,146 +1,147 @@\n @SuppressWarnings(\"boxing\")\n public MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n     checkCallable();\n     fallBackToConfiguration();\n     checkParameters();\n     RevWalk revWalk \u003d null;\n     DirCacheCheckout dco \u003d null;\n     try {\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n         revWalk \u003d new RevWalk(repo);\n         Ref ref \u003d commits.get(0);\n         refLogMessage.append(ref.getName());\n         ref \u003d repo.peel(ref);\n         ObjectId objectId \u003d ref.getPeeledObjectId();\n         if (objectId \u003d\u003d null)\n             objectId \u003d ref.getObjectId();\n         RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n         ObjectId headId \u003d head.getObjectId();\n         if (headId \u003d\u003d null) {\n             revWalk.parseHeaders(srcCommit);\n             dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n             dco.setFailOnConflict(true);\n             dco.checkout();\n             RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n             refUpdate.setNewObjectId(objectId);\n             refUpdate.setExpectedOldObjectId(null);\n             refUpdate.setRefLogMessage(\"initial pull\", false);\n             if (refUpdate.update() !\u003d Result.NEW)\n                 throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n             setCallable(false);\n             return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n         }\n         RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n         if (revWalk.isMergedInto(srcCommit, headCommit)) {\n             setCallable(false);\n             return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n         } else if (revWalk.isMergedInto(headCommit, srcCommit) \u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n             refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n             dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n             dco.setFailOnConflict(true);\n             dco.checkout();\n             String msg \u003d null;\n             ObjectId newHead, base \u003d null;\n             MergeStatus mergeStatus \u003d null;\n             if (!squash) {\n                 updateHead(refLogMessage, srcCommit, headId);\n                 newHead \u003d base \u003d srcCommit;\n                 mergeStatus \u003d MergeStatus.FAST_FORWARD;\n             } else {\n                 msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                 newHead \u003d base \u003d headId;\n                 mergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n                 List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                 String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                 repo.writeSquashCommitMsg(squashMessage);\n             }\n             setCallable(false);\n             return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n         } else {\n             if (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n                 return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n             }\n             String mergeMessage \u003d \"\";\n             if (!squash) {\n                 if (message !\u003d null)\n                     mergeMessage \u003d message;\n                 else\n                     mergeMessage \u003d new MergeMessageFormatter().format(commits, head);\n                 repo.writeMergeCommitMsg(mergeMessage);\n                 repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n             } else {\n                 List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                 String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                 repo.writeSquashCommitMsg(squashMessage);\n             }\n             Merger merger \u003d mergeStrategy.newMerger(repo);\n+            merger.setProgressMonitor(monitor);\n             boolean noProblems;\n             Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n             Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n             List\u003cString\u003e unmergedPaths \u003d null;\n             if (merger instanceof ResolveMerger) {\n                 ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                 resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                 resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n                 lowLevelResults \u003d resolveMerger.getMergeResults();\n                 failingPaths \u003d resolveMerger.getFailingPaths();\n                 unmergedPaths \u003d resolveMerger.getUnmergedPaths();\n             } else\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n             refLogMessage.append(\": Merge made by \");\n             if (!revWalk.isMergedInto(headCommit, srcCommit))\n                 refLogMessage.append(mergeStrategy.getName());\n             else\n                 refLogMessage.append(\"recursive\");\n             refLogMessage.append(\u0027.\u0027);\n             if (noProblems) {\n                 dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                 dco.setFailOnConflict(true);\n                 dco.checkout();\n                 String msg \u003d null;\n                 ObjectId newHeadId \u003d null;\n                 MergeStatus mergeStatus \u003d null;\n                 if (!commit \u0026\u0026 squash) {\n                     mergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n                 }\n                 if (!commit \u0026\u0026 !squash) {\n                     mergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n                 }\n                 if (commit \u0026\u0026 !squash) {\n                     try (Git git \u003d new Git(getRepository())) {\n                         newHeadId \u003d git.commit().setReflogComment(refLogMessage.toString()).call().getId();\n                     }\n                     mergeStatus \u003d MergeStatus.MERGED;\n                 }\n                 if (commit \u0026\u0026 squash) {\n                     msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                     newHeadId \u003d headCommit.getId();\n                     mergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n                 }\n                 return new MergeResult(newHeadId, null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n             } else {\n                 if (failingPaths !\u003d null) {\n                     repo.writeMergeCommitMsg(null);\n                     repo.writeMergeHeads(null);\n                     return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                 } else {\n                     String mergeMessageWithConflicts \u003d new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                     repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                     return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                 }\n             }\n         }\n     } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n         List\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections.\u003cString\u003eemptyList() : dco.getConflicts();\n         throw new CheckoutConflictException(conflicts, e);\n     } catch (IOException e) {\n         throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n     } finally {\n         if (revWalk !\u003d null)\n             revWalk.close();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0e73d395061d1bfee365acaa2f79c392175d13bf": {
      "type": "Ybodychange",
      "commitMessage": "Use AutoClosable to close resources in bundle org.eclipse.jgit\n\n- use try-with-resource where possible\n- replace use of deprecated release() by close()\n\nChange-Id: I0f139c3535679087b7fa09649166bca514750b81\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2015/5/21 上午6:01",
      "commitName": "0e73d395061d1bfee365acaa2f79c392175d13bf",
      "commitAuthor": "Matthias Sohn",
      "commitDateOld": "2014/9/4 下午5:35",
      "commitNameOld": "2f6372337cfd5944e2179f5ec5e2dbe0cbc96386",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 258.52,
      "commitsBetweenForRepo": 318,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"boxing\")\npublic MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    fallBackToConfiguration();\n    checkParameters();\n    RevWalk revWalk \u003d null;\n    DirCacheCheckout dco \u003d null;\n    try {\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n        revWalk \u003d new RevWalk(repo);\n        Ref ref \u003d commits.get(0);\n        refLogMessage.append(ref.getName());\n        ref \u003d repo.peel(ref);\n        ObjectId objectId \u003d ref.getPeeledObjectId();\n        if (objectId \u003d\u003d null)\n            objectId \u003d ref.getObjectId();\n        RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n        ObjectId headId \u003d head.getObjectId();\n        if (headId \u003d\u003d null) {\n            revWalk.parseHeaders(srcCommit);\n            dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() !\u003d Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit) \u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            String msg \u003d null;\n            ObjectId newHead, base \u003d null;\n            MergeStatus mergeStatus \u003d null;\n            if (!squash) {\n                updateHead(refLogMessage, srcCommit, headId);\n                newHead \u003d base \u003d srcCommit;\n                mergeStatus \u003d MergeStatus.FAST_FORWARD;\n            } else {\n                msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                newHead \u003d base \u003d headId;\n                mergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n                List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            setCallable(false);\n            return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n        } else {\n            if (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n                return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n            }\n            String mergeMessage \u003d \"\";\n            if (!squash) {\n                if (message !\u003d null)\n                    mergeMessage \u003d message;\n                else\n                    mergeMessage \u003d new MergeMessageFormatter().format(commits, head);\n                repo.writeMergeCommitMsg(mergeMessage);\n                repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            } else {\n                List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            Merger merger \u003d mergeStrategy.newMerger(repo);\n            boolean noProblems;\n            Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n            Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n            List\u003cString\u003e unmergedPaths \u003d null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n                lowLevelResults \u003d resolveMerger.getMergeResults();\n                failingPaths \u003d resolveMerger.getFailingPaths();\n                unmergedPaths \u003d resolveMerger.getUnmergedPaths();\n            } else\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n            refLogMessage.append(\": Merge made by \");\n            if (!revWalk.isMergedInto(headCommit, srcCommit))\n                refLogMessage.append(mergeStrategy.getName());\n            else\n                refLogMessage.append(\"recursive\");\n            refLogMessage.append(\u0027.\u0027);\n            if (noProblems) {\n                dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                String msg \u003d null;\n                ObjectId newHeadId \u003d null;\n                MergeStatus mergeStatus \u003d null;\n                if (!commit \u0026\u0026 squash) {\n                    mergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n                }\n                if (!commit \u0026\u0026 !squash) {\n                    mergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n                }\n                if (commit \u0026\u0026 !squash) {\n                    try (Git git \u003d new Git(getRepository())) {\n                        newHeadId \u003d git.commit().setReflogComment(refLogMessage.toString()).call().getId();\n                    }\n                    mergeStatus \u003d MergeStatus.MERGED;\n                }\n                if (commit \u0026\u0026 squash) {\n                    msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                    newHeadId \u003d headCommit.getId();\n                    mergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n                }\n                return new MergeResult(newHeadId, null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n            } else {\n                if (failingPaths !\u003d null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else {\n                    String mergeMessageWithConflicts \u003d new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                    repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                }\n            }\n        }\n    } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n        List\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections.\u003cString\u003eemptyList() : dco.getConflicts();\n        throw new CheckoutConflictException(conflicts, e);\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk !\u003d null)\n            revWalk.close();\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 219,
      "functionName": "call",
      "functionAnnotation": "@SuppressWarnings(\"boxing\")",
      "functionDoc": "Executes the {@code Merge} command with all the options and parameters\ncollected by the setter methods (e.g. {@link #include(Ref)}) of this\nclass. Each instance of this class should only be used for one invocation\nof the command. Don\u0027t call this method twice on an instance.\n\n@return the result of the merge\n",
      "diff": "@@ -1,144 +1,146 @@\n @SuppressWarnings(\"boxing\")\n public MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n     checkCallable();\n     fallBackToConfiguration();\n     checkParameters();\n     RevWalk revWalk \u003d null;\n     DirCacheCheckout dco \u003d null;\n     try {\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n         revWalk \u003d new RevWalk(repo);\n         Ref ref \u003d commits.get(0);\n         refLogMessage.append(ref.getName());\n         ref \u003d repo.peel(ref);\n         ObjectId objectId \u003d ref.getPeeledObjectId();\n         if (objectId \u003d\u003d null)\n             objectId \u003d ref.getObjectId();\n         RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n         ObjectId headId \u003d head.getObjectId();\n         if (headId \u003d\u003d null) {\n             revWalk.parseHeaders(srcCommit);\n             dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n             dco.setFailOnConflict(true);\n             dco.checkout();\n             RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n             refUpdate.setNewObjectId(objectId);\n             refUpdate.setExpectedOldObjectId(null);\n             refUpdate.setRefLogMessage(\"initial pull\", false);\n             if (refUpdate.update() !\u003d Result.NEW)\n                 throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n             setCallable(false);\n             return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n         }\n         RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n         if (revWalk.isMergedInto(srcCommit, headCommit)) {\n             setCallable(false);\n             return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n         } else if (revWalk.isMergedInto(headCommit, srcCommit) \u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n             refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n             dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n             dco.setFailOnConflict(true);\n             dco.checkout();\n             String msg \u003d null;\n             ObjectId newHead, base \u003d null;\n             MergeStatus mergeStatus \u003d null;\n             if (!squash) {\n                 updateHead(refLogMessage, srcCommit, headId);\n                 newHead \u003d base \u003d srcCommit;\n                 mergeStatus \u003d MergeStatus.FAST_FORWARD;\n             } else {\n                 msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                 newHead \u003d base \u003d headId;\n                 mergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n                 List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                 String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                 repo.writeSquashCommitMsg(squashMessage);\n             }\n             setCallable(false);\n             return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n         } else {\n             if (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n                 return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n             }\n             String mergeMessage \u003d \"\";\n             if (!squash) {\n                 if (message !\u003d null)\n                     mergeMessage \u003d message;\n                 else\n                     mergeMessage \u003d new MergeMessageFormatter().format(commits, head);\n                 repo.writeMergeCommitMsg(mergeMessage);\n                 repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n             } else {\n                 List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                 String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                 repo.writeSquashCommitMsg(squashMessage);\n             }\n             Merger merger \u003d mergeStrategy.newMerger(repo);\n             boolean noProblems;\n             Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n             Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n             List\u003cString\u003e unmergedPaths \u003d null;\n             if (merger instanceof ResolveMerger) {\n                 ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                 resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                 resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n                 lowLevelResults \u003d resolveMerger.getMergeResults();\n                 failingPaths \u003d resolveMerger.getFailingPaths();\n                 unmergedPaths \u003d resolveMerger.getUnmergedPaths();\n             } else\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n             refLogMessage.append(\": Merge made by \");\n             if (!revWalk.isMergedInto(headCommit, srcCommit))\n                 refLogMessage.append(mergeStrategy.getName());\n             else\n                 refLogMessage.append(\"recursive\");\n             refLogMessage.append(\u0027.\u0027);\n             if (noProblems) {\n                 dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                 dco.setFailOnConflict(true);\n                 dco.checkout();\n                 String msg \u003d null;\n                 ObjectId newHeadId \u003d null;\n                 MergeStatus mergeStatus \u003d null;\n                 if (!commit \u0026\u0026 squash) {\n                     mergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n                 }\n                 if (!commit \u0026\u0026 !squash) {\n                     mergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n                 }\n                 if (commit \u0026\u0026 !squash) {\n-                    newHeadId \u003d new Git(getRepository()).commit().setReflogComment(refLogMessage.toString()).call().getId();\n+                    try (Git git \u003d new Git(getRepository())) {\n+                        newHeadId \u003d git.commit().setReflogComment(refLogMessage.toString()).call().getId();\n+                    }\n                     mergeStatus \u003d MergeStatus.MERGED;\n                 }\n                 if (commit \u0026\u0026 squash) {\n                     msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                     newHeadId \u003d headCommit.getId();\n                     mergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n                 }\n                 return new MergeResult(newHeadId, null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n             } else {\n                 if (failingPaths !\u003d null) {\n                     repo.writeMergeCommitMsg(null);\n                     repo.writeMergeHeads(null);\n                     return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                 } else {\n                     String mergeMessageWithConflicts \u003d new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                     repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                     return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                 }\n             }\n         }\n     } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n         List\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections.\u003cString\u003eemptyList() : dco.getConflicts();\n         throw new CheckoutConflictException(conflicts, e);\n     } catch (IOException e) {\n         throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n     } finally {\n         if (revWalk !\u003d null)\n-            revWalk.release();\n+            revWalk.close();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "46f3007b52a5d12c5a973957128ac38680b20ab8": {
      "type": "Ybodychange",
      "commitMessage": "Handle -m option for Merge command\n\nSet the commit message to be used for the merge commit (in case one is\ncreated)\n\nBug: 442886\nChange-Id: Ie5ecc13822faa366f00b3daa07f74c8441cae195\nSigned-off-by: Axel Richard \u003caxel.richard@obeo.fr\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2014/8/30 上午7:17",
      "commitName": "46f3007b52a5d12c5a973957128ac38680b20ab8",
      "commitAuthor": "Axel Richard",
      "commitDateOld": "2014/3/30 上午1:34",
      "commitNameOld": "32ff57a2b2b9480f4d374a2592fada7f720b124f",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 153.24,
      "commitsBetweenForRepo": 199,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"boxing\")\npublic MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    fallBackToConfiguration();\n    checkParameters();\n    RevWalk revWalk \u003d null;\n    DirCacheCheckout dco \u003d null;\n    try {\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n        revWalk \u003d new RevWalk(repo);\n        Ref ref \u003d commits.get(0);\n        refLogMessage.append(ref.getName());\n        ref \u003d repo.peel(ref);\n        ObjectId objectId \u003d ref.getPeeledObjectId();\n        if (objectId \u003d\u003d null)\n            objectId \u003d ref.getObjectId();\n        RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n        ObjectId headId \u003d head.getObjectId();\n        if (headId \u003d\u003d null) {\n            revWalk.parseHeaders(srcCommit);\n            dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() !\u003d Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit) \u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            String msg \u003d null;\n            ObjectId newHead, base \u003d null;\n            MergeStatus mergeStatus \u003d null;\n            if (!squash) {\n                updateHead(refLogMessage, srcCommit, headId);\n                newHead \u003d base \u003d srcCommit;\n                mergeStatus \u003d MergeStatus.FAST_FORWARD;\n            } else {\n                msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                newHead \u003d base \u003d headId;\n                mergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n                List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            setCallable(false);\n            return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n        } else {\n            if (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n                return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n            }\n            String mergeMessage \u003d \"\";\n            if (!squash) {\n                if (message !\u003d null)\n                    mergeMessage \u003d message;\n                else\n                    mergeMessage \u003d new MergeMessageFormatter().format(commits, head);\n                repo.writeMergeCommitMsg(mergeMessage);\n                repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            } else {\n                List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            Merger merger \u003d mergeStrategy.newMerger(repo);\n            boolean noProblems;\n            Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n            Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n            List\u003cString\u003e unmergedPaths \u003d null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n                lowLevelResults \u003d resolveMerger.getMergeResults();\n                failingPaths \u003d resolveMerger.getFailingPaths();\n                unmergedPaths \u003d resolveMerger.getUnmergedPaths();\n            } else\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n            refLogMessage.append(\": Merge made by \");\n            if (!revWalk.isMergedInto(headCommit, srcCommit))\n                refLogMessage.append(mergeStrategy.getName());\n            else\n                refLogMessage.append(\"recursive\");\n            refLogMessage.append(\u0027.\u0027);\n            if (noProblems) {\n                dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                String msg \u003d null;\n                ObjectId newHeadId \u003d null;\n                MergeStatus mergeStatus \u003d null;\n                if (!commit \u0026\u0026 squash) {\n                    mergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n                }\n                if (!commit \u0026\u0026 !squash) {\n                    mergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n                }\n                if (commit \u0026\u0026 !squash) {\n                    newHeadId \u003d new Git(getRepository()).commit().setReflogComment(refLogMessage.toString()).call().getId();\n                    mergeStatus \u003d MergeStatus.MERGED;\n                }\n                if (commit \u0026\u0026 squash) {\n                    msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                    newHeadId \u003d headCommit.getId();\n                    mergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n                }\n                return new MergeResult(newHeadId, null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n            } else {\n                if (failingPaths !\u003d null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else {\n                    String mergeMessageWithConflicts \u003d new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                    repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                }\n            }\n        }\n    } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n        List\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections.\u003cString\u003eemptyList() : dco.getConflicts();\n        throw new CheckoutConflictException(conflicts, e);\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk !\u003d null)\n            revWalk.release();\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 219,
      "functionName": "call",
      "functionAnnotation": "@SuppressWarnings(\"boxing\")",
      "functionDoc": "Executes the {@code Merge} command with all the options and parameters\ncollected by the setter methods (e.g. {@link #include(Ref)}) of this\nclass. Each instance of this class should only be used for one invocation\nof the command. Don\u0027t call this method twice on an instance.\n\n@return the result of the merge\n",
      "diff": "@@ -1,141 +1,144 @@\n @SuppressWarnings(\"boxing\")\n public MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n     checkCallable();\n     fallBackToConfiguration();\n     checkParameters();\n     RevWalk revWalk \u003d null;\n     DirCacheCheckout dco \u003d null;\n     try {\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n         revWalk \u003d new RevWalk(repo);\n         Ref ref \u003d commits.get(0);\n         refLogMessage.append(ref.getName());\n         ref \u003d repo.peel(ref);\n         ObjectId objectId \u003d ref.getPeeledObjectId();\n         if (objectId \u003d\u003d null)\n             objectId \u003d ref.getObjectId();\n         RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n         ObjectId headId \u003d head.getObjectId();\n         if (headId \u003d\u003d null) {\n             revWalk.parseHeaders(srcCommit);\n             dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n             dco.setFailOnConflict(true);\n             dco.checkout();\n             RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n             refUpdate.setNewObjectId(objectId);\n             refUpdate.setExpectedOldObjectId(null);\n             refUpdate.setRefLogMessage(\"initial pull\", false);\n             if (refUpdate.update() !\u003d Result.NEW)\n                 throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n             setCallable(false);\n             return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n         }\n         RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n         if (revWalk.isMergedInto(srcCommit, headCommit)) {\n             setCallable(false);\n             return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n         } else if (revWalk.isMergedInto(headCommit, srcCommit) \u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n             refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n             dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n             dco.setFailOnConflict(true);\n             dco.checkout();\n             String msg \u003d null;\n             ObjectId newHead, base \u003d null;\n             MergeStatus mergeStatus \u003d null;\n             if (!squash) {\n                 updateHead(refLogMessage, srcCommit, headId);\n                 newHead \u003d base \u003d srcCommit;\n                 mergeStatus \u003d MergeStatus.FAST_FORWARD;\n             } else {\n                 msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                 newHead \u003d base \u003d headId;\n                 mergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n                 List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                 String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                 repo.writeSquashCommitMsg(squashMessage);\n             }\n             setCallable(false);\n             return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n         } else {\n             if (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n                 return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n             }\n             String mergeMessage \u003d \"\";\n             if (!squash) {\n-                mergeMessage \u003d new MergeMessageFormatter().format(commits, head);\n+                if (message !\u003d null)\n+                    mergeMessage \u003d message;\n+                else\n+                    mergeMessage \u003d new MergeMessageFormatter().format(commits, head);\n                 repo.writeMergeCommitMsg(mergeMessage);\n                 repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n             } else {\n                 List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                 String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                 repo.writeSquashCommitMsg(squashMessage);\n             }\n             Merger merger \u003d mergeStrategy.newMerger(repo);\n             boolean noProblems;\n             Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n             Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n             List\u003cString\u003e unmergedPaths \u003d null;\n             if (merger instanceof ResolveMerger) {\n                 ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                 resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                 resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n                 lowLevelResults \u003d resolveMerger.getMergeResults();\n                 failingPaths \u003d resolveMerger.getFailingPaths();\n                 unmergedPaths \u003d resolveMerger.getUnmergedPaths();\n             } else\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n             refLogMessage.append(\": Merge made by \");\n             if (!revWalk.isMergedInto(headCommit, srcCommit))\n                 refLogMessage.append(mergeStrategy.getName());\n             else\n                 refLogMessage.append(\"recursive\");\n             refLogMessage.append(\u0027.\u0027);\n             if (noProblems) {\n                 dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                 dco.setFailOnConflict(true);\n                 dco.checkout();\n                 String msg \u003d null;\n                 ObjectId newHeadId \u003d null;\n                 MergeStatus mergeStatus \u003d null;\n                 if (!commit \u0026\u0026 squash) {\n                     mergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n                 }\n                 if (!commit \u0026\u0026 !squash) {\n                     mergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n                 }\n                 if (commit \u0026\u0026 !squash) {\n                     newHeadId \u003d new Git(getRepository()).commit().setReflogComment(refLogMessage.toString()).call().getId();\n                     mergeStatus \u003d MergeStatus.MERGED;\n                 }\n                 if (commit \u0026\u0026 squash) {\n                     msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                     newHeadId \u003d headCommit.getId();\n                     mergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n                 }\n                 return new MergeResult(newHeadId, null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n             } else {\n                 if (failingPaths !\u003d null) {\n                     repo.writeMergeCommitMsg(null);\n                     repo.writeMergeHeads(null);\n                     return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                 } else {\n                     String mergeMessageWithConflicts \u003d new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                     repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                     return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                 }\n             }\n         }\n     } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n         List\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections.\u003cString\u003eemptyList() : dco.getConflicts();\n         throw new CheckoutConflictException(conflicts, e);\n     } catch (IOException e) {\n         throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n     } finally {\n         if (revWalk !\u003d null)\n             revWalk.release();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "48e36d8cb335382b99ec829d0dfe34be71ed49bb": {
      "type": "Ymultichange(Ybodychange,Yannotationchange)",
      "commitMessage": "Use branch.\u003cx\u003e.mergeoptions and merge.ff as defaults for merging\n\nRead options that control squashing, whether or not to commit the merge\nand regarding fast forwarding from the configuration and use them if no\nexplicit values for these options have been provided to MergeCommand.\n\nChange-Id: Ifdaed4b5e4adc142657c03c8e78b709a99eeddbd\nSigned-off-by: Konrad Kügler \u003cswamblumat-eclipsebugs@yahoo.de\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2014/2/14 上午7:34",
      "commitName": "48e36d8cb335382b99ec829d0dfe34be71ed49bb",
      "commitAuthor": "Konrad Kügler",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "Use branch.\u003cx\u003e.mergeoptions and merge.ff as defaults for merging\n\nRead options that control squashing, whether or not to commit the merge\nand regarding fast forwarding from the configuration and use them if no\nexplicit values for these options have been provided to MergeCommand.\n\nChange-Id: Ifdaed4b5e4adc142657c03c8e78b709a99eeddbd\nSigned-off-by: Konrad Kügler \u003cswamblumat-eclipsebugs@yahoo.de\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
          "commitDate": "2014/2/14 上午7:34",
          "commitName": "48e36d8cb335382b99ec829d0dfe34be71ed49bb",
          "commitAuthor": "Konrad Kügler",
          "commitDateOld": "2013/12/4 上午4:05",
          "commitNameOld": "7dc8a4f089c1ca4762cf6fbf2e77898607a5820a",
          "commitAuthorOld": "Robin Stocker",
          "daysBetweenCommits": 72.14,
          "commitsBetweenForRepo": 59,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"boxing\")\npublic MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    fallBackToConfiguration();\n    checkParameters();\n    RevWalk revWalk \u003d null;\n    DirCacheCheckout dco \u003d null;\n    try {\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n        revWalk \u003d new RevWalk(repo);\n        Ref ref \u003d commits.get(0);\n        refLogMessage.append(ref.getName());\n        ref \u003d repo.peel(ref);\n        ObjectId objectId \u003d ref.getPeeledObjectId();\n        if (objectId \u003d\u003d null)\n            objectId \u003d ref.getObjectId();\n        RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n        ObjectId headId \u003d head.getObjectId();\n        if (headId \u003d\u003d null) {\n            revWalk.parseHeaders(srcCommit);\n            dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() !\u003d Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit) \u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            String msg \u003d null;\n            ObjectId newHead, base \u003d null;\n            MergeStatus mergeStatus \u003d null;\n            if (!squash) {\n                updateHead(refLogMessage, srcCommit, headId);\n                newHead \u003d base \u003d srcCommit;\n                mergeStatus \u003d MergeStatus.FAST_FORWARD;\n            } else {\n                msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                newHead \u003d base \u003d headId;\n                mergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n                List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            setCallable(false);\n            return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n        } else {\n            if (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n                return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n            }\n            String mergeMessage \u003d \"\";\n            if (!squash) {\n                mergeMessage \u003d new MergeMessageFormatter().format(commits, head);\n                repo.writeMergeCommitMsg(mergeMessage);\n                repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            } else {\n                List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            Merger merger \u003d mergeStrategy.newMerger(repo);\n            boolean noProblems;\n            Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n            Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n            List\u003cString\u003e unmergedPaths \u003d null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n                lowLevelResults \u003d resolveMerger.getMergeResults();\n                failingPaths \u003d resolveMerger.getFailingPaths();\n                unmergedPaths \u003d resolveMerger.getUnmergedPaths();\n            } else\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n            refLogMessage.append(\": Merge made by \");\n            if (!revWalk.isMergedInto(headCommit, srcCommit))\n                refLogMessage.append(mergeStrategy.getName());\n            else\n                refLogMessage.append(\"recursive\");\n            refLogMessage.append(\u0027.\u0027);\n            if (noProblems) {\n                dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                String msg \u003d null;\n                ObjectId newHeadId \u003d null;\n                MergeStatus mergeStatus \u003d null;\n                if (!commit \u0026\u0026 squash) {\n                    mergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n                }\n                if (!commit \u0026\u0026 !squash) {\n                    mergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n                }\n                if (commit \u0026\u0026 !squash) {\n                    newHeadId \u003d new Git(getRepository()).commit().setReflogComment(refLogMessage.toString()).call().getId();\n                    mergeStatus \u003d MergeStatus.MERGED;\n                }\n                if (commit \u0026\u0026 squash) {\n                    msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                    newHeadId \u003d headCommit.getId();\n                    mergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n                }\n                return new MergeResult(newHeadId, null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n            } else {\n                if (failingPaths !\u003d null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else {\n                    String mergeMessageWithConflicts \u003d new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                    repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                }\n            }\n        }\n    } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n        List\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections.\u003cString\u003eemptyList() : dco.getConflicts();\n        throw new CheckoutConflictException(conflicts, e);\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk !\u003d null)\n            revWalk.release();\n    }\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
          "functionStartLine": 217,
          "functionName": "call",
          "functionAnnotation": "@SuppressWarnings(\"boxing\")",
          "functionDoc": "Executes the {@code Merge} command with all the options and parameters\ncollected by the setter methods (e.g. {@link #include(Ref)}) of this\nclass. Each instance of this class should only be used for one invocation\nof the command. Don\u0027t call this method twice on an instance.\n\n@return the result of the merge\n",
          "diff": "@@ -1,139 +1,141 @@\n+@SuppressWarnings(\"boxing\")\n public MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n     checkCallable();\n+    fallBackToConfiguration();\n     checkParameters();\n     RevWalk revWalk \u003d null;\n     DirCacheCheckout dco \u003d null;\n     try {\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n         revWalk \u003d new RevWalk(repo);\n         Ref ref \u003d commits.get(0);\n         refLogMessage.append(ref.getName());\n         ref \u003d repo.peel(ref);\n         ObjectId objectId \u003d ref.getPeeledObjectId();\n         if (objectId \u003d\u003d null)\n             objectId \u003d ref.getObjectId();\n         RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n         ObjectId headId \u003d head.getObjectId();\n         if (headId \u003d\u003d null) {\n             revWalk.parseHeaders(srcCommit);\n             dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n             dco.setFailOnConflict(true);\n             dco.checkout();\n             RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n             refUpdate.setNewObjectId(objectId);\n             refUpdate.setExpectedOldObjectId(null);\n             refUpdate.setRefLogMessage(\"initial pull\", false);\n             if (refUpdate.update() !\u003d Result.NEW)\n                 throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n             setCallable(false);\n             return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n         }\n         RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n         if (revWalk.isMergedInto(srcCommit, headCommit)) {\n             setCallable(false);\n             return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n         } else if (revWalk.isMergedInto(headCommit, srcCommit) \u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n             refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n             dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n             dco.setFailOnConflict(true);\n             dco.checkout();\n             String msg \u003d null;\n             ObjectId newHead, base \u003d null;\n             MergeStatus mergeStatus \u003d null;\n             if (!squash) {\n                 updateHead(refLogMessage, srcCommit, headId);\n                 newHead \u003d base \u003d srcCommit;\n                 mergeStatus \u003d MergeStatus.FAST_FORWARD;\n             } else {\n                 msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                 newHead \u003d base \u003d headId;\n                 mergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n                 List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                 String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                 repo.writeSquashCommitMsg(squashMessage);\n             }\n             setCallable(false);\n             return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n         } else {\n             if (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n                 return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n             }\n             String mergeMessage \u003d \"\";\n             if (!squash) {\n                 mergeMessage \u003d new MergeMessageFormatter().format(commits, head);\n                 repo.writeMergeCommitMsg(mergeMessage);\n                 repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n             } else {\n                 List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                 String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                 repo.writeSquashCommitMsg(squashMessage);\n             }\n             Merger merger \u003d mergeStrategy.newMerger(repo);\n             boolean noProblems;\n             Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n             Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n             List\u003cString\u003e unmergedPaths \u003d null;\n             if (merger instanceof ResolveMerger) {\n                 ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                 resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                 resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n                 lowLevelResults \u003d resolveMerger.getMergeResults();\n                 failingPaths \u003d resolveMerger.getFailingPaths();\n                 unmergedPaths \u003d resolveMerger.getUnmergedPaths();\n             } else\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n             refLogMessage.append(\": Merge made by \");\n             if (!revWalk.isMergedInto(headCommit, srcCommit))\n                 refLogMessage.append(mergeStrategy.getName());\n             else\n                 refLogMessage.append(\"recursive\");\n             refLogMessage.append(\u0027.\u0027);\n             if (noProblems) {\n                 dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                 dco.setFailOnConflict(true);\n                 dco.checkout();\n                 String msg \u003d null;\n                 ObjectId newHeadId \u003d null;\n                 MergeStatus mergeStatus \u003d null;\n                 if (!commit \u0026\u0026 squash) {\n                     mergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n                 }\n                 if (!commit \u0026\u0026 !squash) {\n                     mergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n                 }\n                 if (commit \u0026\u0026 !squash) {\n                     newHeadId \u003d new Git(getRepository()).commit().setReflogComment(refLogMessage.toString()).call().getId();\n                     mergeStatus \u003d MergeStatus.MERGED;\n                 }\n                 if (commit \u0026\u0026 squash) {\n                     msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                     newHeadId \u003d headCommit.getId();\n                     mergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n                 }\n                 return new MergeResult(newHeadId, null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n             } else {\n                 if (failingPaths !\u003d null) {\n                     repo.writeMergeCommitMsg(null);\n                     repo.writeMergeHeads(null);\n                     return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                 } else {\n                     String mergeMessageWithConflicts \u003d new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                     repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                     return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                 }\n             }\n         }\n     } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n         List\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections.\u003cString\u003eemptyList() : dco.getConflicts();\n         throw new CheckoutConflictException(conflicts, e);\n     } catch (IOException e) {\n         throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n     } finally {\n         if (revWalk !\u003d null)\n             revWalk.release();\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yannotationchange",
          "commitMessage": "Use branch.\u003cx\u003e.mergeoptions and merge.ff as defaults for merging\n\nRead options that control squashing, whether or not to commit the merge\nand regarding fast forwarding from the configuration and use them if no\nexplicit values for these options have been provided to MergeCommand.\n\nChange-Id: Ifdaed4b5e4adc142657c03c8e78b709a99eeddbd\nSigned-off-by: Konrad Kügler \u003cswamblumat-eclipsebugs@yahoo.de\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
          "commitDate": "2014/2/14 上午7:34",
          "commitName": "48e36d8cb335382b99ec829d0dfe34be71ed49bb",
          "commitAuthor": "Konrad Kügler",
          "commitDateOld": "2013/12/4 上午4:05",
          "commitNameOld": "7dc8a4f089c1ca4762cf6fbf2e77898607a5820a",
          "commitAuthorOld": "Robin Stocker",
          "daysBetweenCommits": 72.14,
          "commitsBetweenForRepo": 59,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"boxing\")\npublic MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    fallBackToConfiguration();\n    checkParameters();\n    RevWalk revWalk \u003d null;\n    DirCacheCheckout dco \u003d null;\n    try {\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n        revWalk \u003d new RevWalk(repo);\n        Ref ref \u003d commits.get(0);\n        refLogMessage.append(ref.getName());\n        ref \u003d repo.peel(ref);\n        ObjectId objectId \u003d ref.getPeeledObjectId();\n        if (objectId \u003d\u003d null)\n            objectId \u003d ref.getObjectId();\n        RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n        ObjectId headId \u003d head.getObjectId();\n        if (headId \u003d\u003d null) {\n            revWalk.parseHeaders(srcCommit);\n            dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() !\u003d Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit) \u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            String msg \u003d null;\n            ObjectId newHead, base \u003d null;\n            MergeStatus mergeStatus \u003d null;\n            if (!squash) {\n                updateHead(refLogMessage, srcCommit, headId);\n                newHead \u003d base \u003d srcCommit;\n                mergeStatus \u003d MergeStatus.FAST_FORWARD;\n            } else {\n                msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                newHead \u003d base \u003d headId;\n                mergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n                List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            setCallable(false);\n            return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n        } else {\n            if (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n                return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n            }\n            String mergeMessage \u003d \"\";\n            if (!squash) {\n                mergeMessage \u003d new MergeMessageFormatter().format(commits, head);\n                repo.writeMergeCommitMsg(mergeMessage);\n                repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            } else {\n                List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            Merger merger \u003d mergeStrategy.newMerger(repo);\n            boolean noProblems;\n            Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n            Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n            List\u003cString\u003e unmergedPaths \u003d null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n                lowLevelResults \u003d resolveMerger.getMergeResults();\n                failingPaths \u003d resolveMerger.getFailingPaths();\n                unmergedPaths \u003d resolveMerger.getUnmergedPaths();\n            } else\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n            refLogMessage.append(\": Merge made by \");\n            if (!revWalk.isMergedInto(headCommit, srcCommit))\n                refLogMessage.append(mergeStrategy.getName());\n            else\n                refLogMessage.append(\"recursive\");\n            refLogMessage.append(\u0027.\u0027);\n            if (noProblems) {\n                dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                String msg \u003d null;\n                ObjectId newHeadId \u003d null;\n                MergeStatus mergeStatus \u003d null;\n                if (!commit \u0026\u0026 squash) {\n                    mergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n                }\n                if (!commit \u0026\u0026 !squash) {\n                    mergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n                }\n                if (commit \u0026\u0026 !squash) {\n                    newHeadId \u003d new Git(getRepository()).commit().setReflogComment(refLogMessage.toString()).call().getId();\n                    mergeStatus \u003d MergeStatus.MERGED;\n                }\n                if (commit \u0026\u0026 squash) {\n                    msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                    newHeadId \u003d headCommit.getId();\n                    mergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n                }\n                return new MergeResult(newHeadId, null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n            } else {\n                if (failingPaths !\u003d null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else {\n                    String mergeMessageWithConflicts \u003d new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                    repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                }\n            }\n        }\n    } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n        List\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections.\u003cString\u003eemptyList() : dco.getConflicts();\n        throw new CheckoutConflictException(conflicts, e);\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk !\u003d null)\n            revWalk.release();\n    }\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
          "functionStartLine": 217,
          "functionName": "call",
          "functionAnnotation": "@SuppressWarnings(\"boxing\")",
          "functionDoc": "Executes the {@code Merge} command with all the options and parameters\ncollected by the setter methods (e.g. {@link #include(Ref)}) of this\nclass. Each instance of this class should only be used for one invocation\nof the command. Don\u0027t call this method twice on an instance.\n\n@return the result of the merge\n",
          "diff": "@@ -1,139 +1,141 @@\n+@SuppressWarnings(\"boxing\")\n public MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n     checkCallable();\n+    fallBackToConfiguration();\n     checkParameters();\n     RevWalk revWalk \u003d null;\n     DirCacheCheckout dco \u003d null;\n     try {\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n         revWalk \u003d new RevWalk(repo);\n         Ref ref \u003d commits.get(0);\n         refLogMessage.append(ref.getName());\n         ref \u003d repo.peel(ref);\n         ObjectId objectId \u003d ref.getPeeledObjectId();\n         if (objectId \u003d\u003d null)\n             objectId \u003d ref.getObjectId();\n         RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n         ObjectId headId \u003d head.getObjectId();\n         if (headId \u003d\u003d null) {\n             revWalk.parseHeaders(srcCommit);\n             dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n             dco.setFailOnConflict(true);\n             dco.checkout();\n             RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n             refUpdate.setNewObjectId(objectId);\n             refUpdate.setExpectedOldObjectId(null);\n             refUpdate.setRefLogMessage(\"initial pull\", false);\n             if (refUpdate.update() !\u003d Result.NEW)\n                 throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n             setCallable(false);\n             return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n         }\n         RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n         if (revWalk.isMergedInto(srcCommit, headCommit)) {\n             setCallable(false);\n             return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n         } else if (revWalk.isMergedInto(headCommit, srcCommit) \u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n             refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n             dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n             dco.setFailOnConflict(true);\n             dco.checkout();\n             String msg \u003d null;\n             ObjectId newHead, base \u003d null;\n             MergeStatus mergeStatus \u003d null;\n             if (!squash) {\n                 updateHead(refLogMessage, srcCommit, headId);\n                 newHead \u003d base \u003d srcCommit;\n                 mergeStatus \u003d MergeStatus.FAST_FORWARD;\n             } else {\n                 msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                 newHead \u003d base \u003d headId;\n                 mergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n                 List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                 String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                 repo.writeSquashCommitMsg(squashMessage);\n             }\n             setCallable(false);\n             return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n         } else {\n             if (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n                 return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n             }\n             String mergeMessage \u003d \"\";\n             if (!squash) {\n                 mergeMessage \u003d new MergeMessageFormatter().format(commits, head);\n                 repo.writeMergeCommitMsg(mergeMessage);\n                 repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n             } else {\n                 List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                 String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                 repo.writeSquashCommitMsg(squashMessage);\n             }\n             Merger merger \u003d mergeStrategy.newMerger(repo);\n             boolean noProblems;\n             Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n             Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n             List\u003cString\u003e unmergedPaths \u003d null;\n             if (merger instanceof ResolveMerger) {\n                 ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                 resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                 resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n                 lowLevelResults \u003d resolveMerger.getMergeResults();\n                 failingPaths \u003d resolveMerger.getFailingPaths();\n                 unmergedPaths \u003d resolveMerger.getUnmergedPaths();\n             } else\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n             refLogMessage.append(\": Merge made by \");\n             if (!revWalk.isMergedInto(headCommit, srcCommit))\n                 refLogMessage.append(mergeStrategy.getName());\n             else\n                 refLogMessage.append(\"recursive\");\n             refLogMessage.append(\u0027.\u0027);\n             if (noProblems) {\n                 dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                 dco.setFailOnConflict(true);\n                 dco.checkout();\n                 String msg \u003d null;\n                 ObjectId newHeadId \u003d null;\n                 MergeStatus mergeStatus \u003d null;\n                 if (!commit \u0026\u0026 squash) {\n                     mergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n                 }\n                 if (!commit \u0026\u0026 !squash) {\n                     mergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n                 }\n                 if (commit \u0026\u0026 !squash) {\n                     newHeadId \u003d new Git(getRepository()).commit().setReflogComment(refLogMessage.toString()).call().getId();\n                     mergeStatus \u003d MergeStatus.MERGED;\n                 }\n                 if (commit \u0026\u0026 squash) {\n                     msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                     newHeadId \u003d headCommit.getId();\n                     mergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n                 }\n                 return new MergeResult(newHeadId, null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n             } else {\n                 if (failingPaths !\u003d null) {\n                     repo.writeMergeCommitMsg(null);\n                     repo.writeMergeHeads(null);\n                     return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                 } else {\n                     String mergeMessageWithConflicts \u003d new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                     repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                     return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                 }\n             }\n         }\n     } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n         List\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections.\u003cString\u003eemptyList() : dco.getConflicts();\n         throw new CheckoutConflictException(conflicts, e);\n     } catch (IOException e) {\n         throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n     } finally {\n         if (revWalk !\u003d null)\n             revWalk.release();\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "",
            "newValue": "@SuppressWarnings(\"boxing\")"
          }
        }
      ]
    },
    "7dc8a4f089c1ca4762cf6fbf2e77898607a5820a": {
      "type": "Ybodychange",
      "commitMessage": "Fix exception on conflicts with recursive merge\n\nWhen there are conflicts with a recursive merge, the conflicting paths\nare stored in unmergedPaths (field in ResolveMerger). Later, when the\nMergeResult is constructed in MergeCommand, getBaseCommit is called,\nwhich computes the merge base a second time.\n\nIn case of RecursiveMerger, getBaseCommit merges the multiple merge\nbases into one. It does this not by creating a new ResolveMerger but\ninstead calling mergeTrees. The problem with mergeTrees is that at the\nend, it checks if unmergedPaths is non-empty and returns false in that\ncase.\n\nBecause unmergedPaths was already non-empty because of the real merge,\nit thinks that there were conflicts when computing the merge base again,\nwhen there really were none.\n\nThis can be fixed by storing the base commit when computing it and then\nreturning that instead of computing it a second time.\n\nNote that another possible fix would be to just use a new ResolveMerger\nfor merging the merge bases instead. This would also remove the need to\nremember the old value of dircache, inCore and workingTreeIterator (see\nRecursiveMerger#getBaseCommit).\n\nBug: 419641\nChange-Id: Ib2ebf4e177498c22a9098aa225e3cfcf16bbd958\nSigned-off-by: Robin Stocker \u003crobin@nibor.org\u003e\n",
      "commitDate": "2013/12/4 上午4:05",
      "commitName": "7dc8a4f089c1ca4762cf6fbf2e77898607a5820a",
      "commitAuthor": "Robin Stocker",
      "commitDateOld": "2013/4/16 上午3:46",
      "commitNameOld": "aa7be667bcca4bdb28b2485e28a05da54c431df7",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 232.01,
      "commitsBetweenForRepo": 251,
      "commitsBetweenForFile": 1,
      "actualSource": "public MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    checkParameters();\n    RevWalk revWalk \u003d null;\n    DirCacheCheckout dco \u003d null;\n    try {\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n        revWalk \u003d new RevWalk(repo);\n        Ref ref \u003d commits.get(0);\n        refLogMessage.append(ref.getName());\n        ref \u003d repo.peel(ref);\n        ObjectId objectId \u003d ref.getPeeledObjectId();\n        if (objectId \u003d\u003d null)\n            objectId \u003d ref.getObjectId();\n        RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n        ObjectId headId \u003d head.getObjectId();\n        if (headId \u003d\u003d null) {\n            revWalk.parseHeaders(srcCommit);\n            dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() !\u003d Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit) \u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            String msg \u003d null;\n            ObjectId newHead, base \u003d null;\n            MergeStatus mergeStatus \u003d null;\n            if (!squash) {\n                updateHead(refLogMessage, srcCommit, headId);\n                newHead \u003d base \u003d srcCommit;\n                mergeStatus \u003d MergeStatus.FAST_FORWARD;\n            } else {\n                msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                newHead \u003d base \u003d headId;\n                mergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n                List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            setCallable(false);\n            return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n        } else {\n            if (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n                return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n            }\n            String mergeMessage \u003d \"\";\n            if (!squash) {\n                mergeMessage \u003d new MergeMessageFormatter().format(commits, head);\n                repo.writeMergeCommitMsg(mergeMessage);\n                repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            } else {\n                List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            Merger merger \u003d mergeStrategy.newMerger(repo);\n            boolean noProblems;\n            Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n            Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n            List\u003cString\u003e unmergedPaths \u003d null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n                lowLevelResults \u003d resolveMerger.getMergeResults();\n                failingPaths \u003d resolveMerger.getFailingPaths();\n                unmergedPaths \u003d resolveMerger.getUnmergedPaths();\n            } else\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n            refLogMessage.append(\": Merge made by \");\n            if (!revWalk.isMergedInto(headCommit, srcCommit))\n                refLogMessage.append(mergeStrategy.getName());\n            else\n                refLogMessage.append(\"recursive\");\n            refLogMessage.append(\u0027.\u0027);\n            if (noProblems) {\n                dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                String msg \u003d null;\n                ObjectId newHeadId \u003d null;\n                MergeStatus mergeStatus \u003d null;\n                if (!commit \u0026\u0026 squash) {\n                    mergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n                }\n                if (!commit \u0026\u0026 !squash) {\n                    mergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n                }\n                if (commit \u0026\u0026 !squash) {\n                    newHeadId \u003d new Git(getRepository()).commit().setReflogComment(refLogMessage.toString()).call().getId();\n                    mergeStatus \u003d MergeStatus.MERGED;\n                }\n                if (commit \u0026\u0026 squash) {\n                    msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                    newHeadId \u003d headCommit.getId();\n                    mergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n                }\n                return new MergeResult(newHeadId, null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n            } else {\n                if (failingPaths !\u003d null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else {\n                    String mergeMessageWithConflicts \u003d new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                    repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                }\n            }\n        }\n    } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n        List\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections.\u003cString\u003eemptyList() : dco.getConflicts();\n        throw new CheckoutConflictException(conflicts, e);\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk !\u003d null)\n            revWalk.release();\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 215,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Merge} command with all the options and parameters\ncollected by the setter methods (e.g. {@link #include(Ref)}) of this\nclass. Each instance of this class should only be used for one invocation\nof the command. Don\u0027t call this method twice on an instance.\n\n@return the result of the merge\n",
      "diff": "@@ -1,139 +1,139 @@\n public MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n     checkCallable();\n     checkParameters();\n     RevWalk revWalk \u003d null;\n     DirCacheCheckout dco \u003d null;\n     try {\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n         revWalk \u003d new RevWalk(repo);\n         Ref ref \u003d commits.get(0);\n         refLogMessage.append(ref.getName());\n         ref \u003d repo.peel(ref);\n         ObjectId objectId \u003d ref.getPeeledObjectId();\n         if (objectId \u003d\u003d null)\n             objectId \u003d ref.getObjectId();\n         RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n         ObjectId headId \u003d head.getObjectId();\n         if (headId \u003d\u003d null) {\n             revWalk.parseHeaders(srcCommit);\n             dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n             dco.setFailOnConflict(true);\n             dco.checkout();\n             RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n             refUpdate.setNewObjectId(objectId);\n             refUpdate.setExpectedOldObjectId(null);\n             refUpdate.setRefLogMessage(\"initial pull\", false);\n             if (refUpdate.update() !\u003d Result.NEW)\n                 throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n             setCallable(false);\n             return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n         }\n         RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n         if (revWalk.isMergedInto(srcCommit, headCommit)) {\n             setCallable(false);\n             return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n         } else if (revWalk.isMergedInto(headCommit, srcCommit) \u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n             refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n             dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n             dco.setFailOnConflict(true);\n             dco.checkout();\n             String msg \u003d null;\n             ObjectId newHead, base \u003d null;\n             MergeStatus mergeStatus \u003d null;\n             if (!squash) {\n                 updateHead(refLogMessage, srcCommit, headId);\n                 newHead \u003d base \u003d srcCommit;\n                 mergeStatus \u003d MergeStatus.FAST_FORWARD;\n             } else {\n                 msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                 newHead \u003d base \u003d headId;\n                 mergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n                 List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                 String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                 repo.writeSquashCommitMsg(squashMessage);\n             }\n             setCallable(false);\n             return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n         } else {\n             if (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n                 return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n             }\n             String mergeMessage \u003d \"\";\n             if (!squash) {\n                 mergeMessage \u003d new MergeMessageFormatter().format(commits, head);\n                 repo.writeMergeCommitMsg(mergeMessage);\n                 repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n             } else {\n                 List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                 String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                 repo.writeSquashCommitMsg(squashMessage);\n             }\n             Merger merger \u003d mergeStrategy.newMerger(repo);\n             boolean noProblems;\n             Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n             Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n             List\u003cString\u003e unmergedPaths \u003d null;\n             if (merger instanceof ResolveMerger) {\n                 ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                 resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                 resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n                 lowLevelResults \u003d resolveMerger.getMergeResults();\n                 failingPaths \u003d resolveMerger.getFailingPaths();\n                 unmergedPaths \u003d resolveMerger.getUnmergedPaths();\n             } else\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n             refLogMessage.append(\": Merge made by \");\n             if (!revWalk.isMergedInto(headCommit, srcCommit))\n                 refLogMessage.append(mergeStrategy.getName());\n             else\n                 refLogMessage.append(\"recursive\");\n             refLogMessage.append(\u0027.\u0027);\n             if (noProblems) {\n                 dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                 dco.setFailOnConflict(true);\n                 dco.checkout();\n                 String msg \u003d null;\n                 ObjectId newHeadId \u003d null;\n                 MergeStatus mergeStatus \u003d null;\n                 if (!commit \u0026\u0026 squash) {\n                     mergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n                 }\n                 if (!commit \u0026\u0026 !squash) {\n                     mergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n                 }\n                 if (commit \u0026\u0026 !squash) {\n                     newHeadId \u003d new Git(getRepository()).commit().setReflogComment(refLogMessage.toString()).call().getId();\n                     mergeStatus \u003d MergeStatus.MERGED;\n                 }\n                 if (commit \u0026\u0026 squash) {\n                     msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                     newHeadId \u003d headCommit.getId();\n                     mergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n                 }\n                 return new MergeResult(newHeadId, null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n             } else {\n                 if (failingPaths !\u003d null) {\n                     repo.writeMergeCommitMsg(null);\n                     repo.writeMergeHeads(null);\n-                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n+                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                 } else {\n                     String mergeMessageWithConflicts \u003d new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                     repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n-                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n+                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                 }\n             }\n         }\n     } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n         List\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections.\u003cString\u003eemptyList() : dco.getConflicts();\n         throw new CheckoutConflictException(conflicts, e);\n     } catch (IOException e) {\n         throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n     } finally {\n         if (revWalk !\u003d null)\n             revWalk.release();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "545358577376bec8fc140a76ce0f72bf81cc0a94": {
      "type": "Ybodychange",
      "commitMessage": "Add the no-commit option to MergeCommand\n\nAdded also tests and the associated option for the command line Merge\ncommand.\n\nBug: 335091\nChange-Id: Ie321c572284a6f64765a81674089fc408a10d059\nSigned-off-by: Christian Halstrick \u003cchristian.halstrick@sap.com\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e\n",
      "commitDate": "2013/4/4 下午9:11",
      "commitName": "545358577376bec8fc140a76ce0f72bf81cc0a94",
      "commitAuthor": "Tomasz Zarna",
      "commitDateOld": "2013/2/8 下午2:27",
      "commitNameOld": "3a4ebc0c24b7732a57064299153794084fbfae59",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 55.28,
      "commitsBetweenForRepo": 84,
      "commitsBetweenForFile": 1,
      "actualSource": "public MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    checkParameters();\n    RevWalk revWalk \u003d null;\n    DirCacheCheckout dco \u003d null;\n    try {\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n        revWalk \u003d new RevWalk(repo);\n        Ref ref \u003d commits.get(0);\n        refLogMessage.append(ref.getName());\n        ref \u003d repo.peel(ref);\n        ObjectId objectId \u003d ref.getPeeledObjectId();\n        if (objectId \u003d\u003d null)\n            objectId \u003d ref.getObjectId();\n        RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n        ObjectId headId \u003d head.getObjectId();\n        if (headId \u003d\u003d null) {\n            revWalk.parseHeaders(srcCommit);\n            dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() !\u003d Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit) \u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            String msg \u003d null;\n            ObjectId newHead, base \u003d null;\n            MergeStatus mergeStatus \u003d null;\n            if (!squash) {\n                updateHead(refLogMessage, srcCommit, headId);\n                newHead \u003d base \u003d srcCommit;\n                mergeStatus \u003d MergeStatus.FAST_FORWARD;\n            } else {\n                msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                newHead \u003d base \u003d headId;\n                mergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n                List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            setCallable(false);\n            return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n        } else {\n            if (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n                return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n            }\n            String mergeMessage \u003d \"\";\n            if (!squash) {\n                mergeMessage \u003d new MergeMessageFormatter().format(commits, head);\n                repo.writeMergeCommitMsg(mergeMessage);\n                repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            } else {\n                List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            Merger merger \u003d mergeStrategy.newMerger(repo);\n            boolean noProblems;\n            Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n            Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n            List\u003cString\u003e unmergedPaths \u003d null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n                lowLevelResults \u003d resolveMerger.getMergeResults();\n                failingPaths \u003d resolveMerger.getFailingPaths();\n                unmergedPaths \u003d resolveMerger.getUnmergedPaths();\n            } else\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n            refLogMessage.append(\": Merge made by \");\n            if (!revWalk.isMergedInto(headCommit, srcCommit))\n                refLogMessage.append(mergeStrategy.getName());\n            else\n                refLogMessage.append(\"recursive\");\n            refLogMessage.append(\u0027.\u0027);\n            if (noProblems) {\n                dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                String msg \u003d null;\n                ObjectId newHeadId \u003d null;\n                MergeStatus mergeStatus \u003d null;\n                if (!commit \u0026\u0026 squash) {\n                    mergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n                }\n                if (!commit \u0026\u0026 !squash) {\n                    mergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n                }\n                if (commit \u0026\u0026 !squash) {\n                    newHeadId \u003d new Git(getRepository()).commit().setReflogComment(refLogMessage.toString()).call().getId();\n                    mergeStatus \u003d MergeStatus.MERGED;\n                }\n                if (commit \u0026\u0026 squash) {\n                    msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                    newHeadId \u003d headCommit.getId();\n                    mergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n                }\n                return new MergeResult(newHeadId, null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n            } else {\n                if (failingPaths !\u003d null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else {\n                    String mergeMessageWithConflicts \u003d new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                    repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                }\n            }\n        }\n    } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n        List\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections.\u003cString\u003eemptyList() : dco.getConflicts();\n        throw new CheckoutConflictException(conflicts, e);\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk !\u003d null)\n            revWalk.release();\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 215,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Merge} command with all the options and parameters\ncollected by the setter methods (e.g. {@link #include(Ref)}) of this\nclass. Each instance of this class should only be used for one invocation\nof the command. Don\u0027t call this method twice on an instance.\n\n@return the result of the merge\n",
      "diff": "@@ -1,132 +1,139 @@\n public MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n     checkCallable();\n     checkParameters();\n     RevWalk revWalk \u003d null;\n     DirCacheCheckout dco \u003d null;\n     try {\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n         revWalk \u003d new RevWalk(repo);\n         Ref ref \u003d commits.get(0);\n         refLogMessage.append(ref.getName());\n         ref \u003d repo.peel(ref);\n         ObjectId objectId \u003d ref.getPeeledObjectId();\n         if (objectId \u003d\u003d null)\n             objectId \u003d ref.getObjectId();\n         RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n         ObjectId headId \u003d head.getObjectId();\n         if (headId \u003d\u003d null) {\n             revWalk.parseHeaders(srcCommit);\n             dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n             dco.setFailOnConflict(true);\n             dco.checkout();\n             RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n             refUpdate.setNewObjectId(objectId);\n             refUpdate.setExpectedOldObjectId(null);\n             refUpdate.setRefLogMessage(\"initial pull\", false);\n             if (refUpdate.update() !\u003d Result.NEW)\n                 throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n             setCallable(false);\n             return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n         }\n         RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n         if (revWalk.isMergedInto(srcCommit, headCommit)) {\n             setCallable(false);\n             return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n         } else if (revWalk.isMergedInto(headCommit, srcCommit) \u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n             refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n             dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n             dco.setFailOnConflict(true);\n             dco.checkout();\n             String msg \u003d null;\n             ObjectId newHead, base \u003d null;\n             MergeStatus mergeStatus \u003d null;\n             if (!squash) {\n                 updateHead(refLogMessage, srcCommit, headId);\n                 newHead \u003d base \u003d srcCommit;\n                 mergeStatus \u003d MergeStatus.FAST_FORWARD;\n             } else {\n                 msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                 newHead \u003d base \u003d headId;\n                 mergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n                 List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                 String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                 repo.writeSquashCommitMsg(squashMessage);\n             }\n             setCallable(false);\n             return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n         } else {\n             if (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n                 return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n             }\n             String mergeMessage \u003d \"\";\n             if (!squash) {\n                 mergeMessage \u003d new MergeMessageFormatter().format(commits, head);\n                 repo.writeMergeCommitMsg(mergeMessage);\n                 repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n             } else {\n                 List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                 String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                 repo.writeSquashCommitMsg(squashMessage);\n             }\n             Merger merger \u003d mergeStrategy.newMerger(repo);\n             boolean noProblems;\n             Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n             Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n             List\u003cString\u003e unmergedPaths \u003d null;\n             if (merger instanceof ResolveMerger) {\n                 ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                 resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                 resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n                 lowLevelResults \u003d resolveMerger.getMergeResults();\n                 failingPaths \u003d resolveMerger.getFailingPaths();\n                 unmergedPaths \u003d resolveMerger.getUnmergedPaths();\n             } else\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n             refLogMessage.append(\": Merge made by \");\n             if (!revWalk.isMergedInto(headCommit, srcCommit))\n                 refLogMessage.append(mergeStrategy.getName());\n             else\n                 refLogMessage.append(\"recursive\");\n             refLogMessage.append(\u0027.\u0027);\n             if (noProblems) {\n                 dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                 dco.setFailOnConflict(true);\n                 dco.checkout();\n                 String msg \u003d null;\n-                RevCommit newHead \u003d null;\n+                ObjectId newHeadId \u003d null;\n                 MergeStatus mergeStatus \u003d null;\n-                if (!squash) {\n-                    newHead \u003d new Git(getRepository()).commit().setReflogComment(refLogMessage.toString()).call();\n+                if (!commit \u0026\u0026 squash) {\n+                    mergeStatus \u003d MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n+                }\n+                if (!commit \u0026\u0026 !squash) {\n+                    mergeStatus \u003d MergeStatus.MERGED_NOT_COMMITTED;\n+                }\n+                if (commit \u0026\u0026 !squash) {\n+                    newHeadId \u003d new Git(getRepository()).commit().setReflogComment(refLogMessage.toString()).call().getId();\n                     mergeStatus \u003d MergeStatus.MERGED;\n-                } else {\n+                }\n+                if (commit \u0026\u0026 squash) {\n                     msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n-                    newHead \u003d headCommit;\n+                    newHeadId \u003d headCommit.getId();\n                     mergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n                 }\n-                return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n+                return new MergeResult(newHeadId, null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n             } else {\n                 if (failingPaths !\u003d null) {\n                     repo.writeMergeCommitMsg(null);\n                     repo.writeMergeHeads(null);\n                     return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                 } else {\n                     String mergeMessageWithConflicts \u003d new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                     repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                     return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                 }\n             }\n         }\n     } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n         List\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections.\u003cString\u003eemptyList() : dco.getConflicts();\n         throw new CheckoutConflictException(conflicts, e);\n     } catch (IOException e) {\n         throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n     } finally {\n         if (revWalk !\u003d null)\n             revWalk.release();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3a4ebc0c24b7732a57064299153794084fbfae59": {
      "type": "Ybodychange",
      "commitMessage": "Really handle annotated tags in MergeCommand\n\nRepository.peel() must be called to ensure a tag is really peeled.\n\nChange-Id: I83e25f09fad3ad55a3ffe41ab4758f249b7ac9f9\n",
      "commitDate": "2013/2/8 下午2:27",
      "commitName": "3a4ebc0c24b7732a57064299153794084fbfae59",
      "commitAuthor": "Robin Rosenberg",
      "commitDateOld": "2013/1/29 下午3:05",
      "commitNameOld": "eb6093293022e468c2aea93a11f63b366e0d3891",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 9.97,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "actualSource": "public MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    checkParameters();\n    RevWalk revWalk \u003d null;\n    DirCacheCheckout dco \u003d null;\n    try {\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n        revWalk \u003d new RevWalk(repo);\n        Ref ref \u003d commits.get(0);\n        refLogMessage.append(ref.getName());\n        ref \u003d repo.peel(ref);\n        ObjectId objectId \u003d ref.getPeeledObjectId();\n        if (objectId \u003d\u003d null)\n            objectId \u003d ref.getObjectId();\n        RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n        ObjectId headId \u003d head.getObjectId();\n        if (headId \u003d\u003d null) {\n            revWalk.parseHeaders(srcCommit);\n            dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() !\u003d Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit) \u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            String msg \u003d null;\n            ObjectId newHead, base \u003d null;\n            MergeStatus mergeStatus \u003d null;\n            if (!squash) {\n                updateHead(refLogMessage, srcCommit, headId);\n                newHead \u003d base \u003d srcCommit;\n                mergeStatus \u003d MergeStatus.FAST_FORWARD;\n            } else {\n                msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                newHead \u003d base \u003d headId;\n                mergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n                List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            setCallable(false);\n            return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n        } else {\n            if (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n                return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n            }\n            String mergeMessage \u003d \"\";\n            if (!squash) {\n                mergeMessage \u003d new MergeMessageFormatter().format(commits, head);\n                repo.writeMergeCommitMsg(mergeMessage);\n                repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            } else {\n                List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            Merger merger \u003d mergeStrategy.newMerger(repo);\n            boolean noProblems;\n            Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n            Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n            List\u003cString\u003e unmergedPaths \u003d null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n                lowLevelResults \u003d resolveMerger.getMergeResults();\n                failingPaths \u003d resolveMerger.getFailingPaths();\n                unmergedPaths \u003d resolveMerger.getUnmergedPaths();\n            } else\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n            refLogMessage.append(\": Merge made by \");\n            if (!revWalk.isMergedInto(headCommit, srcCommit))\n                refLogMessage.append(mergeStrategy.getName());\n            else\n                refLogMessage.append(\"recursive\");\n            refLogMessage.append(\u0027.\u0027);\n            if (noProblems) {\n                dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                String msg \u003d null;\n                RevCommit newHead \u003d null;\n                MergeStatus mergeStatus \u003d null;\n                if (!squash) {\n                    newHead \u003d new Git(getRepository()).commit().setReflogComment(refLogMessage.toString()).call();\n                    mergeStatus \u003d MergeStatus.MERGED;\n                } else {\n                    msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                    newHead \u003d headCommit;\n                    mergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n                }\n                return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n            } else {\n                if (failingPaths !\u003d null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else {\n                    String mergeMessageWithConflicts \u003d new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                    repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                }\n            }\n        }\n    } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n        List\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections.\u003cString\u003eemptyList() : dco.getConflicts();\n        throw new CheckoutConflictException(conflicts, e);\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk !\u003d null)\n            revWalk.release();\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 213,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Merge} command with all the options and parameters\ncollected by the setter methods (e.g. {@link #include(Ref)}) of this\nclass. Each instance of this class should only be used for one invocation\nof the command. Don\u0027t call this method twice on an instance.\n\n@return the result of the merge\n",
      "diff": "@@ -1,131 +1,132 @@\n public MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n     checkCallable();\n     checkParameters();\n     RevWalk revWalk \u003d null;\n     DirCacheCheckout dco \u003d null;\n     try {\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n         revWalk \u003d new RevWalk(repo);\n         Ref ref \u003d commits.get(0);\n         refLogMessage.append(ref.getName());\n+        ref \u003d repo.peel(ref);\n         ObjectId objectId \u003d ref.getPeeledObjectId();\n         if (objectId \u003d\u003d null)\n             objectId \u003d ref.getObjectId();\n         RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n         ObjectId headId \u003d head.getObjectId();\n         if (headId \u003d\u003d null) {\n             revWalk.parseHeaders(srcCommit);\n             dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n             dco.setFailOnConflict(true);\n             dco.checkout();\n             RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n             refUpdate.setNewObjectId(objectId);\n             refUpdate.setExpectedOldObjectId(null);\n             refUpdate.setRefLogMessage(\"initial pull\", false);\n             if (refUpdate.update() !\u003d Result.NEW)\n                 throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n             setCallable(false);\n             return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n         }\n         RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n         if (revWalk.isMergedInto(srcCommit, headCommit)) {\n             setCallable(false);\n             return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n         } else if (revWalk.isMergedInto(headCommit, srcCommit) \u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n             refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n             dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n             dco.setFailOnConflict(true);\n             dco.checkout();\n             String msg \u003d null;\n             ObjectId newHead, base \u003d null;\n             MergeStatus mergeStatus \u003d null;\n             if (!squash) {\n                 updateHead(refLogMessage, srcCommit, headId);\n                 newHead \u003d base \u003d srcCommit;\n                 mergeStatus \u003d MergeStatus.FAST_FORWARD;\n             } else {\n                 msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                 newHead \u003d base \u003d headId;\n                 mergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n                 List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                 String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                 repo.writeSquashCommitMsg(squashMessage);\n             }\n             setCallable(false);\n             return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n         } else {\n             if (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n                 return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n             }\n             String mergeMessage \u003d \"\";\n             if (!squash) {\n                 mergeMessage \u003d new MergeMessageFormatter().format(commits, head);\n                 repo.writeMergeCommitMsg(mergeMessage);\n                 repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n             } else {\n                 List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                 String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                 repo.writeSquashCommitMsg(squashMessage);\n             }\n             Merger merger \u003d mergeStrategy.newMerger(repo);\n             boolean noProblems;\n             Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n             Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n             List\u003cString\u003e unmergedPaths \u003d null;\n             if (merger instanceof ResolveMerger) {\n                 ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                 resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                 resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n                 lowLevelResults \u003d resolveMerger.getMergeResults();\n                 failingPaths \u003d resolveMerger.getFailingPaths();\n                 unmergedPaths \u003d resolveMerger.getUnmergedPaths();\n             } else\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n             refLogMessage.append(\": Merge made by \");\n             if (!revWalk.isMergedInto(headCommit, srcCommit))\n                 refLogMessage.append(mergeStrategy.getName());\n             else\n                 refLogMessage.append(\"recursive\");\n             refLogMessage.append(\u0027.\u0027);\n             if (noProblems) {\n                 dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                 dco.setFailOnConflict(true);\n                 dco.checkout();\n                 String msg \u003d null;\n                 RevCommit newHead \u003d null;\n                 MergeStatus mergeStatus \u003d null;\n                 if (!squash) {\n                     newHead \u003d new Git(getRepository()).commit().setReflogComment(refLogMessage.toString()).call();\n                     mergeStatus \u003d MergeStatus.MERGED;\n                 } else {\n                     msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                     newHead \u003d headCommit;\n                     mergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n                 }\n                 return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n             } else {\n                 if (failingPaths !\u003d null) {\n                     repo.writeMergeCommitMsg(null);\n                     repo.writeMergeHeads(null);\n                     return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                 } else {\n                     String mergeMessageWithConflicts \u003d new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                     repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                     return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                 }\n             }\n         }\n     } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n         List\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections.\u003cString\u003eemptyList() : dco.getConflicts();\n         throw new CheckoutConflictException(conflicts, e);\n     } catch (IOException e) {\n         throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n     } finally {\n         if (revWalk !\u003d null)\n             revWalk.release();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "eb6093293022e468c2aea93a11f63b366e0d3891": {
      "type": "Ybodychange",
      "commitMessage": "Fix Check for FF_ONLY merges again\n\nAdded more FF-mode tests\n\nChange-Id: I33eed5737d9411cc1cf214da62ce719916a1b736\n",
      "commitDate": "2013/1/29 下午3:05",
      "commitName": "eb6093293022e468c2aea93a11f63b366e0d3891",
      "commitAuthor": "Robin Rosenberg",
      "commitDateOld": "2013/1/29 上午7:48",
      "commitNameOld": "642ff2cd7dd6ae361e4993255ade89a32e20601f",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 0.3,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    checkParameters();\n    RevWalk revWalk \u003d null;\n    DirCacheCheckout dco \u003d null;\n    try {\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n        revWalk \u003d new RevWalk(repo);\n        Ref ref \u003d commits.get(0);\n        refLogMessage.append(ref.getName());\n        ObjectId objectId \u003d ref.getPeeledObjectId();\n        if (objectId \u003d\u003d null)\n            objectId \u003d ref.getObjectId();\n        RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n        ObjectId headId \u003d head.getObjectId();\n        if (headId \u003d\u003d null) {\n            revWalk.parseHeaders(srcCommit);\n            dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() !\u003d Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit) \u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            String msg \u003d null;\n            ObjectId newHead, base \u003d null;\n            MergeStatus mergeStatus \u003d null;\n            if (!squash) {\n                updateHead(refLogMessage, srcCommit, headId);\n                newHead \u003d base \u003d srcCommit;\n                mergeStatus \u003d MergeStatus.FAST_FORWARD;\n            } else {\n                msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                newHead \u003d base \u003d headId;\n                mergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n                List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            setCallable(false);\n            return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n        } else {\n            if (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n                return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n            }\n            String mergeMessage \u003d \"\";\n            if (!squash) {\n                mergeMessage \u003d new MergeMessageFormatter().format(commits, head);\n                repo.writeMergeCommitMsg(mergeMessage);\n                repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            } else {\n                List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            Merger merger \u003d mergeStrategy.newMerger(repo);\n            boolean noProblems;\n            Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n            Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n            List\u003cString\u003e unmergedPaths \u003d null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n                lowLevelResults \u003d resolveMerger.getMergeResults();\n                failingPaths \u003d resolveMerger.getFailingPaths();\n                unmergedPaths \u003d resolveMerger.getUnmergedPaths();\n            } else\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n            refLogMessage.append(\": Merge made by \");\n            if (!revWalk.isMergedInto(headCommit, srcCommit))\n                refLogMessage.append(mergeStrategy.getName());\n            else\n                refLogMessage.append(\"recursive\");\n            refLogMessage.append(\u0027.\u0027);\n            if (noProblems) {\n                dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                String msg \u003d null;\n                RevCommit newHead \u003d null;\n                MergeStatus mergeStatus \u003d null;\n                if (!squash) {\n                    newHead \u003d new Git(getRepository()).commit().setReflogComment(refLogMessage.toString()).call();\n                    mergeStatus \u003d MergeStatus.MERGED;\n                } else {\n                    msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                    newHead \u003d headCommit;\n                    mergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n                }\n                return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n            } else {\n                if (failingPaths !\u003d null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else {\n                    String mergeMessageWithConflicts \u003d new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                    repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                }\n            }\n        }\n    } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n        List\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections.\u003cString\u003eemptyList() : dco.getConflicts();\n        throw new CheckoutConflictException(conflicts, e);\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk !\u003d null)\n            revWalk.release();\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 213,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Merge} command with all the options and parameters\ncollected by the setter methods (e.g. {@link #include(Ref)}) of this\nclass. Each instance of this class should only be used for one invocation\nof the command. Don\u0027t call this method twice on an instance.\n\n@return the result of the merge\n",
      "diff": "@@ -1,131 +1,131 @@\n public MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n     checkCallable();\n     checkParameters();\n     RevWalk revWalk \u003d null;\n     DirCacheCheckout dco \u003d null;\n     try {\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n         revWalk \u003d new RevWalk(repo);\n         Ref ref \u003d commits.get(0);\n         refLogMessage.append(ref.getName());\n         ObjectId objectId \u003d ref.getPeeledObjectId();\n         if (objectId \u003d\u003d null)\n             objectId \u003d ref.getObjectId();\n         RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n         ObjectId headId \u003d head.getObjectId();\n         if (headId \u003d\u003d null) {\n             revWalk.parseHeaders(srcCommit);\n             dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n             dco.setFailOnConflict(true);\n             dco.checkout();\n             RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n             refUpdate.setNewObjectId(objectId);\n             refUpdate.setExpectedOldObjectId(null);\n             refUpdate.setRefLogMessage(\"initial pull\", false);\n             if (refUpdate.update() !\u003d Result.NEW)\n                 throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n             setCallable(false);\n             return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n         }\n         RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n         if (revWalk.isMergedInto(srcCommit, headCommit)) {\n             setCallable(false);\n             return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n         } else if (revWalk.isMergedInto(headCommit, srcCommit) \u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n             refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n             dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n             dco.setFailOnConflict(true);\n             dco.checkout();\n             String msg \u003d null;\n             ObjectId newHead, base \u003d null;\n             MergeStatus mergeStatus \u003d null;\n             if (!squash) {\n                 updateHead(refLogMessage, srcCommit, headId);\n                 newHead \u003d base \u003d srcCommit;\n                 mergeStatus \u003d MergeStatus.FAST_FORWARD;\n             } else {\n                 msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                 newHead \u003d base \u003d headId;\n                 mergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n                 List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                 String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                 repo.writeSquashCommitMsg(squashMessage);\n             }\n             setCallable(false);\n             return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n         } else {\n-            if (fastForwardMode \u003d\u003d FastForwardMode.NO_FF) {\n+            if (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n                 return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n             }\n             String mergeMessage \u003d \"\";\n             if (!squash) {\n                 mergeMessage \u003d new MergeMessageFormatter().format(commits, head);\n                 repo.writeMergeCommitMsg(mergeMessage);\n                 repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n             } else {\n                 List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                 String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                 repo.writeSquashCommitMsg(squashMessage);\n             }\n             Merger merger \u003d mergeStrategy.newMerger(repo);\n             boolean noProblems;\n             Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n             Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n             List\u003cString\u003e unmergedPaths \u003d null;\n             if (merger instanceof ResolveMerger) {\n                 ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                 resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                 resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n                 lowLevelResults \u003d resolveMerger.getMergeResults();\n                 failingPaths \u003d resolveMerger.getFailingPaths();\n                 unmergedPaths \u003d resolveMerger.getUnmergedPaths();\n             } else\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n             refLogMessage.append(\": Merge made by \");\n             if (!revWalk.isMergedInto(headCommit, srcCommit))\n                 refLogMessage.append(mergeStrategy.getName());\n             else\n                 refLogMessage.append(\"recursive\");\n             refLogMessage.append(\u0027.\u0027);\n             if (noProblems) {\n                 dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                 dco.setFailOnConflict(true);\n                 dco.checkout();\n                 String msg \u003d null;\n                 RevCommit newHead \u003d null;\n                 MergeStatus mergeStatus \u003d null;\n                 if (!squash) {\n                     newHead \u003d new Git(getRepository()).commit().setReflogComment(refLogMessage.toString()).call();\n                     mergeStatus \u003d MergeStatus.MERGED;\n                 } else {\n                     msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                     newHead \u003d headCommit;\n                     mergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n                 }\n                 return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n             } else {\n                 if (failingPaths !\u003d null) {\n                     repo.writeMergeCommitMsg(null);\n                     repo.writeMergeHeads(null);\n                     return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                 } else {\n                     String mergeMessageWithConflicts \u003d new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                     repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                     return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                 }\n             }\n         }\n     } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n         List\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections.\u003cString\u003eemptyList() : dco.getConflicts();\n         throw new CheckoutConflictException(conflicts, e);\n     } catch (IOException e) {\n         throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n     } finally {\n         if (revWalk !\u003d null)\n             revWalk.release();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "642ff2cd7dd6ae361e4993255ade89a32e20601f": {
      "type": "Ybodychange",
      "commitMessage": "Check for FF_ONLY merges correctly\n\nBug: 398192\nChange-Id: I1253c0ea0632185bbf9f77e32f13ba5842a6e18e\n",
      "commitDate": "2013/1/29 上午7:48",
      "commitName": "642ff2cd7dd6ae361e4993255ade89a32e20601f",
      "commitAuthor": "Robin Rosenberg",
      "commitDateOld": "2013/1/18 下午7:04",
      "commitNameOld": "6a8da4c134dff042712e4bae8817d79cc63866f4",
      "commitAuthorOld": "Tomasz Zarna",
      "daysBetweenCommits": 10.53,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "public MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    checkParameters();\n    RevWalk revWalk \u003d null;\n    DirCacheCheckout dco \u003d null;\n    try {\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n        revWalk \u003d new RevWalk(repo);\n        Ref ref \u003d commits.get(0);\n        refLogMessage.append(ref.getName());\n        ObjectId objectId \u003d ref.getPeeledObjectId();\n        if (objectId \u003d\u003d null)\n            objectId \u003d ref.getObjectId();\n        RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n        ObjectId headId \u003d head.getObjectId();\n        if (headId \u003d\u003d null) {\n            revWalk.parseHeaders(srcCommit);\n            dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() !\u003d Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit) \u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            String msg \u003d null;\n            ObjectId newHead, base \u003d null;\n            MergeStatus mergeStatus \u003d null;\n            if (!squash) {\n                updateHead(refLogMessage, srcCommit, headId);\n                newHead \u003d base \u003d srcCommit;\n                mergeStatus \u003d MergeStatus.FAST_FORWARD;\n            } else {\n                msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                newHead \u003d base \u003d headId;\n                mergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n                List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            setCallable(false);\n            return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n        } else {\n            if (fastForwardMode \u003d\u003d FastForwardMode.NO_FF) {\n                return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n            }\n            String mergeMessage \u003d \"\";\n            if (!squash) {\n                mergeMessage \u003d new MergeMessageFormatter().format(commits, head);\n                repo.writeMergeCommitMsg(mergeMessage);\n                repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            } else {\n                List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            Merger merger \u003d mergeStrategy.newMerger(repo);\n            boolean noProblems;\n            Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n            Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n            List\u003cString\u003e unmergedPaths \u003d null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n                lowLevelResults \u003d resolveMerger.getMergeResults();\n                failingPaths \u003d resolveMerger.getFailingPaths();\n                unmergedPaths \u003d resolveMerger.getUnmergedPaths();\n            } else\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n            refLogMessage.append(\": Merge made by \");\n            if (!revWalk.isMergedInto(headCommit, srcCommit))\n                refLogMessage.append(mergeStrategy.getName());\n            else\n                refLogMessage.append(\"recursive\");\n            refLogMessage.append(\u0027.\u0027);\n            if (noProblems) {\n                dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                String msg \u003d null;\n                RevCommit newHead \u003d null;\n                MergeStatus mergeStatus \u003d null;\n                if (!squash) {\n                    newHead \u003d new Git(getRepository()).commit().setReflogComment(refLogMessage.toString()).call();\n                    mergeStatus \u003d MergeStatus.MERGED;\n                } else {\n                    msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                    newHead \u003d headCommit;\n                    mergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n                }\n                return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n            } else {\n                if (failingPaths !\u003d null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else {\n                    String mergeMessageWithConflicts \u003d new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                    repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                }\n            }\n        }\n    } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n        List\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections.\u003cString\u003eemptyList() : dco.getConflicts();\n        throw new CheckoutConflictException(conflicts, e);\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk !\u003d null)\n            revWalk.release();\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 213,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Merge} command with all the options and parameters\ncollected by the setter methods (e.g. {@link #include(Ref)}) of this\nclass. Each instance of this class should only be used for one invocation\nof the command. Don\u0027t call this method twice on an instance.\n\n@return the result of the merge\n",
      "diff": "@@ -1,131 +1,131 @@\n public MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n     checkCallable();\n     checkParameters();\n     RevWalk revWalk \u003d null;\n     DirCacheCheckout dco \u003d null;\n     try {\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n         revWalk \u003d new RevWalk(repo);\n         Ref ref \u003d commits.get(0);\n         refLogMessage.append(ref.getName());\n         ObjectId objectId \u003d ref.getPeeledObjectId();\n         if (objectId \u003d\u003d null)\n             objectId \u003d ref.getObjectId();\n         RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n         ObjectId headId \u003d head.getObjectId();\n         if (headId \u003d\u003d null) {\n             revWalk.parseHeaders(srcCommit);\n             dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n             dco.setFailOnConflict(true);\n             dco.checkout();\n             RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n             refUpdate.setNewObjectId(objectId);\n             refUpdate.setExpectedOldObjectId(null);\n             refUpdate.setRefLogMessage(\"initial pull\", false);\n             if (refUpdate.update() !\u003d Result.NEW)\n                 throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n             setCallable(false);\n             return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n         }\n         RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n         if (revWalk.isMergedInto(srcCommit, headCommit)) {\n             setCallable(false);\n             return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n-        } else if (revWalk.isMergedInto(headCommit, srcCommit) \u0026\u0026 fastForwardMode \u003d\u003d FastForwardMode.FF) {\n+        } else if (revWalk.isMergedInto(headCommit, srcCommit) \u0026\u0026 fastForwardMode !\u003d FastForwardMode.NO_FF) {\n             refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n             dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n             dco.setFailOnConflict(true);\n             dco.checkout();\n             String msg \u003d null;\n             ObjectId newHead, base \u003d null;\n             MergeStatus mergeStatus \u003d null;\n             if (!squash) {\n                 updateHead(refLogMessage, srcCommit, headId);\n                 newHead \u003d base \u003d srcCommit;\n                 mergeStatus \u003d MergeStatus.FAST_FORWARD;\n             } else {\n                 msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                 newHead \u003d base \u003d headId;\n                 mergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n                 List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                 String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                 repo.writeSquashCommitMsg(squashMessage);\n             }\n             setCallable(false);\n             return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n         } else {\n-            if (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n+            if (fastForwardMode \u003d\u003d FastForwardMode.NO_FF) {\n                 return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n             }\n             String mergeMessage \u003d \"\";\n             if (!squash) {\n                 mergeMessage \u003d new MergeMessageFormatter().format(commits, head);\n                 repo.writeMergeCommitMsg(mergeMessage);\n                 repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n             } else {\n                 List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                 String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                 repo.writeSquashCommitMsg(squashMessage);\n             }\n             Merger merger \u003d mergeStrategy.newMerger(repo);\n             boolean noProblems;\n             Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n             Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n             List\u003cString\u003e unmergedPaths \u003d null;\n             if (merger instanceof ResolveMerger) {\n                 ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                 resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                 resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n                 lowLevelResults \u003d resolveMerger.getMergeResults();\n                 failingPaths \u003d resolveMerger.getFailingPaths();\n                 unmergedPaths \u003d resolveMerger.getUnmergedPaths();\n             } else\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n             refLogMessage.append(\": Merge made by \");\n             if (!revWalk.isMergedInto(headCommit, srcCommit))\n                 refLogMessage.append(mergeStrategy.getName());\n             else\n                 refLogMessage.append(\"recursive\");\n             refLogMessage.append(\u0027.\u0027);\n             if (noProblems) {\n                 dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                 dco.setFailOnConflict(true);\n                 dco.checkout();\n                 String msg \u003d null;\n                 RevCommit newHead \u003d null;\n                 MergeStatus mergeStatus \u003d null;\n                 if (!squash) {\n                     newHead \u003d new Git(getRepository()).commit().setReflogComment(refLogMessage.toString()).call();\n                     mergeStatus \u003d MergeStatus.MERGED;\n                 } else {\n                     msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                     newHead \u003d headCommit;\n                     mergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n                 }\n                 return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n             } else {\n                 if (failingPaths !\u003d null) {\n                     repo.writeMergeCommitMsg(null);\n                     repo.writeMergeHeads(null);\n                     return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                 } else {\n                     String mergeMessageWithConflicts \u003d new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                     repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                     return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                 }\n             }\n         }\n     } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n         List\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections.\u003cString\u003eemptyList() : dco.getConflicts();\n         throw new CheckoutConflictException(conflicts, e);\n     } catch (IOException e) {\n         throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n     } finally {\n         if (revWalk !\u003d null)\n             revWalk.release();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c310fa0c802f40a774edb58641de3ac5bfad0e2c": {
      "type": "Ybodychange",
      "commitMessage": "Mark non-externalizable strings as such\n\nA few classes such as Constanrs are marked with @SuppressWarnings, as are\ntoString() methods with many liternal, but otherwise $NLS-n$ is used for\nstring containing text that should not be translated. A few literals may\nfall into the gray zone, but mostly I\u0027ve tried to only tag the obvious\nones.\n\nChange-Id: I22e50a77e2bf9e0b842a66bdf674e8fa1692f590\n",
      "commitDate": "2012/12/27 下午11:57",
      "commitName": "c310fa0c802f40a774edb58641de3ac5bfad0e2c",
      "commitAuthor": "Robin Rosenberg",
      "commitDateOld": "2012/11/16 下午6:04",
      "commitNameOld": "318f3d464307e3efd8342852310c17e71a7282fe",
      "commitAuthorOld": "Tomasz Zarna",
      "daysBetweenCommits": 41.25,
      "commitsBetweenForRepo": 44,
      "commitsBetweenForFile": 1,
      "actualSource": "public MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    checkParameters();\n    RevWalk revWalk \u003d null;\n    DirCacheCheckout dco \u003d null;\n    try {\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n        revWalk \u003d new RevWalk(repo);\n        Ref ref \u003d commits.get(0);\n        refLogMessage.append(ref.getName());\n        ObjectId objectId \u003d ref.getPeeledObjectId();\n        if (objectId \u003d\u003d null)\n            objectId \u003d ref.getObjectId();\n        RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n        ObjectId headId \u003d head.getObjectId();\n        if (headId \u003d\u003d null) {\n            revWalk.parseHeaders(srcCommit);\n            dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() !\u003d Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit) \u0026\u0026 fastForwardMode \u003d\u003d FastForwardMode.FF) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            String msg \u003d null;\n            ObjectId newHead, base \u003d null;\n            MergeStatus mergeStatus \u003d null;\n            if (!squash) {\n                updateHead(refLogMessage, srcCommit, headId);\n                newHead \u003d base \u003d srcCommit;\n                mergeStatus \u003d MergeStatus.FAST_FORWARD;\n            } else {\n                msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                newHead \u003d base \u003d headId;\n                mergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n                List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            setCallable(false);\n            return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n        } else {\n            if (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n                return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n            }\n            String mergeMessage \u003d \"\";\n            if (!squash) {\n                mergeMessage \u003d new MergeMessageFormatter().format(commits, head);\n                repo.writeMergeCommitMsg(mergeMessage);\n                repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            } else {\n                List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            Merger merger \u003d mergeStrategy.newMerger(repo);\n            boolean noProblems;\n            Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n            Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n            List\u003cString\u003e unmergedPaths \u003d null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n                lowLevelResults \u003d resolveMerger.getMergeResults();\n                failingPaths \u003d resolveMerger.getFailingPaths();\n                unmergedPaths \u003d resolveMerger.getUnmergedPaths();\n            } else\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n            refLogMessage.append(\": Merge made by \");\n            if (!revWalk.isMergedInto(headCommit, srcCommit))\n                refLogMessage.append(mergeStrategy.getName());\n            else\n                refLogMessage.append(\"recursive\");\n            refLogMessage.append(\u0027.\u0027);\n            if (noProblems) {\n                dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                String msg \u003d null;\n                RevCommit newHead \u003d null;\n                MergeStatus mergeStatus \u003d null;\n                if (!squash) {\n                    newHead \u003d new Git(getRepository()).commit().setReflogComment(refLogMessage.toString()).call();\n                    mergeStatus \u003d MergeStatus.MERGED;\n                } else {\n                    msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                    newHead \u003d headCommit;\n                    mergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n                }\n                return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n            } else {\n                if (failingPaths !\u003d null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else {\n                    String mergeMessageWithConflicts \u003d new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                    repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                }\n            }\n        }\n    } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n        List\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections.\u003cString\u003eemptyList() : dco.getConflicts();\n        throw new CheckoutConflictException(conflicts, e);\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk !\u003d null)\n            revWalk.release();\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 141,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Merge} command with all the options and parameters\ncollected by the setter methods (e.g. {@link #include(Ref)}) of this\nclass. Each instance of this class should only be used for one invocation\nof the command. Don\u0027t call this method twice on an instance.\n\n@return the result of the merge\n",
      "diff": "",
      "extendedDetails": {}
    },
    "318f3d464307e3efd8342852310c17e71a7282fe": {
      "type": "Ybodychange",
      "commitMessage": "Add support for --no-ff while merging\n\nBug: 394432\nChange-Id: I373128c0ba949f9b24248874f77f3d68b50ccfd1\nSigned-off-by: Chris Aniszczyk \u003czx@twitter.com\u003e\n",
      "commitDate": "2012/11/16 下午6:04",
      "commitName": "318f3d464307e3efd8342852310c17e71a7282fe",
      "commitAuthor": "Tomasz Zarna",
      "commitDateOld": "2012/6/15 下午2:59",
      "commitNameOld": "2656ac1b5acb9b73c6b47e2cf8830a0a0b2cc214",
      "commitAuthorOld": "Tomasz Zarna",
      "daysBetweenCommits": 154.13,
      "commitsBetweenForRepo": 148,
      "commitsBetweenForFile": 1,
      "actualSource": "public MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    checkParameters();\n    RevWalk revWalk \u003d null;\n    DirCacheCheckout dco \u003d null;\n    try {\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n        revWalk \u003d new RevWalk(repo);\n        Ref ref \u003d commits.get(0);\n        refLogMessage.append(ref.getName());\n        ObjectId objectId \u003d ref.getPeeledObjectId();\n        if (objectId \u003d\u003d null)\n            objectId \u003d ref.getObjectId();\n        RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n        ObjectId headId \u003d head.getObjectId();\n        if (headId \u003d\u003d null) {\n            revWalk.parseHeaders(srcCommit);\n            dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() !\u003d Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit) \u0026\u0026 fastForwardMode \u003d\u003d FastForwardMode.FF) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            String msg \u003d null;\n            ObjectId newHead, base \u003d null;\n            MergeStatus mergeStatus \u003d null;\n            if (!squash) {\n                updateHead(refLogMessage, srcCommit, headId);\n                newHead \u003d base \u003d srcCommit;\n                mergeStatus \u003d MergeStatus.FAST_FORWARD;\n            } else {\n                msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                newHead \u003d base \u003d headId;\n                mergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n                List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            setCallable(false);\n            return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n        } else {\n            if (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n                return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n            }\n            String mergeMessage \u003d \"\";\n            if (!squash) {\n                mergeMessage \u003d new MergeMessageFormatter().format(commits, head);\n                repo.writeMergeCommitMsg(mergeMessage);\n                repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            } else {\n                List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            Merger merger \u003d mergeStrategy.newMerger(repo);\n            boolean noProblems;\n            Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n            Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n            List\u003cString\u003e unmergedPaths \u003d null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n                lowLevelResults \u003d resolveMerger.getMergeResults();\n                failingPaths \u003d resolveMerger.getFailingPaths();\n                unmergedPaths \u003d resolveMerger.getUnmergedPaths();\n            } else\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n            refLogMessage.append(\": Merge made by \");\n            if (!revWalk.isMergedInto(headCommit, srcCommit))\n                refLogMessage.append(mergeStrategy.getName());\n            else\n                refLogMessage.append(\"recursive\");\n            refLogMessage.append(\u0027.\u0027);\n            if (noProblems) {\n                dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                String msg \u003d null;\n                RevCommit newHead \u003d null;\n                MergeStatus mergeStatus \u003d null;\n                if (!squash) {\n                    newHead \u003d new Git(getRepository()).commit().setReflogComment(refLogMessage.toString()).call();\n                    mergeStatus \u003d MergeStatus.MERGED;\n                } else {\n                    msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                    newHead \u003d headCommit;\n                    mergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n                }\n                return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n            } else {\n                if (failingPaths !\u003d null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else {\n                    String mergeMessageWithConflicts \u003d new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                    repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                }\n            }\n        }\n    } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n        List\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections.\u003cString\u003eemptyList() : dco.getConflicts();\n        throw new CheckoutConflictException(conflicts, e);\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk !\u003d null)\n            revWalk.release();\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 141,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Merge} command with all the options and parameters\ncollected by the setter methods (e.g. {@link #include(Ref)}) of this\nclass. Each instance of this class should only be used for one invocation\nof the command. Don\u0027t call this method twice on an instance.\n\n@return the result of the merge\n",
      "diff": "@@ -1,126 +1,131 @@\n public MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n     checkCallable();\n-    if (commits.size() !\u003d 1)\n-        throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads, mergeStrategy.getName(), Integer.valueOf(commits.size())));\n+    checkParameters();\n     RevWalk revWalk \u003d null;\n     DirCacheCheckout dco \u003d null;\n     try {\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n         revWalk \u003d new RevWalk(repo);\n         Ref ref \u003d commits.get(0);\n         refLogMessage.append(ref.getName());\n         ObjectId objectId \u003d ref.getPeeledObjectId();\n         if (objectId \u003d\u003d null)\n             objectId \u003d ref.getObjectId();\n         RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n         ObjectId headId \u003d head.getObjectId();\n         if (headId \u003d\u003d null) {\n             revWalk.parseHeaders(srcCommit);\n             dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n             dco.setFailOnConflict(true);\n             dco.checkout();\n             RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n             refUpdate.setNewObjectId(objectId);\n             refUpdate.setExpectedOldObjectId(null);\n             refUpdate.setRefLogMessage(\"initial pull\", false);\n             if (refUpdate.update() !\u003d Result.NEW)\n                 throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n             setCallable(false);\n             return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n         }\n         RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n         if (revWalk.isMergedInto(srcCommit, headCommit)) {\n             setCallable(false);\n             return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n-        } else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n+        } else if (revWalk.isMergedInto(headCommit, srcCommit) \u0026\u0026 fastForwardMode \u003d\u003d FastForwardMode.FF) {\n             refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n             dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n             dco.setFailOnConflict(true);\n             dco.checkout();\n             String msg \u003d null;\n             ObjectId newHead, base \u003d null;\n             MergeStatus mergeStatus \u003d null;\n             if (!squash) {\n                 updateHead(refLogMessage, srcCommit, headId);\n                 newHead \u003d base \u003d srcCommit;\n                 mergeStatus \u003d MergeStatus.FAST_FORWARD;\n             } else {\n                 msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                 newHead \u003d base \u003d headId;\n                 mergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n                 List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                 String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                 repo.writeSquashCommitMsg(squashMessage);\n             }\n             setCallable(false);\n             return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n         } else {\n+            if (fastForwardMode \u003d\u003d FastForwardMode.FF_ONLY) {\n+                return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n+            }\n             String mergeMessage \u003d \"\";\n             if (!squash) {\n                 mergeMessage \u003d new MergeMessageFormatter().format(commits, head);\n                 repo.writeMergeCommitMsg(mergeMessage);\n                 repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n             } else {\n                 List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                 String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                 repo.writeSquashCommitMsg(squashMessage);\n             }\n             Merger merger \u003d mergeStrategy.newMerger(repo);\n             boolean noProblems;\n             Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n             Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n             List\u003cString\u003e unmergedPaths \u003d null;\n             if (merger instanceof ResolveMerger) {\n                 ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                 resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                 resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n                 lowLevelResults \u003d resolveMerger.getMergeResults();\n                 failingPaths \u003d resolveMerger.getFailingPaths();\n                 unmergedPaths \u003d resolveMerger.getUnmergedPaths();\n             } else\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n             refLogMessage.append(\": Merge made by \");\n-            refLogMessage.append(mergeStrategy.getName());\n+            if (!revWalk.isMergedInto(headCommit, srcCommit))\n+                refLogMessage.append(mergeStrategy.getName());\n+            else\n+                refLogMessage.append(\"recursive\");\n             refLogMessage.append(\u0027.\u0027);\n             if (noProblems) {\n                 dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                 dco.setFailOnConflict(true);\n                 dco.checkout();\n                 String msg \u003d null;\n                 RevCommit newHead \u003d null;\n                 MergeStatus mergeStatus \u003d null;\n                 if (!squash) {\n                     newHead \u003d new Git(getRepository()).commit().setReflogComment(refLogMessage.toString()).call();\n                     mergeStatus \u003d MergeStatus.MERGED;\n                 } else {\n                     msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                     newHead \u003d headCommit;\n                     mergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n                 }\n                 return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n             } else {\n                 if (failingPaths !\u003d null) {\n                     repo.writeMergeCommitMsg(null);\n                     repo.writeMergeHeads(null);\n                     return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                 } else {\n                     String mergeMessageWithConflicts \u003d new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                     repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                     return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                 }\n             }\n         }\n     } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n         List\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections.\u003cString\u003eemptyList() : dco.getConflicts();\n         throw new CheckoutConflictException(conflicts, e);\n     } catch (IOException e) {\n         throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n     } finally {\n         if (revWalk !\u003d null)\n             revWalk.release();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2656ac1b5acb9b73c6b47e2cf8830a0a0b2cc214": {
      "type": "Ybodychange",
      "commitMessage": "Add \"--squash\" option to MergeCommand\n\nCQ: 6570\nBug: 351806\nChange-Id: I5e47810376419264ecf4247b5a333af5c8945080\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e\n",
      "commitDate": "2012/6/15 下午2:59",
      "commitName": "2656ac1b5acb9b73c6b47e2cf8830a0a0b2cc214",
      "commitAuthor": "Tomasz Zarna",
      "commitDateOld": "2012/5/31 上午4:08",
      "commitNameOld": "4e1454ded6e2fcf6cb789c004756883c3ea5f77e",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 15.45,
      "commitsBetweenForRepo": 43,
      "commitsBetweenForFile": 1,
      "actualSource": "public MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    if (commits.size() !\u003d 1)\n        throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads, mergeStrategy.getName(), Integer.valueOf(commits.size())));\n    RevWalk revWalk \u003d null;\n    DirCacheCheckout dco \u003d null;\n    try {\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n        revWalk \u003d new RevWalk(repo);\n        Ref ref \u003d commits.get(0);\n        refLogMessage.append(ref.getName());\n        ObjectId objectId \u003d ref.getPeeledObjectId();\n        if (objectId \u003d\u003d null)\n            objectId \u003d ref.getObjectId();\n        RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n        ObjectId headId \u003d head.getObjectId();\n        if (headId \u003d\u003d null) {\n            revWalk.parseHeaders(srcCommit);\n            dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() !\u003d Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            String msg \u003d null;\n            ObjectId newHead, base \u003d null;\n            MergeStatus mergeStatus \u003d null;\n            if (!squash) {\n                updateHead(refLogMessage, srcCommit, headId);\n                newHead \u003d base \u003d srcCommit;\n                mergeStatus \u003d MergeStatus.FAST_FORWARD;\n            } else {\n                msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                newHead \u003d base \u003d headId;\n                mergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n                List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            setCallable(false);\n            return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n        } else {\n            String mergeMessage \u003d \"\";\n            if (!squash) {\n                mergeMessage \u003d new MergeMessageFormatter().format(commits, head);\n                repo.writeMergeCommitMsg(mergeMessage);\n                repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            } else {\n                List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            Merger merger \u003d mergeStrategy.newMerger(repo);\n            boolean noProblems;\n            Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n            Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n            List\u003cString\u003e unmergedPaths \u003d null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n                lowLevelResults \u003d resolveMerger.getMergeResults();\n                failingPaths \u003d resolveMerger.getFailingPaths();\n                unmergedPaths \u003d resolveMerger.getUnmergedPaths();\n            } else\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n            refLogMessage.append(\": Merge made by \");\n            refLogMessage.append(mergeStrategy.getName());\n            refLogMessage.append(\u0027.\u0027);\n            if (noProblems) {\n                dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                String msg \u003d null;\n                RevCommit newHead \u003d null;\n                MergeStatus mergeStatus \u003d null;\n                if (!squash) {\n                    newHead \u003d new Git(getRepository()).commit().setReflogComment(refLogMessage.toString()).call();\n                    mergeStatus \u003d MergeStatus.MERGED;\n                } else {\n                    msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n                    newHead \u003d headCommit;\n                    mergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n                }\n                return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n            } else {\n                if (failingPaths !\u003d null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else {\n                    String mergeMessageWithConflicts \u003d new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                    repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                }\n            }\n        }\n    } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n        List\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections.\u003cString\u003eemptyList() : dco.getConflicts();\n        throw new CheckoutConflictException(conflicts, e);\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk !\u003d null)\n            revWalk.release();\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 117,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Merge} command with all the options and parameters\ncollected by the setter methods (e.g. {@link #include(Ref)}) of this\nclass. Each instance of this class should only be used for one invocation\nof the command. Don\u0027t call this method twice on an instance.\n\n@return the result of the merge\n",
      "diff": "@@ -1,95 +1,126 @@\n public MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n     checkCallable();\n     if (commits.size() !\u003d 1)\n         throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads, mergeStrategy.getName(), Integer.valueOf(commits.size())));\n     RevWalk revWalk \u003d null;\n     DirCacheCheckout dco \u003d null;\n     try {\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n         revWalk \u003d new RevWalk(repo);\n         Ref ref \u003d commits.get(0);\n         refLogMessage.append(ref.getName());\n         ObjectId objectId \u003d ref.getPeeledObjectId();\n         if (objectId \u003d\u003d null)\n             objectId \u003d ref.getObjectId();\n         RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n         ObjectId headId \u003d head.getObjectId();\n         if (headId \u003d\u003d null) {\n             revWalk.parseHeaders(srcCommit);\n             dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n             dco.setFailOnConflict(true);\n             dco.checkout();\n             RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n             refUpdate.setNewObjectId(objectId);\n             refUpdate.setExpectedOldObjectId(null);\n             refUpdate.setRefLogMessage(\"initial pull\", false);\n             if (refUpdate.update() !\u003d Result.NEW)\n                 throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n             setCallable(false);\n             return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n         }\n         RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n         if (revWalk.isMergedInto(srcCommit, headCommit)) {\n             setCallable(false);\n             return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n         } else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n             refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n             dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n             dco.setFailOnConflict(true);\n             dco.checkout();\n-            updateHead(refLogMessage, srcCommit, headId);\n+            String msg \u003d null;\n+            ObjectId newHead, base \u003d null;\n+            MergeStatus mergeStatus \u003d null;\n+            if (!squash) {\n+                updateHead(refLogMessage, srcCommit, headId);\n+                newHead \u003d base \u003d srcCommit;\n+                mergeStatus \u003d MergeStatus.FAST_FORWARD;\n+            } else {\n+                msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n+                newHead \u003d base \u003d headId;\n+                mergeStatus \u003d MergeStatus.FAST_FORWARD_SQUASHED;\n+                List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n+                String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n+                repo.writeSquashCommitMsg(squashMessage);\n+            }\n             setCallable(false);\n-            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n+            return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n         } else {\n-            String mergeMessage \u003d new MergeMessageFormatter().format(commits, head);\n-            repo.writeMergeCommitMsg(mergeMessage);\n-            repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n+            String mergeMessage \u003d \"\";\n+            if (!squash) {\n+                mergeMessage \u003d new MergeMessageFormatter().format(commits, head);\n+                repo.writeMergeCommitMsg(mergeMessage);\n+                repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n+            } else {\n+                List\u003cRevCommit\u003e squashedCommits \u003d RevWalkUtils.find(revWalk, srcCommit, headCommit);\n+                String squashMessage \u003d new SquashMessageFormatter().format(squashedCommits, head);\n+                repo.writeSquashCommitMsg(squashMessage);\n+            }\n             Merger merger \u003d mergeStrategy.newMerger(repo);\n             boolean noProblems;\n             Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n             Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n             List\u003cString\u003e unmergedPaths \u003d null;\n             if (merger instanceof ResolveMerger) {\n                 ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                 resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                 resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n                 lowLevelResults \u003d resolveMerger.getMergeResults();\n                 failingPaths \u003d resolveMerger.getFailingPaths();\n                 unmergedPaths \u003d resolveMerger.getUnmergedPaths();\n             } else\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n             refLogMessage.append(\": Merge made by \");\n             refLogMessage.append(mergeStrategy.getName());\n             refLogMessage.append(\u0027.\u0027);\n             if (noProblems) {\n                 dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                 dco.setFailOnConflict(true);\n                 dco.checkout();\n-                RevCommit newHead \u003d new Git(getRepository()).commit().setReflogComment(refLogMessage.toString()).call();\n-                return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.MERGED, mergeStrategy, null, null);\n+                String msg \u003d null;\n+                RevCommit newHead \u003d null;\n+                MergeStatus mergeStatus \u003d null;\n+                if (!squash) {\n+                    newHead \u003d new Git(getRepository()).commit().setReflogComment(refLogMessage.toString()).call();\n+                    mergeStatus \u003d MergeStatus.MERGED;\n+                } else {\n+                    msg \u003d JGitText.get().squashCommitNotUpdatingHEAD;\n+                    newHead \u003d headCommit;\n+                    mergeStatus \u003d MergeStatus.MERGED_SQUASHED;\n+                }\n+                return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n             } else {\n                 if (failingPaths !\u003d null) {\n                     repo.writeMergeCommitMsg(null);\n                     repo.writeMergeHeads(null);\n                     return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                 } else {\n                     String mergeMessageWithConflicts \u003d new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                     repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                     return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                 }\n             }\n         }\n     } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n         List\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections.\u003cString\u003eemptyList() : dco.getConflicts();\n         throw new CheckoutConflictException(conflicts, e);\n     } catch (IOException e) {\n         throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n     } finally {\n         if (revWalk !\u003d null)\n             revWalk.release();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4e1454ded6e2fcf6cb789c004756883c3ea5f77e": {
      "type": "Yexceptionschange",
      "commitMessage": "Git API does not declare GitAPIException call() and related cleanups\n\nAll commands should throw a GitAPIException so new exceptions can be\nadded without breaking the builds of old code, i.e. anyone that calls\na Git API should catch GitAPIException and not just the currently known\nexceptions.\n\nNow the only checked exceptions on Git API calls are GitException and\nsubclasses of it. New checked exceptions that are subclasses of\nGitException may be added without breaking the API.\n\nJavadoc for GitAPIException is declared on GitCommand and\ninherited to subclasses. JGitInternalException is not explicitly\ndocumented anymore.\n\nUnfortunately this change itself breaks the API. The intention is\nthat it shall be possible to add new checked subclasses of\nGitAPIException without breaking the API.\n\nBug: 366914\nEGit-Change-Id: I50380f13fc82c22d0036f47c7859cc3a77e767c5\nChange-Id: I50380f13fc82c22d0036f47c7859cc3a77e767c5\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e\n",
      "commitDate": "2012/5/31 上午4:08",
      "commitName": "4e1454ded6e2fcf6cb789c004756883c3ea5f77e",
      "commitAuthor": "Robin Rosenberg",
      "commitDateOld": "2012/3/12 下午10:20",
      "commitNameOld": "95d311f8886f42f31a4475f84aa23c6345ab7059",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 79.24,
      "commitsBetweenForRepo": 65,
      "commitsBetweenForFile": 1,
      "actualSource": "public MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    if (commits.size() !\u003d 1)\n        throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads, mergeStrategy.getName(), Integer.valueOf(commits.size())));\n    RevWalk revWalk \u003d null;\n    DirCacheCheckout dco \u003d null;\n    try {\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n        revWalk \u003d new RevWalk(repo);\n        Ref ref \u003d commits.get(0);\n        refLogMessage.append(ref.getName());\n        ObjectId objectId \u003d ref.getPeeledObjectId();\n        if (objectId \u003d\u003d null)\n            objectId \u003d ref.getObjectId();\n        RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n        ObjectId headId \u003d head.getObjectId();\n        if (headId \u003d\u003d null) {\n            revWalk.parseHeaders(srcCommit);\n            dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() !\u003d Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            updateHead(refLogMessage, srcCommit, headId);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        } else {\n            String mergeMessage \u003d new MergeMessageFormatter().format(commits, head);\n            repo.writeMergeCommitMsg(mergeMessage);\n            repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            Merger merger \u003d mergeStrategy.newMerger(repo);\n            boolean noProblems;\n            Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n            Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n            List\u003cString\u003e unmergedPaths \u003d null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n                lowLevelResults \u003d resolveMerger.getMergeResults();\n                failingPaths \u003d resolveMerger.getFailingPaths();\n                unmergedPaths \u003d resolveMerger.getUnmergedPaths();\n            } else\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n            refLogMessage.append(\": Merge made by \");\n            refLogMessage.append(mergeStrategy.getName());\n            refLogMessage.append(\u0027.\u0027);\n            if (noProblems) {\n                dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                RevCommit newHead \u003d new Git(getRepository()).commit().setReflogComment(refLogMessage.toString()).call();\n                return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.MERGED, mergeStrategy, null, null);\n            } else {\n                if (failingPaths !\u003d null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else {\n                    String mergeMessageWithConflicts \u003d new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                    repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                }\n            }\n        }\n    } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n        List\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections.\u003cString\u003eemptyList() : dco.getConflicts();\n        throw new CheckoutConflictException(conflicts, e);\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk !\u003d null)\n            revWalk.release();\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 113,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Merge} command with all the options and parameters\ncollected by the setter methods (e.g. {@link #include(Ref)}) of this\nclass. Each instance of this class should only be used for one invocation\nof the command. Don\u0027t call this method twice on an instance.\n\n@return the result of the merge\n",
      "diff": "@@ -1,95 +1,95 @@\n-public MergeResult call() throws NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n+public MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n     checkCallable();\n     if (commits.size() !\u003d 1)\n         throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads, mergeStrategy.getName(), Integer.valueOf(commits.size())));\n     RevWalk revWalk \u003d null;\n     DirCacheCheckout dco \u003d null;\n     try {\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n         revWalk \u003d new RevWalk(repo);\n         Ref ref \u003d commits.get(0);\n         refLogMessage.append(ref.getName());\n         ObjectId objectId \u003d ref.getPeeledObjectId();\n         if (objectId \u003d\u003d null)\n             objectId \u003d ref.getObjectId();\n         RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n         ObjectId headId \u003d head.getObjectId();\n         if (headId \u003d\u003d null) {\n             revWalk.parseHeaders(srcCommit);\n             dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n             dco.setFailOnConflict(true);\n             dco.checkout();\n             RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n             refUpdate.setNewObjectId(objectId);\n             refUpdate.setExpectedOldObjectId(null);\n             refUpdate.setRefLogMessage(\"initial pull\", false);\n             if (refUpdate.update() !\u003d Result.NEW)\n                 throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n             setCallable(false);\n             return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n         }\n         RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n         if (revWalk.isMergedInto(srcCommit, headCommit)) {\n             setCallable(false);\n             return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n         } else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n             refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n             dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n             dco.setFailOnConflict(true);\n             dco.checkout();\n             updateHead(refLogMessage, srcCommit, headId);\n             setCallable(false);\n             return new MergeResult(srcCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n         } else {\n             String mergeMessage \u003d new MergeMessageFormatter().format(commits, head);\n             repo.writeMergeCommitMsg(mergeMessage);\n             repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n             Merger merger \u003d mergeStrategy.newMerger(repo);\n             boolean noProblems;\n             Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n             Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n             List\u003cString\u003e unmergedPaths \u003d null;\n             if (merger instanceof ResolveMerger) {\n                 ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                 resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                 resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n                 lowLevelResults \u003d resolveMerger.getMergeResults();\n                 failingPaths \u003d resolveMerger.getFailingPaths();\n                 unmergedPaths \u003d resolveMerger.getUnmergedPaths();\n             } else\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n             refLogMessage.append(\": Merge made by \");\n             refLogMessage.append(mergeStrategy.getName());\n             refLogMessage.append(\u0027.\u0027);\n             if (noProblems) {\n                 dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                 dco.setFailOnConflict(true);\n                 dco.checkout();\n                 RevCommit newHead \u003d new Git(getRepository()).commit().setReflogComment(refLogMessage.toString()).call();\n                 return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.MERGED, mergeStrategy, null, null);\n             } else {\n                 if (failingPaths !\u003d null) {\n                     repo.writeMergeCommitMsg(null);\n                     repo.writeMergeHeads(null);\n                     return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                 } else {\n                     String mergeMessageWithConflicts \u003d new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                     repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                     return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                 }\n             }\n         }\n     } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n         List\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections.\u003cString\u003eemptyList() : dco.getConflicts();\n         throw new CheckoutConflictException(conflicts, e);\n     } catch (IOException e) {\n         throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n     } finally {\n         if (revWalk !\u003d null)\n             revWalk.release();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException]",
        "newValue": "[GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException]"
      }
    },
    "26b573862912b2faf3824bb18dfeb44a3b700014": {
      "type": "Ybodychange",
      "commitMessage": "Throw API exception when MergeCommand hits checkout conflicts \n\nWhen MergeCommand hit checkout conflicts it did throw an internal JGit\nexception org.eclipse.jgit.errors.CheckoutConflictException instead of\norg.eclipse.jgit.api.errors.CheckoutConflictException which it\ndeclares to throw. Hence translate the internal exception to the\nexception declared in the API.\n\nBug: 327573\nChange-Id: I1efcd93a43ecbf4a40583e0fc9d8d53cffc98cae\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2011/12/9 上午6:33",
      "commitName": "26b573862912b2faf3824bb18dfeb44a3b700014",
      "commitAuthor": "Matthias Sohn",
      "commitDateOld": "2011/9/22 上午5:36",
      "commitNameOld": "39ad503fcb0c293e9c6d47d653a0d52456d4760b",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 78.04,
      "commitsBetweenForRepo": 83,
      "commitsBetweenForFile": 1,
      "actualSource": "public MergeResult call() throws NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    if (commits.size() !\u003d 1)\n        throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads, mergeStrategy.getName(), Integer.valueOf(commits.size())));\n    RevWalk revWalk \u003d null;\n    DirCacheCheckout dco \u003d null;\n    try {\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n        revWalk \u003d new RevWalk(repo);\n        Ref ref \u003d commits.get(0);\n        refLogMessage.append(ref.getName());\n        ObjectId objectId \u003d ref.getPeeledObjectId();\n        if (objectId \u003d\u003d null)\n            objectId \u003d ref.getObjectId();\n        RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n        ObjectId headId \u003d head.getObjectId();\n        if (headId \u003d\u003d null) {\n            revWalk.parseHeaders(srcCommit);\n            dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() !\u003d Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            updateHead(refLogMessage, srcCommit, headId);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        } else {\n            String mergeMessage \u003d new MergeMessageFormatter().format(commits, head);\n            repo.writeMergeCommitMsg(mergeMessage);\n            repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            Merger merger \u003d mergeStrategy.newMerger(repo);\n            boolean noProblems;\n            Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n            Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n            List\u003cString\u003e unmergedPaths \u003d null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n                lowLevelResults \u003d resolveMerger.getMergeResults();\n                failingPaths \u003d resolveMerger.getFailingPaths();\n                unmergedPaths \u003d resolveMerger.getUnmergedPaths();\n            } else\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n            refLogMessage.append(\": Merge made by \");\n            refLogMessage.append(mergeStrategy.getName());\n            refLogMessage.append(\u0027.\u0027);\n            if (noProblems) {\n                dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                RevCommit newHead \u003d new Git(getRepository()).commit().setReflogComment(refLogMessage.toString()).call();\n                return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.MERGED, mergeStrategy, null, null);\n            } else {\n                if (failingPaths !\u003d null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else {\n                    String mergeMessageWithConflicts \u003d new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                    repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                }\n            }\n        }\n    } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n        List\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections.\u003cString\u003eemptyList() : dco.getConflicts();\n        throw new CheckoutConflictException(conflicts, e);\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk !\u003d null)\n            revWalk.release();\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 112,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Merge} command with all the options and parameters\ncollected by the setter methods (e.g. {@link #include(Ref)}) of this\nclass. Each instance of this class should only be used for one invocation\nof the command. Don\u0027t call this method twice on an instance.\n\n@return the result of the merge\n",
      "diff": "@@ -1,91 +1,95 @@\n public MergeResult call() throws NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n     checkCallable();\n     if (commits.size() !\u003d 1)\n         throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads, mergeStrategy.getName(), Integer.valueOf(commits.size())));\n     RevWalk revWalk \u003d null;\n+    DirCacheCheckout dco \u003d null;\n     try {\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n         revWalk \u003d new RevWalk(repo);\n         Ref ref \u003d commits.get(0);\n         refLogMessage.append(ref.getName());\n         ObjectId objectId \u003d ref.getPeeledObjectId();\n         if (objectId \u003d\u003d null)\n             objectId \u003d ref.getObjectId();\n         RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n         ObjectId headId \u003d head.getObjectId();\n         if (headId \u003d\u003d null) {\n             revWalk.parseHeaders(srcCommit);\n-            DirCacheCheckout dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n+            dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n             dco.setFailOnConflict(true);\n             dco.checkout();\n             RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n             refUpdate.setNewObjectId(objectId);\n             refUpdate.setExpectedOldObjectId(null);\n             refUpdate.setRefLogMessage(\"initial pull\", false);\n             if (refUpdate.update() !\u003d Result.NEW)\n                 throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n             setCallable(false);\n             return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n         }\n         RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n         if (revWalk.isMergedInto(srcCommit, headCommit)) {\n             setCallable(false);\n             return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n         } else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n             refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n-            DirCacheCheckout dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n+            dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n             dco.setFailOnConflict(true);\n             dco.checkout();\n             updateHead(refLogMessage, srcCommit, headId);\n             setCallable(false);\n             return new MergeResult(srcCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n         } else {\n             String mergeMessage \u003d new MergeMessageFormatter().format(commits, head);\n             repo.writeMergeCommitMsg(mergeMessage);\n             repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n             Merger merger \u003d mergeStrategy.newMerger(repo);\n             boolean noProblems;\n             Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n             Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n             List\u003cString\u003e unmergedPaths \u003d null;\n             if (merger instanceof ResolveMerger) {\n                 ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                 resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                 resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n                 lowLevelResults \u003d resolveMerger.getMergeResults();\n                 failingPaths \u003d resolveMerger.getFailingPaths();\n                 unmergedPaths \u003d resolveMerger.getUnmergedPaths();\n             } else\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n             refLogMessage.append(\": Merge made by \");\n             refLogMessage.append(mergeStrategy.getName());\n             refLogMessage.append(\u0027.\u0027);\n             if (noProblems) {\n-                DirCacheCheckout dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n+                dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                 dco.setFailOnConflict(true);\n                 dco.checkout();\n                 RevCommit newHead \u003d new Git(getRepository()).commit().setReflogComment(refLogMessage.toString()).call();\n                 return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.MERGED, mergeStrategy, null, null);\n             } else {\n                 if (failingPaths !\u003d null) {\n                     repo.writeMergeCommitMsg(null);\n                     repo.writeMergeHeads(null);\n                     return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                 } else {\n                     String mergeMessageWithConflicts \u003d new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                     repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                     return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                 }\n             }\n         }\n+    } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n+        List\u003cString\u003e conflicts \u003d (dco \u003d\u003d null) ? Collections.\u003cString\u003eemptyList() : dco.getConflicts();\n+        throw new CheckoutConflictException(conflicts, e);\n     } catch (IOException e) {\n         throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n     } finally {\n         if (revWalk !\u003d null)\n             revWalk.release();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "39ad503fcb0c293e9c6d47d653a0d52456d4760b": {
      "type": "Ybodychange",
      "commitMessage": "Append merge strategy to reflog message\n\nChange-Id: Ia0e73208b86c45a3d96698e973f6e70ec5cb7303\nSigned-off-by: Robin Rosenberg \u003crobin.rosenberg@dewire.com\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e\n",
      "commitDate": "2011/9/22 上午5:36",
      "commitName": "39ad503fcb0c293e9c6d47d653a0d52456d4760b",
      "commitAuthor": "Robin Rosenberg",
      "commitDateOld": "2011/9/22 上午5:36",
      "commitNameOld": "4f4e468f6f344ed7c106b86b850d2c9171dd1a0f",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public MergeResult call() throws NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    if (commits.size() !\u003d 1)\n        throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads, mergeStrategy.getName(), Integer.valueOf(commits.size())));\n    RevWalk revWalk \u003d null;\n    try {\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n        revWalk \u003d new RevWalk(repo);\n        Ref ref \u003d commits.get(0);\n        refLogMessage.append(ref.getName());\n        ObjectId objectId \u003d ref.getPeeledObjectId();\n        if (objectId \u003d\u003d null)\n            objectId \u003d ref.getObjectId();\n        RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n        ObjectId headId \u003d head.getObjectId();\n        if (headId \u003d\u003d null) {\n            revWalk.parseHeaders(srcCommit);\n            DirCacheCheckout dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() !\u003d Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            DirCacheCheckout dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            updateHead(refLogMessage, srcCommit, headId);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        } else {\n            String mergeMessage \u003d new MergeMessageFormatter().format(commits, head);\n            repo.writeMergeCommitMsg(mergeMessage);\n            repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            Merger merger \u003d mergeStrategy.newMerger(repo);\n            boolean noProblems;\n            Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n            Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n            List\u003cString\u003e unmergedPaths \u003d null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n                lowLevelResults \u003d resolveMerger.getMergeResults();\n                failingPaths \u003d resolveMerger.getFailingPaths();\n                unmergedPaths \u003d resolveMerger.getUnmergedPaths();\n            } else\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n            refLogMessage.append(\": Merge made by \");\n            refLogMessage.append(mergeStrategy.getName());\n            refLogMessage.append(\u0027.\u0027);\n            if (noProblems) {\n                DirCacheCheckout dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                RevCommit newHead \u003d new Git(getRepository()).commit().setReflogComment(refLogMessage.toString()).call();\n                return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.MERGED, mergeStrategy, null, null);\n            } else {\n                if (failingPaths !\u003d null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else {\n                    String mergeMessageWithConflicts \u003d new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                    repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                }\n            }\n        }\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk !\u003d null)\n            revWalk.release();\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 111,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Merge} command with all the options and parameters\ncollected by the setter methods (e.g. {@link #include(Ref)}) of this\nclass. Each instance of this class should only be used for one invocation\nof the command. Don\u0027t call this method twice on an instance.\n\n@return the result of the merge\n",
      "diff": "@@ -1,88 +1,91 @@\n public MergeResult call() throws NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n     checkCallable();\n     if (commits.size() !\u003d 1)\n         throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads, mergeStrategy.getName(), Integer.valueOf(commits.size())));\n     RevWalk revWalk \u003d null;\n     try {\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n         revWalk \u003d new RevWalk(repo);\n         Ref ref \u003d commits.get(0);\n         refLogMessage.append(ref.getName());\n         ObjectId objectId \u003d ref.getPeeledObjectId();\n         if (objectId \u003d\u003d null)\n             objectId \u003d ref.getObjectId();\n         RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n         ObjectId headId \u003d head.getObjectId();\n         if (headId \u003d\u003d null) {\n             revWalk.parseHeaders(srcCommit);\n             DirCacheCheckout dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n             dco.setFailOnConflict(true);\n             dco.checkout();\n             RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n             refUpdate.setNewObjectId(objectId);\n             refUpdate.setExpectedOldObjectId(null);\n             refUpdate.setRefLogMessage(\"initial pull\", false);\n             if (refUpdate.update() !\u003d Result.NEW)\n                 throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n             setCallable(false);\n             return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n         }\n         RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n         if (revWalk.isMergedInto(srcCommit, headCommit)) {\n             setCallable(false);\n             return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n         } else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n             refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n             DirCacheCheckout dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n             dco.setFailOnConflict(true);\n             dco.checkout();\n             updateHead(refLogMessage, srcCommit, headId);\n             setCallable(false);\n             return new MergeResult(srcCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n         } else {\n             String mergeMessage \u003d new MergeMessageFormatter().format(commits, head);\n             repo.writeMergeCommitMsg(mergeMessage);\n             repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n             Merger merger \u003d mergeStrategy.newMerger(repo);\n             boolean noProblems;\n             Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n             Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n             List\u003cString\u003e unmergedPaths \u003d null;\n             if (merger instanceof ResolveMerger) {\n                 ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                 resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                 resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n                 lowLevelResults \u003d resolveMerger.getMergeResults();\n                 failingPaths \u003d resolveMerger.getFailingPaths();\n                 unmergedPaths \u003d resolveMerger.getUnmergedPaths();\n             } else\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n+            refLogMessage.append(\": Merge made by \");\n+            refLogMessage.append(mergeStrategy.getName());\n+            refLogMessage.append(\u0027.\u0027);\n             if (noProblems) {\n                 DirCacheCheckout dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                 dco.setFailOnConflict(true);\n                 dco.checkout();\n                 RevCommit newHead \u003d new Git(getRepository()).commit().setReflogComment(refLogMessage.toString()).call();\n                 return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.MERGED, mergeStrategy, null, null);\n             } else {\n                 if (failingPaths !\u003d null) {\n                     repo.writeMergeCommitMsg(null);\n                     repo.writeMergeHeads(null);\n                     return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                 } else {\n                     String mergeMessageWithConflicts \u003d new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                     repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                     return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                 }\n             }\n         }\n     } catch (IOException e) {\n         throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n     } finally {\n         if (revWalk !\u003d null)\n             revWalk.release();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4f4e468f6f344ed7c106b86b850d2c9171dd1a0f": {
      "type": "Ybodychange",
      "commitMessage": "Fix the reflog prefix for cherry-pick, revert and merge commands\n\nWe should see whether the commit was a regular commit or something\nelse.\n\nChange-Id: I82d8300cf3c53cb2bdcb6495386aadb803e0c6f7\nSigned-off-by: Robin Rosenberg \u003crobin.rosenberg@dewire.com\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e\n",
      "commitDate": "2011/9/22 上午5:36",
      "commitName": "4f4e468f6f344ed7c106b86b850d2c9171dd1a0f",
      "commitAuthor": "Robin Rosenberg",
      "commitDateOld": "2011/8/22 上午4:53",
      "commitNameOld": "c580c56c4def9639b603553b3d4cbc7117a30938",
      "commitAuthorOld": "Denys Digtiar",
      "daysBetweenCommits": 31.03,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "actualSource": "public MergeResult call() throws NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    if (commits.size() !\u003d 1)\n        throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads, mergeStrategy.getName(), Integer.valueOf(commits.size())));\n    RevWalk revWalk \u003d null;\n    try {\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n        revWalk \u003d new RevWalk(repo);\n        Ref ref \u003d commits.get(0);\n        refLogMessage.append(ref.getName());\n        ObjectId objectId \u003d ref.getPeeledObjectId();\n        if (objectId \u003d\u003d null)\n            objectId \u003d ref.getObjectId();\n        RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n        ObjectId headId \u003d head.getObjectId();\n        if (headId \u003d\u003d null) {\n            revWalk.parseHeaders(srcCommit);\n            DirCacheCheckout dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() !\u003d Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            DirCacheCheckout dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            updateHead(refLogMessage, srcCommit, headId);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        } else {\n            String mergeMessage \u003d new MergeMessageFormatter().format(commits, head);\n            repo.writeMergeCommitMsg(mergeMessage);\n            repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            Merger merger \u003d mergeStrategy.newMerger(repo);\n            boolean noProblems;\n            Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n            Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n            List\u003cString\u003e unmergedPaths \u003d null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n                lowLevelResults \u003d resolveMerger.getMergeResults();\n                failingPaths \u003d resolveMerger.getFailingPaths();\n                unmergedPaths \u003d resolveMerger.getUnmergedPaths();\n            } else\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n            if (noProblems) {\n                DirCacheCheckout dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                RevCommit newHead \u003d new Git(getRepository()).commit().setReflogComment(refLogMessage.toString()).call();\n                return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.MERGED, mergeStrategy, null, null);\n            } else {\n                if (failingPaths !\u003d null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else {\n                    String mergeMessageWithConflicts \u003d new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                    repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                }\n            }\n        }\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk !\u003d null)\n            revWalk.release();\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 111,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Merge} command with all the options and parameters\ncollected by the setter methods (e.g. {@link #include(Ref)}) of this\nclass. Each instance of this class should only be used for one invocation\nof the command. Don\u0027t call this method twice on an instance.\n\n@return the result of the merge\n",
      "diff": "@@ -1,88 +1,88 @@\n public MergeResult call() throws NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n     checkCallable();\n     if (commits.size() !\u003d 1)\n         throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads, mergeStrategy.getName(), Integer.valueOf(commits.size())));\n     RevWalk revWalk \u003d null;\n     try {\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n         revWalk \u003d new RevWalk(repo);\n         Ref ref \u003d commits.get(0);\n         refLogMessage.append(ref.getName());\n         ObjectId objectId \u003d ref.getPeeledObjectId();\n         if (objectId \u003d\u003d null)\n             objectId \u003d ref.getObjectId();\n         RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n         ObjectId headId \u003d head.getObjectId();\n         if (headId \u003d\u003d null) {\n             revWalk.parseHeaders(srcCommit);\n             DirCacheCheckout dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n             dco.setFailOnConflict(true);\n             dco.checkout();\n             RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n             refUpdate.setNewObjectId(objectId);\n             refUpdate.setExpectedOldObjectId(null);\n             refUpdate.setRefLogMessage(\"initial pull\", false);\n             if (refUpdate.update() !\u003d Result.NEW)\n                 throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n             setCallable(false);\n             return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n         }\n         RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n         if (revWalk.isMergedInto(srcCommit, headCommit)) {\n             setCallable(false);\n             return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n         } else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n             refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n             DirCacheCheckout dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n             dco.setFailOnConflict(true);\n             dco.checkout();\n             updateHead(refLogMessage, srcCommit, headId);\n             setCallable(false);\n             return new MergeResult(srcCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n         } else {\n             String mergeMessage \u003d new MergeMessageFormatter().format(commits, head);\n             repo.writeMergeCommitMsg(mergeMessage);\n             repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n             Merger merger \u003d mergeStrategy.newMerger(repo);\n             boolean noProblems;\n             Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n             Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n             List\u003cString\u003e unmergedPaths \u003d null;\n             if (merger instanceof ResolveMerger) {\n                 ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                 resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                 resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n                 lowLevelResults \u003d resolveMerger.getMergeResults();\n                 failingPaths \u003d resolveMerger.getFailingPaths();\n                 unmergedPaths \u003d resolveMerger.getUnmergedPaths();\n             } else\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n             if (noProblems) {\n                 DirCacheCheckout dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                 dco.setFailOnConflict(true);\n                 dco.checkout();\n-                RevCommit newHead \u003d new Git(getRepository()).commit().call();\n+                RevCommit newHead \u003d new Git(getRepository()).commit().setReflogComment(refLogMessage.toString()).call();\n                 return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.MERGED, mergeStrategy, null, null);\n             } else {\n                 if (failingPaths !\u003d null) {\n                     repo.writeMergeCommitMsg(null);\n                     repo.writeMergeHeads(null);\n                     return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                 } else {\n                     String mergeMessageWithConflicts \u003d new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                     repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                     return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                 }\n             }\n         }\n     } catch (IOException e) {\n         throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n     } finally {\n         if (revWalk !\u003d null)\n             revWalk.release();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c580c56c4def9639b603553b3d4cbc7117a30938": {
      "type": "Ybodychange",
      "commitMessage": "Fix ClassCastException in MergeCommand\n\nTest was added which reproduce the ClassCastException when ours or\ntheirs merge strategy is set to MergeCommand. Merger and MergeCommand\nwere updated in order to avoid exception.\n\nChange-Id: I4c1284b4e80d82638d0677a05e5d38182526d196\nSigned-off-by: Denys Digtiar \u003cduemir@gmail.com\u003e\nSigned-off-by: Chris Aniszczyk \u003ccaniszczyk@gmail.com\u003e\n",
      "commitDate": "2011/8/22 上午4:53",
      "commitName": "c580c56c4def9639b603553b3d4cbc7117a30938",
      "commitAuthor": "Denys Digtiar",
      "commitDateOld": "2011/4/7 上午4:57",
      "commitNameOld": "5dbef3fa51053b37f68b44ed390cab6dc8336dcc",
      "commitAuthorOld": "Robin Stocker",
      "daysBetweenCommits": 137.0,
      "commitsBetweenForRepo": 148,
      "commitsBetweenForFile": 1,
      "actualSource": "public MergeResult call() throws NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    if (commits.size() !\u003d 1)\n        throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads, mergeStrategy.getName(), Integer.valueOf(commits.size())));\n    RevWalk revWalk \u003d null;\n    try {\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n        revWalk \u003d new RevWalk(repo);\n        Ref ref \u003d commits.get(0);\n        refLogMessage.append(ref.getName());\n        ObjectId objectId \u003d ref.getPeeledObjectId();\n        if (objectId \u003d\u003d null)\n            objectId \u003d ref.getObjectId();\n        RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n        ObjectId headId \u003d head.getObjectId();\n        if (headId \u003d\u003d null) {\n            revWalk.parseHeaders(srcCommit);\n            DirCacheCheckout dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() !\u003d Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            DirCacheCheckout dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            updateHead(refLogMessage, srcCommit, headId);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        } else {\n            String mergeMessage \u003d new MergeMessageFormatter().format(commits, head);\n            repo.writeMergeCommitMsg(mergeMessage);\n            repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            Merger merger \u003d mergeStrategy.newMerger(repo);\n            boolean noProblems;\n            Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n            Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n            List\u003cString\u003e unmergedPaths \u003d null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n                lowLevelResults \u003d resolveMerger.getMergeResults();\n                failingPaths \u003d resolveMerger.getFailingPaths();\n                unmergedPaths \u003d resolveMerger.getUnmergedPaths();\n            } else\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n            if (noProblems) {\n                DirCacheCheckout dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                RevCommit newHead \u003d new Git(getRepository()).commit().call();\n                return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.MERGED, mergeStrategy, null, null);\n            } else {\n                if (failingPaths !\u003d null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else {\n                    String mergeMessageWithConflicts \u003d new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                    repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                }\n            }\n        }\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk !\u003d null)\n            revWalk.release();\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 111,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Merge} command with all the options and parameters\ncollected by the setter methods (e.g. {@link #include(Ref)}) of this\nclass. Each instance of this class should only be used for one invocation\nof the command. Don\u0027t call this method twice on an instance.\n\n@return the result of the merge\n",
      "diff": "@@ -1,88 +1,88 @@\n public MergeResult call() throws NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n     checkCallable();\n     if (commits.size() !\u003d 1)\n         throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads, mergeStrategy.getName(), Integer.valueOf(commits.size())));\n     RevWalk revWalk \u003d null;\n     try {\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n         revWalk \u003d new RevWalk(repo);\n         Ref ref \u003d commits.get(0);\n         refLogMessage.append(ref.getName());\n         ObjectId objectId \u003d ref.getPeeledObjectId();\n         if (objectId \u003d\u003d null)\n             objectId \u003d ref.getObjectId();\n         RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n         ObjectId headId \u003d head.getObjectId();\n         if (headId \u003d\u003d null) {\n             revWalk.parseHeaders(srcCommit);\n             DirCacheCheckout dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n             dco.setFailOnConflict(true);\n             dco.checkout();\n             RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n             refUpdate.setNewObjectId(objectId);\n             refUpdate.setExpectedOldObjectId(null);\n             refUpdate.setRefLogMessage(\"initial pull\", false);\n             if (refUpdate.update() !\u003d Result.NEW)\n                 throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n             setCallable(false);\n             return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n         }\n         RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n         if (revWalk.isMergedInto(srcCommit, headCommit)) {\n             setCallable(false);\n             return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n         } else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n             refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n             DirCacheCheckout dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n             dco.setFailOnConflict(true);\n             dco.checkout();\n             updateHead(refLogMessage, srcCommit, headId);\n             setCallable(false);\n             return new MergeResult(srcCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n         } else {\n             String mergeMessage \u003d new MergeMessageFormatter().format(commits, head);\n             repo.writeMergeCommitMsg(mergeMessage);\n             repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n-            ThreeWayMerger merger \u003d (ThreeWayMerger) mergeStrategy.newMerger(repo);\n+            Merger merger \u003d mergeStrategy.newMerger(repo);\n             boolean noProblems;\n             Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n             Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n             List\u003cString\u003e unmergedPaths \u003d null;\n             if (merger instanceof ResolveMerger) {\n                 ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                 resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                 resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n                 lowLevelResults \u003d resolveMerger.getMergeResults();\n                 failingPaths \u003d resolveMerger.getFailingPaths();\n                 unmergedPaths \u003d resolveMerger.getUnmergedPaths();\n             } else\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n             if (noProblems) {\n                 DirCacheCheckout dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                 dco.setFailOnConflict(true);\n                 dco.checkout();\n                 RevCommit newHead \u003d new Git(getRepository()).commit().call();\n                 return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.MERGED, mergeStrategy, null, null);\n             } else {\n                 if (failingPaths !\u003d null) {\n                     repo.writeMergeCommitMsg(null);\n                     repo.writeMergeHeads(null);\n                     return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                 } else {\n                     String mergeMessageWithConflicts \u003d new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                     repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                     return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                 }\n             }\n         }\n     } catch (IOException e) {\n         throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n     } finally {\n         if (revWalk !\u003d null)\n             revWalk.release();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5dbef3fa51053b37f68b44ed390cab6dc8336dcc": {
      "type": "Ybodychange",
      "commitMessage": "Add \"Conflicts\" section to merge message on conflict\n\nThe same as with cherry-pick, the commit message of a merge should\ninclude a \"Conflicts\" section when the merge resulted in conflicts.\n\nChange-Id: I6261dc898262322924af5ca1bef841a654b0df55\nSigned-off-by: Robin Stocker \u003crobin@nibor.org\u003e\n",
      "commitDate": "2011/4/7 上午4:57",
      "commitName": "5dbef3fa51053b37f68b44ed390cab6dc8336dcc",
      "commitAuthor": "Robin Stocker",
      "commitDateOld": "2011/3/21 下午7:33",
      "commitNameOld": "dcf7bd9a8f7acafbd1461dc0414aded2db030983",
      "commitAuthorOld": "Philipp Thun",
      "daysBetweenCommits": 16.39,
      "commitsBetweenForRepo": 41,
      "commitsBetweenForFile": 1,
      "actualSource": "public MergeResult call() throws NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    if (commits.size() !\u003d 1)\n        throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads, mergeStrategy.getName(), Integer.valueOf(commits.size())));\n    RevWalk revWalk \u003d null;\n    try {\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n        revWalk \u003d new RevWalk(repo);\n        Ref ref \u003d commits.get(0);\n        refLogMessage.append(ref.getName());\n        ObjectId objectId \u003d ref.getPeeledObjectId();\n        if (objectId \u003d\u003d null)\n            objectId \u003d ref.getObjectId();\n        RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n        ObjectId headId \u003d head.getObjectId();\n        if (headId \u003d\u003d null) {\n            revWalk.parseHeaders(srcCommit);\n            DirCacheCheckout dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() !\u003d Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            DirCacheCheckout dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            updateHead(refLogMessage, srcCommit, headId);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        } else {\n            String mergeMessage \u003d new MergeMessageFormatter().format(commits, head);\n            repo.writeMergeCommitMsg(mergeMessage);\n            repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            ThreeWayMerger merger \u003d (ThreeWayMerger) mergeStrategy.newMerger(repo);\n            boolean noProblems;\n            Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n            Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n            List\u003cString\u003e unmergedPaths \u003d null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n                lowLevelResults \u003d resolveMerger.getMergeResults();\n                failingPaths \u003d resolveMerger.getFailingPaths();\n                unmergedPaths \u003d resolveMerger.getUnmergedPaths();\n            } else\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n            if (noProblems) {\n                DirCacheCheckout dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                RevCommit newHead \u003d new Git(getRepository()).commit().call();\n                return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.MERGED, mergeStrategy, null, null);\n            } else {\n                if (failingPaths !\u003d null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else {\n                    String mergeMessageWithConflicts \u003d new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                    repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                }\n            }\n        }\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk !\u003d null)\n            revWalk.release();\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 111,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Merge} command with all the options and parameters\ncollected by the setter methods (e.g. {@link #include(Ref)}) of this\nclass. Each instance of this class should only be used for one invocation\nof the command. Don\u0027t call this method twice on an instance.\n\n@return the result of the merge\n",
      "diff": "@@ -1,82 +1,88 @@\n public MergeResult call() throws NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n     checkCallable();\n     if (commits.size() !\u003d 1)\n         throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads, mergeStrategy.getName(), Integer.valueOf(commits.size())));\n     RevWalk revWalk \u003d null;\n     try {\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n         revWalk \u003d new RevWalk(repo);\n         Ref ref \u003d commits.get(0);\n         refLogMessage.append(ref.getName());\n         ObjectId objectId \u003d ref.getPeeledObjectId();\n         if (objectId \u003d\u003d null)\n             objectId \u003d ref.getObjectId();\n         RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n         ObjectId headId \u003d head.getObjectId();\n         if (headId \u003d\u003d null) {\n             revWalk.parseHeaders(srcCommit);\n             DirCacheCheckout dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n             dco.setFailOnConflict(true);\n             dco.checkout();\n             RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n             refUpdate.setNewObjectId(objectId);\n             refUpdate.setExpectedOldObjectId(null);\n             refUpdate.setRefLogMessage(\"initial pull\", false);\n             if (refUpdate.update() !\u003d Result.NEW)\n                 throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n             setCallable(false);\n             return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n         }\n         RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n         if (revWalk.isMergedInto(srcCommit, headCommit)) {\n             setCallable(false);\n             return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n         } else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n             refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n             DirCacheCheckout dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n             dco.setFailOnConflict(true);\n             dco.checkout();\n             updateHead(refLogMessage, srcCommit, headId);\n             setCallable(false);\n             return new MergeResult(srcCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n         } else {\n-            repo.writeMergeCommitMsg(new MergeMessageFormatter().format(commits, head));\n+            String mergeMessage \u003d new MergeMessageFormatter().format(commits, head);\n+            repo.writeMergeCommitMsg(mergeMessage);\n             repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n             ThreeWayMerger merger \u003d (ThreeWayMerger) mergeStrategy.newMerger(repo);\n             boolean noProblems;\n             Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n             Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n+            List\u003cString\u003e unmergedPaths \u003d null;\n             if (merger instanceof ResolveMerger) {\n                 ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                 resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                 resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n                 lowLevelResults \u003d resolveMerger.getMergeResults();\n                 failingPaths \u003d resolveMerger.getFailingPaths();\n+                unmergedPaths \u003d resolveMerger.getUnmergedPaths();\n             } else\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n             if (noProblems) {\n                 DirCacheCheckout dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                 dco.setFailOnConflict(true);\n                 dco.checkout();\n                 RevCommit newHead \u003d new Git(getRepository()).commit().call();\n                 return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.MERGED, mergeStrategy, null, null);\n             } else {\n                 if (failingPaths !\u003d null) {\n                     repo.writeMergeCommitMsg(null);\n                     repo.writeMergeHeads(null);\n                     return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n-                } else\n+                } else {\n+                    String mergeMessageWithConflicts \u003d new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n+                    repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                     return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n+                }\n             }\n         }\n     } catch (IOException e) {\n         throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n     } finally {\n         if (revWalk !\u003d null)\n             revWalk.release();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "dcf7bd9a8f7acafbd1461dc0414aded2db030983": {
      "type": "Ybodychange",
      "commitMessage": "Improve MergeResult\n\nAdd paths causing abnormal merge failures (e.g. due to unstaged\nchanges) to the MergeResult returned by MergeCommand. This helps\ncallers to better handle (e.g. present) merge results.\n\nChange-Id: Idb8cf04c5cecfb6a12cb880e16febfc3b9358564\nSigned-off-by: Philipp Thun \u003cphilipp.thun@sap.com\u003e\n",
      "commitDate": "2011/3/21 下午7:33",
      "commitName": "dcf7bd9a8f7acafbd1461dc0414aded2db030983",
      "commitAuthor": "Philipp Thun",
      "commitDateOld": "2011/1/27 上午12:17",
      "commitNameOld": "85f69c286b6c3225dcff05aba42910daefb28da0",
      "commitAuthorOld": "Christian Halstrick",
      "daysBetweenCommits": 53.8,
      "commitsBetweenForRepo": 182,
      "commitsBetweenForFile": 1,
      "actualSource": "public MergeResult call() throws NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    if (commits.size() !\u003d 1)\n        throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads, mergeStrategy.getName(), Integer.valueOf(commits.size())));\n    RevWalk revWalk \u003d null;\n    try {\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n        revWalk \u003d new RevWalk(repo);\n        Ref ref \u003d commits.get(0);\n        refLogMessage.append(ref.getName());\n        ObjectId objectId \u003d ref.getPeeledObjectId();\n        if (objectId \u003d\u003d null)\n            objectId \u003d ref.getObjectId();\n        RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n        ObjectId headId \u003d head.getObjectId();\n        if (headId \u003d\u003d null) {\n            revWalk.parseHeaders(srcCommit);\n            DirCacheCheckout dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() !\u003d Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            DirCacheCheckout dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            updateHead(refLogMessage, srcCommit, headId);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        } else {\n            repo.writeMergeCommitMsg(new MergeMessageFormatter().format(commits, head));\n            repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            ThreeWayMerger merger \u003d (ThreeWayMerger) mergeStrategy.newMerger(repo);\n            boolean noProblems;\n            Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n            Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n                lowLevelResults \u003d resolveMerger.getMergeResults();\n                failingPaths \u003d resolveMerger.getFailingPaths();\n            } else\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n            if (noProblems) {\n                DirCacheCheckout dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                RevCommit newHead \u003d new Git(getRepository()).commit().call();\n                return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.MERGED, mergeStrategy, null, null);\n            } else {\n                if (failingPaths !\u003d null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n            }\n        }\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk !\u003d null)\n            revWalk.release();\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 111,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Merge} command with all the options and parameters\ncollected by the setter methods (e.g. {@link #include(Ref)}) of this\nclass. Each instance of this class should only be used for one invocation\nof the command. Don\u0027t call this method twice on an instance.\n\n@return the result of the merge\n",
      "diff": "@@ -1,82 +1,82 @@\n public MergeResult call() throws NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n     checkCallable();\n     if (commits.size() !\u003d 1)\n         throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads, mergeStrategy.getName(), Integer.valueOf(commits.size())));\n     RevWalk revWalk \u003d null;\n     try {\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n         revWalk \u003d new RevWalk(repo);\n         Ref ref \u003d commits.get(0);\n         refLogMessage.append(ref.getName());\n         ObjectId objectId \u003d ref.getPeeledObjectId();\n         if (objectId \u003d\u003d null)\n             objectId \u003d ref.getObjectId();\n         RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n         ObjectId headId \u003d head.getObjectId();\n         if (headId \u003d\u003d null) {\n             revWalk.parseHeaders(srcCommit);\n             DirCacheCheckout dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n             dco.setFailOnConflict(true);\n             dco.checkout();\n             RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n             refUpdate.setNewObjectId(objectId);\n             refUpdate.setExpectedOldObjectId(null);\n             refUpdate.setRefLogMessage(\"initial pull\", false);\n             if (refUpdate.update() !\u003d Result.NEW)\n                 throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n             setCallable(false);\n             return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n         }\n         RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n         if (revWalk.isMergedInto(srcCommit, headCommit)) {\n             setCallable(false);\n             return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n         } else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n             refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n             DirCacheCheckout dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n             dco.setFailOnConflict(true);\n             dco.checkout();\n             updateHead(refLogMessage, srcCommit, headId);\n             setCallable(false);\n             return new MergeResult(srcCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n         } else {\n             repo.writeMergeCommitMsg(new MergeMessageFormatter().format(commits, head));\n             repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n             ThreeWayMerger merger \u003d (ThreeWayMerger) mergeStrategy.newMerger(repo);\n             boolean noProblems;\n             Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n             Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n             if (merger instanceof ResolveMerger) {\n                 ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                 resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                 resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n                 lowLevelResults \u003d resolveMerger.getMergeResults();\n                 failingPaths \u003d resolveMerger.getFailingPaths();\n             } else\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n             if (noProblems) {\n                 DirCacheCheckout dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                 dco.setFailOnConflict(true);\n                 dco.checkout();\n                 RevCommit newHead \u003d new Git(getRepository()).commit().call();\n                 return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.MERGED, mergeStrategy, null, null);\n             } else {\n                 if (failingPaths !\u003d null) {\n                     repo.writeMergeCommitMsg(null);\n                     repo.writeMergeHeads(null);\n-                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, null);\n+                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                 } else\n                     return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n             }\n         }\n     } catch (IOException e) {\n         throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n     } finally {\n         if (revWalk !\u003d null)\n             revWalk.release();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "85f69c286b6c3225dcff05aba42910daefb28da0": {
      "type": "Ybodychange",
      "commitMessage": "MergeCommand should create missing branches\n\nIf HEAD exists but points to an not-existing branch the merge\ncommand should silently create the missing branch and check\nit out. This happens if you pull into freshly initalized repo.\nHEAD points to refs/heads/master but refs/heads/master doesn\u0027t\nexist. If you know merge a commit X into HEAD then the branch\nmaster should be created (pointing to X) the working tree should\nbe updated to reflect X. That is achieved by checkout with one\ntree only (HEAD is missing).\n\nA test for this functionality will come the the next proposal\nin PullCommandTest.\n\nChange-Id: Id4a0d56d944e0acebd4b3157428bb50bd3fdd872\nSigned-off-by: Christian Halstrick \u003cchristian.halstrick@sap.com\u003e\n",
      "commitDate": "2011/1/27 上午12:17",
      "commitName": "85f69c286b6c3225dcff05aba42910daefb28da0",
      "commitAuthor": "Christian Halstrick",
      "commitDateOld": "2011/1/18 上午5:04",
      "commitNameOld": "e43887b69e27672b80e55391e0ee255efe715ab9",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 8.8,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "actualSource": "public MergeResult call() throws NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    if (commits.size() !\u003d 1)\n        throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads, mergeStrategy.getName(), Integer.valueOf(commits.size())));\n    RevWalk revWalk \u003d null;\n    try {\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n        revWalk \u003d new RevWalk(repo);\n        Ref ref \u003d commits.get(0);\n        refLogMessage.append(ref.getName());\n        ObjectId objectId \u003d ref.getPeeledObjectId();\n        if (objectId \u003d\u003d null)\n            objectId \u003d ref.getObjectId();\n        RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n        ObjectId headId \u003d head.getObjectId();\n        if (headId \u003d\u003d null) {\n            revWalk.parseHeaders(srcCommit);\n            DirCacheCheckout dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() !\u003d Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            DirCacheCheckout dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            updateHead(refLogMessage, srcCommit, headId);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        } else {\n            repo.writeMergeCommitMsg(new MergeMessageFormatter().format(commits, head));\n            repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            ThreeWayMerger merger \u003d (ThreeWayMerger) mergeStrategy.newMerger(repo);\n            boolean noProblems;\n            Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n            Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n                lowLevelResults \u003d resolveMerger.getMergeResults();\n                failingPaths \u003d resolveMerger.getFailingPaths();\n            } else\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n            if (noProblems) {\n                DirCacheCheckout dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                RevCommit newHead \u003d new Git(getRepository()).commit().call();\n                return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.MERGED, mergeStrategy, null, null);\n            } else {\n                if (failingPaths !\u003d null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, null);\n                } else\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n            }\n        }\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk !\u003d null)\n            revWalk.release();\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 111,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Merge} command with all the options and parameters\ncollected by the setter methods (e.g. {@link #include(Ref)}) of this\nclass. Each instance of this class should only be used for one invocation\nof the command. Don\u0027t call this method twice on an instance.\n\n@return the result of the merge\n",
      "diff": "@@ -1,67 +1,82 @@\n public MergeResult call() throws NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n     checkCallable();\n     if (commits.size() !\u003d 1)\n         throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads, mergeStrategy.getName(), Integer.valueOf(commits.size())));\n     RevWalk revWalk \u003d null;\n     try {\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n         revWalk \u003d new RevWalk(repo);\n-        RevCommit headCommit \u003d revWalk.lookupCommit(head.getObjectId());\n         Ref ref \u003d commits.get(0);\n         refLogMessage.append(ref.getName());\n         ObjectId objectId \u003d ref.getPeeledObjectId();\n         if (objectId \u003d\u003d null)\n             objectId \u003d ref.getObjectId();\n         RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n+        ObjectId headId \u003d head.getObjectId();\n+        if (headId \u003d\u003d null) {\n+            revWalk.parseHeaders(srcCommit);\n+            DirCacheCheckout dco \u003d new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n+            dco.setFailOnConflict(true);\n+            dco.checkout();\n+            RefUpdate refUpdate \u003d repo.updateRef(head.getTarget().getName());\n+            refUpdate.setNewObjectId(objectId);\n+            refUpdate.setExpectedOldObjectId(null);\n+            refUpdate.setRefLogMessage(\"initial pull\", false);\n+            if (refUpdate.update() !\u003d Result.NEW)\n+                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n+            setCallable(false);\n+            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n+        }\n+        RevCommit headCommit \u003d revWalk.lookupCommit(headId);\n         if (revWalk.isMergedInto(srcCommit, headCommit)) {\n             setCallable(false);\n             return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n         } else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n             refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n             DirCacheCheckout dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n             dco.setFailOnConflict(true);\n             dco.checkout();\n-            updateHead(refLogMessage, srcCommit, head.getObjectId());\n+            updateHead(refLogMessage, srcCommit, headId);\n             setCallable(false);\n             return new MergeResult(srcCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n         } else {\n             repo.writeMergeCommitMsg(new MergeMessageFormatter().format(commits, head));\n             repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n             ThreeWayMerger merger \u003d (ThreeWayMerger) mergeStrategy.newMerger(repo);\n             boolean noProblems;\n             Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n             Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n             if (merger instanceof ResolveMerger) {\n                 ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                 resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                 resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n                 lowLevelResults \u003d resolveMerger.getMergeResults();\n                 failingPaths \u003d resolveMerger.getFailingPaths();\n             } else\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n             if (noProblems) {\n                 DirCacheCheckout dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                 dco.setFailOnConflict(true);\n                 dco.checkout();\n                 RevCommit newHead \u003d new Git(getRepository()).commit().call();\n                 return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.MERGED, mergeStrategy, null, null);\n             } else {\n                 if (failingPaths !\u003d null) {\n                     repo.writeMergeCommitMsg(null);\n                     repo.writeMergeHeads(null);\n                     return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, null);\n                 } else\n                     return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n             }\n         }\n     } catch (IOException e) {\n         throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n     } finally {\n         if (revWalk !\u003d null)\n             revWalk.release();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e43887b69e27672b80e55391e0ee255efe715ab9": {
      "type": "Ybodychange",
      "commitMessage": "Fix misc spelling errors in comments and method names\n\nChange-Id: I24552443710075856540696717ac4068dfe6a7f2\nSigned-off-by: Robin Rosenberg \u003crobin.rosenberg@dewire.com\u003e\n",
      "commitDate": "2011/1/18 上午5:04",
      "commitName": "e43887b69e27672b80e55391e0ee255efe715ab9",
      "commitAuthor": "Robin Rosenberg",
      "commitDateOld": "2010/11/6 下午8:48",
      "commitNameOld": "6290ca3a638d1ac999da6c11628f904b31972067",
      "commitAuthorOld": "Robin Stocker",
      "daysBetweenCommits": 72.34,
      "commitsBetweenForRepo": 166,
      "commitsBetweenForFile": 1,
      "actualSource": "public MergeResult call() throws NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    if (commits.size() !\u003d 1)\n        throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads, mergeStrategy.getName(), Integer.valueOf(commits.size())));\n    RevWalk revWalk \u003d null;\n    try {\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n        revWalk \u003d new RevWalk(repo);\n        RevCommit headCommit \u003d revWalk.lookupCommit(head.getObjectId());\n        Ref ref \u003d commits.get(0);\n        refLogMessage.append(ref.getName());\n        ObjectId objectId \u003d ref.getPeeledObjectId();\n        if (objectId \u003d\u003d null)\n            objectId \u003d ref.getObjectId();\n        RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            DirCacheCheckout dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            updateHead(refLogMessage, srcCommit, head.getObjectId());\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        } else {\n            repo.writeMergeCommitMsg(new MergeMessageFormatter().format(commits, head));\n            repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            ThreeWayMerger merger \u003d (ThreeWayMerger) mergeStrategy.newMerger(repo);\n            boolean noProblems;\n            Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n            Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n                lowLevelResults \u003d resolveMerger.getMergeResults();\n                failingPaths \u003d resolveMerger.getFailingPaths();\n            } else\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n            if (noProblems) {\n                DirCacheCheckout dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                RevCommit newHead \u003d new Git(getRepository()).commit().call();\n                return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.MERGED, mergeStrategy, null, null);\n            } else {\n                if (failingPaths !\u003d null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, null);\n                } else\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n            }\n        }\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk !\u003d null)\n            revWalk.release();\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 111,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Merge} command with all the options and parameters\ncollected by the setter methods (e.g. {@link #include(Ref)}) of this\nclass. Each instance of this class should only be used for one invocation\nof the command. Don\u0027t call this method twice on an instance.\n\n@return the result of the merge\n",
      "diff": "@@ -1,67 +1,67 @@\n public MergeResult call() throws NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n     checkCallable();\n     if (commits.size() !\u003d 1)\n         throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads, mergeStrategy.getName(), Integer.valueOf(commits.size())));\n     RevWalk revWalk \u003d null;\n     try {\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n         revWalk \u003d new RevWalk(repo);\n         RevCommit headCommit \u003d revWalk.lookupCommit(head.getObjectId());\n         Ref ref \u003d commits.get(0);\n         refLogMessage.append(ref.getName());\n         ObjectId objectId \u003d ref.getPeeledObjectId();\n         if (objectId \u003d\u003d null)\n             objectId \u003d ref.getObjectId();\n         RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n         if (revWalk.isMergedInto(srcCommit, headCommit)) {\n             setCallable(false);\n             return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n         } else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n             refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n             DirCacheCheckout dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n             dco.setFailOnConflict(true);\n             dco.checkout();\n             updateHead(refLogMessage, srcCommit, head.getObjectId());\n             setCallable(false);\n             return new MergeResult(srcCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n         } else {\n             repo.writeMergeCommitMsg(new MergeMessageFormatter().format(commits, head));\n             repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n             ThreeWayMerger merger \u003d (ThreeWayMerger) mergeStrategy.newMerger(repo);\n             boolean noProblems;\n             Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n             Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n             if (merger instanceof ResolveMerger) {\n                 ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                 resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                 resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n                 lowLevelResults \u003d resolveMerger.getMergeResults();\n-                failingPaths \u003d resolveMerger.getFailingPathes();\n+                failingPaths \u003d resolveMerger.getFailingPaths();\n             } else\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n             if (noProblems) {\n                 DirCacheCheckout dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                 dco.setFailOnConflict(true);\n                 dco.checkout();\n                 RevCommit newHead \u003d new Git(getRepository()).commit().call();\n                 return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.MERGED, mergeStrategy, null, null);\n             } else {\n                 if (failingPaths !\u003d null) {\n                     repo.writeMergeCommitMsg(null);\n                     repo.writeMergeHeads(null);\n                     return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, null);\n                 } else\n                     return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n             }\n         }\n     } catch (IOException e) {\n         throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n     } finally {\n         if (revWalk !\u003d null)\n             revWalk.release();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6290ca3a638d1ac999da6c11628f904b31972067": {
      "type": "Ybodychange",
      "commitMessage": "Format merge commit messages like C Git\n\nThe automatically generated commit message of a merge should have the\nsame structure as in C Git for consistency (as per git fmt-merge-msg).\n\nBefore this change:\n\n  merging refs/heads/a into refs/heads/master\n\nAfter:\n\n  Merge branch \u0027a\u0027\n\nPlurals, \"into\" and joining by \",\" and \"and\" also work.\n\nChange-Id: I9658ce2817adc90d2df1060e8ac508d7bd0571cb\n",
      "commitDate": "2010/11/6 下午8:48",
      "commitName": "6290ca3a638d1ac999da6c11628f904b31972067",
      "commitAuthor": "Robin Stocker",
      "commitDateOld": "2010/10/13 下午5:30",
      "commitNameOld": "fb1e500adc011dfaad1a6e68b23a9b254a77bf43",
      "commitAuthorOld": "Christian Halstrick",
      "daysBetweenCommits": 24.14,
      "commitsBetweenForRepo": 46,
      "commitsBetweenForFile": 1,
      "actualSource": "public MergeResult call() throws NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    if (commits.size() !\u003d 1)\n        throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads, mergeStrategy.getName(), Integer.valueOf(commits.size())));\n    RevWalk revWalk \u003d null;\n    try {\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n        revWalk \u003d new RevWalk(repo);\n        RevCommit headCommit \u003d revWalk.lookupCommit(head.getObjectId());\n        Ref ref \u003d commits.get(0);\n        refLogMessage.append(ref.getName());\n        ObjectId objectId \u003d ref.getPeeledObjectId();\n        if (objectId \u003d\u003d null)\n            objectId \u003d ref.getObjectId();\n        RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            DirCacheCheckout dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            updateHead(refLogMessage, srcCommit, head.getObjectId());\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        } else {\n            repo.writeMergeCommitMsg(new MergeMessageFormatter().format(commits, head));\n            repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            ThreeWayMerger merger \u003d (ThreeWayMerger) mergeStrategy.newMerger(repo);\n            boolean noProblems;\n            Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n            Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n                lowLevelResults \u003d resolveMerger.getMergeResults();\n                failingPaths \u003d resolveMerger.getFailingPathes();\n            } else\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n            if (noProblems) {\n                DirCacheCheckout dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                RevCommit newHead \u003d new Git(getRepository()).commit().call();\n                return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.MERGED, mergeStrategy, null, null);\n            } else {\n                if (failingPaths !\u003d null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, null);\n                } else\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n            }\n        }\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk !\u003d null)\n            revWalk.release();\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 111,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Merge} command with all the options and parameters\ncollected by the setter methods (e.g. {@link #include(Ref)}) of this\nclass. Each instance of this class should only be used for one invocation\nof the command. Don\u0027t call this method twice on an instance.\n\n@return the result of the merge\n",
      "diff": "@@ -1,67 +1,67 @@\n public MergeResult call() throws NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n     checkCallable();\n     if (commits.size() !\u003d 1)\n         throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads, mergeStrategy.getName(), Integer.valueOf(commits.size())));\n     RevWalk revWalk \u003d null;\n     try {\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n         revWalk \u003d new RevWalk(repo);\n         RevCommit headCommit \u003d revWalk.lookupCommit(head.getObjectId());\n         Ref ref \u003d commits.get(0);\n         refLogMessage.append(ref.getName());\n         ObjectId objectId \u003d ref.getPeeledObjectId();\n         if (objectId \u003d\u003d null)\n             objectId \u003d ref.getObjectId();\n         RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n         if (revWalk.isMergedInto(srcCommit, headCommit)) {\n             setCallable(false);\n             return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n         } else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n             refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n             DirCacheCheckout dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n             dco.setFailOnConflict(true);\n             dco.checkout();\n             updateHead(refLogMessage, srcCommit, head.getObjectId());\n             setCallable(false);\n             return new MergeResult(srcCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n         } else {\n-            repo.writeMergeCommitMsg(\"merging \" + ref.getName() + \" into \" + head.getName());\n+            repo.writeMergeCommitMsg(new MergeMessageFormatter().format(commits, head));\n             repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n             ThreeWayMerger merger \u003d (ThreeWayMerger) mergeStrategy.newMerger(repo);\n             boolean noProblems;\n             Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n             Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n             if (merger instanceof ResolveMerger) {\n                 ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                 resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                 resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n                 lowLevelResults \u003d resolveMerger.getMergeResults();\n                 failingPaths \u003d resolveMerger.getFailingPathes();\n             } else\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n             if (noProblems) {\n                 DirCacheCheckout dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                 dco.setFailOnConflict(true);\n                 dco.checkout();\n                 RevCommit newHead \u003d new Git(getRepository()).commit().call();\n                 return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.MERGED, mergeStrategy, null, null);\n             } else {\n                 if (failingPaths !\u003d null) {\n                     repo.writeMergeCommitMsg(null);\n                     repo.writeMergeHeads(null);\n                     return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, null);\n                 } else\n                     return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n             }\n         }\n     } catch (IOException e) {\n         throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n     } finally {\n         if (revWalk !\u003d null)\n             revWalk.release();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fb1e500adc011dfaad1a6e68b23a9b254a77bf43": {
      "type": "Ybodychange",
      "commitMessage": "Rename method to ResolveMerger.setWorkingTreeIterator()\n\nrenamed an ugly methodname\n\nChange-Id: I26bda06ef64b8644fd3a555dc55dff43cdb56a71\nSigned-off-by: Christian Halstrick \u003cchristian.halstrick@sap.com\u003e\n",
      "commitDate": "2010/10/13 下午5:30",
      "commitName": "fb1e500adc011dfaad1a6e68b23a9b254a77bf43",
      "commitAuthor": "Christian Halstrick",
      "commitDateOld": "2010/10/13 上午1:18",
      "commitNameOld": "be93452842cfd18d7d738482175cfdbb128ed7dc",
      "commitAuthorOld": "Christian Halstrick",
      "daysBetweenCommits": 0.67,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "public MergeResult call() throws NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    if (commits.size() !\u003d 1)\n        throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads, mergeStrategy.getName(), Integer.valueOf(commits.size())));\n    RevWalk revWalk \u003d null;\n    try {\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n        revWalk \u003d new RevWalk(repo);\n        RevCommit headCommit \u003d revWalk.lookupCommit(head.getObjectId());\n        Ref ref \u003d commits.get(0);\n        refLogMessage.append(ref.getName());\n        ObjectId objectId \u003d ref.getPeeledObjectId();\n        if (objectId \u003d\u003d null)\n            objectId \u003d ref.getObjectId();\n        RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            DirCacheCheckout dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            updateHead(refLogMessage, srcCommit, head.getObjectId());\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        } else {\n            repo.writeMergeCommitMsg(\"merging \" + ref.getName() + \" into \" + head.getName());\n            repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            ThreeWayMerger merger \u003d (ThreeWayMerger) mergeStrategy.newMerger(repo);\n            boolean noProblems;\n            Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n            Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n                lowLevelResults \u003d resolveMerger.getMergeResults();\n                failingPaths \u003d resolveMerger.getFailingPathes();\n            } else\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n            if (noProblems) {\n                DirCacheCheckout dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                RevCommit newHead \u003d new Git(getRepository()).commit().call();\n                return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.MERGED, mergeStrategy, null, null);\n            } else {\n                if (failingPaths !\u003d null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, null);\n                } else\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n            }\n        }\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk !\u003d null)\n            revWalk.release();\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 110,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Merge} command with all the options and parameters\ncollected by the setter methods (e.g. {@link #include(Ref)}) of this\nclass. Each instance of this class should only be used for one invocation\nof the command. Don\u0027t call this method twice on an instance.\n\n@return the result of the merge\n",
      "diff": "@@ -1,67 +1,67 @@\n public MergeResult call() throws NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n     checkCallable();\n     if (commits.size() !\u003d 1)\n         throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads, mergeStrategy.getName(), Integer.valueOf(commits.size())));\n     RevWalk revWalk \u003d null;\n     try {\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n         revWalk \u003d new RevWalk(repo);\n         RevCommit headCommit \u003d revWalk.lookupCommit(head.getObjectId());\n         Ref ref \u003d commits.get(0);\n         refLogMessage.append(ref.getName());\n         ObjectId objectId \u003d ref.getPeeledObjectId();\n         if (objectId \u003d\u003d null)\n             objectId \u003d ref.getObjectId();\n         RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n         if (revWalk.isMergedInto(srcCommit, headCommit)) {\n             setCallable(false);\n             return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n         } else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n             refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n             DirCacheCheckout dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n             dco.setFailOnConflict(true);\n             dco.checkout();\n             updateHead(refLogMessage, srcCommit, head.getObjectId());\n             setCallable(false);\n             return new MergeResult(srcCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n         } else {\n             repo.writeMergeCommitMsg(\"merging \" + ref.getName() + \" into \" + head.getName());\n             repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n             ThreeWayMerger merger \u003d (ThreeWayMerger) mergeStrategy.newMerger(repo);\n             boolean noProblems;\n             Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n             Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n             if (merger instanceof ResolveMerger) {\n                 ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                 resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n-                resolveMerger.setWorkingTreeIt(new FileTreeIterator(repo));\n+                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n                 lowLevelResults \u003d resolveMerger.getMergeResults();\n                 failingPaths \u003d resolveMerger.getFailingPathes();\n             } else\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n             if (noProblems) {\n                 DirCacheCheckout dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                 dco.setFailOnConflict(true);\n                 dco.checkout();\n                 RevCommit newHead \u003d new Git(getRepository()).commit().call();\n                 return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.MERGED, mergeStrategy, null, null);\n             } else {\n                 if (failingPaths !\u003d null) {\n                     repo.writeMergeCommitMsg(null);\n                     repo.writeMergeHeads(null);\n                     return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, null);\n                 } else\n                     return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n             }\n         }\n     } catch (IOException e) {\n         throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n     } finally {\n         if (revWalk !\u003d null)\n             revWalk.release();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "67263e2056108e471d684c3cef9e719724b51220": {
      "type": "Ybodychange",
      "commitMessage": "Refactor diff sequence API\n\nInstead of making the sequence itself responsible for the equivalence\nfunction, use an external function that is supplied by the caller.\nThis cleans up the code because we now say cmp.equals(a, ai, b, bi)\ninstead of a.equals(ai, b, bi).\n\nThis refactoring also removes the odd concept of creating different\ntypes of sequences to have different behaviors for whitespace\nignoring.  Instead DiffComparator now supports singleton functions\nthat apply a particular equivalence algorithm to a type of sequence.\n\nChange-Id: I559f494d81cdc6f06bfb4208f60780c0ae251df9\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010/9/7 上午10:37",
      "commitName": "67263e2056108e471d684c3cef9e719724b51220",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2010/9/2 上午6:27",
      "commitNameOld": "38327a54a86697458a1b326278e04833c105c00e",
      "commitAuthorOld": "Chris Aniszczyk",
      "daysBetweenCommits": 5.17,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "actualSource": "public MergeResult call() throws NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    if (commits.size() !\u003d 1)\n        throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads, mergeStrategy.getName(), Integer.valueOf(commits.size())));\n    RevWalk revWalk \u003d null;\n    try {\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n        revWalk \u003d new RevWalk(repo);\n        RevCommit headCommit \u003d revWalk.lookupCommit(head.getObjectId());\n        Ref ref \u003d commits.get(0);\n        refLogMessage.append(ref.getName());\n        ObjectId objectId \u003d ref.getPeeledObjectId();\n        if (objectId \u003d\u003d null)\n            objectId \u003d ref.getObjectId();\n        RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            DirCacheCheckout dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            updateHead(refLogMessage, srcCommit, head.getObjectId());\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        } else {\n            repo.writeMergeCommitMsg(\"merging \" + ref.getName() + \" into \" + head.getName());\n            repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            ThreeWayMerger merger \u003d (ThreeWayMerger) mergeStrategy.newMerger(repo);\n            boolean noProblems;\n            Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n            Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIt(new FileTreeIterator(repo));\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n                lowLevelResults \u003d resolveMerger.getMergeResults();\n                failingPaths \u003d resolveMerger.getFailingPathes();\n            } else\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n            if (noProblems) {\n                DirCacheCheckout dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                RevCommit newHead \u003d new Git(getRepository()).commit().call();\n                return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.MERGED, mergeStrategy, null, null);\n            } else {\n                if (failingPaths !\u003d null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, null);\n                } else\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n            }\n        }\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk !\u003d null)\n            revWalk.release();\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 113,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Merge} command with all the options and parameters\ncollected by the setter methods (e.g. {@link #include(Ref)}) of this\nclass. Each instance of this class should only be used for one invocation\nof the command. Don\u0027t call this method twice on an instance.\n\n@return the result of the merge\n",
      "diff": "@@ -1,67 +1,67 @@\n public MergeResult call() throws NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n     checkCallable();\n     if (commits.size() !\u003d 1)\n         throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads, mergeStrategy.getName(), Integer.valueOf(commits.size())));\n     RevWalk revWalk \u003d null;\n     try {\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n         revWalk \u003d new RevWalk(repo);\n         RevCommit headCommit \u003d revWalk.lookupCommit(head.getObjectId());\n         Ref ref \u003d commits.get(0);\n         refLogMessage.append(ref.getName());\n         ObjectId objectId \u003d ref.getPeeledObjectId();\n         if (objectId \u003d\u003d null)\n             objectId \u003d ref.getObjectId();\n         RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n         if (revWalk.isMergedInto(srcCommit, headCommit)) {\n             setCallable(false);\n             return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n         } else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n             refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n             DirCacheCheckout dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n             dco.setFailOnConflict(true);\n             dco.checkout();\n             updateHead(refLogMessage, srcCommit, head.getObjectId());\n             setCallable(false);\n             return new MergeResult(srcCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n         } else {\n             repo.writeMergeCommitMsg(\"merging \" + ref.getName() + \" into \" + head.getName());\n             repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n             ThreeWayMerger merger \u003d (ThreeWayMerger) mergeStrategy.newMerger(repo);\n             boolean noProblems;\n-            Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003e lowLevelResults \u003d null;\n+            Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003c?\u003e\u003e lowLevelResults \u003d null;\n             Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n             if (merger instanceof ResolveMerger) {\n                 ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                 resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                 resolveMerger.setWorkingTreeIt(new FileTreeIterator(repo));\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n                 lowLevelResults \u003d resolveMerger.getMergeResults();\n                 failingPaths \u003d resolveMerger.getFailingPathes();\n             } else\n                 noProblems \u003d merger.merge(headCommit, srcCommit);\n             if (noProblems) {\n                 DirCacheCheckout dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                 dco.setFailOnConflict(true);\n                 dco.checkout();\n                 RevCommit newHead \u003d new Git(getRepository()).commit().call();\n                 return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.MERGED, mergeStrategy, null, null);\n             } else {\n                 if (failingPaths !\u003d null) {\n                     repo.writeMergeCommitMsg(null);\n                     repo.writeMergeHeads(null);\n                     return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, null);\n                 } else\n                     return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n             }\n         }\n     } catch (IOException e) {\n         throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n     } finally {\n         if (revWalk !\u003d null)\n             revWalk.release();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "45e79a526c7ffebaf8e4758a6cb6b7af05716707": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "Added merge strategy RESOLVE\n\nThis adds the first merge strategy to JGit which does real\ncontent-merges if necessary. The new merge strategy \"resolve\" takes as\ninput three commits: a common base, ours and theirs. It will simply takeover\nchanges on files which are only touched in ours or theirs. For files\ntouched in ours and theirs it will try to merge the two contents\nknowing taking into account the specified common base.\n\nRename detection has not been introduced for now.\n\nChange-Id: I49a5ebcdcf4f540f606092c0f1dc66c965dc66ba\nSigned-off-by: Christian Halstrick \u003cchristian.halstrick@sap.com\u003e\nSigned-off-by: Stefan Lay \u003cstefan.lay@sap.com\u003e\n",
      "commitDate": "2010/8/31 上午7:21",
      "commitName": "45e79a526c7ffebaf8e4758a6cb6b7af05716707",
      "commitAuthor": "Christian Halstrick",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "Added merge strategy RESOLVE\n\nThis adds the first merge strategy to JGit which does real\ncontent-merges if necessary. The new merge strategy \"resolve\" takes as\ninput three commits: a common base, ours and theirs. It will simply takeover\nchanges on files which are only touched in ours or theirs. For files\ntouched in ours and theirs it will try to merge the two contents\nknowing taking into account the specified common base.\n\nRename detection has not been introduced for now.\n\nChange-Id: I49a5ebcdcf4f540f606092c0f1dc66c965dc66ba\nSigned-off-by: Christian Halstrick \u003cchristian.halstrick@sap.com\u003e\nSigned-off-by: Stefan Lay \u003cstefan.lay@sap.com\u003e\n",
          "commitDate": "2010/8/31 上午7:21",
          "commitName": "45e79a526c7ffebaf8e4758a6cb6b7af05716707",
          "commitAuthor": "Christian Halstrick",
          "commitDateOld": "2010/8/23 下午4:20",
          "commitNameOld": "5fc990130bbd3cf3a0d505c0e12132ec0ecd6b75",
          "commitAuthorOld": "Christian Halstrick",
          "daysBetweenCommits": 7.63,
          "commitsBetweenForRepo": 41,
          "commitsBetweenForFile": 1,
          "actualSource": "public MergeResult call() throws NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    if (commits.size() !\u003d 1)\n        throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads, mergeStrategy.getName(), Integer.valueOf(commits.size())));\n    RevWalk revWalk \u003d null;\n    try {\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n        revWalk \u003d new RevWalk(repo);\n        RevCommit headCommit \u003d revWalk.lookupCommit(head.getObjectId());\n        Ref ref \u003d commits.get(0);\n        refLogMessage.append(ref.getName());\n        ObjectId objectId \u003d ref.getPeeledObjectId();\n        if (objectId \u003d\u003d null)\n            objectId \u003d ref.getObjectId();\n        RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            DirCacheCheckout dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            updateHead(refLogMessage, srcCommit, head.getObjectId());\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        } else {\n            repo.writeMergeCommitMsg(\"merging \" + ref.getName() + \" into \" + head.getName());\n            repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            ThreeWayMerger merger \u003d (ThreeWayMerger) mergeStrategy.newMerger(repo);\n            boolean noProblems;\n            Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003e lowLevelResults \u003d null;\n            Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIt(new FileTreeIterator(repo));\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n                lowLevelResults \u003d resolveMerger.getMergeResults();\n                failingPaths \u003d resolveMerger.getFailingPathes();\n            } else\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n            if (noProblems) {\n                DirCacheCheckout dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                RevCommit newHead \u003d new Git(getRepository()).commit().call();\n                return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.MERGED, mergeStrategy, null, null);\n            } else {\n                if (failingPaths !\u003d null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, null);\n                } else\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n            }\n        }\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk !\u003d null)\n            revWalk.release();\n    }\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
          "functionStartLine": 106,
          "functionName": "call",
          "functionAnnotation": "",
          "functionDoc": "Executes the {@code Merge} command with all the options and parameters\ncollected by the setter methods (e.g. {@link #include(Ref)}) of this\nclass. Each instance of this class should only be used for one invocation\nof the command. Don\u0027t call this method twice on an instance.\n\n@return the result of the merge\n",
          "diff": "@@ -1,37 +1,67 @@\n-public MergeResult call() throws NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException {\n+public MergeResult call() throws NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n     checkCallable();\n     if (commits.size() !\u003d 1)\n-        throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads, mergeStrategy.getName(), commits.size()));\n+        throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads, mergeStrategy.getName(), Integer.valueOf(commits.size())));\n+    RevWalk revWalk \u003d null;\n     try {\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n-        RevWalk revWalk \u003d new RevWalk(repo);\n-        try {\n-            RevCommit headCommit \u003d revWalk.lookupCommit(head.getObjectId());\n-            Ref ref \u003d commits.get(0);\n-            refLogMessage.append(ref.getName());\n-            ObjectId objectId \u003d ref.getPeeledObjectId();\n-            if (objectId \u003d\u003d null)\n-                objectId \u003d ref.getObjectId();\n-            RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n-            if (revWalk.isMergedInto(srcCommit, headCommit)) {\n-                setCallable(false);\n-                return new MergeResult(headCommit, srcCommit, new ObjectId[] { srcCommit, headCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy);\n-            } else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n-                refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n-                checkoutNewHead(revWalk, headCommit, srcCommit);\n-                updateHead(refLogMessage, srcCommit, head.getObjectId());\n-                setCallable(false);\n-                return new MergeResult(srcCommit, headCommit, new ObjectId[] { srcCommit, headCommit }, MergeStatus.FAST_FORWARD, mergeStrategy);\n+        revWalk \u003d new RevWalk(repo);\n+        RevCommit headCommit \u003d revWalk.lookupCommit(head.getObjectId());\n+        Ref ref \u003d commits.get(0);\n+        refLogMessage.append(ref.getName());\n+        ObjectId objectId \u003d ref.getPeeledObjectId();\n+        if (objectId \u003d\u003d null)\n+            objectId \u003d ref.getObjectId();\n+        RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n+        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n+            setCallable(false);\n+            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n+        } else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n+            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n+            DirCacheCheckout dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n+            dco.setFailOnConflict(true);\n+            dco.checkout();\n+            updateHead(refLogMessage, srcCommit, head.getObjectId());\n+            setCallable(false);\n+            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n+        } else {\n+            repo.writeMergeCommitMsg(\"merging \" + ref.getName() + \" into \" + head.getName());\n+            repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n+            ThreeWayMerger merger \u003d (ThreeWayMerger) mergeStrategy.newMerger(repo);\n+            boolean noProblems;\n+            Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003e lowLevelResults \u003d null;\n+            Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n+            if (merger instanceof ResolveMerger) {\n+                ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n+                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n+                resolveMerger.setWorkingTreeIt(new FileTreeIterator(repo));\n+                noProblems \u003d merger.merge(headCommit, srcCommit);\n+                lowLevelResults \u003d resolveMerger.getMergeResults();\n+                failingPaths \u003d resolveMerger.getFailingPathes();\n+            } else\n+                noProblems \u003d merger.merge(headCommit, srcCommit);\n+            if (noProblems) {\n+                DirCacheCheckout dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n+                dco.setFailOnConflict(true);\n+                dco.checkout();\n+                RevCommit newHead \u003d new Git(getRepository()).commit().call();\n+                return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.MERGED, mergeStrategy, null, null);\n             } else {\n-                return new MergeResult(headCommit, null, new ObjectId[] { srcCommit, headCommit }, MergeResult.MergeStatus.NOT_SUPPORTED, mergeStrategy, JGitText.get().onlyAlreadyUpToDateAndFastForwardMergesAreAvailable);\n+                if (failingPaths !\u003d null) {\n+                    repo.writeMergeCommitMsg(null);\n+                    repo.writeMergeHeads(null);\n+                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, null);\n+                } else\n+                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n             }\n-        } finally {\n-            revWalk.release();\n         }\n     } catch (IOException e) {\n         throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n+    } finally {\n+        if (revWalk !\u003d null)\n+            revWalk.release();\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException]",
            "newValue": "[NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Added merge strategy RESOLVE\n\nThis adds the first merge strategy to JGit which does real\ncontent-merges if necessary. The new merge strategy \"resolve\" takes as\ninput three commits: a common base, ours and theirs. It will simply takeover\nchanges on files which are only touched in ours or theirs. For files\ntouched in ours and theirs it will try to merge the two contents\nknowing taking into account the specified common base.\n\nRename detection has not been introduced for now.\n\nChange-Id: I49a5ebcdcf4f540f606092c0f1dc66c965dc66ba\nSigned-off-by: Christian Halstrick \u003cchristian.halstrick@sap.com\u003e\nSigned-off-by: Stefan Lay \u003cstefan.lay@sap.com\u003e\n",
          "commitDate": "2010/8/31 上午7:21",
          "commitName": "45e79a526c7ffebaf8e4758a6cb6b7af05716707",
          "commitAuthor": "Christian Halstrick",
          "commitDateOld": "2010/8/23 下午4:20",
          "commitNameOld": "5fc990130bbd3cf3a0d505c0e12132ec0ecd6b75",
          "commitAuthorOld": "Christian Halstrick",
          "daysBetweenCommits": 7.63,
          "commitsBetweenForRepo": 41,
          "commitsBetweenForFile": 1,
          "actualSource": "public MergeResult call() throws NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    if (commits.size() !\u003d 1)\n        throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads, mergeStrategy.getName(), Integer.valueOf(commits.size())));\n    RevWalk revWalk \u003d null;\n    try {\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n        revWalk \u003d new RevWalk(repo);\n        RevCommit headCommit \u003d revWalk.lookupCommit(head.getObjectId());\n        Ref ref \u003d commits.get(0);\n        refLogMessage.append(ref.getName());\n        ObjectId objectId \u003d ref.getPeeledObjectId();\n        if (objectId \u003d\u003d null)\n            objectId \u003d ref.getObjectId();\n        RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            DirCacheCheckout dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            updateHead(refLogMessage, srcCommit, head.getObjectId());\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        } else {\n            repo.writeMergeCommitMsg(\"merging \" + ref.getName() + \" into \" + head.getName());\n            repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            ThreeWayMerger merger \u003d (ThreeWayMerger) mergeStrategy.newMerger(repo);\n            boolean noProblems;\n            Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003e lowLevelResults \u003d null;\n            Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIt(new FileTreeIterator(repo));\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n                lowLevelResults \u003d resolveMerger.getMergeResults();\n                failingPaths \u003d resolveMerger.getFailingPathes();\n            } else\n                noProblems \u003d merger.merge(headCommit, srcCommit);\n            if (noProblems) {\n                DirCacheCheckout dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                RevCommit newHead \u003d new Git(getRepository()).commit().call();\n                return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.MERGED, mergeStrategy, null, null);\n            } else {\n                if (failingPaths !\u003d null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, null);\n                } else\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n            }\n        }\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk !\u003d null)\n            revWalk.release();\n    }\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
          "functionStartLine": 106,
          "functionName": "call",
          "functionAnnotation": "",
          "functionDoc": "Executes the {@code Merge} command with all the options and parameters\ncollected by the setter methods (e.g. {@link #include(Ref)}) of this\nclass. Each instance of this class should only be used for one invocation\nof the command. Don\u0027t call this method twice on an instance.\n\n@return the result of the merge\n",
          "diff": "@@ -1,37 +1,67 @@\n-public MergeResult call() throws NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException {\n+public MergeResult call() throws NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n     checkCallable();\n     if (commits.size() !\u003d 1)\n-        throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads, mergeStrategy.getName(), commits.size()));\n+        throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads, mergeStrategy.getName(), Integer.valueOf(commits.size())));\n+    RevWalk revWalk \u003d null;\n     try {\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n-        RevWalk revWalk \u003d new RevWalk(repo);\n-        try {\n-            RevCommit headCommit \u003d revWalk.lookupCommit(head.getObjectId());\n-            Ref ref \u003d commits.get(0);\n-            refLogMessage.append(ref.getName());\n-            ObjectId objectId \u003d ref.getPeeledObjectId();\n-            if (objectId \u003d\u003d null)\n-                objectId \u003d ref.getObjectId();\n-            RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n-            if (revWalk.isMergedInto(srcCommit, headCommit)) {\n-                setCallable(false);\n-                return new MergeResult(headCommit, srcCommit, new ObjectId[] { srcCommit, headCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy);\n-            } else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n-                refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n-                checkoutNewHead(revWalk, headCommit, srcCommit);\n-                updateHead(refLogMessage, srcCommit, head.getObjectId());\n-                setCallable(false);\n-                return new MergeResult(srcCommit, headCommit, new ObjectId[] { srcCommit, headCommit }, MergeStatus.FAST_FORWARD, mergeStrategy);\n+        revWalk \u003d new RevWalk(repo);\n+        RevCommit headCommit \u003d revWalk.lookupCommit(head.getObjectId());\n+        Ref ref \u003d commits.get(0);\n+        refLogMessage.append(ref.getName());\n+        ObjectId objectId \u003d ref.getPeeledObjectId();\n+        if (objectId \u003d\u003d null)\n+            objectId \u003d ref.getObjectId();\n+        RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n+        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n+            setCallable(false);\n+            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n+        } else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n+            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n+            DirCacheCheckout dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n+            dco.setFailOnConflict(true);\n+            dco.checkout();\n+            updateHead(refLogMessage, srcCommit, head.getObjectId());\n+            setCallable(false);\n+            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n+        } else {\n+            repo.writeMergeCommitMsg(\"merging \" + ref.getName() + \" into \" + head.getName());\n+            repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n+            ThreeWayMerger merger \u003d (ThreeWayMerger) mergeStrategy.newMerger(repo);\n+            boolean noProblems;\n+            Map\u003cString, org.eclipse.jgit.merge.MergeResult\u003e lowLevelResults \u003d null;\n+            Map\u003cString, MergeFailureReason\u003e failingPaths \u003d null;\n+            if (merger instanceof ResolveMerger) {\n+                ResolveMerger resolveMerger \u003d (ResolveMerger) merger;\n+                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n+                resolveMerger.setWorkingTreeIt(new FileTreeIterator(repo));\n+                noProblems \u003d merger.merge(headCommit, srcCommit);\n+                lowLevelResults \u003d resolveMerger.getMergeResults();\n+                failingPaths \u003d resolveMerger.getFailingPathes();\n+            } else\n+                noProblems \u003d merger.merge(headCommit, srcCommit);\n+            if (noProblems) {\n+                DirCacheCheckout dco \u003d new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n+                dco.setFailOnConflict(true);\n+                dco.checkout();\n+                RevCommit newHead \u003d new Git(getRepository()).commit().call();\n+                return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.MERGED, mergeStrategy, null, null);\n             } else {\n-                return new MergeResult(headCommit, null, new ObjectId[] { srcCommit, headCommit }, MergeResult.MergeStatus.NOT_SUPPORTED, mergeStrategy, JGitText.get().onlyAlreadyUpToDateAndFastForwardMergesAreAvailable);\n+                if (failingPaths !\u003d null) {\n+                    repo.writeMergeCommitMsg(null);\n+                    repo.writeMergeHeads(null);\n+                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, null);\n+                } else\n+                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n             }\n-        } finally {\n-            revWalk.release();\n         }\n     } catch (IOException e) {\n         throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n+    } finally {\n+        if (revWalk !\u003d null)\n+            revWalk.release();\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "5fc990130bbd3cf3a0d505c0e12132ec0ecd6b75": {
      "type": "Ybodychange",
      "commitMessage": "Improved creation of JGitInternalException\n\nThere where 3 cases where a JGitInternalExcption was created\nwithout specifying the root cause. This has been fixed.\n\nChange-Id: I2ee08d04732371cd9e30874b1437b61217770b6a\nSigned-off-by: Christian Halstrick \u003cchristian.halstrick@sap.com\u003e\n",
      "commitDate": "2010/8/23 下午4:20",
      "commitName": "5fc990130bbd3cf3a0d505c0e12132ec0ecd6b75",
      "commitAuthor": "Christian Halstrick",
      "commitDateOld": "2010/8/21 上午8:38",
      "commitNameOld": "b46b635c0389e01a55b2f9c490e5b6c54a8ce640",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 2.32,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "actualSource": "public MergeResult call() throws NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException {\n    checkCallable();\n    if (commits.size() !\u003d 1)\n        throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads, mergeStrategy.getName(), commits.size()));\n    try {\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n        RevWalk revWalk \u003d new RevWalk(repo);\n        try {\n            RevCommit headCommit \u003d revWalk.lookupCommit(head.getObjectId());\n            Ref ref \u003d commits.get(0);\n            refLogMessage.append(ref.getName());\n            ObjectId objectId \u003d ref.getPeeledObjectId();\n            if (objectId \u003d\u003d null)\n                objectId \u003d ref.getObjectId();\n            RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n            if (revWalk.isMergedInto(srcCommit, headCommit)) {\n                setCallable(false);\n                return new MergeResult(headCommit, srcCommit, new ObjectId[] { srcCommit, headCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy);\n            } else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n                refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n                checkoutNewHead(revWalk, headCommit, srcCommit);\n                updateHead(refLogMessage, srcCommit, head.getObjectId());\n                setCallable(false);\n                return new MergeResult(srcCommit, headCommit, new ObjectId[] { srcCommit, headCommit }, MergeStatus.FAST_FORWARD, mergeStrategy);\n            } else {\n                return new MergeResult(headCommit, null, new ObjectId[] { srcCommit, headCommit }, MergeResult.MergeStatus.NOT_SUPPORTED, mergeStrategy, JGitText.get().onlyAlreadyUpToDateAndFastForwardMergesAreAvailable);\n            }\n        } finally {\n            revWalk.release();\n        }\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 102,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Merge} command with all the options and parameters\ncollected by the setter methods (e.g. {@link #include(Ref)}) of this\nclass. Each instance of this class should only be used for one invocation\nof the command. Don\u0027t call this method twice on an instance.\n\n@return the result of the merge\n",
      "diff": "@@ -1,37 +1,37 @@\n public MergeResult call() throws NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException {\n     checkCallable();\n     if (commits.size() !\u003d 1)\n         throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads, mergeStrategy.getName(), commits.size()));\n     try {\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n         RevWalk revWalk \u003d new RevWalk(repo);\n         try {\n             RevCommit headCommit \u003d revWalk.lookupCommit(head.getObjectId());\n             Ref ref \u003d commits.get(0);\n             refLogMessage.append(ref.getName());\n             ObjectId objectId \u003d ref.getPeeledObjectId();\n             if (objectId \u003d\u003d null)\n                 objectId \u003d ref.getObjectId();\n             RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n             if (revWalk.isMergedInto(srcCommit, headCommit)) {\n                 setCallable(false);\n                 return new MergeResult(headCommit, srcCommit, new ObjectId[] { srcCommit, headCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy);\n             } else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n                 refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n                 checkoutNewHead(revWalk, headCommit, srcCommit);\n                 updateHead(refLogMessage, srcCommit, head.getObjectId());\n                 setCallable(false);\n                 return new MergeResult(srcCommit, headCommit, new ObjectId[] { srcCommit, headCommit }, MergeStatus.FAST_FORWARD, mergeStrategy);\n             } else {\n                 return new MergeResult(headCommit, null, new ObjectId[] { srcCommit, headCommit }, MergeResult.MergeStatus.NOT_SUPPORTED, mergeStrategy, JGitText.get().onlyAlreadyUpToDateAndFastForwardMergesAreAvailable);\n             }\n         } finally {\n             revWalk.release();\n         }\n     } catch (IOException e) {\n-        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e));\n+        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "75c9b2438594dc6ac125ff1bdf97022c7f429b78": {
      "type": "Ybodychange",
      "commitMessage": "Enhance MergeResult to report conflicts, etc\n\nThe MergeResult class is enhanced to report more data about a\nthree-way merge. Information about conflicts and the base, ours,\ntheirs commits can be retrived.\n\nChange-Id: Iaaf41a1f4002b8fe3ddfa62dc73c787f363460c2\nSigned-off-by: Christian Halstrick \u003cchristian.halstrick@sap.com\u003e\nSigned-off-by: Chris Aniszczyk \u003ccaniszczyk@gmail.com\u003e\n",
      "commitDate": "2010/8/20 上午1:16",
      "commitName": "75c9b2438594dc6ac125ff1bdf97022c7f429b78",
      "commitAuthor": "Christian Halstrick",
      "commitDateOld": "2010/6/30 上午6:12",
      "commitNameOld": "515deaf7e503738b4c53c3c2dfd6d7acab3bef18",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 50.79,
      "commitsBetweenForRepo": 131,
      "commitsBetweenForFile": 1,
      "actualSource": "public MergeResult call() throws NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException {\n    checkCallable();\n    if (commits.size() !\u003d 1)\n        throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads, mergeStrategy.getName(), commits.size()));\n    try {\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n        RevWalk revWalk \u003d new RevWalk(repo);\n        try {\n            RevCommit headCommit \u003d revWalk.lookupCommit(head.getObjectId());\n            Ref ref \u003d commits.get(0);\n            refLogMessage.append(ref.getName());\n            ObjectId objectId \u003d ref.getPeeledObjectId();\n            if (objectId \u003d\u003d null)\n                objectId \u003d ref.getObjectId();\n            RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n            if (revWalk.isMergedInto(srcCommit, headCommit)) {\n                setCallable(false);\n                return new MergeResult(headCommit, srcCommit, new ObjectId[] { srcCommit, headCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy);\n            } else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n                refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n                checkoutNewHead(revWalk, headCommit, srcCommit);\n                updateHead(refLogMessage, srcCommit, head.getObjectId());\n                setCallable(false);\n                return new MergeResult(srcCommit, headCommit, new ObjectId[] { srcCommit, headCommit }, MergeStatus.FAST_FORWARD, mergeStrategy);\n            } else {\n                return new MergeResult(headCommit, null, new ObjectId[] { srcCommit, headCommit }, MergeResult.MergeStatus.NOT_SUPPORTED, mergeStrategy, JGitText.get().onlyAlreadyUpToDateAndFastForwardMergesAreAvailable);\n            }\n        } finally {\n            revWalk.release();\n        }\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e));\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 102,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Merge} command with all the options and parameters\ncollected by the setter methods (e.g. {@link #include(Ref)}) of this\nclass. Each instance of this class should only be used for one invocation\nof the command. Don\u0027t call this method twice on an instance.\n\n@return the result of the merge\n",
      "diff": "@@ -1,37 +1,37 @@\n public MergeResult call() throws NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException {\n     checkCallable();\n     if (commits.size() !\u003d 1)\n         throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads, mergeStrategy.getName(), commits.size()));\n     try {\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n         RevWalk revWalk \u003d new RevWalk(repo);\n         try {\n             RevCommit headCommit \u003d revWalk.lookupCommit(head.getObjectId());\n             Ref ref \u003d commits.get(0);\n             refLogMessage.append(ref.getName());\n             ObjectId objectId \u003d ref.getPeeledObjectId();\n             if (objectId \u003d\u003d null)\n                 objectId \u003d ref.getObjectId();\n             RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n             if (revWalk.isMergedInto(srcCommit, headCommit)) {\n                 setCallable(false);\n-                return new MergeResult(headCommit, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy);\n+                return new MergeResult(headCommit, srcCommit, new ObjectId[] { srcCommit, headCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy);\n             } else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n                 refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n                 checkoutNewHead(revWalk, headCommit, srcCommit);\n                 updateHead(refLogMessage, srcCommit, head.getObjectId());\n                 setCallable(false);\n-                return new MergeResult(srcCommit, MergeStatus.FAST_FORWARD, mergeStrategy);\n+                return new MergeResult(srcCommit, headCommit, new ObjectId[] { srcCommit, headCommit }, MergeStatus.FAST_FORWARD, mergeStrategy);\n             } else {\n-                return new MergeResult(headCommit, MergeResult.MergeStatus.NOT_SUPPORTED, mergeStrategy, JGitText.get().onlyAlreadyUpToDateAndFastForwardMergesAreAvailable);\n+                return new MergeResult(headCommit, null, new ObjectId[] { srcCommit, headCommit }, MergeResult.MergeStatus.NOT_SUPPORTED, mergeStrategy, JGitText.get().onlyAlreadyUpToDateAndFastForwardMergesAreAvailable);\n             }\n         } finally {\n             revWalk.release();\n         }\n     } catch (IOException e) {\n         throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e));\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "515deaf7e503738b4c53c3c2dfd6d7acab3bef18": {
      "type": "Ybodychange",
      "commitMessage": "Ensure RevWalk is released when done\n\nUpdate a number of calling sites of RevWalk to ensure the walker\u0027s\ninternal ObjectReader is released after the walk is no longer used.\nBecause the ObjectReader is likely to hold onto a native resource\nlike an Inflater, we don\u0027t want to leak them outside of their\nuseful scope.\n\nWhere possible we also try to share ObjectReaders across several\nwalk pools, or between a walker and a PackWriter.  This permits\nthe ObjectReader to actually do some caching if it felt inclined\nto do so.\n\nNot everything was updated, we\u0027ll probably need to come back and\nupdate even more call sites, but these are some of the biggest\noffenders.  Test cases in particular aren\u0027t updated.  My plan is to\nmove most storage-agnostic tests onto some purely in-memory storage\nsolution that doesn\u0027t do compression.\n\nChange-Id: I04087ec79faeea208b19848939898ad7172b6672\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010/6/30 上午6:12",
      "commitName": "515deaf7e503738b4c53c3c2dfd6d7acab3bef18",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2010/6/26 上午9:03",
      "commitNameOld": "203bd6626767015dfb04d421c572b26a34e9cecf",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 3.88,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "actualSource": "public MergeResult call() throws NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException {\n    checkCallable();\n    if (commits.size() !\u003d 1)\n        throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads, mergeStrategy.getName(), commits.size()));\n    try {\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n        RevWalk revWalk \u003d new RevWalk(repo);\n        try {\n            RevCommit headCommit \u003d revWalk.lookupCommit(head.getObjectId());\n            Ref ref \u003d commits.get(0);\n            refLogMessage.append(ref.getName());\n            ObjectId objectId \u003d ref.getPeeledObjectId();\n            if (objectId \u003d\u003d null)\n                objectId \u003d ref.getObjectId();\n            RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n            if (revWalk.isMergedInto(srcCommit, headCommit)) {\n                setCallable(false);\n                return new MergeResult(headCommit, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy);\n            } else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n                refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n                checkoutNewHead(revWalk, headCommit, srcCommit);\n                updateHead(refLogMessage, srcCommit, head.getObjectId());\n                setCallable(false);\n                return new MergeResult(srcCommit, MergeStatus.FAST_FORWARD, mergeStrategy);\n            } else {\n                return new MergeResult(headCommit, MergeResult.MergeStatus.NOT_SUPPORTED, mergeStrategy, JGitText.get().onlyAlreadyUpToDateAndFastForwardMergesAreAvailable);\n            }\n        } finally {\n            revWalk.release();\n        }\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e));\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 102,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Merge} command with all the options and parameters\ncollected by the setter methods (e.g. {@link #include(Ref)}) of this\nclass. Each instance of this class should only be used for one invocation\nof the command. Don\u0027t call this method twice on an instance.\n\n@return the result of the merge\n",
      "diff": "@@ -1,33 +1,37 @@\n public MergeResult call() throws NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException {\n     checkCallable();\n     if (commits.size() !\u003d 1)\n         throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads, mergeStrategy.getName(), commits.size()));\n     try {\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n         RevWalk revWalk \u003d new RevWalk(repo);\n-        RevCommit headCommit \u003d revWalk.lookupCommit(head.getObjectId());\n-        Ref ref \u003d commits.get(0);\n-        refLogMessage.append(ref.getName());\n-        ObjectId objectId \u003d ref.getPeeledObjectId();\n-        if (objectId \u003d\u003d null)\n-            objectId \u003d ref.getObjectId();\n-        RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n-        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n-            setCallable(false);\n-            return new MergeResult(headCommit, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy);\n-        } else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n-            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n-            checkoutNewHead(revWalk, headCommit, srcCommit);\n-            updateHead(refLogMessage, srcCommit, head.getObjectId());\n-            setCallable(false);\n-            return new MergeResult(srcCommit, MergeStatus.FAST_FORWARD, mergeStrategy);\n-        } else {\n-            return new MergeResult(headCommit, MergeResult.MergeStatus.NOT_SUPPORTED, mergeStrategy, JGitText.get().onlyAlreadyUpToDateAndFastForwardMergesAreAvailable);\n+        try {\n+            RevCommit headCommit \u003d revWalk.lookupCommit(head.getObjectId());\n+            Ref ref \u003d commits.get(0);\n+            refLogMessage.append(ref.getName());\n+            ObjectId objectId \u003d ref.getPeeledObjectId();\n+            if (objectId \u003d\u003d null)\n+                objectId \u003d ref.getObjectId();\n+            RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n+            if (revWalk.isMergedInto(srcCommit, headCommit)) {\n+                setCallable(false);\n+                return new MergeResult(headCommit, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy);\n+            } else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n+                refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n+                checkoutNewHead(revWalk, headCommit, srcCommit);\n+                updateHead(refLogMessage, srcCommit, head.getObjectId());\n+                setCallable(false);\n+                return new MergeResult(srcCommit, MergeStatus.FAST_FORWARD, mergeStrategy);\n+            } else {\n+                return new MergeResult(headCommit, MergeResult.MergeStatus.NOT_SUPPORTED, mergeStrategy, JGitText.get().onlyAlreadyUpToDateAndFastForwardMergesAreAvailable);\n+            }\n+        } finally {\n+            revWalk.release();\n         }\n     } catch (IOException e) {\n         throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e));\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5b0e73b849d19c9f072c4c6738a5d5adae413112": {
      "type": "Yintroduced",
      "commitMessage": "Add a merge command to the jgit API\n\nMerges the current head with one other commit.\nIn this first iteration the merge command supports\nonly fast forward and already up-to-date.\n\nChange-Id: I0db480f061e01b343570cf7da02cac13a0cbdf8f\nSigned-off-by: Stefan Lay \u003cstefan.lay@sap.com\u003e\nSigned-off-by: Christian Halstrick \u003cchristian.halstrick@sap.com\u003e\nSigned-off-by: Chris Aniszczyk \u003ccaniszczyk@gmail.com\u003e\n",
      "commitDate": "2010/5/24 下午10:52",
      "commitName": "5b0e73b849d19c9f072c4c6738a5d5adae413112",
      "commitAuthor": "Stefan Lay",
      "diff": "@@ -0,0 +1,33 @@\n+public MergeResult call() throws NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException {\n+    checkCallable();\n+    if (commits.size() !\u003d 1)\n+        throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads, mergeStrategy.getName(), commits.size()));\n+    try {\n+        Ref head \u003d repo.getRef(Constants.HEAD);\n+        if (head \u003d\u003d null)\n+            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n+        StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n+        RevWalk revWalk \u003d new RevWalk(repo);\n+        RevCommit headCommit \u003d revWalk.lookupCommit(head.getObjectId());\n+        Ref ref \u003d commits.get(0);\n+        refLogMessage.append(ref.getName());\n+        ObjectId objectId \u003d ref.getPeeledObjectId();\n+        if (objectId \u003d\u003d null)\n+            objectId \u003d ref.getObjectId();\n+        RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n+        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n+            setCallable(false);\n+            return new MergeResult(headCommit, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy);\n+        } else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n+            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n+            checkoutNewHead(revWalk, headCommit, srcCommit);\n+            updateHead(refLogMessage, srcCommit, head.getObjectId());\n+            setCallable(false);\n+            return new MergeResult(srcCommit, MergeStatus.FAST_FORWARD, mergeStrategy);\n+        } else {\n+            return new MergeResult(headCommit, MergeResult.MergeStatus.NOT_SUPPORTED, mergeStrategy, JGitText.get().onlyAlreadyUpToDateAndFastForwardMergesAreAvailable);\n+        }\n+    } catch (IOException e) {\n+        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e));\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "public MergeResult call() throws NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException {\n    checkCallable();\n    if (commits.size() !\u003d 1)\n        throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads, mergeStrategy.getName(), commits.size()));\n    try {\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage \u003d new StringBuilder(\"merge \");\n        RevWalk revWalk \u003d new RevWalk(repo);\n        RevCommit headCommit \u003d revWalk.lookupCommit(head.getObjectId());\n        Ref ref \u003d commits.get(0);\n        refLogMessage.append(ref.getName());\n        ObjectId objectId \u003d ref.getPeeledObjectId();\n        if (objectId \u003d\u003d null)\n            objectId \u003d ref.getObjectId();\n        RevCommit srcCommit \u003d revWalk.lookupCommit(objectId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            checkoutNewHead(revWalk, headCommit, srcCommit);\n            updateHead(refLogMessage, srcCommit, head.getObjectId());\n            setCallable(false);\n            return new MergeResult(srcCommit, MergeStatus.FAST_FORWARD, mergeStrategy);\n        } else {\n            return new MergeResult(headCommit, MergeResult.MergeStatus.NOT_SUPPORTED, mergeStrategy, JGitText.get().onlyAlreadyUpToDateAndFastForwardMergesAreAvailable);\n        }\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e));\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/MergeCommand.java",
      "functionStartLine": 102,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Merge} command with all the options and parameters\ncollected by the setter methods (e.g. {@link #include(Ref)}) of this\nclass. Each instance of this class should only be used for one invocation\nof the command. Don\u0027t call this method twice on an instance.\n\n@return the result of the merge\n"
    }
  }
}