{
  "origin": "codeshovel",
  "repositoryName": "okhttp",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/okhttp/.git",
  "startCommitName": "5224f3045ba9b171fce521777edf389f9206173c",
  "sourceFileName": "OkHttpURLConnection.java",
  "functionName": "getResponse",
  "functionId": "getResponse___networkResponseOnError-boolean",
  "sourceFilePath": "okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java",
  "functionAnnotation": "",
  "functionDoc": "Aggressively tries to get the final HTTP response, potentially making many HTTP requests in the\nprocess in order to cope with redirects and authentication.\n",
  "functionStartLine": 443,
  "functionEndLine": 484,
  "numCommitsSeen": 145,
  "timeTaken": 2134,
  "changeHistory": [
    "aac684aeae32ff18e443799a3ccff6de9d68a684",
    "2b8ad31b084af93ad202a1b835e5be63ac58a269",
    "2843933b4b4778451d1d43822db1a148bf2aa7ea",
    "ec39c462324c0a54e6abf06cbf8079298056b7d5",
    "084b06b48bae2b566bb1be3415b6c847d8ea3682",
    "98ae0fb92c9335ec17f8710376183e18f5edd355",
    "c9a89876de476983f273edbf108c365127c18c5e",
    "93d547dcdaecddfa456aee0571131db2342e5abb",
    "c358656c8799d30fd422448153e99a5dd37e298a",
    "4c90a2e04a83646597a506a80b5a885d5c515bf0",
    "e49dd7a2f08deac92fab3de2b8a63e90b588f746",
    "ed70981925e64fd0cb593d09bdd401ea4ea19848",
    "0676d8b1733589a869098b9980118644b3bade4f",
    "ee2ed56c9ad4563f5713ff0f572a5454af16901d",
    "b7542587b8e90aa4472d4d9e4b74a72ca0c42cb4",
    "9146c579dd9110d0028144c59515da9be1ce7108",
    "996e9c95bdcafd62e84c79c512d6ccac65c30758",
    "84184afdb26b42ff615896f9c0161157cc84ec73",
    "dac5aed3d5f9307b9d1ab0a8c7840b232d053ef3",
    "4831a8dc6577f762e0f21fd15dd9700fe824740d",
    "350c43b6fe02401a73f967d9ef322061638b372a",
    "37c01895cca5ec2bec26a3d381611f0938acd6d0",
    "a948ffce1eb2b9ec46069722f6744f252d6dbfc7",
    "7ccbf48838b7cfe42759c67790636d442ea5daa3",
    "7e7a3896df109ef442af9ec69423c33ec667c9f5",
    "6f6d959fdae64065521990413f86bc7ab038d7c1",
    "637783ce8ae3ffb9805c2f78b436703c29b2220a",
    "194290e5f3819bf91d87c5d08c152946b6aa3509",
    "689f66222bd8984dd69229a4ee9caf8da528ae12",
    "67604f618d96ae00318ce696ec29a66bec6aafa8",
    "50999cceb5f5bcdaf79baa5ac7eeef90c72bda8d",
    "3355d0c99bb946a6441f08fe6fd1c9881a9ea96a",
    "ea63463c2ff8a67f63e541036f0d5998b5bb1f3e"
  ],
  "changeHistoryShort": {
    "aac684aeae32ff18e443799a3ccff6de9d68a684": "Ybodychange",
    "2b8ad31b084af93ad202a1b835e5be63ac58a269": "Ymultichange(Yparameterchange,Ybodychange)",
    "2843933b4b4778451d1d43822db1a148bf2aa7ea": "Ybodychange",
    "ec39c462324c0a54e6abf06cbf8079298056b7d5": "Yfilerename",
    "084b06b48bae2b566bb1be3415b6c847d8ea3682": "Ymultichange(Yreturntypechange,Ybodychange)",
    "98ae0fb92c9335ec17f8710376183e18f5edd355": "Ydocchange",
    "c9a89876de476983f273edbf108c365127c18c5e": "Ymovefromfile",
    "93d547dcdaecddfa456aee0571131db2342e5abb": "Ybodychange",
    "c358656c8799d30fd422448153e99a5dd37e298a": "Ybodychange",
    "4c90a2e04a83646597a506a80b5a885d5c515bf0": "Ybodychange",
    "e49dd7a2f08deac92fab3de2b8a63e90b588f746": "Ybodychange",
    "ed70981925e64fd0cb593d09bdd401ea4ea19848": "Ybodychange",
    "0676d8b1733589a869098b9980118644b3bade4f": "Yfilerename",
    "ee2ed56c9ad4563f5713ff0f572a5454af16901d": "Ybodychange",
    "b7542587b8e90aa4472d4d9e4b74a72ca0c42cb4": "Ybodychange",
    "9146c579dd9110d0028144c59515da9be1ce7108": "Ybodychange",
    "996e9c95bdcafd62e84c79c512d6ccac65c30758": "Yfilerename",
    "84184afdb26b42ff615896f9c0161157cc84ec73": "Ybodychange",
    "dac5aed3d5f9307b9d1ab0a8c7840b232d053ef3": "Ybodychange",
    "4831a8dc6577f762e0f21fd15dd9700fe824740d": "Ybodychange",
    "350c43b6fe02401a73f967d9ef322061638b372a": "Ybodychange",
    "37c01895cca5ec2bec26a3d381611f0938acd6d0": "Ybodychange",
    "a948ffce1eb2b9ec46069722f6744f252d6dbfc7": "Ybodychange",
    "7ccbf48838b7cfe42759c67790636d442ea5daa3": "Yfilerename",
    "7e7a3896df109ef442af9ec69423c33ec667c9f5": "Ybodychange",
    "6f6d959fdae64065521990413f86bc7ab038d7c1": "Ybodychange",
    "637783ce8ae3ffb9805c2f78b436703c29b2220a": "Ybodychange",
    "194290e5f3819bf91d87c5d08c152946b6aa3509": "Ybodychange",
    "689f66222bd8984dd69229a4ee9caf8da528ae12": "Yfilerename",
    "67604f618d96ae00318ce696ec29a66bec6aafa8": "Ybodychange",
    "50999cceb5f5bcdaf79baa5ac7eeef90c72bda8d": "Yfilerename",
    "3355d0c99bb946a6441f08fe6fd1c9881a9ea96a": "Ybodychange",
    "ea63463c2ff8a67f63e541036f0d5998b5bb1f3e": "Yintroduced"
  },
  "changeHistoryDetails": {
    "aac684aeae32ff18e443799a3ccff6de9d68a684": {
      "type": "Ybodychange",
      "commitMessage": "Retain interrupted state when throwing InterruptedIOException\n\nThe drawbacks seem small; the callsite needs to handle interruption anyway\nbecause the thread is prone to interruption.\n\nAnd the upside is that a single interrupt should now be sufficient to break\nout an in-flight OkHttp call.\n\nNote that although we\u0027re fixing this, thread interruption is not well tested\nin OkHttp. Most users should prefer Call.cancel(), which is well tested and\ndoesn\u0027t rely on the caller to know which threads OkHttp is using to make\nthe actual HTTP request.\n\nCloses: https://github.com/square/okhttp/issues/3945\n",
      "commitDate": "2018/7/6 上午10:37",
      "commitName": "aac684aeae32ff18e443799a3ccff6de9d68a684",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "2018/2/18 下午7:57",
      "commitNameOld": "2db8c41b3b0f0476c0e8735f4d57562d50f32ffa",
      "commitAuthorOld": "Eric Cochran",
      "daysBetweenCommits": 137.61,
      "commitsBetweenForRepo": 65,
      "commitsBetweenForFile": 1,
      "actualSource": "private Response getResponse(boolean networkResponseOnError) throws IOException {\n    synchronized (lock) {\n        if (response !\u003d null)\n            return response;\n        if (callFailure !\u003d null) {\n            if (networkResponseOnError \u0026\u0026 networkResponse !\u003d null)\n                return networkResponse;\n            throw propagate(callFailure);\n        }\n    }\n    Call call \u003d buildCall();\n    networkInterceptor.proceed();\n    OutputStreamRequestBody requestBody \u003d (OutputStreamRequestBody) call.request().body();\n    if (requestBody !\u003d null)\n        requestBody.outputStream().close();\n    if (executed) {\n        synchronized (lock) {\n            try {\n                while (response \u003d\u003d null \u0026\u0026 callFailure \u003d\u003d null) {\n                    lock.wait();\n                }\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                throw new InterruptedIOException();\n            }\n        }\n    } else {\n        executed \u003d true;\n        try {\n            onResponse(call, call.execute());\n        } catch (IOException e) {\n            onFailure(call, e);\n        }\n    }\n    synchronized (lock) {\n        if (callFailure !\u003d null)\n            throw propagate(callFailure);\n        if (response !\u003d null)\n            return response;\n    }\n    throw new AssertionError();\n}",
      "path": "okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java",
      "functionStartLine": 427,
      "functionName": "getResponse",
      "functionAnnotation": "",
      "functionDoc": "Aggressively tries to get the final HTTP response, potentially making many HTTP requests in the\nprocess in order to cope with redirects and authentication.\n",
      "diff": "@@ -1,41 +1,42 @@\n private Response getResponse(boolean networkResponseOnError) throws IOException {\n     synchronized (lock) {\n         if (response !\u003d null)\n             return response;\n         if (callFailure !\u003d null) {\n             if (networkResponseOnError \u0026\u0026 networkResponse !\u003d null)\n                 return networkResponse;\n             throw propagate(callFailure);\n         }\n     }\n     Call call \u003d buildCall();\n     networkInterceptor.proceed();\n     OutputStreamRequestBody requestBody \u003d (OutputStreamRequestBody) call.request().body();\n     if (requestBody !\u003d null)\n         requestBody.outputStream().close();\n     if (executed) {\n         synchronized (lock) {\n             try {\n                 while (response \u003d\u003d null \u0026\u0026 callFailure \u003d\u003d null) {\n                     lock.wait();\n                 }\n             } catch (InterruptedException e) {\n+                Thread.currentThread().interrupt();\n                 throw new InterruptedIOException();\n             }\n         }\n     } else {\n         executed \u003d true;\n         try {\n             onResponse(call, call.execute());\n         } catch (IOException e) {\n             onFailure(call, e);\n         }\n     }\n     synchronized (lock) {\n         if (callFailure !\u003d null)\n             throw propagate(callFailure);\n         if (response !\u003d null)\n             return response;\n     }\n     throw new AssertionError();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2b8ad31b084af93ad202a1b835e5be63ac58a269": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Fix flakiness in authenticateWithChunkedStreaming().\n\nWe were prefering to return the networkResponse before the request\nhad completely failed. Instead we should return the network response\nonly on failure, and only for APIs that return failed responses.\n",
      "commitDate": "2016/11/22 上午10:58",
      "commitName": "2b8ad31b084af93ad202a1b835e5be63ac58a269",
      "commitAuthor": "jwilson",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Fix flakiness in authenticateWithChunkedStreaming().\n\nWe were prefering to return the networkResponse before the request\nhad completely failed. Instead we should return the network response\nonly on failure, and only for APIs that return failed responses.\n",
          "commitDate": "2016/11/22 上午10:58",
          "commitName": "2b8ad31b084af93ad202a1b835e5be63ac58a269",
          "commitAuthor": "jwilson",
          "commitDateOld": "2016/7/25 上午7:07",
          "commitNameOld": "591d59556153555c9f5b56bf601780a817defc09",
          "commitAuthorOld": "jwilson",
          "daysBetweenCommits": 120.16,
          "commitsBetweenForRepo": 68,
          "commitsBetweenForFile": 1,
          "actualSource": "private Response getResponse(boolean networkResponseOnError) throws IOException {\n    synchronized (lock) {\n        if (response !\u003d null)\n            return response;\n        if (callFailure !\u003d null) {\n            if (networkResponseOnError \u0026\u0026 networkResponse !\u003d null)\n                return networkResponse;\n            throw propagate(callFailure);\n        }\n    }\n    Call call \u003d buildCall();\n    networkInterceptor.proceed();\n    OutputStreamRequestBody requestBody \u003d (OutputStreamRequestBody) call.request().body();\n    if (requestBody !\u003d null)\n        requestBody.outputStream().close();\n    if (executed) {\n        synchronized (lock) {\n            try {\n                while (response \u003d\u003d null \u0026\u0026 callFailure \u003d\u003d null) {\n                    lock.wait();\n                }\n            } catch (InterruptedException e) {\n                throw new InterruptedIOException();\n            }\n        }\n    } else {\n        executed \u003d true;\n        try {\n            onResponse(call, call.execute());\n        } catch (IOException e) {\n            onFailure(call, e);\n        }\n    }\n    synchronized (lock) {\n        if (callFailure !\u003d null)\n            throw propagate(callFailure);\n        if (response !\u003d null)\n            return response;\n    }\n    throw new AssertionError();\n}",
          "path": "okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java",
          "functionStartLine": 408,
          "functionName": "getResponse",
          "functionAnnotation": "",
          "functionDoc": "Aggressively tries to get the final HTTP response, potentially making many HTTP requests in the\nprocess in order to cope with redirects and authentication.\n",
          "diff": "@@ -1,39 +1,41 @@\n-private Response getResponse() throws IOException {\n-    if (response !\u003d null) {\n-        return response;\n-    } else if (networkResponse !\u003d null) {\n-        return networkResponse;\n-    } else if (callFailure !\u003d null) {\n-        throw propagate(callFailure);\n+private Response getResponse(boolean networkResponseOnError) throws IOException {\n+    synchronized (lock) {\n+        if (response !\u003d null)\n+            return response;\n+        if (callFailure !\u003d null) {\n+            if (networkResponseOnError \u0026\u0026 networkResponse !\u003d null)\n+                return networkResponse;\n+            throw propagate(callFailure);\n+        }\n     }\n     Call call \u003d buildCall();\n     networkInterceptor.proceed();\n     OutputStreamRequestBody requestBody \u003d (OutputStreamRequestBody) call.request().body();\n     if (requestBody !\u003d null)\n         requestBody.outputStream().close();\n     if (executed) {\n         synchronized (lock) {\n             try {\n                 while (response \u003d\u003d null \u0026\u0026 callFailure \u003d\u003d null) {\n                     lock.wait();\n                 }\n             } catch (InterruptedException e) {\n                 throw new InterruptedIOException();\n             }\n         }\n     } else {\n         executed \u003d true;\n         try {\n             onResponse(call, call.execute());\n         } catch (IOException e) {\n             onFailure(call, e);\n         }\n     }\n     synchronized (lock) {\n         if (callFailure !\u003d null)\n             throw propagate(callFailure);\n         if (response !\u003d null)\n             return response;\n     }\n     throw new AssertionError();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[networkResponseOnError-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Fix flakiness in authenticateWithChunkedStreaming().\n\nWe were prefering to return the networkResponse before the request\nhad completely failed. Instead we should return the network response\nonly on failure, and only for APIs that return failed responses.\n",
          "commitDate": "2016/11/22 上午10:58",
          "commitName": "2b8ad31b084af93ad202a1b835e5be63ac58a269",
          "commitAuthor": "jwilson",
          "commitDateOld": "2016/7/25 上午7:07",
          "commitNameOld": "591d59556153555c9f5b56bf601780a817defc09",
          "commitAuthorOld": "jwilson",
          "daysBetweenCommits": 120.16,
          "commitsBetweenForRepo": 68,
          "commitsBetweenForFile": 1,
          "actualSource": "private Response getResponse(boolean networkResponseOnError) throws IOException {\n    synchronized (lock) {\n        if (response !\u003d null)\n            return response;\n        if (callFailure !\u003d null) {\n            if (networkResponseOnError \u0026\u0026 networkResponse !\u003d null)\n                return networkResponse;\n            throw propagate(callFailure);\n        }\n    }\n    Call call \u003d buildCall();\n    networkInterceptor.proceed();\n    OutputStreamRequestBody requestBody \u003d (OutputStreamRequestBody) call.request().body();\n    if (requestBody !\u003d null)\n        requestBody.outputStream().close();\n    if (executed) {\n        synchronized (lock) {\n            try {\n                while (response \u003d\u003d null \u0026\u0026 callFailure \u003d\u003d null) {\n                    lock.wait();\n                }\n            } catch (InterruptedException e) {\n                throw new InterruptedIOException();\n            }\n        }\n    } else {\n        executed \u003d true;\n        try {\n            onResponse(call, call.execute());\n        } catch (IOException e) {\n            onFailure(call, e);\n        }\n    }\n    synchronized (lock) {\n        if (callFailure !\u003d null)\n            throw propagate(callFailure);\n        if (response !\u003d null)\n            return response;\n    }\n    throw new AssertionError();\n}",
          "path": "okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java",
          "functionStartLine": 408,
          "functionName": "getResponse",
          "functionAnnotation": "",
          "functionDoc": "Aggressively tries to get the final HTTP response, potentially making many HTTP requests in the\nprocess in order to cope with redirects and authentication.\n",
          "diff": "@@ -1,39 +1,41 @@\n-private Response getResponse() throws IOException {\n-    if (response !\u003d null) {\n-        return response;\n-    } else if (networkResponse !\u003d null) {\n-        return networkResponse;\n-    } else if (callFailure !\u003d null) {\n-        throw propagate(callFailure);\n+private Response getResponse(boolean networkResponseOnError) throws IOException {\n+    synchronized (lock) {\n+        if (response !\u003d null)\n+            return response;\n+        if (callFailure !\u003d null) {\n+            if (networkResponseOnError \u0026\u0026 networkResponse !\u003d null)\n+                return networkResponse;\n+            throw propagate(callFailure);\n+        }\n     }\n     Call call \u003d buildCall();\n     networkInterceptor.proceed();\n     OutputStreamRequestBody requestBody \u003d (OutputStreamRequestBody) call.request().body();\n     if (requestBody !\u003d null)\n         requestBody.outputStream().close();\n     if (executed) {\n         synchronized (lock) {\n             try {\n                 while (response \u003d\u003d null \u0026\u0026 callFailure \u003d\u003d null) {\n                     lock.wait();\n                 }\n             } catch (InterruptedException e) {\n                 throw new InterruptedIOException();\n             }\n         }\n     } else {\n         executed \u003d true;\n         try {\n             onResponse(call, call.execute());\n         } catch (IOException e) {\n             onFailure(call, e);\n         }\n     }\n     synchronized (lock) {\n         if (callFailure !\u003d null)\n             throw propagate(callFailure);\n         if (response !\u003d null)\n             return response;\n     }\n     throw new AssertionError();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "2843933b4b4778451d1d43822db1a148bf2aa7ea": {
      "type": "Ybodychange",
      "commitMessage": "Fix OkHttpURLConnection to not swallow unexpected exceptions.\n\nPreviously we would sometimes delegate to the asynchronous implementation,\nand that would prevent exceptions from reaching their destination.\n",
      "commitDate": "2016/6/26 上午6:04",
      "commitName": "2843933b4b4778451d1d43822db1a148bf2aa7ea",
      "commitAuthor": "jwilson",
      "commitDateOld": "2016/6/26 上午3:46",
      "commitNameOld": "ec39c462324c0a54e6abf06cbf8079298056b7d5",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "private Response getResponse() throws IOException {\n    if (response !\u003d null) {\n        return response;\n    } else if (networkResponse !\u003d null) {\n        return networkResponse;\n    } else if (callFailure !\u003d null) {\n        throw propagate(callFailure);\n    }\n    Call call \u003d buildCall();\n    networkInterceptor.proceed();\n    OutputStreamRequestBody requestBody \u003d (OutputStreamRequestBody) call.request().body();\n    if (requestBody !\u003d null)\n        requestBody.outputStream().close();\n    if (executed) {\n        synchronized (lock) {\n            try {\n                while (response \u003d\u003d null \u0026\u0026 callFailure \u003d\u003d null) {\n                    lock.wait();\n                }\n            } catch (InterruptedException e) {\n                throw new InterruptedIOException();\n            }\n        }\n    } else {\n        executed \u003d true;\n        try {\n            onResponse(call, call.execute());\n        } catch (IOException e) {\n            onFailure(call, e);\n        }\n    }\n    synchronized (lock) {\n        if (callFailure !\u003d null)\n            throw propagate(callFailure);\n        if (response !\u003d null)\n            return response;\n    }\n    throw new AssertionError();\n}",
      "path": "okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java",
      "functionStartLine": 406,
      "functionName": "getResponse",
      "functionAnnotation": "",
      "functionDoc": "Aggressively tries to get the final HTTP response, potentially making many HTTP requests in the\nprocess in order to cope with redirects and authentication.\n",
      "diff": "@@ -1,39 +1,39 @@\n private Response getResponse() throws IOException {\n     if (response !\u003d null) {\n         return response;\n     } else if (networkResponse !\u003d null) {\n         return networkResponse;\n     } else if (callFailure !\u003d null) {\n-        throw callFailure;\n+        throw propagate(callFailure);\n     }\n     Call call \u003d buildCall();\n     networkInterceptor.proceed();\n     OutputStreamRequestBody requestBody \u003d (OutputStreamRequestBody) call.request().body();\n     if (requestBody !\u003d null)\n         requestBody.outputStream().close();\n     if (executed) {\n         synchronized (lock) {\n             try {\n                 while (response \u003d\u003d null \u0026\u0026 callFailure \u003d\u003d null) {\n                     lock.wait();\n                 }\n             } catch (InterruptedException e) {\n                 throw new InterruptedIOException();\n             }\n         }\n     } else {\n         executed \u003d true;\n         try {\n             onResponse(call, call.execute());\n         } catch (IOException e) {\n             onFailure(call, e);\n         }\n     }\n     synchronized (lock) {\n         if (callFailure !\u003d null)\n-            throw callFailure;\n+            throw propagate(callFailure);\n         if (response !\u003d null)\n             return response;\n     }\n     throw new AssertionError();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ec39c462324c0a54e6abf06cbf8079298056b7d5": {
      "type": "Yfilerename",
      "commitMessage": "Rename HttpURLConnectionImpl to OkHttpURLConnection.\n\nThis is an internal class so nobody should see the name. But having a\ncompletely different name will make it much easier to diagnose future\nstacktraces because the internal implementation has changed so much\nrecently.\n\nAlso share fewer internal details with the rest of OkHttp. In particular\nremove the OkHttp-Selected-Protocol and OkHttp-Response-Source headers\nfrom the core.\n",
      "commitDate": "2016/6/26 上午3:46",
      "commitName": "ec39c462324c0a54e6abf06cbf8079298056b7d5",
      "commitAuthor": "jwilson",
      "commitDateOld": "2016/6/26 上午1:57",
      "commitNameOld": "3f282e8bf0b8af519cbf35833fdcf69d824661fc",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 0.08,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private Response getResponse() throws IOException {\n    if (response !\u003d null) {\n        return response;\n    } else if (networkResponse !\u003d null) {\n        return networkResponse;\n    } else if (callFailure !\u003d null) {\n        throw callFailure;\n    }\n    Call call \u003d buildCall();\n    networkInterceptor.proceed();\n    OutputStreamRequestBody requestBody \u003d (OutputStreamRequestBody) call.request().body();\n    if (requestBody !\u003d null)\n        requestBody.outputStream().close();\n    if (executed) {\n        synchronized (lock) {\n            try {\n                while (response \u003d\u003d null \u0026\u0026 callFailure \u003d\u003d null) {\n                    lock.wait();\n                }\n            } catch (InterruptedException e) {\n                throw new InterruptedIOException();\n            }\n        }\n    } else {\n        executed \u003d true;\n        try {\n            onResponse(call, call.execute());\n        } catch (IOException e) {\n            onFailure(call, e);\n        }\n    }\n    synchronized (lock) {\n        if (callFailure !\u003d null)\n            throw callFailure;\n        if (response !\u003d null)\n            return response;\n    }\n    throw new AssertionError();\n}",
      "path": "okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java",
      "functionStartLine": 405,
      "functionName": "getResponse",
      "functionAnnotation": "",
      "functionDoc": "Aggressively tries to get the final HTTP response, potentially making many HTTP requests in the\nprocess in order to cope with redirects and authentication.\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpURLConnectionImpl.java",
        "newPath": "okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java"
      }
    },
    "084b06b48bae2b566bb1be3415b6c847d8ea3682": {
      "type": "Ymultichange(Yreturntypechange,Ybodychange)",
      "commitMessage": "Reimplement HttpURLConnection on the native OkHttp API.\n",
      "commitDate": "2016/6/22 上午2:30",
      "commitName": "084b06b48bae2b566bb1be3415b6c847d8ea3682",
      "commitAuthor": "jwilson",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "Reimplement HttpURLConnection on the native OkHttp API.\n",
          "commitDate": "2016/6/22 上午2:30",
          "commitName": "084b06b48bae2b566bb1be3415b6c847d8ea3682",
          "commitAuthor": "jwilson",
          "commitDateOld": "2016/5/8 上午9:08",
          "commitNameOld": "4f24a30c12032b7033884a630696014afd3e77cb",
          "commitAuthorOld": "jwilson",
          "daysBetweenCommits": 44.72,
          "commitsBetweenForRepo": 27,
          "commitsBetweenForFile": 1,
          "actualSource": "private Response getResponse() throws IOException {\n    if (response !\u003d null) {\n        return response;\n    } else if (networkResponse !\u003d null) {\n        return networkResponse;\n    } else if (callFailure !\u003d null) {\n        throw callFailure;\n    }\n    Call call \u003d buildCall();\n    networkInterceptor.proceed();\n    OutputStreamRequestBody requestBody \u003d (OutputStreamRequestBody) call.request().body();\n    if (requestBody !\u003d null)\n        requestBody.outputStream().close();\n    if (executed) {\n        synchronized (lock) {\n            try {\n                while (response \u003d\u003d null \u0026\u0026 callFailure \u003d\u003d null) {\n                    lock.wait();\n                }\n            } catch (InterruptedException e) {\n                throw new InterruptedIOException();\n            }\n        }\n    } else {\n        executed \u003d true;\n        try {\n            onResponse(call, call.execute());\n        } catch (IOException e) {\n            onFailure(call, e);\n        }\n    }\n    synchronized (lock) {\n        if (callFailure !\u003d null)\n            throw callFailure;\n        if (response !\u003d null)\n            return response;\n    }\n    throw new AssertionError();\n}",
          "path": "okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpURLConnectionImpl.java",
          "functionStartLine": 398,
          "functionName": "getResponse",
          "functionAnnotation": "",
          "functionDoc": "Aggressively tries to get the final HTTP response, potentially making many HTTP requests in the\nprocess in order to cope with redirects and authentication.\n",
          "diff": "@@ -1,35 +1,39 @@\n-private HttpEngine getResponse() throws IOException {\n-    initHttpEngine();\n-    if (httpEngine.hasResponse()) {\n-        return httpEngine;\n+private Response getResponse() throws IOException {\n+    if (response !\u003d null) {\n+        return response;\n+    } else if (networkResponse !\u003d null) {\n+        return networkResponse;\n+    } else if (callFailure !\u003d null) {\n+        throw callFailure;\n     }\n-    while (true) {\n-        if (!execute(true)) {\n-            continue;\n+    Call call \u003d buildCall();\n+    networkInterceptor.proceed();\n+    OutputStreamRequestBody requestBody \u003d (OutputStreamRequestBody) call.request().body();\n+    if (requestBody !\u003d null)\n+        requestBody.outputStream().close();\n+    if (executed) {\n+        synchronized (lock) {\n+            try {\n+                while (response \u003d\u003d null \u0026\u0026 callFailure \u003d\u003d null) {\n+                    lock.wait();\n+                }\n+            } catch (InterruptedException e) {\n+                throw new InterruptedIOException();\n+            }\n         }\n-        Response response \u003d httpEngine.getResponse();\n-        Request followUp \u003d httpEngine.followUpRequest();\n-        if (followUp \u003d\u003d null) {\n-            httpEngine.releaseStreamAllocation();\n-            return httpEngine;\n+    } else {\n+        executed \u003d true;\n+        try {\n+            onResponse(call, call.execute());\n+        } catch (IOException e) {\n+            onFailure(call, e);\n         }\n-        if (++followUpCount \u003e HttpEngine.MAX_FOLLOW_UPS) {\n-            throw new ProtocolException(\"Too many follow-up requests: \" + followUpCount);\n-        }\n-        url \u003d followUp.url().url();\n-        requestHeaders \u003d followUp.headers().newBuilder();\n-        Sink requestBody \u003d httpEngine.getRequestBody();\n-        if (!followUp.method().equals(method)) {\n-            requestBody \u003d null;\n-        }\n-        if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableSink)) {\n-            throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n-        }\n-        StreamAllocation streamAllocation \u003d httpEngine.close();\n-        if (!httpEngine.sameConnection(followUp.url())) {\n-            streamAllocation.release();\n-            streamAllocation \u003d null;\n-        }\n-        httpEngine \u003d newHttpEngine(followUp.method(), streamAllocation, (RetryableSink) requestBody, response);\n     }\n+    synchronized (lock) {\n+        if (callFailure !\u003d null)\n+            throw callFailure;\n+        if (response !\u003d null)\n+            return response;\n+    }\n+    throw new AssertionError();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "HttpEngine",
            "newValue": "Response"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Reimplement HttpURLConnection on the native OkHttp API.\n",
          "commitDate": "2016/6/22 上午2:30",
          "commitName": "084b06b48bae2b566bb1be3415b6c847d8ea3682",
          "commitAuthor": "jwilson",
          "commitDateOld": "2016/5/8 上午9:08",
          "commitNameOld": "4f24a30c12032b7033884a630696014afd3e77cb",
          "commitAuthorOld": "jwilson",
          "daysBetweenCommits": 44.72,
          "commitsBetweenForRepo": 27,
          "commitsBetweenForFile": 1,
          "actualSource": "private Response getResponse() throws IOException {\n    if (response !\u003d null) {\n        return response;\n    } else if (networkResponse !\u003d null) {\n        return networkResponse;\n    } else if (callFailure !\u003d null) {\n        throw callFailure;\n    }\n    Call call \u003d buildCall();\n    networkInterceptor.proceed();\n    OutputStreamRequestBody requestBody \u003d (OutputStreamRequestBody) call.request().body();\n    if (requestBody !\u003d null)\n        requestBody.outputStream().close();\n    if (executed) {\n        synchronized (lock) {\n            try {\n                while (response \u003d\u003d null \u0026\u0026 callFailure \u003d\u003d null) {\n                    lock.wait();\n                }\n            } catch (InterruptedException e) {\n                throw new InterruptedIOException();\n            }\n        }\n    } else {\n        executed \u003d true;\n        try {\n            onResponse(call, call.execute());\n        } catch (IOException e) {\n            onFailure(call, e);\n        }\n    }\n    synchronized (lock) {\n        if (callFailure !\u003d null)\n            throw callFailure;\n        if (response !\u003d null)\n            return response;\n    }\n    throw new AssertionError();\n}",
          "path": "okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpURLConnectionImpl.java",
          "functionStartLine": 398,
          "functionName": "getResponse",
          "functionAnnotation": "",
          "functionDoc": "Aggressively tries to get the final HTTP response, potentially making many HTTP requests in the\nprocess in order to cope with redirects and authentication.\n",
          "diff": "@@ -1,35 +1,39 @@\n-private HttpEngine getResponse() throws IOException {\n-    initHttpEngine();\n-    if (httpEngine.hasResponse()) {\n-        return httpEngine;\n+private Response getResponse() throws IOException {\n+    if (response !\u003d null) {\n+        return response;\n+    } else if (networkResponse !\u003d null) {\n+        return networkResponse;\n+    } else if (callFailure !\u003d null) {\n+        throw callFailure;\n     }\n-    while (true) {\n-        if (!execute(true)) {\n-            continue;\n+    Call call \u003d buildCall();\n+    networkInterceptor.proceed();\n+    OutputStreamRequestBody requestBody \u003d (OutputStreamRequestBody) call.request().body();\n+    if (requestBody !\u003d null)\n+        requestBody.outputStream().close();\n+    if (executed) {\n+        synchronized (lock) {\n+            try {\n+                while (response \u003d\u003d null \u0026\u0026 callFailure \u003d\u003d null) {\n+                    lock.wait();\n+                }\n+            } catch (InterruptedException e) {\n+                throw new InterruptedIOException();\n+            }\n         }\n-        Response response \u003d httpEngine.getResponse();\n-        Request followUp \u003d httpEngine.followUpRequest();\n-        if (followUp \u003d\u003d null) {\n-            httpEngine.releaseStreamAllocation();\n-            return httpEngine;\n+    } else {\n+        executed \u003d true;\n+        try {\n+            onResponse(call, call.execute());\n+        } catch (IOException e) {\n+            onFailure(call, e);\n         }\n-        if (++followUpCount \u003e HttpEngine.MAX_FOLLOW_UPS) {\n-            throw new ProtocolException(\"Too many follow-up requests: \" + followUpCount);\n-        }\n-        url \u003d followUp.url().url();\n-        requestHeaders \u003d followUp.headers().newBuilder();\n-        Sink requestBody \u003d httpEngine.getRequestBody();\n-        if (!followUp.method().equals(method)) {\n-            requestBody \u003d null;\n-        }\n-        if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableSink)) {\n-            throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n-        }\n-        StreamAllocation streamAllocation \u003d httpEngine.close();\n-        if (!httpEngine.sameConnection(followUp.url())) {\n-            streamAllocation.release();\n-            streamAllocation \u003d null;\n-        }\n-        httpEngine \u003d newHttpEngine(followUp.method(), streamAllocation, (RetryableSink) requestBody, response);\n     }\n+    synchronized (lock) {\n+        if (callFailure !\u003d null)\n+            throw callFailure;\n+        if (response !\u003d null)\n+            return response;\n+    }\n+    throw new AssertionError();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "98ae0fb92c9335ec17f8710376183e18f5edd355": {
      "type": "Ydocchange",
      "commitMessage": "Sort imports and wrap documentation at 100 columns.\n\nThis is a mechanical refactoring. The only thing I had trouble with is IntelliJ\u0027s\nweak support for \u003cul\u003e tags in Javadoc.\n",
      "commitDate": "2015/12/24 上午8:34",
      "commitName": "98ae0fb92c9335ec17f8710376183e18f5edd355",
      "commitAuthor": "jwilson",
      "commitDateOld": "2015/12/22 上午10:10",
      "commitNameOld": "02d6b4e78c4f1bda5f20e3089af024c58fe6baf6",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 1.93,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "private HttpEngine getResponse() throws IOException {\n    initHttpEngine();\n    if (httpEngine.hasResponse()) {\n        return httpEngine;\n    }\n    while (true) {\n        if (!execute(true)) {\n            continue;\n        }\n        Response response \u003d httpEngine.getResponse();\n        Request followUp \u003d httpEngine.followUpRequest();\n        if (followUp \u003d\u003d null) {\n            httpEngine.releaseStreamAllocation();\n            return httpEngine;\n        }\n        if (++followUpCount \u003e HttpEngine.MAX_FOLLOW_UPS) {\n            throw new ProtocolException(\"Too many follow-up requests: \" + followUpCount);\n        }\n        url \u003d followUp.url().url();\n        requestHeaders \u003d followUp.headers().newBuilder();\n        Sink requestBody \u003d httpEngine.getRequestBody();\n        if (!followUp.method().equals(method)) {\n            requestBody \u003d null;\n        }\n        if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableSink)) {\n            throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n        }\n        StreamAllocation streamAllocation \u003d httpEngine.close();\n        if (!httpEngine.sameConnection(followUp.url())) {\n            streamAllocation.release();\n            streamAllocation \u003d null;\n        }\n        httpEngine \u003d newHttpEngine(followUp.method(), streamAllocation, (RetryableSink) requestBody, response);\n    }\n}",
      "path": "okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpURLConnectionImpl.java",
      "functionStartLine": 388,
      "functionName": "getResponse",
      "functionAnnotation": "",
      "functionDoc": "Aggressively tries to get the final HTTP response, potentially making many HTTP requests in the\nprocess in order to cope with redirects and authentication.\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "Aggressively tries to get the final HTTP response, potentially making\nmany HTTP requests in the process in order to cope with redirects and\nauthentication.\n",
        "newValue": "Aggressively tries to get the final HTTP response, potentially making many HTTP requests in the\nprocess in order to cope with redirects and authentication.\n"
      }
    },
    "c9a89876de476983f273edbf108c365127c18c5e": {
      "type": "Ymovefromfile",
      "commitMessage": "Rename com.squareup.okhttp to okhttp3\n\nMaven group changes will come in follow up.\n",
      "commitDate": "2015/12/16 下午2:34",
      "commitName": "c9a89876de476983f273edbf108c365127c18c5e",
      "commitAuthor": "jwilson",
      "commitDateOld": "2015/12/16 上午10:36",
      "commitNameOld": "54dc2df914f2aae37fb48cc2c2f7560ee664bc2b",
      "commitAuthorOld": "Jake Wharton",
      "daysBetweenCommits": 0.17,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private HttpEngine getResponse() throws IOException {\n    initHttpEngine();\n    if (httpEngine.hasResponse()) {\n        return httpEngine;\n    }\n    while (true) {\n        if (!execute(true)) {\n            continue;\n        }\n        Response response \u003d httpEngine.getResponse();\n        Request followUp \u003d httpEngine.followUpRequest();\n        if (followUp \u003d\u003d null) {\n            httpEngine.releaseStreamAllocation();\n            return httpEngine;\n        }\n        if (++followUpCount \u003e HttpEngine.MAX_FOLLOW_UPS) {\n            throw new ProtocolException(\"Too many follow-up requests: \" + followUpCount);\n        }\n        url \u003d followUp.url().url();\n        requestHeaders \u003d followUp.headers().newBuilder();\n        Sink requestBody \u003d httpEngine.getRequestBody();\n        if (!followUp.method().equals(method)) {\n            requestBody \u003d null;\n        }\n        if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableSink)) {\n            throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n        }\n        StreamAllocation streamAllocation \u003d httpEngine.close();\n        if (!httpEngine.sameConnection(followUp.url())) {\n            streamAllocation.release();\n            streamAllocation \u003d null;\n        }\n        httpEngine \u003d newHttpEngine(followUp.method(), streamAllocation, (RetryableSink) requestBody, response);\n    }\n}",
      "path": "okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpURLConnectionImpl.java",
      "functionStartLine": 391,
      "functionName": "getResponse",
      "functionAnnotation": "",
      "functionDoc": "Aggressively tries to get the final HTTP response, potentially making\nmany HTTP requests in the process in order to cope with redirects and\nauthentication.\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java",
        "newPath": "okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpURLConnectionImpl.java",
        "oldMethodName": "getResponse",
        "newMethodName": "getResponse"
      }
    },
    "93d547dcdaecddfa456aee0571131db2342e5abb": {
      "type": "Ybodychange",
      "commitMessage": "Make HttpUrl the blessed URL method of Request.\n",
      "commitDate": "2015/12/15 上午4:11",
      "commitName": "93d547dcdaecddfa456aee0571131db2342e5abb",
      "commitAuthor": "Jake Wharton",
      "commitDateOld": "2015/12/13 下午11:07",
      "commitNameOld": "45260b51b1948abe139c568e2c400955870b9339",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 1.21,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "actualSource": "private HttpEngine getResponse() throws IOException {\n    initHttpEngine();\n    if (httpEngine.hasResponse()) {\n        return httpEngine;\n    }\n    while (true) {\n        if (!execute(true)) {\n            continue;\n        }\n        Response response \u003d httpEngine.getResponse();\n        Request followUp \u003d httpEngine.followUpRequest();\n        if (followUp \u003d\u003d null) {\n            httpEngine.releaseStreamAllocation();\n            return httpEngine;\n        }\n        if (++followUpCount \u003e HttpEngine.MAX_FOLLOW_UPS) {\n            throw new ProtocolException(\"Too many follow-up requests: \" + followUpCount);\n        }\n        url \u003d followUp.url().url();\n        requestHeaders \u003d followUp.headers().newBuilder();\n        Sink requestBody \u003d httpEngine.getRequestBody();\n        if (!followUp.method().equals(method)) {\n            requestBody \u003d null;\n        }\n        if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableSink)) {\n            throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n        }\n        StreamAllocation streamAllocation \u003d httpEngine.close();\n        if (!httpEngine.sameConnection(followUp.url())) {\n            streamAllocation.release();\n            streamAllocation \u003d null;\n        }\n        httpEngine \u003d newHttpEngine(followUp.method(), streamAllocation, (RetryableSink) requestBody, response);\n    }\n}",
      "path": "okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java",
      "functionStartLine": 391,
      "functionName": "getResponse",
      "functionAnnotation": "",
      "functionDoc": "Aggressively tries to get the final HTTP response, potentially making\nmany HTTP requests in the process in order to cope with redirects and\nauthentication.\n",
      "diff": "@@ -1,35 +1,35 @@\n private HttpEngine getResponse() throws IOException {\n     initHttpEngine();\n     if (httpEngine.hasResponse()) {\n         return httpEngine;\n     }\n     while (true) {\n         if (!execute(true)) {\n             continue;\n         }\n         Response response \u003d httpEngine.getResponse();\n         Request followUp \u003d httpEngine.followUpRequest();\n         if (followUp \u003d\u003d null) {\n             httpEngine.releaseStreamAllocation();\n             return httpEngine;\n         }\n         if (++followUpCount \u003e HttpEngine.MAX_FOLLOW_UPS) {\n             throw new ProtocolException(\"Too many follow-up requests: \" + followUpCount);\n         }\n-        url \u003d followUp.url();\n+        url \u003d followUp.url().url();\n         requestHeaders \u003d followUp.headers().newBuilder();\n         Sink requestBody \u003d httpEngine.getRequestBody();\n         if (!followUp.method().equals(method)) {\n             requestBody \u003d null;\n         }\n         if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableSink)) {\n             throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n         }\n         StreamAllocation streamAllocation \u003d httpEngine.close();\n-        if (!httpEngine.sameConnection(followUp.httpUrl())) {\n+        if (!httpEngine.sameConnection(followUp.url())) {\n             streamAllocation.release();\n             streamAllocation \u003d null;\n         }\n         httpEngine \u003d newHttpEngine(followUp.method(), streamAllocation, (RetryableSink) requestBody, response);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c358656c8799d30fd422448153e99a5dd37e298a": {
      "type": "Ybodychange",
      "commitMessage": "First draft of the new new stream allocations model.\n",
      "commitDate": "2015/11/28 下午10:36",
      "commitName": "c358656c8799d30fd422448153e99a5dd37e298a",
      "commitAuthor": "jwilson",
      "commitDateOld": "2015/11/25 上午11:03",
      "commitNameOld": "6fff68b1e9be384ad134812d3e14af5ae7fef83f",
      "commitAuthorOld": "Jake Wharton",
      "daysBetweenCommits": 3.48,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "actualSource": "private HttpEngine getResponse() throws IOException {\n    initHttpEngine();\n    if (httpEngine.hasResponse()) {\n        return httpEngine;\n    }\n    while (true) {\n        if (!execute(true)) {\n            continue;\n        }\n        Response response \u003d httpEngine.getResponse();\n        Request followUp \u003d httpEngine.followUpRequest();\n        if (followUp \u003d\u003d null) {\n            httpEngine.releaseStreamAllocation();\n            return httpEngine;\n        }\n        if (++followUpCount \u003e HttpEngine.MAX_FOLLOW_UPS) {\n            throw new ProtocolException(\"Too many follow-up requests: \" + followUpCount);\n        }\n        url \u003d followUp.url();\n        requestHeaders \u003d followUp.headers().newBuilder();\n        Sink requestBody \u003d httpEngine.getRequestBody();\n        if (!followUp.method().equals(method)) {\n            requestBody \u003d null;\n        }\n        if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableSink)) {\n            throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n        }\n        StreamAllocation streamAllocation \u003d httpEngine.close();\n        if (!httpEngine.sameConnection(followUp.httpUrl())) {\n            streamAllocation.release();\n            streamAllocation \u003d null;\n        }\n        httpEngine \u003d newHttpEngine(followUp.method(), streamAllocation, (RetryableSink) requestBody, response);\n    }\n}",
      "path": "okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java",
      "functionStartLine": 391,
      "functionName": "getResponse",
      "functionAnnotation": "",
      "functionDoc": "Aggressively tries to get the final HTTP response, potentially making\nmany HTTP requests in the process in order to cope with redirects and\nauthentication.\n",
      "diff": "@@ -1,34 +1,35 @@\n private HttpEngine getResponse() throws IOException {\n     initHttpEngine();\n     if (httpEngine.hasResponse()) {\n         return httpEngine;\n     }\n     while (true) {\n         if (!execute(true)) {\n             continue;\n         }\n         Response response \u003d httpEngine.getResponse();\n         Request followUp \u003d httpEngine.followUpRequest();\n         if (followUp \u003d\u003d null) {\n-            httpEngine.releaseConnection();\n+            httpEngine.releaseStreamAllocation();\n             return httpEngine;\n         }\n         if (++followUpCount \u003e HttpEngine.MAX_FOLLOW_UPS) {\n             throw new ProtocolException(\"Too many follow-up requests: \" + followUpCount);\n         }\n         url \u003d followUp.url();\n         requestHeaders \u003d followUp.headers().newBuilder();\n         Sink requestBody \u003d httpEngine.getRequestBody();\n         if (!followUp.method().equals(method)) {\n             requestBody \u003d null;\n         }\n         if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableSink)) {\n             throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n         }\n+        StreamAllocation streamAllocation \u003d httpEngine.close();\n         if (!httpEngine.sameConnection(followUp.httpUrl())) {\n-            httpEngine.releaseConnection();\n+            streamAllocation.release();\n+            streamAllocation \u003d null;\n         }\n-        Connection connection \u003d httpEngine.close();\n-        httpEngine \u003d newHttpEngine(followUp.method(), connection, (RetryableSink) requestBody, response);\n+        httpEngine \u003d newHttpEngine(followUp.method(), streamAllocation, (RetryableSink) requestBody, response);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4c90a2e04a83646597a506a80b5a885d5c515bf0": {
      "type": "Ybodychange",
      "commitMessage": "Use HttpUrl internally.\n",
      "commitDate": "2015/8/3 上午9:01",
      "commitName": "4c90a2e04a83646597a506a80b5a885d5c515bf0",
      "commitAuthor": "jwilson",
      "commitDateOld": "2015/4/17 上午8:20",
      "commitNameOld": "80901a680a341a79f4bc4523b191eeb219941cd7",
      "commitAuthorOld": "",
      "daysBetweenCommits": 108.03,
      "commitsBetweenForRepo": 80,
      "commitsBetweenForFile": 1,
      "actualSource": "private HttpEngine getResponse() throws IOException {\n    initHttpEngine();\n    if (httpEngine.hasResponse()) {\n        return httpEngine;\n    }\n    while (true) {\n        if (!execute(true)) {\n            continue;\n        }\n        Response response \u003d httpEngine.getResponse();\n        Request followUp \u003d httpEngine.followUpRequest();\n        if (followUp \u003d\u003d null) {\n            httpEngine.releaseConnection();\n            return httpEngine;\n        }\n        if (++followUpCount \u003e HttpEngine.MAX_FOLLOW_UPS) {\n            throw new ProtocolException(\"Too many follow-up requests: \" + followUpCount);\n        }\n        url \u003d followUp.url();\n        requestHeaders \u003d followUp.headers().newBuilder();\n        Sink requestBody \u003d httpEngine.getRequestBody();\n        if (!followUp.method().equals(method)) {\n            requestBody \u003d null;\n        }\n        if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableSink)) {\n            throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n        }\n        if (!httpEngine.sameConnection(followUp.httpUrl())) {\n            httpEngine.releaseConnection();\n        }\n        Connection connection \u003d httpEngine.close();\n        httpEngine \u003d newHttpEngine(followUp.method(), connection, (RetryableSink) requestBody, response);\n    }\n}",
      "path": "okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java",
      "functionStartLine": 379,
      "functionName": "getResponse",
      "functionAnnotation": "",
      "functionDoc": "Aggressively tries to get the final HTTP response, potentially making\nmany HTTP requests in the process in order to cope with redirects and\nauthentication.\n",
      "diff": "@@ -1,34 +1,34 @@\n private HttpEngine getResponse() throws IOException {\n     initHttpEngine();\n     if (httpEngine.hasResponse()) {\n         return httpEngine;\n     }\n     while (true) {\n         if (!execute(true)) {\n             continue;\n         }\n         Response response \u003d httpEngine.getResponse();\n         Request followUp \u003d httpEngine.followUpRequest();\n         if (followUp \u003d\u003d null) {\n             httpEngine.releaseConnection();\n             return httpEngine;\n         }\n         if (++followUpCount \u003e HttpEngine.MAX_FOLLOW_UPS) {\n             throw new ProtocolException(\"Too many follow-up requests: \" + followUpCount);\n         }\n         url \u003d followUp.url();\n         requestHeaders \u003d followUp.headers().newBuilder();\n         Sink requestBody \u003d httpEngine.getRequestBody();\n         if (!followUp.method().equals(method)) {\n             requestBody \u003d null;\n         }\n         if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableSink)) {\n             throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n         }\n-        if (!httpEngine.sameConnection(followUp.url())) {\n+        if (!httpEngine.sameConnection(followUp.httpUrl())) {\n             httpEngine.releaseConnection();\n         }\n         Connection connection \u003d httpEngine.close();\n         httpEngine \u003d newHttpEngine(followUp.method(), connection, (RetryableSink) requestBody, response);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e49dd7a2f08deac92fab3de2b8a63e90b588f746": {
      "type": "Ybodychange",
      "commitMessage": "Limit 20 authorization attempts.\n\nWe use one count for both redirects and authorization attempts. This\nseems like good enough policy.\n\nCloses https://github.com/square/okhttp/issues/960\n",
      "commitDate": "2014/12/31 上午1:14",
      "commitName": "e49dd7a2f08deac92fab3de2b8a63e90b588f746",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "2014/12/25 上午3:33",
      "commitNameOld": "15c81fdfc2ba4ecfbadac5a7ec73fcc61f6624bc",
      "commitAuthorOld": "Jake Wharton",
      "daysBetweenCommits": 5.9,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "actualSource": "private HttpEngine getResponse() throws IOException {\n    initHttpEngine();\n    if (httpEngine.hasResponse()) {\n        return httpEngine;\n    }\n    while (true) {\n        if (!execute(true)) {\n            continue;\n        }\n        Response response \u003d httpEngine.getResponse();\n        Request followUp \u003d httpEngine.followUpRequest();\n        if (followUp \u003d\u003d null) {\n            httpEngine.releaseConnection();\n            return httpEngine;\n        }\n        if (++followUpCount \u003e HttpEngine.MAX_FOLLOW_UPS) {\n            throw new ProtocolException(\"Too many follow-up requests: \" + followUpCount);\n        }\n        url \u003d followUp.url();\n        requestHeaders \u003d followUp.headers().newBuilder();\n        Sink requestBody \u003d httpEngine.getRequestBody();\n        if (!followUp.method().equals(method)) {\n            requestBody \u003d null;\n        }\n        if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableSink)) {\n            throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n        }\n        if (!httpEngine.sameConnection(followUp.url())) {\n            httpEngine.releaseConnection();\n        }\n        Connection connection \u003d httpEngine.close();\n        httpEngine \u003d newHttpEngine(followUp.method(), connection, (RetryableSink) requestBody, response);\n    }\n}",
      "path": "okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java",
      "functionStartLine": 368,
      "functionName": "getResponse",
      "functionAnnotation": "",
      "functionDoc": "Aggressively tries to get the final HTTP response, potentially making\nmany HTTP requests in the process in order to cope with redirects and\nauthentication.\n",
      "diff": "@@ -1,34 +1,34 @@\n private HttpEngine getResponse() throws IOException {\n     initHttpEngine();\n     if (httpEngine.hasResponse()) {\n         return httpEngine;\n     }\n     while (true) {\n         if (!execute(true)) {\n             continue;\n         }\n         Response response \u003d httpEngine.getResponse();\n         Request followUp \u003d httpEngine.followUpRequest();\n         if (followUp \u003d\u003d null) {\n             httpEngine.releaseConnection();\n             return httpEngine;\n         }\n-        if (response.isRedirect() \u0026\u0026 ++redirectionCount \u003e HttpEngine.MAX_REDIRECTS) {\n-            throw new ProtocolException(\"Too many redirects: \" + redirectionCount);\n+        if (++followUpCount \u003e HttpEngine.MAX_FOLLOW_UPS) {\n+            throw new ProtocolException(\"Too many follow-up requests: \" + followUpCount);\n         }\n         url \u003d followUp.url();\n         requestHeaders \u003d followUp.headers().newBuilder();\n         Sink requestBody \u003d httpEngine.getRequestBody();\n         if (!followUp.method().equals(method)) {\n             requestBody \u003d null;\n         }\n         if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableSink)) {\n             throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n         }\n         if (!httpEngine.sameConnection(followUp.url())) {\n             httpEngine.releaseConnection();\n         }\n         Connection connection \u003d httpEngine.close();\n         httpEngine \u003d newHttpEngine(followUp.method(), connection, (RetryableSink) requestBody, response);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ed70981925e64fd0cb593d09bdd401ea4ea19848": {
      "type": "Ybodychange",
      "commitMessage": "Strip auth headers when redirected to another host.\n\nThese are potentially private and we don\u0027t want to leak them to another\nhost, regardless of whether they\u0027re created by the calling application or\nby the Authenticator.\n",
      "commitDate": "2014/5/20 上午11:18",
      "commitName": "ed70981925e64fd0cb593d09bdd401ea4ea19848",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "2014/5/18 上午9:00",
      "commitNameOld": "0676d8b1733589a869098b9980118644b3bade4f",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 2.1,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "actualSource": "private HttpEngine getResponse() throws IOException {\n    initHttpEngine();\n    if (httpEngine.hasResponse()) {\n        return httpEngine;\n    }\n    while (true) {\n        if (!execute(true)) {\n            continue;\n        }\n        Response response \u003d httpEngine.getResponse();\n        Request followUp \u003d httpEngine.followUpRequest();\n        if (followUp \u003d\u003d null) {\n            httpEngine.releaseConnection();\n            return httpEngine;\n        }\n        if (response.isRedirect() \u0026\u0026 ++redirectionCount \u003e HttpEngine.MAX_REDIRECTS) {\n            throw new ProtocolException(\"Too many redirects: \" + redirectionCount);\n        }\n        url \u003d followUp.url();\n        requestHeaders \u003d followUp.headers().newBuilder();\n        Sink requestBody \u003d httpEngine.getRequestBody();\n        if (!followUp.method().equals(method)) {\n            requestBody \u003d null;\n        }\n        if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableSink)) {\n            throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n        }\n        if (!httpEngine.sameConnection(followUp.url())) {\n            httpEngine.releaseConnection();\n        }\n        Connection connection \u003d httpEngine.close();\n        httpEngine \u003d newHttpEngine(followUp.method(), connection, (RetryableSink) requestBody, response);\n    }\n}",
      "path": "okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java",
      "functionStartLine": 320,
      "functionName": "getResponse",
      "functionAnnotation": "",
      "functionDoc": "Aggressively tries to get the final HTTP response, potentially making\nmany HTTP requests in the process in order to cope with redirects and\nauthentication.\n",
      "diff": "@@ -1,34 +1,34 @@\n private HttpEngine getResponse() throws IOException {\n     initHttpEngine();\n     if (httpEngine.hasResponse()) {\n         return httpEngine;\n     }\n     while (true) {\n         if (!execute(true)) {\n             continue;\n         }\n         Response response \u003d httpEngine.getResponse();\n         Request followUp \u003d httpEngine.followUpRequest();\n         if (followUp \u003d\u003d null) {\n             httpEngine.releaseConnection();\n             return httpEngine;\n         }\n         if (response.isRedirect() \u0026\u0026 ++redirectionCount \u003e HttpEngine.MAX_REDIRECTS) {\n             throw new ProtocolException(\"Too many redirects: \" + redirectionCount);\n         }\n         url \u003d followUp.url();\n         requestHeaders \u003d followUp.headers().newBuilder();\n         Sink requestBody \u003d httpEngine.getRequestBody();\n         if (!followUp.method().equals(method)) {\n             requestBody \u003d null;\n         }\n         if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableSink)) {\n             throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n         }\n-        if (!httpEngine.sameConnection(followUp)) {\n+        if (!httpEngine.sameConnection(followUp.url())) {\n             httpEngine.releaseConnection();\n         }\n         Connection connection \u003d httpEngine.close();\n         httpEngine \u003d newHttpEngine(followUp.method(), connection, (RetryableSink) requestBody, response);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0676d8b1733589a869098b9980118644b3bade4f": {
      "type": "Yfilerename",
      "commitMessage": "Move code to the urlconnection module.\n\nWe don\u0027t need this code for the core OkHttp API.\n",
      "commitDate": "2014/5/18 上午9:00",
      "commitName": "0676d8b1733589a869098b9980118644b3bade4f",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "2014/5/18 上午6:40",
      "commitNameOld": "85a3e9bfc58040c9ffb2ee906b39702bb26a84a5",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private HttpEngine getResponse() throws IOException {\n    initHttpEngine();\n    if (httpEngine.hasResponse()) {\n        return httpEngine;\n    }\n    while (true) {\n        if (!execute(true)) {\n            continue;\n        }\n        Response response \u003d httpEngine.getResponse();\n        Request followUp \u003d httpEngine.followUpRequest();\n        if (followUp \u003d\u003d null) {\n            httpEngine.releaseConnection();\n            return httpEngine;\n        }\n        if (response.isRedirect() \u0026\u0026 ++redirectionCount \u003e HttpEngine.MAX_REDIRECTS) {\n            throw new ProtocolException(\"Too many redirects: \" + redirectionCount);\n        }\n        url \u003d followUp.url();\n        requestHeaders \u003d followUp.headers().newBuilder();\n        Sink requestBody \u003d httpEngine.getRequestBody();\n        if (!followUp.method().equals(method)) {\n            requestBody \u003d null;\n        }\n        if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableSink)) {\n            throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n        }\n        if (!httpEngine.sameConnection(followUp)) {\n            httpEngine.releaseConnection();\n        }\n        Connection connection \u003d httpEngine.close();\n        httpEngine \u003d newHttpEngine(followUp.method(), connection, (RetryableSink) requestBody, response);\n    }\n}",
      "path": "okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java",
      "functionStartLine": 320,
      "functionName": "getResponse",
      "functionAnnotation": "",
      "functionDoc": "Aggressively tries to get the final HTTP response, potentially making\nmany HTTP requests in the process in order to cope with redirects and\nauthentication.\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "okhttp/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java",
        "newPath": "okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java"
      }
    },
    "ee2ed56c9ad4563f5713ff0f572a5454af16901d": {
      "type": "Ybodychange",
      "commitMessage": "Track redirectedBy in HttpEngine.\n\nTracking it in Call meant we would need to duplicate code\nin HttpURLConnection if we wanted the same behavior.\n",
      "commitDate": "2014/5/6 上午8:41",
      "commitName": "ee2ed56c9ad4563f5713ff0f572a5454af16901d",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "2014/5/1 上午9:36",
      "commitNameOld": "1044d9eea21d8be54c195fff75ca0a7b9bba79b3",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 4.96,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "actualSource": "private HttpEngine getResponse() throws IOException {\n    initHttpEngine();\n    if (httpEngine.hasResponse()) {\n        return httpEngine;\n    }\n    while (true) {\n        if (!execute(true)) {\n            continue;\n        }\n        Response response \u003d httpEngine.getResponse();\n        Request followUp \u003d httpEngine.followUpRequest();\n        if (followUp \u003d\u003d null) {\n            httpEngine.releaseConnection();\n            return httpEngine;\n        }\n        if (response.isRedirect() \u0026\u0026 ++redirectionCount \u003e HttpEngine.MAX_REDIRECTS) {\n            throw new ProtocolException(\"Too many redirects: \" + redirectionCount);\n        }\n        url \u003d followUp.url();\n        requestHeaders \u003d followUp.headers().newBuilder();\n        Sink requestBody \u003d httpEngine.getRequestBody();\n        if (!followUp.method().equals(method)) {\n            requestBody \u003d null;\n        }\n        if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableSink)) {\n            throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n        }\n        if (!httpEngine.sameConnection(followUp)) {\n            httpEngine.releaseConnection();\n        }\n        Connection connection \u003d httpEngine.close();\n        httpEngine \u003d newHttpEngine(followUp.method(), connection, (RetryableSink) requestBody, response);\n    }\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java",
      "functionStartLine": 320,
      "functionName": "getResponse",
      "functionAnnotation": "",
      "functionDoc": "Aggressively tries to get the final HTTP response, potentially making\nmany HTTP requests in the process in order to cope with redirects and\nauthentication.\n",
      "diff": "@@ -1,34 +1,34 @@\n private HttpEngine getResponse() throws IOException {\n     initHttpEngine();\n     if (httpEngine.hasResponse()) {\n         return httpEngine;\n     }\n     while (true) {\n         if (!execute(true)) {\n             continue;\n         }\n         Response response \u003d httpEngine.getResponse();\n         Request followUp \u003d httpEngine.followUpRequest();\n         if (followUp \u003d\u003d null) {\n             httpEngine.releaseConnection();\n             return httpEngine;\n         }\n         if (response.isRedirect() \u0026\u0026 ++redirectionCount \u003e HttpEngine.MAX_REDIRECTS) {\n             throw new ProtocolException(\"Too many redirects: \" + redirectionCount);\n         }\n         url \u003d followUp.url();\n         requestHeaders \u003d followUp.headers().newBuilder();\n         Sink requestBody \u003d httpEngine.getRequestBody();\n         if (!followUp.method().equals(method)) {\n             requestBody \u003d null;\n         }\n         if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableSink)) {\n             throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n         }\n         if (!httpEngine.sameConnection(followUp)) {\n             httpEngine.releaseConnection();\n         }\n         Connection connection \u003d httpEngine.close();\n-        httpEngine \u003d newHttpEngine(followUp.method(), connection, (RetryableSink) requestBody);\n+        httpEngine \u003d newHttpEngine(followUp.method(), connection, (RetryableSink) requestBody, response);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b7542587b8e90aa4472d4d9e4b74a72ca0c42cb4": {
      "type": "Ybodychange",
      "commitMessage": "Move more behavior into HttpEngine.followUpRequest\n",
      "commitDate": "2014/4/27 上午1:02",
      "commitName": "b7542587b8e90aa4472d4d9e4b74a72ca0c42cb4",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "2014/4/22 下午11:39",
      "commitNameOld": "112dcc40900d503ea7e416e0da0a8fd9b08a9c17",
      "commitAuthorOld": "Adrian Cole",
      "daysBetweenCommits": 4.06,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "actualSource": "private HttpEngine getResponse() throws IOException {\n    initHttpEngine();\n    if (httpEngine.hasResponse()) {\n        return httpEngine;\n    }\n    while (true) {\n        if (!execute(true)) {\n            continue;\n        }\n        Response response \u003d httpEngine.getResponse();\n        Request followUp \u003d httpEngine.followUpRequest();\n        if (followUp \u003d\u003d null) {\n            httpEngine.releaseConnection();\n            return httpEngine;\n        }\n        if (response.isRedirect() \u0026\u0026 ++redirectionCount \u003e HttpEngine.MAX_REDIRECTS) {\n            throw new ProtocolException(\"Too many redirects: \" + redirectionCount);\n        }\n        url \u003d followUp.url();\n        requestHeaders \u003d followUp.headers().newBuilder();\n        Sink requestBody \u003d httpEngine.getRequestBody();\n        if (!followUp.method().equals(method)) {\n            requestBody \u003d null;\n        }\n        if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableSink)) {\n            throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n        }\n        if (!httpEngine.sameConnection(followUp)) {\n            httpEngine.releaseConnection();\n        }\n        Connection connection \u003d httpEngine.close();\n        httpEngine \u003d newHttpEngine(followUp.method(), connection, (RetryableSink) requestBody);\n    }\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java",
      "functionStartLine": 318,
      "functionName": "getResponse",
      "functionAnnotation": "",
      "functionDoc": "Aggressively tries to get the final HTTP response, potentially making\nmany HTTP requests in the process in order to cope with redirects and\nauthentication.\n",
      "diff": "@@ -1,41 +1,34 @@\n private HttpEngine getResponse() throws IOException {\n     initHttpEngine();\n     if (httpEngine.hasResponse()) {\n         return httpEngine;\n     }\n     while (true) {\n         if (!execute(true)) {\n             continue;\n         }\n         Response response \u003d httpEngine.getResponse();\n         Request followUp \u003d httpEngine.followUpRequest();\n         if (followUp \u003d\u003d null) {\n             httpEngine.releaseConnection();\n             return httpEngine;\n         }\n         if (response.isRedirect() \u0026\u0026 ++redirectionCount \u003e HttpEngine.MAX_REDIRECTS) {\n             throw new ProtocolException(\"Too many redirects: \" + redirectionCount);\n         }\n-        if (response.isRedirect()) {\n-            url \u003d followUp.url();\n-        } else {\n-            requestHeaders \u003d followUp.headers().newBuilder();\n-        }\n-        String retryMethod \u003d method;\n+        url \u003d followUp.url();\n+        requestHeaders \u003d followUp.headers().newBuilder();\n         Sink requestBody \u003d httpEngine.getRequestBody();\n-        int responseCode \u003d response.code();\n-        if (responseCode \u003d\u003d HTTP_MULT_CHOICE || responseCode \u003d\u003d HTTP_MOVED_PERM || responseCode \u003d\u003d HTTP_MOVED_TEMP || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n-            retryMethod \u003d \"GET\";\n-            requestHeaders.removeAll(\"Content-Length\");\n+        if (!followUp.method().equals(method)) {\n             requestBody \u003d null;\n         }\n         if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableSink)) {\n             throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n         }\n         if (!httpEngine.sameConnection(followUp)) {\n             httpEngine.releaseConnection();\n         }\n         Connection connection \u003d httpEngine.close();\n-        httpEngine \u003d newHttpEngine(retryMethod, connection, (RetryableSink) requestBody);\n+        httpEngine \u003d newHttpEngine(followUp.method(), connection, (RetryableSink) requestBody);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9146c579dd9110d0028144c59515da9be1ce7108": {
      "type": "Ybodychange",
      "commitMessage": "Deduplicate followup request handling.\n\nThis code\u0027s currently both gnarly and subtle; there\u0027s a lot of\nnuance to the HTTP behavior, and a lot of state, but it isn\u0027t\nobvious in the state of the objects doing the work.\n\nDeduplicating work in HttpURLConnection with Job is a shy first\nstep. It also points out some potential problems with Job, where\nwe don\u0027t handle method changes or cookies correctly. That\u0027s\ncritical!\n",
      "commitDate": "2014/4/22 下午12:14",
      "commitName": "9146c579dd9110d0028144c59515da9be1ce7108",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "2014/4/22 上午12:00",
      "commitNameOld": "e920196fbd71822fc284ab76204bf75f95d3265a",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 0.51,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "private HttpEngine getResponse() throws IOException {\n    initHttpEngine();\n    if (httpEngine.hasResponse()) {\n        return httpEngine;\n    }\n    while (true) {\n        if (!execute(true)) {\n            continue;\n        }\n        Response response \u003d httpEngine.getResponse();\n        Request followUp \u003d httpEngine.followUpRequest();\n        if (followUp \u003d\u003d null) {\n            httpEngine.releaseConnection();\n            return httpEngine;\n        }\n        if (response.isRedirect() \u0026\u0026 ++redirectionCount \u003e HttpEngine.MAX_REDIRECTS) {\n            throw new ProtocolException(\"Too many redirects: \" + redirectionCount);\n        }\n        if (response.isRedirect()) {\n            url \u003d followUp.url();\n        } else {\n            requestHeaders \u003d followUp.headers().newBuilder();\n        }\n        String retryMethod \u003d method;\n        Sink requestBody \u003d httpEngine.getRequestBody();\n        int responseCode \u003d response.code();\n        if (responseCode \u003d\u003d HTTP_MULT_CHOICE || responseCode \u003d\u003d HTTP_MOVED_PERM || responseCode \u003d\u003d HTTP_MOVED_TEMP || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n            retryMethod \u003d \"GET\";\n            requestHeaders.removeAll(\"Content-Length\");\n            requestBody \u003d null;\n        }\n        if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableSink)) {\n            throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n        }\n        if (!httpEngine.sameConnection(followUp)) {\n            httpEngine.releaseConnection();\n        }\n        Connection connection \u003d httpEngine.close();\n        httpEngine \u003d newHttpEngine(retryMethod, connection, (RetryableSink) requestBody);\n    }\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java",
      "functionStartLine": 321,
      "functionName": "getResponse",
      "functionAnnotation": "",
      "functionDoc": "Aggressively tries to get the final HTTP response, potentially making\nmany HTTP requests in the process in order to cope with redirects and\nauthentication.\n",
      "diff": "@@ -1,32 +1,41 @@\n private HttpEngine getResponse() throws IOException {\n     initHttpEngine();\n     if (httpEngine.hasResponse()) {\n         return httpEngine;\n     }\n     while (true) {\n         if (!execute(true)) {\n             continue;\n         }\n-        Retry retry \u003d processResponseHeaders();\n-        if (retry \u003d\u003d Retry.NONE) {\n+        Response response \u003d httpEngine.getResponse();\n+        Request followUp \u003d httpEngine.followUpRequest();\n+        if (followUp \u003d\u003d null) {\n             httpEngine.releaseConnection();\n             return httpEngine;\n         }\n+        if (response.isRedirect() \u0026\u0026 ++redirectionCount \u003e HttpEngine.MAX_REDIRECTS) {\n+            throw new ProtocolException(\"Too many redirects: \" + redirectionCount);\n+        }\n+        if (response.isRedirect()) {\n+            url \u003d followUp.url();\n+        } else {\n+            requestHeaders \u003d followUp.headers().newBuilder();\n+        }\n         String retryMethod \u003d method;\n         Sink requestBody \u003d httpEngine.getRequestBody();\n-        int responseCode \u003d httpEngine.getResponse().code();\n+        int responseCode \u003d response.code();\n         if (responseCode \u003d\u003d HTTP_MULT_CHOICE || responseCode \u003d\u003d HTTP_MOVED_PERM || responseCode \u003d\u003d HTTP_MOVED_TEMP || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n             retryMethod \u003d \"GET\";\n             requestHeaders.removeAll(\"Content-Length\");\n             requestBody \u003d null;\n         }\n         if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableSink)) {\n             throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n         }\n-        if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n+        if (!httpEngine.sameConnection(followUp)) {\n             httpEngine.releaseConnection();\n         }\n         Connection connection \u003d httpEngine.close();\n         httpEngine \u003d newHttpEngine(retryMethod, connection, (RetryableSink) requestBody);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "996e9c95bdcafd62e84c79c512d6ccac65c30758": {
      "type": "Yfilerename",
      "commitMessage": "Move HttpUrlConnection implementation to its own package.\n",
      "commitDate": "2014/4/20 下午2:59",
      "commitName": "996e9c95bdcafd62e84c79c512d6ccac65c30758",
      "commitAuthor": "Jake Wharton",
      "commitDateOld": "2014/4/20 上午9:19",
      "commitNameOld": "6486179b9d9c888a818c85384eed88fa0a8768a6",
      "commitAuthorOld": "Jake Wharton",
      "daysBetweenCommits": 0.24,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private HttpEngine getResponse() throws IOException {\n    initHttpEngine();\n    if (httpEngine.hasResponse()) {\n        return httpEngine;\n    }\n    while (true) {\n        if (!execute(true)) {\n            continue;\n        }\n        Retry retry \u003d processResponseHeaders();\n        if (retry \u003d\u003d Retry.NONE) {\n            httpEngine.releaseConnection();\n            return httpEngine;\n        }\n        String retryMethod \u003d method;\n        Sink requestBody \u003d httpEngine.getRequestBody();\n        int responseCode \u003d httpEngine.getResponse().code();\n        if (responseCode \u003d\u003d HTTP_MULT_CHOICE || responseCode \u003d\u003d HTTP_MOVED_PERM || responseCode \u003d\u003d HTTP_MOVED_TEMP || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n            retryMethod \u003d \"GET\";\n            requestHeaders.removeAll(\"Content-Length\");\n            requestBody \u003d null;\n        }\n        if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableSink)) {\n            throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n        }\n        if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n            httpEngine.releaseConnection();\n        }\n        Connection connection \u003d httpEngine.close();\n        httpEngine \u003d newHttpEngine(retryMethod, connection, (RetryableSink) requestBody);\n    }\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java",
      "functionStartLine": 332,
      "functionName": "getResponse",
      "functionAnnotation": "",
      "functionDoc": "Aggressively tries to get the final HTTP response, potentially making\nmany HTTP requests in the process in order to cope with redirects and\nauthentication.\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java",
        "newPath": "okhttp/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java"
      }
    },
    "84184afdb26b42ff615896f9c0161157cc84ec73": {
      "type": "Ybodychange",
      "commitMessage": "Use Sink in HttpEngine.\n",
      "commitDate": "2014/2/24 上午7:13",
      "commitName": "84184afdb26b42ff615896f9c0161157cc84ec73",
      "commitAuthor": "jwilson",
      "commitDateOld": "2014/2/23 上午3:23",
      "commitNameOld": "2581c36905db13dcd1df9a602c6201e3a9f80965",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 1.16,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "private HttpEngine getResponse() throws IOException {\n    initHttpEngine();\n    if (httpEngine.hasResponse()) {\n        return httpEngine;\n    }\n    while (true) {\n        if (!execute(true)) {\n            continue;\n        }\n        Retry retry \u003d processResponseHeaders();\n        if (retry \u003d\u003d Retry.NONE) {\n            httpEngine.releaseConnection();\n            return httpEngine;\n        }\n        String retryMethod \u003d method;\n        Sink requestBody \u003d httpEngine.getRequestBody();\n        int responseCode \u003d httpEngine.getResponse().code();\n        if (responseCode \u003d\u003d HTTP_MULT_CHOICE || responseCode \u003d\u003d HTTP_MOVED_PERM || responseCode \u003d\u003d HTTP_MOVED_TEMP || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n            retryMethod \u003d \"GET\";\n            requestHeaders.removeAll(\"Content-Length\");\n            requestBody \u003d null;\n        }\n        if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableSink)) {\n            throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n        }\n        if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n            httpEngine.releaseConnection();\n        }\n        Connection connection \u003d httpEngine.close();\n        httpEngine \u003d newHttpEngine(retryMethod, connection, (RetryableSink) requestBody);\n    }\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java",
      "functionStartLine": 310,
      "functionName": "getResponse",
      "functionAnnotation": "",
      "functionDoc": "Aggressively tries to get the final HTTP response, potentially making\nmany HTTP requests in the process in order to cope with redirects and\nauthentication.\n",
      "diff": "@@ -1,32 +1,32 @@\n private HttpEngine getResponse() throws IOException {\n     initHttpEngine();\n     if (httpEngine.hasResponse()) {\n         return httpEngine;\n     }\n     while (true) {\n         if (!execute(true)) {\n             continue;\n         }\n         Retry retry \u003d processResponseHeaders();\n         if (retry \u003d\u003d Retry.NONE) {\n             httpEngine.releaseConnection();\n             return httpEngine;\n         }\n         String retryMethod \u003d method;\n-        OutputStream requestBody \u003d httpEngine.getRequestBody();\n+        Sink requestBody \u003d httpEngine.getRequestBody();\n         int responseCode \u003d httpEngine.getResponse().code();\n         if (responseCode \u003d\u003d HTTP_MULT_CHOICE || responseCode \u003d\u003d HTTP_MOVED_PERM || responseCode \u003d\u003d HTTP_MOVED_TEMP || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n             retryMethod \u003d \"GET\";\n             requestHeaders.removeAll(\"Content-Length\");\n             requestBody \u003d null;\n         }\n-        if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableOutputStream)) {\n+        if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableSink)) {\n             throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n         }\n         if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n             httpEngine.releaseConnection();\n         }\n         Connection connection \u003d httpEngine.close();\n-        httpEngine \u003d newHttpEngine(retryMethod, connection, (RetryableOutputStream) requestBody);\n+        httpEngine \u003d newHttpEngine(retryMethod, connection, (RetryableSink) requestBody);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "dac5aed3d5f9307b9d1ab0a8c7840b232d053ef3": {
      "type": "Ybodychange",
      "commitMessage": "Move connection pooling logic.\n\nPreviously we had this ugly, awkward release() method that\nattempted to manage connection pooling, discarding streams\nfor caching, and closing broken streams.\n\nMove connection reuse to HttpConnection, with policy informed\nby HttpEngine. It specifies what to do when the connection\nbecomes idle: pool, close or hold. The connection does what\nit\u0027s told.\n",
      "commitDate": "2014/2/16 上午7:44",
      "commitName": "dac5aed3d5f9307b9d1ab0a8c7840b232d053ef3",
      "commitAuthor": "jwilson",
      "commitDateOld": "2014/1/27 上午7:09",
      "commitNameOld": "32a2b1d8d000a19d4a340cc1d77a68973a9d65dc",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 20.02,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "actualSource": "private HttpEngine getResponse() throws IOException {\n    initHttpEngine();\n    if (httpEngine.hasResponse()) {\n        return httpEngine;\n    }\n    while (true) {\n        if (!execute(true)) {\n            continue;\n        }\n        Retry retry \u003d processResponseHeaders();\n        if (retry \u003d\u003d Retry.NONE) {\n            httpEngine.releaseConnection();\n            return httpEngine;\n        }\n        String retryMethod \u003d method;\n        OutputStream requestBody \u003d httpEngine.getRequestBody();\n        int responseCode \u003d httpEngine.getResponse().code();\n        if (responseCode \u003d\u003d HTTP_MULT_CHOICE || responseCode \u003d\u003d HTTP_MOVED_PERM || responseCode \u003d\u003d HTTP_MOVED_TEMP || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n            retryMethod \u003d \"GET\";\n            requestHeaders.removeAll(\"Content-Length\");\n            requestBody \u003d null;\n        }\n        if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableOutputStream)) {\n            throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n        }\n        if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n            httpEngine.releaseConnection();\n        }\n        Connection connection \u003d httpEngine.close();\n        httpEngine \u003d newHttpEngine(retryMethod, connection, (RetryableOutputStream) requestBody);\n    }\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java",
      "functionStartLine": 308,
      "functionName": "getResponse",
      "functionAnnotation": "",
      "functionDoc": "Aggressively tries to get the final HTTP response, potentially making\nmany HTTP requests in the process in order to cope with redirects and\nauthentication.\n",
      "diff": "@@ -1,32 +1,32 @@\n private HttpEngine getResponse() throws IOException {\n     initHttpEngine();\n     if (httpEngine.hasResponse()) {\n         return httpEngine;\n     }\n     while (true) {\n         if (!execute(true)) {\n             continue;\n         }\n         Retry retry \u003d processResponseHeaders();\n         if (retry \u003d\u003d Retry.NONE) {\n-            httpEngine.automaticallyReleaseConnectionToPool();\n+            httpEngine.releaseConnection();\n             return httpEngine;\n         }\n         String retryMethod \u003d method;\n         OutputStream requestBody \u003d httpEngine.getRequestBody();\n         int responseCode \u003d httpEngine.getResponse().code();\n         if (responseCode \u003d\u003d HTTP_MULT_CHOICE || responseCode \u003d\u003d HTTP_MOVED_PERM || responseCode \u003d\u003d HTTP_MOVED_TEMP || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n             retryMethod \u003d \"GET\";\n             requestHeaders.removeAll(\"Content-Length\");\n             requestBody \u003d null;\n         }\n         if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableOutputStream)) {\n             throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n         }\n         if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n-            httpEngine.automaticallyReleaseConnectionToPool();\n+            httpEngine.releaseConnection();\n         }\n-        httpEngine.release(false);\n-        httpEngine \u003d newHttpEngine(retryMethod, httpEngine.getConnection(), (RetryableOutputStream) requestBody);\n+        Connection connection \u003d httpEngine.close();\n+        httpEngine \u003d newHttpEngine(retryMethod, connection, (RetryableOutputStream) requestBody);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4831a8dc6577f762e0f21fd15dd9700fe824740d": {
      "type": "Ybodychange",
      "commitMessage": "Rename RawHeaders to Headers.\n\nNow that Request and Response self-describe, I think the\nword Headers is sufficient. And it\u0027s a lot less ugly than\nRawHeaders.\n\nAlso move header serialization code to HttpTransport and\nSpdyTransport.\n",
      "commitDate": "2013/12/31 下午2:58",
      "commitName": "4831a8dc6577f762e0f21fd15dd9700fe824740d",
      "commitAuthor": "jwilson",
      "commitDateOld": "2013/12/31 下午2:15",
      "commitNameOld": "60f20dc23cb08d598d605f51f7526725ec42abd9",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private HttpEngine getResponse() throws IOException {\n    initHttpEngine();\n    if (httpEngine.hasResponse()) {\n        return httpEngine;\n    }\n    while (true) {\n        if (!execute(true)) {\n            continue;\n        }\n        Retry retry \u003d processResponseHeaders();\n        if (retry \u003d\u003d Retry.NONE) {\n            httpEngine.automaticallyReleaseConnectionToPool();\n            return httpEngine;\n        }\n        String retryMethod \u003d method;\n        OutputStream requestBody \u003d httpEngine.getRequestBody();\n        int responseCode \u003d httpEngine.getResponse().code();\n        if (responseCode \u003d\u003d HTTP_MULT_CHOICE || responseCode \u003d\u003d HTTP_MOVED_PERM || responseCode \u003d\u003d HTTP_MOVED_TEMP || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n            retryMethod \u003d \"GET\";\n            requestHeaders.removeAll(\"Content-Length\");\n            requestBody \u003d null;\n        }\n        if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableOutputStream)) {\n            throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n        }\n        if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n            httpEngine.automaticallyReleaseConnectionToPool();\n        }\n        httpEngine.release(false);\n        httpEngine \u003d newHttpEngine(retryMethod, httpEngine.getConnection(), (RetryableOutputStream) requestBody);\n    }\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java",
      "functionStartLine": 293,
      "functionName": "getResponse",
      "functionAnnotation": "",
      "functionDoc": "Aggressively tries to get the final HTTP response, potentially making\nmany HTTP requests in the process in order to cope with redirects and\nauthentication.\n",
      "diff": "@@ -1,32 +1,32 @@\n private HttpEngine getResponse() throws IOException {\n     initHttpEngine();\n     if (httpEngine.hasResponse()) {\n         return httpEngine;\n     }\n     while (true) {\n         if (!execute(true)) {\n             continue;\n         }\n         Retry retry \u003d processResponseHeaders();\n         if (retry \u003d\u003d Retry.NONE) {\n             httpEngine.automaticallyReleaseConnectionToPool();\n             return httpEngine;\n         }\n         String retryMethod \u003d method;\n         OutputStream requestBody \u003d httpEngine.getRequestBody();\n-        int responseCode \u003d httpEngine.getResponseCode();\n+        int responseCode \u003d httpEngine.getResponse().code();\n         if (responseCode \u003d\u003d HTTP_MULT_CHOICE || responseCode \u003d\u003d HTTP_MOVED_PERM || responseCode \u003d\u003d HTTP_MOVED_TEMP || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n             retryMethod \u003d \"GET\";\n             requestHeaders.removeAll(\"Content-Length\");\n             requestBody \u003d null;\n         }\n         if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableOutputStream)) {\n             throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n         }\n         if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n             httpEngine.automaticallyReleaseConnectionToPool();\n         }\n         httpEngine.release(false);\n         httpEngine \u003d newHttpEngine(retryMethod, httpEngine.getConnection(), (RetryableOutputStream) requestBody);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "350c43b6fe02401a73f967d9ef322061638b372a": {
      "type": "Ybodychange",
      "commitMessage": "Make RawHeaders, RequestHeaders and ResponseHeaders immutable.\n\nThis introduces a new, poorly-named class ResponseStrategy\nthat pulls some code out of ResponseHeaders. That was necessary\nbecause the old method mutated itself and its parameters in\nplace.\n\nObvious follow-up for this is to combine ResponseHeaders with\nResponse, and RequestHeaders with Response.\n",
      "commitDate": "2013/12/30 上午10:17",
      "commitName": "350c43b6fe02401a73f967d9ef322061638b372a",
      "commitAuthor": "jwilson",
      "commitDateOld": "2013/12/30 上午7:57",
      "commitNameOld": "30ecba897fb624df201f0a014b54a604418a0e73",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private HttpEngine getResponse() throws IOException {\n    initHttpEngine();\n    if (httpEngine.hasResponse()) {\n        return httpEngine;\n    }\n    while (true) {\n        if (!execute(true)) {\n            continue;\n        }\n        Retry retry \u003d processResponseHeaders();\n        if (retry \u003d\u003d Retry.NONE) {\n            httpEngine.automaticallyReleaseConnectionToPool();\n            return httpEngine;\n        }\n        String retryMethod \u003d method;\n        OutputStream requestBody \u003d httpEngine.getRequestBody();\n        int responseCode \u003d httpEngine.getResponseCode();\n        if (responseCode \u003d\u003d HTTP_MULT_CHOICE || responseCode \u003d\u003d HTTP_MOVED_PERM || responseCode \u003d\u003d HTTP_MOVED_TEMP || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n            retryMethod \u003d \"GET\";\n            requestHeaders.removeAll(\"Content-Length\");\n            requestBody \u003d null;\n        }\n        if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableOutputStream)) {\n            throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n        }\n        if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n            httpEngine.automaticallyReleaseConnectionToPool();\n        }\n        httpEngine.release(false);\n        httpEngine \u003d newHttpEngine(retryMethod, httpEngine.getConnection(), (RetryableOutputStream) requestBody);\n    }\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java",
      "functionStartLine": 284,
      "functionName": "getResponse",
      "functionAnnotation": "",
      "functionDoc": "Aggressively tries to get the final HTTP response, potentially making\nmany HTTP requests in the process in order to cope with redirects and\nauthentication.\n",
      "diff": "@@ -1,34 +1,32 @@\n private HttpEngine getResponse() throws IOException {\n     initHttpEngine();\n     if (httpEngine.hasResponse()) {\n         return httpEngine;\n     }\n     while (true) {\n         if (!execute(true)) {\n             continue;\n         }\n         Retry retry \u003d processResponseHeaders();\n         if (retry \u003d\u003d Retry.NONE) {\n             httpEngine.automaticallyReleaseConnectionToPool();\n             return httpEngine;\n         }\n         String retryMethod \u003d method;\n         OutputStream requestBody \u003d httpEngine.getRequestBody();\n         int responseCode \u003d httpEngine.getResponseCode();\n         if (responseCode \u003d\u003d HTTP_MULT_CHOICE || responseCode \u003d\u003d HTTP_MOVED_PERM || responseCode \u003d\u003d HTTP_MOVED_TEMP || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n             retryMethod \u003d \"GET\";\n+            requestHeaders.removeAll(\"Content-Length\");\n             requestBody \u003d null;\n         }\n         if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableOutputStream)) {\n             throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n         }\n         if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n             httpEngine.automaticallyReleaseConnectionToPool();\n         }\n         httpEngine.release(false);\n-        httpEngine \u003d newHttpEngine(retryMethod, rawRequestHeaders, httpEngine.getConnection(), (RetryableOutputStream) requestBody);\n-        if (requestBody \u003d\u003d null) {\n-            httpEngine.getRequestHeaders().removeContentLength();\n-        }\n+        httpEngine \u003d newHttpEngine(retryMethod, httpEngine.getConnection(), (RetryableOutputStream) requestBody);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "37c01895cca5ec2bec26a3d381611f0938acd6d0": {
      "type": "Ybodychange",
      "commitMessage": "Define async APIs and switch Job to use HttpEngine directly.\n\nUsing HttpEngine directly introduces some duplicated code with\nHttpURLConnection. It also breaks the response cache. I think\nthis is the best route going forward; and eventually we could\ninvert this relationship to have HttpURLConnection depending on\nJob directly rather than vice versa.\n",
      "commitDate": "2013/12/29 上午9:24",
      "commitName": "37c01895cca5ec2bec26a3d381611f0938acd6d0",
      "commitAuthor": "jwilson",
      "commitDateOld": "2013/11/1 上午5:17",
      "commitNameOld": "adec488f99795bcba135cbbdb1b9821880425b4c",
      "commitAuthorOld": "Jon Watson",
      "daysBetweenCommits": 58.17,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "actualSource": "private HttpEngine getResponse() throws IOException {\n    initHttpEngine();\n    if (httpEngine.hasResponse()) {\n        return httpEngine;\n    }\n    while (true) {\n        if (!execute(true)) {\n            continue;\n        }\n        Retry retry \u003d processResponseHeaders();\n        if (retry \u003d\u003d Retry.NONE) {\n            httpEngine.automaticallyReleaseConnectionToPool();\n            return httpEngine;\n        }\n        String retryMethod \u003d method;\n        OutputStream requestBody \u003d httpEngine.getRequestBody();\n        int responseCode \u003d httpEngine.getResponseCode();\n        if (responseCode \u003d\u003d HTTP_MULT_CHOICE || responseCode \u003d\u003d HTTP_MOVED_PERM || responseCode \u003d\u003d HTTP_MOVED_TEMP || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n            retryMethod \u003d \"GET\";\n            requestBody \u003d null;\n        }\n        if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableOutputStream)) {\n            throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n        }\n        if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n            httpEngine.automaticallyReleaseConnectionToPool();\n        }\n        httpEngine.release(false);\n        httpEngine \u003d newHttpEngine(retryMethod, rawRequestHeaders, httpEngine.getConnection(), (RetryableOutputStream) requestBody);\n        if (requestBody \u003d\u003d null) {\n            httpEngine.getRequestHeaders().removeContentLength();\n        }\n    }\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java",
      "functionStartLine": 289,
      "functionName": "getResponse",
      "functionAnnotation": "",
      "functionDoc": "Aggressively tries to get the final HTTP response, potentially making\nmany HTTP requests in the process in order to cope with redirects and\nauthentication.\n",
      "diff": "@@ -1,34 +1,34 @@\n private HttpEngine getResponse() throws IOException {\n     initHttpEngine();\n     if (httpEngine.hasResponse()) {\n         return httpEngine;\n     }\n     while (true) {\n         if (!execute(true)) {\n             continue;\n         }\n         Retry retry \u003d processResponseHeaders();\n         if (retry \u003d\u003d Retry.NONE) {\n             httpEngine.automaticallyReleaseConnectionToPool();\n             return httpEngine;\n         }\n         String retryMethod \u003d method;\n         OutputStream requestBody \u003d httpEngine.getRequestBody();\n-        int responseCode \u003d getResponseCode();\n+        int responseCode \u003d httpEngine.getResponseCode();\n         if (responseCode \u003d\u003d HTTP_MULT_CHOICE || responseCode \u003d\u003d HTTP_MOVED_PERM || responseCode \u003d\u003d HTTP_MOVED_TEMP || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n             retryMethod \u003d \"GET\";\n             requestBody \u003d null;\n         }\n         if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableOutputStream)) {\n-            throw new HttpRetryException(\"Cannot retry streamed HTTP body\", httpEngine.getResponseCode());\n+            throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n         }\n         if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n             httpEngine.automaticallyReleaseConnectionToPool();\n         }\n         httpEngine.release(false);\n         httpEngine \u003d newHttpEngine(retryMethod, rawRequestHeaders, httpEngine.getConnection(), (RetryableOutputStream) requestBody);\n         if (requestBody \u003d\u003d null) {\n             httpEngine.getRequestHeaders().removeContentLength();\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a948ffce1eb2b9ec46069722f6744f252d6dbfc7": {
      "type": "Ybodychange",
      "commitMessage": "Drop Content-Length when redirected from POST to GET.\n\nhttps://github.com/square/okhttp/issues/296\n",
      "commitDate": "2013/8/25 上午2:11",
      "commitName": "a948ffce1eb2b9ec46069722f6744f252d6dbfc7",
      "commitAuthor": "jwilson",
      "commitDateOld": "2013/7/20 下午11:13",
      "commitNameOld": "de1b5f244df1e29c457fdd87e91b9919c2336da7",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 35.12,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "actualSource": "private HttpEngine getResponse() throws IOException {\n    initHttpEngine();\n    if (httpEngine.hasResponse()) {\n        return httpEngine;\n    }\n    while (true) {\n        if (!execute(true)) {\n            continue;\n        }\n        Retry retry \u003d processResponseHeaders();\n        if (retry \u003d\u003d Retry.NONE) {\n            httpEngine.automaticallyReleaseConnectionToPool();\n            return httpEngine;\n        }\n        String retryMethod \u003d method;\n        OutputStream requestBody \u003d httpEngine.getRequestBody();\n        int responseCode \u003d getResponseCode();\n        if (responseCode \u003d\u003d HTTP_MULT_CHOICE || responseCode \u003d\u003d HTTP_MOVED_PERM || responseCode \u003d\u003d HTTP_MOVED_TEMP || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n            retryMethod \u003d \"GET\";\n            requestBody \u003d null;\n        }\n        if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableOutputStream)) {\n            throw new HttpRetryException(\"Cannot retry streamed HTTP body\", httpEngine.getResponseCode());\n        }\n        if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n            httpEngine.automaticallyReleaseConnectionToPool();\n        }\n        httpEngine.release(false);\n        httpEngine \u003d newHttpEngine(retryMethod, rawRequestHeaders, httpEngine.getConnection(), (RetryableOutputStream) requestBody);\n        if (requestBody \u003d\u003d null) {\n            httpEngine.getRequestHeaders().removeContentLength();\n        }\n    }\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java",
      "functionStartLine": 287,
      "functionName": "getResponse",
      "functionAnnotation": "",
      "functionDoc": "Aggressively tries to get the final HTTP response, potentially making\nmany HTTP requests in the process in order to cope with redirects and\nauthentication.\n",
      "diff": "@@ -1,31 +1,34 @@\n private HttpEngine getResponse() throws IOException {\n     initHttpEngine();\n     if (httpEngine.hasResponse()) {\n         return httpEngine;\n     }\n     while (true) {\n         if (!execute(true)) {\n             continue;\n         }\n         Retry retry \u003d processResponseHeaders();\n         if (retry \u003d\u003d Retry.NONE) {\n             httpEngine.automaticallyReleaseConnectionToPool();\n             return httpEngine;\n         }\n         String retryMethod \u003d method;\n         OutputStream requestBody \u003d httpEngine.getRequestBody();\n         int responseCode \u003d getResponseCode();\n         if (responseCode \u003d\u003d HTTP_MULT_CHOICE || responseCode \u003d\u003d HTTP_MOVED_PERM || responseCode \u003d\u003d HTTP_MOVED_TEMP || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n             retryMethod \u003d \"GET\";\n             requestBody \u003d null;\n         }\n         if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableOutputStream)) {\n             throw new HttpRetryException(\"Cannot retry streamed HTTP body\", httpEngine.getResponseCode());\n         }\n         if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n             httpEngine.automaticallyReleaseConnectionToPool();\n         }\n         httpEngine.release(false);\n         httpEngine \u003d newHttpEngine(retryMethod, rawRequestHeaders, httpEngine.getConnection(), (RetryableOutputStream) requestBody);\n+        if (requestBody \u003d\u003d null) {\n+            httpEngine.getRequestHeaders().removeContentLength();\n+        }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7ccbf48838b7cfe42759c67790636d442ea5daa3": {
      "type": "Yfilerename",
      "commitMessage": "Move library into a module. Introduce sample module with simple GitHub client.\n",
      "commitDate": "2013/3/26 上午11:04",
      "commitName": "7ccbf48838b7cfe42759c67790636d442ea5daa3",
      "commitAuthor": "Jake Wharton",
      "commitDateOld": "2013/3/15 下午10:39",
      "commitNameOld": "ba2b7432cb9fabfc725b09a9f14878cb128ef208",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 10.52,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private HttpEngine getResponse() throws IOException {\n    initHttpEngine();\n    if (httpEngine.hasResponse()) {\n        return httpEngine;\n    }\n    while (true) {\n        if (!execute(true)) {\n            continue;\n        }\n        Retry retry \u003d processResponseHeaders();\n        if (retry \u003d\u003d Retry.NONE) {\n            httpEngine.automaticallyReleaseConnectionToPool();\n            return httpEngine;\n        }\n        String retryMethod \u003d method;\n        OutputStream requestBody \u003d httpEngine.getRequestBody();\n        int responseCode \u003d getResponseCode();\n        if (responseCode \u003d\u003d HTTP_MULT_CHOICE || responseCode \u003d\u003d HTTP_MOVED_PERM || responseCode \u003d\u003d HTTP_MOVED_TEMP || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n            retryMethod \u003d \"GET\";\n            requestBody \u003d null;\n        }\n        if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableOutputStream)) {\n            throw new HttpRetryException(\"Cannot retry streamed HTTP body\", httpEngine.getResponseCode());\n        }\n        if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n            httpEngine.automaticallyReleaseConnectionToPool();\n        }\n        httpEngine.release(false);\n        httpEngine \u003d newHttpEngine(retryMethod, rawRequestHeaders, httpEngine.getConnection(), (RetryableOutputStream) requestBody);\n    }\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java",
      "functionStartLine": 293,
      "functionName": "getResponse",
      "functionAnnotation": "",
      "functionDoc": "Aggressively tries to get the final HTTP response, potentially making\nmany HTTP requests in the process in order to cope with redirects and\nauthentication.\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java",
        "newPath": "okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java"
      }
    },
    "7e7a3896df109ef442af9ec69423c33ec667c9f5": {
      "type": "Ybodychange",
      "commitMessage": "Switch to Square style for comments.\n",
      "commitDate": "2013/2/2 上午12:13",
      "commitName": "7e7a3896df109ef442af9ec69423c33ec667c9f5",
      "commitAuthor": "jwilson",
      "commitDateOld": "2013/2/1 上午6:36",
      "commitNameOld": "2d45a13249943cafa73460b35c3c366e5742eb6f",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 0.73,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "private HttpEngine getResponse() throws IOException {\n    initHttpEngine();\n    if (httpEngine.hasResponse()) {\n        return httpEngine;\n    }\n    while (true) {\n        if (!execute(true)) {\n            continue;\n        }\n        Retry retry \u003d processResponseHeaders();\n        if (retry \u003d\u003d Retry.NONE) {\n            httpEngine.automaticallyReleaseConnectionToPool();\n            return httpEngine;\n        }\n        String retryMethod \u003d method;\n        OutputStream requestBody \u003d httpEngine.getRequestBody();\n        int responseCode \u003d getResponseCode();\n        if (responseCode \u003d\u003d HTTP_MULT_CHOICE || responseCode \u003d\u003d HTTP_MOVED_PERM || responseCode \u003d\u003d HTTP_MOVED_TEMP || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n            retryMethod \u003d \"GET\";\n            requestBody \u003d null;\n        }\n        if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableOutputStream)) {\n            throw new HttpRetryException(\"Cannot retry streamed HTTP body\", httpEngine.getResponseCode());\n        }\n        if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n            httpEngine.automaticallyReleaseConnectionToPool();\n        }\n        httpEngine.release(false);\n        httpEngine \u003d newHttpEngine(retryMethod, rawRequestHeaders, httpEngine.getConnection(), (RetryableOutputStream) requestBody);\n    }\n}",
      "path": "src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java",
      "functionStartLine": 277,
      "functionName": "getResponse",
      "functionAnnotation": "",
      "functionDoc": "Aggressively tries to get the final HTTP response, potentially making\nmany HTTP requests in the process in order to cope with redirects and\nauthentication.\n",
      "diff": "",
      "extendedDetails": {}
    },
    "6f6d959fdae64065521990413f86bc7ab038d7c1": {
      "type": "Ybodychange",
      "commitMessage": "Improvements to connection pool\n",
      "commitDate": "2013/2/1 上午6:23",
      "commitName": "6f6d959fdae64065521990413f86bc7ab038d7c1",
      "commitAuthor": "Marcelo Cortes",
      "commitDateOld": "2013/1/31 下午1:55",
      "commitNameOld": "83de4eb552994d30451f8a3481b5a00d6b457a2e",
      "commitAuthorOld": "",
      "daysBetweenCommits": 0.69,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private HttpEngine getResponse() throws IOException {\n    initHttpEngine();\n    if (httpEngine.hasResponse()) {\n        return httpEngine;\n    }\n    while (true) {\n        if (!execute(true)) {\n            continue;\n        }\n        Retry retry \u003d processResponseHeaders();\n        if (retry \u003d\u003d Retry.NONE) {\n            httpEngine.automaticallyReleaseConnectionToPool();\n            return httpEngine;\n        }\n        String retryMethod \u003d method;\n        OutputStream requestBody \u003d httpEngine.getRequestBody();\n        int responseCode \u003d getResponseCode();\n        if (responseCode \u003d\u003d HTTP_MULT_CHOICE || responseCode \u003d\u003d HTTP_MOVED_PERM || responseCode \u003d\u003d HTTP_MOVED_TEMP || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n            retryMethod \u003d \"GET\";\n            requestBody \u003d null;\n        }\n        if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableOutputStream)) {\n            throw new HttpRetryException(\"Cannot retry streamed HTTP body\", httpEngine.getResponseCode());\n        }\n        if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n            httpEngine.automaticallyReleaseConnectionToPool();\n        }\n        httpEngine.release(false);\n        httpEngine \u003d newHttpEngine(retryMethod, rawRequestHeaders, httpEngine.getConnection(), (RetryableOutputStream) requestBody);\n    }\n}",
      "path": "src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java",
      "functionStartLine": 286,
      "functionName": "getResponse",
      "functionAnnotation": "",
      "functionDoc": "Aggressively tries to get the final HTTP response, potentially making\nmany HTTP requests in the process in order to cope with redirects and\nauthentication.\n",
      "diff": "@@ -1,33 +1,31 @@\n private HttpEngine getResponse() throws IOException {\n     initHttpEngine();\n     if (httpEngine.hasResponse()) {\n         return httpEngine;\n     }\n     while (true) {\n         if (!execute(true)) {\n             continue;\n         }\n         Retry retry \u003d processResponseHeaders();\n         if (retry \u003d\u003d Retry.NONE) {\n             httpEngine.automaticallyReleaseConnectionToPool();\n             return httpEngine;\n         }\n         String retryMethod \u003d method;\n         OutputStream requestBody \u003d httpEngine.getRequestBody();\n         int responseCode \u003d getResponseCode();\n         if (responseCode \u003d\u003d HTTP_MULT_CHOICE || responseCode \u003d\u003d HTTP_MOVED_PERM || responseCode \u003d\u003d HTTP_MOVED_TEMP || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n             retryMethod \u003d \"GET\";\n             requestBody \u003d null;\n         }\n         if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableOutputStream)) {\n             throw new HttpRetryException(\"Cannot retry streamed HTTP body\", httpEngine.getResponseCode());\n         }\n         if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n             httpEngine.automaticallyReleaseConnectionToPool();\n-        } else if (retry \u003d\u003d Retry.SAME_CONNECTION \u0026\u0026 httpEngine.getConnection() !\u003d null) {\n-            httpEngine.getConnection().setRecycled();\n         }\n         httpEngine.release(false);\n         httpEngine \u003d newHttpEngine(retryMethod, rawRequestHeaders, httpEngine.getConnection(), (RetryableOutputStream) requestBody);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "637783ce8ae3ffb9805c2f78b436703c29b2220a": {
      "type": "Ybodychange",
      "commitMessage": "Retry if a request fails after a redirect.\n\nhttps://code.google.com/p/android/issues/detail?id\u003d41576\n",
      "commitDate": "2013/1/31 下午1:05",
      "commitName": "637783ce8ae3ffb9805c2f78b436703c29b2220a",
      "commitAuthor": "jwilson",
      "commitDateOld": "2013/1/23 上午5:14",
      "commitNameOld": "194290e5f3819bf91d87c5d08c152946b6aa3509",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 8.33,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "private HttpEngine getResponse() throws IOException {\n    initHttpEngine();\n    if (httpEngine.hasResponse()) {\n        return httpEngine;\n    }\n    while (true) {\n        if (!execute(true)) {\n            continue;\n        }\n        Retry retry \u003d processResponseHeaders();\n        if (retry \u003d\u003d Retry.NONE) {\n            httpEngine.automaticallyReleaseConnectionToPool();\n            return httpEngine;\n        }\n        String retryMethod \u003d method;\n        OutputStream requestBody \u003d httpEngine.getRequestBody();\n        int responseCode \u003d getResponseCode();\n        if (responseCode \u003d\u003d HTTP_MULT_CHOICE || responseCode \u003d\u003d HTTP_MOVED_PERM || responseCode \u003d\u003d HTTP_MOVED_TEMP || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n            retryMethod \u003d \"GET\";\n            requestBody \u003d null;\n        }\n        if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableOutputStream)) {\n            throw new HttpRetryException(\"Cannot retry streamed HTTP body\", httpEngine.getResponseCode());\n        }\n        if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n            httpEngine.automaticallyReleaseConnectionToPool();\n        } else if (retry \u003d\u003d Retry.SAME_CONNECTION \u0026\u0026 httpEngine.getConnection() !\u003d null) {\n            httpEngine.getConnection().setRecycled();\n        }\n        httpEngine.release(false);\n        httpEngine \u003d newHttpEngine(retryMethod, rawRequestHeaders, httpEngine.getConnection(), (RetryableOutputStream) requestBody);\n    }\n}",
      "path": "src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java",
      "functionStartLine": 286,
      "functionName": "getResponse",
      "functionAnnotation": "",
      "functionDoc": "Aggressively tries to get the final HTTP response, potentially making\nmany HTTP requests in the process in order to cope with redirects and\nauthentication.\n",
      "diff": "@@ -1,31 +1,33 @@\n private HttpEngine getResponse() throws IOException {\n     initHttpEngine();\n     if (httpEngine.hasResponse()) {\n         return httpEngine;\n     }\n     while (true) {\n         if (!execute(true)) {\n             continue;\n         }\n         Retry retry \u003d processResponseHeaders();\n         if (retry \u003d\u003d Retry.NONE) {\n             httpEngine.automaticallyReleaseConnectionToPool();\n             return httpEngine;\n         }\n         String retryMethod \u003d method;\n         OutputStream requestBody \u003d httpEngine.getRequestBody();\n         int responseCode \u003d getResponseCode();\n         if (responseCode \u003d\u003d HTTP_MULT_CHOICE || responseCode \u003d\u003d HTTP_MOVED_PERM || responseCode \u003d\u003d HTTP_MOVED_TEMP || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n             retryMethod \u003d \"GET\";\n             requestBody \u003d null;\n         }\n         if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableOutputStream)) {\n             throw new HttpRetryException(\"Cannot retry streamed HTTP body\", httpEngine.getResponseCode());\n         }\n         if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n             httpEngine.automaticallyReleaseConnectionToPool();\n+        } else if (retry \u003d\u003d Retry.SAME_CONNECTION \u0026\u0026 httpEngine.getConnection() !\u003d null) {\n+            httpEngine.getConnection().setRecycled();\n         }\n         httpEngine.release(false);\n         httpEngine \u003d newHttpEngine(retryMethod, rawRequestHeaders, httpEngine.getConnection(), (RetryableOutputStream) requestBody);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "194290e5f3819bf91d87c5d08c152946b6aa3509": {
      "type": "Ybodychange",
      "commitMessage": "Improve SPDY+HTTP integration.\n\nWriting tests shook out a few bugs:\n - Pooling wasn\u0027t working well. We were trying to connect\n   after already having been connected.\n - We weren\u0027t writing response bodies to the cache.\n - We weren\u0027t capturing the request time for the cache.\n - MockSpdyServer wasn\u0027t trimming headers.\n\nNew files in this change aren\u0027t new, they\u0027re just inner classes promoted\nto top-level classes for better sharing.\n",
      "commitDate": "2013/1/23 上午5:14",
      "commitName": "194290e5f3819bf91d87c5d08c152946b6aa3509",
      "commitAuthor": "jwilson",
      "commitDateOld": "2013/1/2 上午11:50",
      "commitNameOld": "689f66222bd8984dd69229a4ee9caf8da528ae12",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 20.73,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "private HttpEngine getResponse() throws IOException {\n    initHttpEngine();\n    if (httpEngine.hasResponse()) {\n        return httpEngine;\n    }\n    while (true) {\n        if (!execute(true)) {\n            continue;\n        }\n        Retry retry \u003d processResponseHeaders();\n        if (retry \u003d\u003d Retry.NONE) {\n            httpEngine.automaticallyReleaseConnectionToPool();\n            return httpEngine;\n        }\n        String retryMethod \u003d method;\n        OutputStream requestBody \u003d httpEngine.getRequestBody();\n        int responseCode \u003d getResponseCode();\n        if (responseCode \u003d\u003d HTTP_MULT_CHOICE || responseCode \u003d\u003d HTTP_MOVED_PERM || responseCode \u003d\u003d HTTP_MOVED_TEMP || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n            retryMethod \u003d \"GET\";\n            requestBody \u003d null;\n        }\n        if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableOutputStream)) {\n            throw new HttpRetryException(\"Cannot retry streamed HTTP body\", httpEngine.getResponseCode());\n        }\n        if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n            httpEngine.automaticallyReleaseConnectionToPool();\n        }\n        httpEngine.release(false);\n        httpEngine \u003d newHttpEngine(retryMethod, rawRequestHeaders, httpEngine.getConnection(), (RetryableOutputStream) requestBody);\n    }\n}",
      "path": "src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java",
      "functionStartLine": 286,
      "functionName": "getResponse",
      "functionAnnotation": "",
      "functionDoc": "Aggressively tries to get the final HTTP response, potentially making\nmany HTTP requests in the process in order to cope with redirects and\nauthentication.\n",
      "diff": "@@ -1,31 +1,31 @@\n private HttpEngine getResponse() throws IOException {\n     initHttpEngine();\n     if (httpEngine.hasResponse()) {\n         return httpEngine;\n     }\n     while (true) {\n         if (!execute(true)) {\n             continue;\n         }\n         Retry retry \u003d processResponseHeaders();\n         if (retry \u003d\u003d Retry.NONE) {\n             httpEngine.automaticallyReleaseConnectionToPool();\n             return httpEngine;\n         }\n         String retryMethod \u003d method;\n         OutputStream requestBody \u003d httpEngine.getRequestBody();\n         int responseCode \u003d getResponseCode();\n         if (responseCode \u003d\u003d HTTP_MULT_CHOICE || responseCode \u003d\u003d HTTP_MOVED_PERM || responseCode \u003d\u003d HTTP_MOVED_TEMP || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n             retryMethod \u003d \"GET\";\n             requestBody \u003d null;\n         }\n         if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableOutputStream)) {\n             throw new HttpRetryException(\"Cannot retry streamed HTTP body\", httpEngine.getResponseCode());\n         }\n         if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n             httpEngine.automaticallyReleaseConnectionToPool();\n         }\n-        httpEngine.release(true);\n+        httpEngine.release(false);\n         httpEngine \u003d newHttpEngine(retryMethod, rawRequestHeaders, httpEngine.getConnection(), (RetryableOutputStream) requestBody);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "689f66222bd8984dd69229a4ee9caf8da528ae12": {
      "type": "Yfilerename",
      "commitMessage": "Flatten internal packages and utility classes.\n\nThe previous structure had hierarchy that was useful\nfor libcore but overkill for OkHttp.\n",
      "commitDate": "2013/1/2 上午11:50",
      "commitName": "689f66222bd8984dd69229a4ee9caf8da528ae12",
      "commitAuthor": "jwilson",
      "commitDateOld": "2013/1/2 上午11:27",
      "commitNameOld": "73516e6ab1d336ffd520e845e14f80cf08657bd0",
      "commitAuthorOld": "Jake Wharton",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private HttpEngine getResponse() throws IOException {\n    initHttpEngine();\n    if (httpEngine.hasResponse()) {\n        return httpEngine;\n    }\n    while (true) {\n        if (!execute(true)) {\n            continue;\n        }\n        Retry retry \u003d processResponseHeaders();\n        if (retry \u003d\u003d Retry.NONE) {\n            httpEngine.automaticallyReleaseConnectionToPool();\n            return httpEngine;\n        }\n        String retryMethod \u003d method;\n        OutputStream requestBody \u003d httpEngine.getRequestBody();\n        int responseCode \u003d getResponseCode();\n        if (responseCode \u003d\u003d HTTP_MULT_CHOICE || responseCode \u003d\u003d HTTP_MOVED_PERM || responseCode \u003d\u003d HTTP_MOVED_TEMP || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n            retryMethod \u003d \"GET\";\n            requestBody \u003d null;\n        }\n        if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableOutputStream)) {\n            throw new HttpRetryException(\"Cannot retry streamed HTTP body\", httpEngine.getResponseCode());\n        }\n        if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n            httpEngine.automaticallyReleaseConnectionToPool();\n        }\n        httpEngine.release(true);\n        httpEngine \u003d newHttpEngine(retryMethod, rawRequestHeaders, httpEngine.getConnection(), (RetryableOutputStream) requestBody);\n    }\n}",
      "path": "src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java",
      "functionStartLine": 286,
      "functionName": "getResponse",
      "functionAnnotation": "",
      "functionDoc": "Aggressively tries to get the final HTTP response, potentially making\nmany HTTP requests in the process in order to cope with redirects and\nauthentication.\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/main/java/com/squareup/okhttp/internal/net/http/HttpURLConnectionImpl.java",
        "newPath": "src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java"
      }
    },
    "67604f618d96ae00318ce696ec29a66bec6aafa8": {
      "type": "Ybodychange",
      "commitMessage": "Clean up utility code for submission to AOSP.\n\nThis moves methods that will have Android-specific implementations\nto Platform.java; all other utility methods are in a junk drawer\nclass called Utils.java.\n\nThis also moves method names (like \"GET\") to compare with .equals\ninstead of \u0027\u003d\u003d\u0027. The old code took advantage of a hidden agreement\nbetween HttpURLConnection and HttpEngine; with these in separate\nprojects that behavior isn\u0027t as obvious and shouldn\u0027t be relied\nupon.\n",
      "commitDate": "2012/12/27 上午2:31",
      "commitName": "67604f618d96ae00318ce696ec29a66bec6aafa8",
      "commitAuthor": "jwilson",
      "commitDateOld": "2012/12/24 下午1:39",
      "commitNameOld": "78c6624b11d5f33504dae8211b4592383468343e",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 2.54,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private HttpEngine getResponse() throws IOException {\n    initHttpEngine();\n    if (httpEngine.hasResponse()) {\n        return httpEngine;\n    }\n    while (true) {\n        if (!execute(true)) {\n            continue;\n        }\n        Retry retry \u003d processResponseHeaders();\n        if (retry \u003d\u003d Retry.NONE) {\n            httpEngine.automaticallyReleaseConnectionToPool();\n            return httpEngine;\n        }\n        String retryMethod \u003d method;\n        OutputStream requestBody \u003d httpEngine.getRequestBody();\n        int responseCode \u003d getResponseCode();\n        if (responseCode \u003d\u003d HTTP_MULT_CHOICE || responseCode \u003d\u003d HTTP_MOVED_PERM || responseCode \u003d\u003d HTTP_MOVED_TEMP || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n            retryMethod \u003d \"GET\";\n            requestBody \u003d null;\n        }\n        if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableOutputStream)) {\n            throw new HttpRetryException(\"Cannot retry streamed HTTP body\", httpEngine.getResponseCode());\n        }\n        if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n            httpEngine.automaticallyReleaseConnectionToPool();\n        }\n        httpEngine.release(true);\n        httpEngine \u003d newHttpEngine(retryMethod, rawRequestHeaders, httpEngine.getConnection(), (RetryableOutputStream) requestBody);\n    }\n}",
      "path": "src/main/java/com/squareup/okhttp/internal/net/http/HttpURLConnectionImpl.java",
      "functionStartLine": 286,
      "functionName": "getResponse",
      "functionAnnotation": "",
      "functionDoc": "Aggressively tries to get the final HTTP response, potentially making\nmany HTTP requests in the process in order to cope with redirects and\nauthentication.\n",
      "diff": "@@ -1,31 +1,31 @@\n private HttpEngine getResponse() throws IOException {\n     initHttpEngine();\n     if (httpEngine.hasResponse()) {\n         return httpEngine;\n     }\n     while (true) {\n         if (!execute(true)) {\n             continue;\n         }\n         Retry retry \u003d processResponseHeaders();\n         if (retry \u003d\u003d Retry.NONE) {\n             httpEngine.automaticallyReleaseConnectionToPool();\n             return httpEngine;\n         }\n         String retryMethod \u003d method;\n         OutputStream requestBody \u003d httpEngine.getRequestBody();\n         int responseCode \u003d getResponseCode();\n         if (responseCode \u003d\u003d HTTP_MULT_CHOICE || responseCode \u003d\u003d HTTP_MOVED_PERM || responseCode \u003d\u003d HTTP_MOVED_TEMP || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n-            retryMethod \u003d HttpEngine.GET;\n+            retryMethod \u003d \"GET\";\n             requestBody \u003d null;\n         }\n         if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableOutputStream)) {\n             throw new HttpRetryException(\"Cannot retry streamed HTTP body\", httpEngine.getResponseCode());\n         }\n         if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n             httpEngine.automaticallyReleaseConnectionToPool();\n         }\n         httpEngine.release(true);\n         httpEngine \u003d newHttpEngine(retryMethod, rawRequestHeaders, httpEngine.getConnection(), (RetryableOutputStream) requestBody);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "50999cceb5f5bcdaf79baa5ac7eeef90c72bda8d": {
      "type": "Yfilerename",
      "commitMessage": "Move out of the libcore package.\n\nTo promote the code into AOSP, we\u0027ll keep this package as-is\nand do the jarjar in Android instead.\n",
      "commitDate": "2012/12/16 上午5:55",
      "commitName": "50999cceb5f5bcdaf79baa5ac7eeef90c72bda8d",
      "commitAuthor": "jwilson",
      "commitDateOld": "2012/12/16 上午5:17",
      "commitNameOld": "7f7aa90bc5d41d8f818fc988d2a91d22393c7329",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private HttpEngine getResponse() throws IOException {\n    initHttpEngine();\n    if (httpEngine.hasResponse()) {\n        return httpEngine;\n    }\n    while (true) {\n        if (!execute(true)) {\n            continue;\n        }\n        Retry retry \u003d processResponseHeaders();\n        if (retry \u003d\u003d Retry.NONE) {\n            httpEngine.automaticallyReleaseConnectionToPool();\n            return httpEngine;\n        }\n        String retryMethod \u003d method;\n        OutputStream requestBody \u003d httpEngine.getRequestBody();\n        int responseCode \u003d getResponseCode();\n        if (responseCode \u003d\u003d HTTP_MULT_CHOICE || responseCode \u003d\u003d HTTP_MOVED_PERM || responseCode \u003d\u003d HTTP_MOVED_TEMP || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n            retryMethod \u003d HttpEngine.GET;\n            requestBody \u003d null;\n        }\n        if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableOutputStream)) {\n            throw new HttpRetryException(\"Cannot retry streamed HTTP body\", httpEngine.getResponseCode());\n        }\n        if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n            httpEngine.automaticallyReleaseConnectionToPool();\n        }\n        httpEngine.release(true);\n        httpEngine \u003d newHttpEngine(retryMethod, rawRequestHeaders, httpEngine.getConnection(), (RetryableOutputStream) requestBody);\n    }\n}",
      "path": "src/main/java/com/squareup/okhttp/internal/net/http/HttpURLConnectionImpl.java",
      "functionStartLine": 275,
      "functionName": "getResponse",
      "functionAnnotation": "",
      "functionDoc": "Aggressively tries to get the final HTTP response, potentially making\nmany HTTP requests in the process in order to cope with redirects and\nauthentication.\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/main/java/libcore/net/http/HttpURLConnectionImpl.java",
        "newPath": "src/main/java/com/squareup/okhttp/internal/net/http/HttpURLConnectionImpl.java"
      }
    },
    "3355d0c99bb946a6441f08fe6fd1c9881a9ea96a": {
      "type": "Ybodychange",
      "commitMessage": "New route selector to support multiple routes.\n",
      "commitDate": "2012/11/11 上午5:05",
      "commitName": "3355d0c99bb946a6441f08fe6fd1c9881a9ea96a",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "2012/11/6 下午12:25",
      "commitNameOld": "40ff76547064c3fb5acb9047a6f679dd4379a4d0",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 4.69,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "private HttpEngine getResponse() throws IOException {\n    initHttpEngine();\n    if (httpEngine.hasResponse()) {\n        return httpEngine;\n    }\n    while (true) {\n        if (!execute(true)) {\n            continue;\n        }\n        Retry retry \u003d processResponseHeaders();\n        if (retry \u003d\u003d Retry.NONE) {\n            httpEngine.automaticallyReleaseConnectionToPool();\n            return httpEngine;\n        }\n        String retryMethod \u003d method;\n        OutputStream requestBody \u003d httpEngine.getRequestBody();\n        int responseCode \u003d getResponseCode();\n        if (responseCode \u003d\u003d HTTP_MULT_CHOICE || responseCode \u003d\u003d HTTP_MOVED_PERM || responseCode \u003d\u003d HTTP_MOVED_TEMP || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n            retryMethod \u003d HttpEngine.GET;\n            requestBody \u003d null;\n        }\n        if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableOutputStream)) {\n            throw new HttpRetryException(\"Cannot retry streamed HTTP body\", httpEngine.getResponseCode());\n        }\n        if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n            httpEngine.automaticallyReleaseConnectionToPool();\n        }\n        httpEngine.release(true);\n        httpEngine \u003d newHttpEngine(retryMethod, rawRequestHeaders, httpEngine.getConnection(), (RetryableOutputStream) requestBody);\n    }\n}",
      "path": "src/main/java/libcore/net/http/HttpURLConnectionImpl.java",
      "functionStartLine": 272,
      "functionName": "getResponse",
      "functionAnnotation": "",
      "functionDoc": "Aggressively tries to get the final HTTP response, potentially making\nmany HTTP requests in the process in order to cope with redirects and\nauthentication.\n",
      "diff": "@@ -1,41 +1,31 @@\n private HttpEngine getResponse() throws IOException {\n     initHttpEngine();\n     if (httpEngine.hasResponse()) {\n         return httpEngine;\n     }\n     while (true) {\n-        try {\n-            httpEngine.sendRequest();\n-            httpEngine.readResponse();\n-        } catch (IOException e) {\n-            OutputStream requestBody \u003d httpEngine.getRequestBody();\n-            if (httpEngine.hasRecycledConnection() \u0026\u0026 (requestBody \u003d\u003d null || requestBody instanceof RetryableOutputStream)) {\n-                httpEngine.release(false);\n-                httpEngine \u003d newHttpEngine(method, rawRequestHeaders, null, (RetryableOutputStream) requestBody);\n-                continue;\n-            }\n-            httpEngineFailure \u003d e;\n-            throw e;\n+        if (!execute(true)) {\n+            continue;\n         }\n         Retry retry \u003d processResponseHeaders();\n         if (retry \u003d\u003d Retry.NONE) {\n             httpEngine.automaticallyReleaseConnectionToPool();\n             return httpEngine;\n         }\n         String retryMethod \u003d method;\n         OutputStream requestBody \u003d httpEngine.getRequestBody();\n         int responseCode \u003d getResponseCode();\n         if (responseCode \u003d\u003d HTTP_MULT_CHOICE || responseCode \u003d\u003d HTTP_MOVED_PERM || responseCode \u003d\u003d HTTP_MOVED_TEMP || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n             retryMethod \u003d HttpEngine.GET;\n             requestBody \u003d null;\n         }\n         if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableOutputStream)) {\n             throw new HttpRetryException(\"Cannot retry streamed HTTP body\", httpEngine.getResponseCode());\n         }\n         if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n             httpEngine.automaticallyReleaseConnectionToPool();\n         }\n         httpEngine.release(true);\n         httpEngine \u003d newHttpEngine(retryMethod, rawRequestHeaders, httpEngine.getConnection(), (RetryableOutputStream) requestBody);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ea63463c2ff8a67f63e541036f0d5998b5bb1f3e": {
      "type": "Yintroduced",
      "commitMessage": "Initial import.\n\nThis is a fork of okhttp from http://code.google.com/p/okhttp.\nI\u0027m moving it to Github since that\u0027s where my code reviewers\nare. I\u0027ve renamed the core package from com.google.okhttp to\ncom.squareup.okhttp because Square is where I expect ongoing\ndevelopment of this project to take place.\n\nAll code in this project is subject to be contributed upstream\nto AOSP. In particular, all code in the libcore package is\nderived from AOSP and intended to be contributed back to AOSP\non an ongoing basis.\n",
      "commitDate": "2012/7/23 下午10:02",
      "commitName": "ea63463c2ff8a67f63e541036f0d5998b5bb1f3e",
      "commitAuthor": "Jesse Wilson",
      "diff": "@@ -0,0 +1,41 @@\n+private HttpEngine getResponse() throws IOException {\n+    initHttpEngine();\n+    if (httpEngine.hasResponse()) {\n+        return httpEngine;\n+    }\n+    while (true) {\n+        try {\n+            httpEngine.sendRequest();\n+            httpEngine.readResponse();\n+        } catch (IOException e) {\n+            OutputStream requestBody \u003d httpEngine.getRequestBody();\n+            if (httpEngine.hasRecycledConnection() \u0026\u0026 (requestBody \u003d\u003d null || requestBody instanceof RetryableOutputStream)) {\n+                httpEngine.release(false);\n+                httpEngine \u003d newHttpEngine(method, rawRequestHeaders, null, (RetryableOutputStream) requestBody);\n+                continue;\n+            }\n+            httpEngineFailure \u003d e;\n+            throw e;\n+        }\n+        Retry retry \u003d processResponseHeaders();\n+        if (retry \u003d\u003d Retry.NONE) {\n+            httpEngine.automaticallyReleaseConnectionToPool();\n+            return httpEngine;\n+        }\n+        String retryMethod \u003d method;\n+        OutputStream requestBody \u003d httpEngine.getRequestBody();\n+        int responseCode \u003d getResponseCode();\n+        if (responseCode \u003d\u003d HTTP_MULT_CHOICE || responseCode \u003d\u003d HTTP_MOVED_PERM || responseCode \u003d\u003d HTTP_MOVED_TEMP || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n+            retryMethod \u003d HttpEngine.GET;\n+            requestBody \u003d null;\n+        }\n+        if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableOutputStream)) {\n+            throw new HttpRetryException(\"Cannot retry streamed HTTP body\", httpEngine.getResponseCode());\n+        }\n+        if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n+            httpEngine.automaticallyReleaseConnectionToPool();\n+        }\n+        httpEngine.release(true);\n+        httpEngine \u003d newHttpEngine(retryMethod, rawRequestHeaders, httpEngine.getConnection(), (RetryableOutputStream) requestBody);\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "private HttpEngine getResponse() throws IOException {\n    initHttpEngine();\n    if (httpEngine.hasResponse()) {\n        return httpEngine;\n    }\n    while (true) {\n        try {\n            httpEngine.sendRequest();\n            httpEngine.readResponse();\n        } catch (IOException e) {\n            OutputStream requestBody \u003d httpEngine.getRequestBody();\n            if (httpEngine.hasRecycledConnection() \u0026\u0026 (requestBody \u003d\u003d null || requestBody instanceof RetryableOutputStream)) {\n                httpEngine.release(false);\n                httpEngine \u003d newHttpEngine(method, rawRequestHeaders, null, (RetryableOutputStream) requestBody);\n                continue;\n            }\n            httpEngineFailure \u003d e;\n            throw e;\n        }\n        Retry retry \u003d processResponseHeaders();\n        if (retry \u003d\u003d Retry.NONE) {\n            httpEngine.automaticallyReleaseConnectionToPool();\n            return httpEngine;\n        }\n        String retryMethod \u003d method;\n        OutputStream requestBody \u003d httpEngine.getRequestBody();\n        int responseCode \u003d getResponseCode();\n        if (responseCode \u003d\u003d HTTP_MULT_CHOICE || responseCode \u003d\u003d HTTP_MOVED_PERM || responseCode \u003d\u003d HTTP_MOVED_TEMP || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n            retryMethod \u003d HttpEngine.GET;\n            requestBody \u003d null;\n        }\n        if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableOutputStream)) {\n            throw new HttpRetryException(\"Cannot retry streamed HTTP body\", httpEngine.getResponseCode());\n        }\n        if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n            httpEngine.automaticallyReleaseConnectionToPool();\n        }\n        httpEngine.release(true);\n        httpEngine \u003d newHttpEngine(retryMethod, rawRequestHeaders, httpEngine.getConnection(), (RetryableOutputStream) requestBody);\n    }\n}",
      "path": "src/main/java/libcore/net/http/HttpURLConnectionImpl.java",
      "functionStartLine": 271,
      "functionName": "getResponse",
      "functionAnnotation": "",
      "functionDoc": "Aggressively tries to get the final HTTP response, potentially making\nmany HTTP requests in the process in order to cope with redirects and\nauthentication.\n"
    }
  }
}