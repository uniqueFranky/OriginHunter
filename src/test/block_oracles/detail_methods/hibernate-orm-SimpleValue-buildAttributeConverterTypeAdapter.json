{
  "origin": "codeshovel",
  "repositoryName": "hibernate-orm",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/hibernate-orm/.git",
  "startCommitName": "8bd79b29cfa7b2d539a746dc356d60b66e1e596b",
  "sourceFileName": "SimpleValue.java",
  "functionName": "buildAttributeConverterTypeAdapter",
  "functionId": "buildAttributeConverterTypeAdapter",
  "sourceFilePath": "hibernate-core/src/main/java/org/hibernate/mapping/SimpleValue.java",
  "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
  "functionDoc": "Build a Hibernate Type that incorporates the JPA AttributeConverter.  AttributeConverter works totally in\nmemory, meaning it converts between one Java representation (the entity attribute representation) and another\n(the value bound into JDBC statements or extracted from results).  However, the Hibernate Type system operates\nat the lower level of actually dealing directly with those JDBC objects.  So even though we have an\nAttributeConverter, we still need to \"fill out\" the rest of the BasicType data and bridge calls\nto bind/extract through the converter.\n\u003cp/\u003e\nEssentially the idea here is that an intermediate Java type needs to be used.  Let\u0027s use an example as a means\nto illustrate...  Consider an {@code AttributeConverter\u003cInteger,String\u003e}.  This tells Hibernate that the domain\nmodel defines this attribute as an Integer value (the \u0027entityAttributeJavaType\u0027), but that we need to treat the\nvalue as a String (the \u0027databaseColumnJavaType\u0027) when dealing with JDBC (aka, the database type is a\nVARCHAR/CHAR):\u003cul\u003e\n    \u003cli\u003e\n        When binding values to PreparedStatements we need to convert the Integer value from the entity\n        into a String and pass that String to setString.  The conversion is handled by calling\n        {@link AttributeConverter#convertToDatabaseColumn(Object)}\n    \u003c/li\u003e\n    \u003cli\u003e\n        When extracting values from ResultSets (or CallableStatement parameters) we need to handle the\n        value via getString, and convert that returned String to an Integer.  That conversion is handled\n        by calling {@link AttributeConverter#convertToEntityAttribute(Object)}\n    \u003c/li\u003e\n\u003c/ul\u003e\n\n@return The built AttributeConverter -\u003e Type adapter\n@todo : ultimately I want to see attributeConverterJavaType and attributeConverterJdbcTypeCode specify-able separately\nthen we can \"play them against each other\" in terms of determining proper typing\n@todo : see if we already have previously built a custom on-the-fly BasicType for this AttributeConverter; see note below about caching\n",
  "functionStartLine": 565,
  "functionEndLine": 660,
  "numCommitsSeen": 46,
  "timeTaken": 3459,
  "changeHistory": [
    "c14180ea5b16b69cdd06eb5bb159f7da1ff4db54",
    "0d82dc7c8387a954edfa971af99c16a66e33c65a",
    "9229514ed407b1610a52ab7ba97806c435352ad2",
    "8f889e95d76f47945c9ec072fd08cb045767578c",
    "90cabb43ad8b186d73cb6b310fb2fd6774ffe44f",
    "9aa164ed27b8338f592dee504a5793bc4e5bbfd9",
    "0cf66b85e03a997dc94f8f82598ca8edac04e889",
    "3ac508882c89ebd7c80af71d0e65ba26a017ebe3",
    "38c004431d006ac5173d0c095f97415b5e6267a6",
    "22730624fc267cd12bf1e6551158fa3057fd8d58",
    "498735aa3791097e0fc25e918d47336f359fa5ae",
    "1f6daa67854e1fd6c464fe3d2a98bda1047b252d",
    "9f86babd880b785b965f7f1b55d58dc6a6943ada",
    "bf168ca24ef0c328bd53d6d32e79f66b99ac56db",
    "7bcf161d36d5b1e59fba1ae32e8e2d692c2fd33d"
  ],
  "changeHistoryShort": {
    "c14180ea5b16b69cdd06eb5bb159f7da1ff4db54": "Ybodychange",
    "0d82dc7c8387a954edfa971af99c16a66e33c65a": "Ybodychange",
    "9229514ed407b1610a52ab7ba97806c435352ad2": "Ybodychange",
    "8f889e95d76f47945c9ec072fd08cb045767578c": "Ybodychange",
    "90cabb43ad8b186d73cb6b310fb2fd6774ffe44f": "Ybodychange",
    "9aa164ed27b8338f592dee504a5793bc4e5bbfd9": "Ybodychange",
    "0cf66b85e03a997dc94f8f82598ca8edac04e889": "Ybodychange",
    "3ac508882c89ebd7c80af71d0e65ba26a017ebe3": "Ybodychange",
    "38c004431d006ac5173d0c095f97415b5e6267a6": "Ybodychange",
    "22730624fc267cd12bf1e6551158fa3057fd8d58": "Ybodychange",
    "498735aa3791097e0fc25e918d47336f359fa5ae": "Ybodychange",
    "1f6daa67854e1fd6c464fe3d2a98bda1047b252d": "Ybodychange",
    "9f86babd880b785b965f7f1b55d58dc6a6943ada": "Ybodychange",
    "bf168ca24ef0c328bd53d6d32e79f66b99ac56db": "Ymultichange(Ybodychange,Ydocchange)",
    "7bcf161d36d5b1e59fba1ae32e8e2d692c2fd33d": "Yintroduced"
  },
  "changeHistoryDetails": {
    "c14180ea5b16b69cdd06eb5bb159f7da1ff4db54": {
      "type": "Ybodychange",
      "commitMessage": "HHH-12410 - Cannot use AttributeConverter with spatial types\nHHH-12443 - Introduce TypeConfiguration\n",
      "commitDate": "2018/3/30 下午12:16",
      "commitName": "c14180ea5b16b69cdd06eb5bb159f7da1ff4db54",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2018/3/29 上午6:43",
      "commitNameOld": "0d82dc7c8387a954edfa971af99c16a66e33c65a",
      "commitAuthorOld": "Andrea Boriero",
      "daysBetweenCommits": 1.23,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate Type buildAttributeConverterTypeAdapter() {\n    final JpaAttributeConverter jpaAttributeConverter \u003d attributeConverterDescriptor.createJpaAttributeConverter(new JpaAttributeConverterCreationContext() {\n\n        @Override\n        public ManagedBeanRegistry getManagedBeanRegistry() {\n            return getMetadata().getMetadataBuildingOptions().getServiceRegistry().getService(ManagedBeanRegistry.class);\n        }\n\n        @Override\n        public org.hibernate.type.descriptor.java.spi.JavaTypeDescriptorRegistry getJavaTypeDescriptorRegistry() {\n            return metadata.getTypeConfiguration().getJavaTypeDescriptorRegistry();\n        }\n    });\n    final BasicJavaDescriptor entityAttributeJavaTypeDescriptor \u003d jpaAttributeConverter.getDomainJavaTypeDescriptor();\n    final SqlTypeDescriptor recommendedSqlType \u003d jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJdbcRecommendedSqlType(metadata::getTypeConfiguration);\n    int jdbcTypeCode \u003d recommendedSqlType.getSqlType();\n    if (isLob()) {\n        if (LobTypeMappings.INSTANCE.hasCorrespondingLobCode(jdbcTypeCode)) {\n            jdbcTypeCode \u003d LobTypeMappings.INSTANCE.getCorrespondingLobCode(jdbcTypeCode);\n        } else {\n            if (Serializable.class.isAssignableFrom(entityAttributeJavaTypeDescriptor.getJavaType())) {\n                jdbcTypeCode \u003d Types.BLOB;\n            } else {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"JDBC type-code [%s (%s)] not known to have a corresponding LOB equivalent, and Java type is not Serializable (to use BLOB)\", jdbcTypeCode, JdbcTypeNameMapper.getTypeName(jdbcTypeCode)));\n            }\n        }\n    }\n    if (isNationalized()) {\n        jdbcTypeCode \u003d NationalizedTypeMappings.INSTANCE.getCorrespondingNationalizedCode(jdbcTypeCode);\n    }\n    final SqlTypeDescriptor sqlTypeDescriptor \u003d getMetadata().getMetadataBuildingOptions().getServiceRegistry().getService(JdbcServices.class).getJdbcEnvironment().getDialect().remapSqlTypeDescriptor(metadata.getTypeConfiguration().getSqlTypeDescriptorRegistry().getDescriptor(jdbcTypeCode));\n    final SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(jpaAttributeConverter, sqlTypeDescriptor, jpaAttributeConverter.getRelationalJavaTypeDescriptor());\n    final String name \u003d AttributeConverterTypeAdapter.NAME_PREFIX + jpaAttributeConverter.getConverterJavaTypeDescriptor().getJavaType().getName();\n    final String description \u003d String.format(\"BasicType adapter for AttributeConverter\u003c%s,%s\u003e\", jpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType().getSimpleName(), jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType().getSimpleName());\n    return new AttributeConverterTypeAdapter(name, description, jpaAttributeConverter, sqlTypeDescriptorAdapter, jpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType(), jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType(), entityAttributeJavaTypeDescriptor);\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/mapping/SimpleValue.java",
      "functionStartLine": 565,
      "functionName": "buildAttributeConverterTypeAdapter",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Build a Hibernate Type that incorporates the JPA AttributeConverter.  AttributeConverter works totally in\nmemory, meaning it converts between one Java representation (the entity attribute representation) and another\n(the value bound into JDBC statements or extracted from results).  However, the Hibernate Type system operates\nat the lower level of actually dealing directly with those JDBC objects.  So even though we have an\nAttributeConverter, we still need to \"fill out\" the rest of the BasicType data and bridge calls\nto bind/extract through the converter.\n\u003cp/\u003e\nEssentially the idea here is that an intermediate Java type needs to be used.  Let\u0027s use an example as a means\nto illustrate...  Consider an {@code AttributeConverter\u003cInteger,String\u003e}.  This tells Hibernate that the domain\nmodel defines this attribute as an Integer value (the \u0027entityAttributeJavaType\u0027), but that we need to treat the\nvalue as a String (the \u0027databaseColumnJavaType\u0027) when dealing with JDBC (aka, the database type is a\nVARCHAR/CHAR):\u003cul\u003e\n    \u003cli\u003e\n        When binding values to PreparedStatements we need to convert the Integer value from the entity\n        into a String and pass that String to setString.  The conversion is handled by calling\n        {@link AttributeConverter#convertToDatabaseColumn(Object)}\n    \u003c/li\u003e\n    \u003cli\u003e\n        When extracting values from ResultSets (or CallableStatement parameters) we need to handle the\n        value via getString, and convert that returned String to an Integer.  That conversion is handled\n        by calling {@link AttributeConverter#convertToEntityAttribute(Object)}\n    \u003c/li\u003e\n\u003c/ul\u003e\n\n@return The built AttributeConverter -\u003e Type adapter\n@todo : ultimately I want to see attributeConverterJavaType and attributeConverterJdbcTypeCode specify-able separately\nthen we can \"play them against each other\" in terms of determining proper typing\n@todo : see if we already have previously built a custom on-the-fly BasicType for this AttributeConverter; see note below about caching\n",
      "diff": "@@ -1,36 +1,37 @@\n @SuppressWarnings(\"unchecked\")\n private Type buildAttributeConverterTypeAdapter() {\n     final JpaAttributeConverter jpaAttributeConverter \u003d attributeConverterDescriptor.createJpaAttributeConverter(new JpaAttributeConverterCreationContext() {\n \n         @Override\n         public ManagedBeanRegistry getManagedBeanRegistry() {\n             return getMetadata().getMetadataBuildingOptions().getServiceRegistry().getService(ManagedBeanRegistry.class);\n         }\n \n         @Override\n-        public JavaTypeDescriptorRegistry getJavaTypeDescriptorRegistry() {\n+        public org.hibernate.type.descriptor.java.spi.JavaTypeDescriptorRegistry getJavaTypeDescriptorRegistry() {\n             return metadata.getTypeConfiguration().getJavaTypeDescriptorRegistry();\n         }\n     });\n-    final JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d jpaAttributeConverter.getDomainJavaTypeDescriptor();\n-    int jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass(jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType());\n+    final BasicJavaDescriptor entityAttributeJavaTypeDescriptor \u003d jpaAttributeConverter.getDomainJavaTypeDescriptor();\n+    final SqlTypeDescriptor recommendedSqlType \u003d jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJdbcRecommendedSqlType(metadata::getTypeConfiguration);\n+    int jdbcTypeCode \u003d recommendedSqlType.getSqlType();\n     if (isLob()) {\n         if (LobTypeMappings.INSTANCE.hasCorrespondingLobCode(jdbcTypeCode)) {\n             jdbcTypeCode \u003d LobTypeMappings.INSTANCE.getCorrespondingLobCode(jdbcTypeCode);\n         } else {\n             if (Serializable.class.isAssignableFrom(entityAttributeJavaTypeDescriptor.getJavaType())) {\n                 jdbcTypeCode \u003d Types.BLOB;\n             } else {\n                 throw new IllegalArgumentException(String.format(Locale.ROOT, \"JDBC type-code [%s (%s)] not known to have a corresponding LOB equivalent, and Java type is not Serializable (to use BLOB)\", jdbcTypeCode, JdbcTypeNameMapper.getTypeName(jdbcTypeCode)));\n             }\n         }\n     }\n     if (isNationalized()) {\n         jdbcTypeCode \u003d NationalizedTypeMappings.INSTANCE.getCorrespondingNationalizedCode(jdbcTypeCode);\n     }\n     final SqlTypeDescriptor sqlTypeDescriptor \u003d getMetadata().getMetadataBuildingOptions().getServiceRegistry().getService(JdbcServices.class).getJdbcEnvironment().getDialect().remapSqlTypeDescriptor(metadata.getTypeConfiguration().getSqlTypeDescriptorRegistry().getDescriptor(jdbcTypeCode));\n     final SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(jpaAttributeConverter, sqlTypeDescriptor, jpaAttributeConverter.getRelationalJavaTypeDescriptor());\n     final String name \u003d AttributeConverterTypeAdapter.NAME_PREFIX + jpaAttributeConverter.getConverterJavaTypeDescriptor().getJavaType().getName();\n     final String description \u003d String.format(\"BasicType adapter for AttributeConverter\u003c%s,%s\u003e\", jpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType().getSimpleName(), jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType().getSimpleName());\n     return new AttributeConverterTypeAdapter(name, description, jpaAttributeConverter, sqlTypeDescriptorAdapter, jpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType(), jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType(), entityAttributeJavaTypeDescriptor);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0d82dc7c8387a954edfa971af99c16a66e33c65a": {
      "type": "Ybodychange",
      "commitMessage": "HHH-12444 - Introduce BootstrapContext\nHHH-12443 - Introduce TypeConfiguration\n",
      "commitDate": "2018/3/29 上午6:43",
      "commitName": "0d82dc7c8387a954edfa971af99c16a66e33c65a",
      "commitAuthor": "Andrea Boriero",
      "commitDateOld": "2018/3/29 上午6:43",
      "commitNameOld": "11462e786007f65f3cf9c2539e5b8259b05feaf3",
      "commitAuthorOld": "Andrea Boriero",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate Type buildAttributeConverterTypeAdapter() {\n    final JpaAttributeConverter jpaAttributeConverter \u003d attributeConverterDescriptor.createJpaAttributeConverter(new JpaAttributeConverterCreationContext() {\n\n        @Override\n        public ManagedBeanRegistry getManagedBeanRegistry() {\n            return getMetadata().getMetadataBuildingOptions().getServiceRegistry().getService(ManagedBeanRegistry.class);\n        }\n\n        @Override\n        public JavaTypeDescriptorRegistry getJavaTypeDescriptorRegistry() {\n            return metadata.getTypeConfiguration().getJavaTypeDescriptorRegistry();\n        }\n    });\n    final JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d jpaAttributeConverter.getDomainJavaTypeDescriptor();\n    int jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass(jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType());\n    if (isLob()) {\n        if (LobTypeMappings.INSTANCE.hasCorrespondingLobCode(jdbcTypeCode)) {\n            jdbcTypeCode \u003d LobTypeMappings.INSTANCE.getCorrespondingLobCode(jdbcTypeCode);\n        } else {\n            if (Serializable.class.isAssignableFrom(entityAttributeJavaTypeDescriptor.getJavaType())) {\n                jdbcTypeCode \u003d Types.BLOB;\n            } else {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"JDBC type-code [%s (%s)] not known to have a corresponding LOB equivalent, and Java type is not Serializable (to use BLOB)\", jdbcTypeCode, JdbcTypeNameMapper.getTypeName(jdbcTypeCode)));\n            }\n        }\n    }\n    if (isNationalized()) {\n        jdbcTypeCode \u003d NationalizedTypeMappings.INSTANCE.getCorrespondingNationalizedCode(jdbcTypeCode);\n    }\n    final SqlTypeDescriptor sqlTypeDescriptor \u003d getMetadata().getMetadataBuildingOptions().getServiceRegistry().getService(JdbcServices.class).getJdbcEnvironment().getDialect().remapSqlTypeDescriptor(metadata.getTypeConfiguration().getSqlTypeDescriptorRegistry().getDescriptor(jdbcTypeCode));\n    final SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(jpaAttributeConverter, sqlTypeDescriptor, jpaAttributeConverter.getRelationalJavaTypeDescriptor());\n    final String name \u003d AttributeConverterTypeAdapter.NAME_PREFIX + jpaAttributeConverter.getConverterJavaTypeDescriptor().getJavaType().getName();\n    final String description \u003d String.format(\"BasicType adapter for AttributeConverter\u003c%s,%s\u003e\", jpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType().getSimpleName(), jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType().getSimpleName());\n    return new AttributeConverterTypeAdapter(name, description, jpaAttributeConverter, sqlTypeDescriptorAdapter, jpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType(), jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType(), entityAttributeJavaTypeDescriptor);\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/mapping/SimpleValue.java",
      "functionStartLine": 565,
      "functionName": "buildAttributeConverterTypeAdapter",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Build a Hibernate Type that incorporates the JPA AttributeConverter.  AttributeConverter works totally in\nmemory, meaning it converts between one Java representation (the entity attribute representation) and another\n(the value bound into JDBC statements or extracted from results).  However, the Hibernate Type system operates\nat the lower level of actually dealing directly with those JDBC objects.  So even though we have an\nAttributeConverter, we still need to \"fill out\" the rest of the BasicType data and bridge calls\nto bind/extract through the converter.\n\u003cp/\u003e\nEssentially the idea here is that an intermediate Java type needs to be used.  Let\u0027s use an example as a means\nto illustrate...  Consider an {@code AttributeConverter\u003cInteger,String\u003e}.  This tells Hibernate that the domain\nmodel defines this attribute as an Integer value (the \u0027entityAttributeJavaType\u0027), but that we need to treat the\nvalue as a String (the \u0027databaseColumnJavaType\u0027) when dealing with JDBC (aka, the database type is a\nVARCHAR/CHAR):\u003cul\u003e\n    \u003cli\u003e\n        When binding values to PreparedStatements we need to convert the Integer value from the entity\n        into a String and pass that String to setString.  The conversion is handled by calling\n        {@link AttributeConverter#convertToDatabaseColumn(Object)}\n    \u003c/li\u003e\n    \u003cli\u003e\n        When extracting values from ResultSets (or CallableStatement parameters) we need to handle the\n        value via getString, and convert that returned String to an Integer.  That conversion is handled\n        by calling {@link AttributeConverter#convertToEntityAttribute(Object)}\n    \u003c/li\u003e\n\u003c/ul\u003e\n\n@return The built AttributeConverter -\u003e Type adapter\n@todo : ultimately I want to see attributeConverterJavaType and attributeConverterJdbcTypeCode specify-able separately\nthen we can \"play them against each other\" in terms of determining proper typing\n@todo : see if we already have previously built a custom on-the-fly BasicType for this AttributeConverter; see note below about caching\n",
      "diff": "@@ -1,36 +1,36 @@\n @SuppressWarnings(\"unchecked\")\n private Type buildAttributeConverterTypeAdapter() {\n     final JpaAttributeConverter jpaAttributeConverter \u003d attributeConverterDescriptor.createJpaAttributeConverter(new JpaAttributeConverterCreationContext() {\n \n         @Override\n         public ManagedBeanRegistry getManagedBeanRegistry() {\n             return getMetadata().getMetadataBuildingOptions().getServiceRegistry().getService(ManagedBeanRegistry.class);\n         }\n \n         @Override\n         public JavaTypeDescriptorRegistry getJavaTypeDescriptorRegistry() {\n-            return JavaTypeDescriptorRegistry.INSTANCE;\n+            return metadata.getTypeConfiguration().getJavaTypeDescriptorRegistry();\n         }\n     });\n     final JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d jpaAttributeConverter.getDomainJavaTypeDescriptor();\n     int jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass(jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType());\n     if (isLob()) {\n         if (LobTypeMappings.INSTANCE.hasCorrespondingLobCode(jdbcTypeCode)) {\n             jdbcTypeCode \u003d LobTypeMappings.INSTANCE.getCorrespondingLobCode(jdbcTypeCode);\n         } else {\n             if (Serializable.class.isAssignableFrom(entityAttributeJavaTypeDescriptor.getJavaType())) {\n                 jdbcTypeCode \u003d Types.BLOB;\n             } else {\n                 throw new IllegalArgumentException(String.format(Locale.ROOT, \"JDBC type-code [%s (%s)] not known to have a corresponding LOB equivalent, and Java type is not Serializable (to use BLOB)\", jdbcTypeCode, JdbcTypeNameMapper.getTypeName(jdbcTypeCode)));\n             }\n         }\n     }\n     if (isNationalized()) {\n         jdbcTypeCode \u003d NationalizedTypeMappings.INSTANCE.getCorrespondingNationalizedCode(jdbcTypeCode);\n     }\n-    final SqlTypeDescriptor sqlTypeDescriptor \u003d getMetadata().getMetadataBuildingOptions().getServiceRegistry().getService(JdbcServices.class).getJdbcEnvironment().getDialect().remapSqlTypeDescriptor(SqlTypeDescriptorRegistry.INSTANCE.getDescriptor(jdbcTypeCode));\n+    final SqlTypeDescriptor sqlTypeDescriptor \u003d getMetadata().getMetadataBuildingOptions().getServiceRegistry().getService(JdbcServices.class).getJdbcEnvironment().getDialect().remapSqlTypeDescriptor(metadata.getTypeConfiguration().getSqlTypeDescriptorRegistry().getDescriptor(jdbcTypeCode));\n     final SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(jpaAttributeConverter, sqlTypeDescriptor, jpaAttributeConverter.getRelationalJavaTypeDescriptor());\n     final String name \u003d AttributeConverterTypeAdapter.NAME_PREFIX + jpaAttributeConverter.getConverterJavaTypeDescriptor().getJavaType().getName();\n     final String description \u003d String.format(\"BasicType adapter for AttributeConverter\u003c%s,%s\u003e\", jpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType().getSimpleName(), jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType().getSimpleName());\n     return new AttributeConverterTypeAdapter(name, description, jpaAttributeConverter, sqlTypeDescriptorAdapter, jpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType(), jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType(), entityAttributeJavaTypeDescriptor);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9229514ed407b1610a52ab7ba97806c435352ad2": {
      "type": "Ybodychange",
      "commitMessage": "HHH-12444 - Introduce BootstrapContext\nHHH-12443 - Introduce TypeConfiguration\n",
      "commitDate": "2018/3/29 上午6:43",
      "commitName": "9229514ed407b1610a52ab7ba97806c435352ad2",
      "commitAuthor": "Andrea Boriero",
      "commitDateOld": "2018/3/29 上午6:43",
      "commitNameOld": "8f889e95d76f47945c9ec072fd08cb045767578c",
      "commitAuthorOld": "Andrea Boriero",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate Type buildAttributeConverterTypeAdapter() {\n    final JpaAttributeConverter jpaAttributeConverter \u003d attributeConverterDescriptor.createJpaAttributeConverter(new JpaAttributeConverterCreationContext() {\n\n        @Override\n        public ManagedBeanRegistry getManagedBeanRegistry() {\n            return getMetadata().getMetadataBuildingOptions().getServiceRegistry().getService(ManagedBeanRegistry.class);\n        }\n\n        @Override\n        public JavaTypeDescriptorRegistry getJavaTypeDescriptorRegistry() {\n            return JavaTypeDescriptorRegistry.INSTANCE;\n        }\n    });\n    final JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d jpaAttributeConverter.getDomainJavaTypeDescriptor();\n    int jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass(jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType());\n    if (isLob()) {\n        if (LobTypeMappings.INSTANCE.hasCorrespondingLobCode(jdbcTypeCode)) {\n            jdbcTypeCode \u003d LobTypeMappings.INSTANCE.getCorrespondingLobCode(jdbcTypeCode);\n        } else {\n            if (Serializable.class.isAssignableFrom(entityAttributeJavaTypeDescriptor.getJavaType())) {\n                jdbcTypeCode \u003d Types.BLOB;\n            } else {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"JDBC type-code [%s (%s)] not known to have a corresponding LOB equivalent, and Java type is not Serializable (to use BLOB)\", jdbcTypeCode, JdbcTypeNameMapper.getTypeName(jdbcTypeCode)));\n            }\n        }\n    }\n    if (isNationalized()) {\n        jdbcTypeCode \u003d NationalizedTypeMappings.INSTANCE.getCorrespondingNationalizedCode(jdbcTypeCode);\n    }\n    final SqlTypeDescriptor sqlTypeDescriptor \u003d getMetadata().getMetadataBuildingOptions().getServiceRegistry().getService(JdbcServices.class).getJdbcEnvironment().getDialect().remapSqlTypeDescriptor(SqlTypeDescriptorRegistry.INSTANCE.getDescriptor(jdbcTypeCode));\n    final SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(jpaAttributeConverter, sqlTypeDescriptor, jpaAttributeConverter.getRelationalJavaTypeDescriptor());\n    final String name \u003d AttributeConverterTypeAdapter.NAME_PREFIX + jpaAttributeConverter.getConverterJavaTypeDescriptor().getJavaType().getName();\n    final String description \u003d String.format(\"BasicType adapter for AttributeConverter\u003c%s,%s\u003e\", jpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType().getSimpleName(), jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType().getSimpleName());\n    return new AttributeConverterTypeAdapter(name, description, jpaAttributeConverter, sqlTypeDescriptorAdapter, jpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType(), jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType(), entityAttributeJavaTypeDescriptor);\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/mapping/SimpleValue.java",
      "functionStartLine": 563,
      "functionName": "buildAttributeConverterTypeAdapter",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Build a Hibernate Type that incorporates the JPA AttributeConverter.  AttributeConverter works totally in\nmemory, meaning it converts between one Java representation (the entity attribute representation) and another\n(the value bound into JDBC statements or extracted from results).  However, the Hibernate Type system operates\nat the lower level of actually dealing directly with those JDBC objects.  So even though we have an\nAttributeConverter, we still need to \"fill out\" the rest of the BasicType data and bridge calls\nto bind/extract through the converter.\n\u003cp/\u003e\nEssentially the idea here is that an intermediate Java type needs to be used.  Let\u0027s use an example as a means\nto illustrate...  Consider an {@code AttributeConverter\u003cInteger,String\u003e}.  This tells Hibernate that the domain\nmodel defines this attribute as an Integer value (the \u0027entityAttributeJavaType\u0027), but that we need to treat the\nvalue as a String (the \u0027databaseColumnJavaType\u0027) when dealing with JDBC (aka, the database type is a\nVARCHAR/CHAR):\u003cul\u003e\n    \u003cli\u003e\n        When binding values to PreparedStatements we need to convert the Integer value from the entity\n        into a String and pass that String to setString.  The conversion is handled by calling\n        {@link AttributeConverter#convertToDatabaseColumn(Object)}\n    \u003c/li\u003e\n    \u003cli\u003e\n        When extracting values from ResultSets (or CallableStatement parameters) we need to handle the\n        value via getString, and convert that returned String to an Integer.  That conversion is handled\n        by calling {@link AttributeConverter#convertToEntityAttribute(Object)}\n    \u003c/li\u003e\n\u003c/ul\u003e\n\n@return The built AttributeConverter -\u003e Type adapter\n@todo : ultimately I want to see attributeConverterJavaType and attributeConverterJdbcTypeCode specify-able separately\nthen we can \"play them against each other\" in terms of determining proper typing\n@todo : see if we already have previously built a custom on-the-fly BasicType for this AttributeConverter; see note below about caching\n",
      "diff": "@@ -1,36 +1,36 @@\n @SuppressWarnings(\"unchecked\")\n private Type buildAttributeConverterTypeAdapter() {\n     final JpaAttributeConverter jpaAttributeConverter \u003d attributeConverterDescriptor.createJpaAttributeConverter(new JpaAttributeConverterCreationContext() {\n \n         @Override\n         public ManagedBeanRegistry getManagedBeanRegistry() {\n-            return buildingContext.getBootstrapContext().getMetadataBuildingOptions().getServiceRegistry().getService(ManagedBeanRegistry.class);\n+            return getMetadata().getMetadataBuildingOptions().getServiceRegistry().getService(ManagedBeanRegistry.class);\n         }\n \n         @Override\n         public JavaTypeDescriptorRegistry getJavaTypeDescriptorRegistry() {\n             return JavaTypeDescriptorRegistry.INSTANCE;\n         }\n     });\n     final JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d jpaAttributeConverter.getDomainJavaTypeDescriptor();\n     int jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass(jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType());\n     if (isLob()) {\n         if (LobTypeMappings.INSTANCE.hasCorrespondingLobCode(jdbcTypeCode)) {\n             jdbcTypeCode \u003d LobTypeMappings.INSTANCE.getCorrespondingLobCode(jdbcTypeCode);\n         } else {\n             if (Serializable.class.isAssignableFrom(entityAttributeJavaTypeDescriptor.getJavaType())) {\n                 jdbcTypeCode \u003d Types.BLOB;\n             } else {\n                 throw new IllegalArgumentException(String.format(Locale.ROOT, \"JDBC type-code [%s (%s)] not known to have a corresponding LOB equivalent, and Java type is not Serializable (to use BLOB)\", jdbcTypeCode, JdbcTypeNameMapper.getTypeName(jdbcTypeCode)));\n             }\n         }\n     }\n     if (isNationalized()) {\n         jdbcTypeCode \u003d NationalizedTypeMappings.INSTANCE.getCorrespondingNationalizedCode(jdbcTypeCode);\n     }\n-    final SqlTypeDescriptor sqlTypeDescriptor \u003d buildingContext.getBootstrapContext().getMetadataBuildingOptions().getServiceRegistry().getService(JdbcServices.class).getJdbcEnvironment().getDialect().remapSqlTypeDescriptor(SqlTypeDescriptorRegistry.INSTANCE.getDescriptor(jdbcTypeCode));\n+    final SqlTypeDescriptor sqlTypeDescriptor \u003d getMetadata().getMetadataBuildingOptions().getServiceRegistry().getService(JdbcServices.class).getJdbcEnvironment().getDialect().remapSqlTypeDescriptor(SqlTypeDescriptorRegistry.INSTANCE.getDescriptor(jdbcTypeCode));\n     final SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(jpaAttributeConverter, sqlTypeDescriptor, jpaAttributeConverter.getRelationalJavaTypeDescriptor());\n     final String name \u003d AttributeConverterTypeAdapter.NAME_PREFIX + jpaAttributeConverter.getConverterJavaTypeDescriptor().getJavaType().getName();\n     final String description \u003d String.format(\"BasicType adapter for AttributeConverter\u003c%s,%s\u003e\", jpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType().getSimpleName(), jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType().getSimpleName());\n     return new AttributeConverterTypeAdapter(name, description, jpaAttributeConverter, sqlTypeDescriptorAdapter, jpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType(), jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType(), entityAttributeJavaTypeDescriptor);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8f889e95d76f47945c9ec072fd08cb045767578c": {
      "type": "Ybodychange",
      "commitMessage": "HHH-12444 - Introduce BootstrapContext\nHHH-12443 - Introduce TypeConfiguration\n",
      "commitDate": "2018/3/29 上午6:43",
      "commitName": "8f889e95d76f47945c9ec072fd08cb045767578c",
      "commitAuthor": "Andrea Boriero",
      "commitDateOld": "2018/3/7 下午10:57",
      "commitNameOld": "1e5a8d3c434c6791b89281c4ebf04ef08181fcd7",
      "commitAuthorOld": "Christian Beikov",
      "daysBetweenCommits": 21.32,
      "commitsBetweenForRepo": 90,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate Type buildAttributeConverterTypeAdapter() {\n    final JpaAttributeConverter jpaAttributeConverter \u003d attributeConverterDescriptor.createJpaAttributeConverter(new JpaAttributeConverterCreationContext() {\n\n        @Override\n        public ManagedBeanRegistry getManagedBeanRegistry() {\n            return buildingContext.getBootstrapContext().getMetadataBuildingOptions().getServiceRegistry().getService(ManagedBeanRegistry.class);\n        }\n\n        @Override\n        public JavaTypeDescriptorRegistry getJavaTypeDescriptorRegistry() {\n            return JavaTypeDescriptorRegistry.INSTANCE;\n        }\n    });\n    final JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d jpaAttributeConverter.getDomainJavaTypeDescriptor();\n    int jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass(jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType());\n    if (isLob()) {\n        if (LobTypeMappings.INSTANCE.hasCorrespondingLobCode(jdbcTypeCode)) {\n            jdbcTypeCode \u003d LobTypeMappings.INSTANCE.getCorrespondingLobCode(jdbcTypeCode);\n        } else {\n            if (Serializable.class.isAssignableFrom(entityAttributeJavaTypeDescriptor.getJavaType())) {\n                jdbcTypeCode \u003d Types.BLOB;\n            } else {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"JDBC type-code [%s (%s)] not known to have a corresponding LOB equivalent, and Java type is not Serializable (to use BLOB)\", jdbcTypeCode, JdbcTypeNameMapper.getTypeName(jdbcTypeCode)));\n            }\n        }\n    }\n    if (isNationalized()) {\n        jdbcTypeCode \u003d NationalizedTypeMappings.INSTANCE.getCorrespondingNationalizedCode(jdbcTypeCode);\n    }\n    final SqlTypeDescriptor sqlTypeDescriptor \u003d buildingContext.getBootstrapContext().getMetadataBuildingOptions().getServiceRegistry().getService(JdbcServices.class).getJdbcEnvironment().getDialect().remapSqlTypeDescriptor(SqlTypeDescriptorRegistry.INSTANCE.getDescriptor(jdbcTypeCode));\n    final SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(jpaAttributeConverter, sqlTypeDescriptor, jpaAttributeConverter.getRelationalJavaTypeDescriptor());\n    final String name \u003d AttributeConverterTypeAdapter.NAME_PREFIX + jpaAttributeConverter.getConverterJavaTypeDescriptor().getJavaType().getName();\n    final String description \u003d String.format(\"BasicType adapter for AttributeConverter\u003c%s,%s\u003e\", jpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType().getSimpleName(), jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType().getSimpleName());\n    return new AttributeConverterTypeAdapter(name, description, jpaAttributeConverter, sqlTypeDescriptorAdapter, jpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType(), jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType(), entityAttributeJavaTypeDescriptor);\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/mapping/SimpleValue.java",
      "functionStartLine": 549,
      "functionName": "buildAttributeConverterTypeAdapter",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Build a Hibernate Type that incorporates the JPA AttributeConverter.  AttributeConverter works totally in\nmemory, meaning it converts between one Java representation (the entity attribute representation) and another\n(the value bound into JDBC statements or extracted from results).  However, the Hibernate Type system operates\nat the lower level of actually dealing directly with those JDBC objects.  So even though we have an\nAttributeConverter, we still need to \"fill out\" the rest of the BasicType data and bridge calls\nto bind/extract through the converter.\n\u003cp/\u003e\nEssentially the idea here is that an intermediate Java type needs to be used.  Let\u0027s use an example as a means\nto illustrate...  Consider an {@code AttributeConverter\u003cInteger,String\u003e}.  This tells Hibernate that the domain\nmodel defines this attribute as an Integer value (the \u0027entityAttributeJavaType\u0027), but that we need to treat the\nvalue as a String (the \u0027databaseColumnJavaType\u0027) when dealing with JDBC (aka, the database type is a\nVARCHAR/CHAR):\u003cul\u003e\n    \u003cli\u003e\n        When binding values to PreparedStatements we need to convert the Integer value from the entity\n        into a String and pass that String to setString.  The conversion is handled by calling\n        {@link AttributeConverter#convertToDatabaseColumn(Object)}\n    \u003c/li\u003e\n    \u003cli\u003e\n        When extracting values from ResultSets (or CallableStatement parameters) we need to handle the\n        value via getString, and convert that returned String to an Integer.  That conversion is handled\n        by calling {@link AttributeConverter#convertToEntityAttribute(Object)}\n    \u003c/li\u003e\n\u003c/ul\u003e\n\n@return The built AttributeConverter -\u003e Type adapter\n@todo : ultimately I want to see attributeConverterJavaType and attributeConverterJdbcTypeCode specify-able separately\nthen we can \"play them against each other\" in terms of determining proper typing\n@todo : see if we already have previously built a custom on-the-fly BasicType for this AttributeConverter; see note below about caching\n",
      "diff": "@@ -1,36 +1,36 @@\n @SuppressWarnings(\"unchecked\")\n private Type buildAttributeConverterTypeAdapter() {\n     final JpaAttributeConverter jpaAttributeConverter \u003d attributeConverterDescriptor.createJpaAttributeConverter(new JpaAttributeConverterCreationContext() {\n \n         @Override\n         public ManagedBeanRegistry getManagedBeanRegistry() {\n-            return getMetadata().getMetadataBuildingOptions().getServiceRegistry().getService(ManagedBeanRegistry.class);\n+            return buildingContext.getBootstrapContext().getMetadataBuildingOptions().getServiceRegistry().getService(ManagedBeanRegistry.class);\n         }\n \n         @Override\n         public JavaTypeDescriptorRegistry getJavaTypeDescriptorRegistry() {\n             return JavaTypeDescriptorRegistry.INSTANCE;\n         }\n     });\n     final JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d jpaAttributeConverter.getDomainJavaTypeDescriptor();\n     int jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass(jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType());\n     if (isLob()) {\n         if (LobTypeMappings.INSTANCE.hasCorrespondingLobCode(jdbcTypeCode)) {\n             jdbcTypeCode \u003d LobTypeMappings.INSTANCE.getCorrespondingLobCode(jdbcTypeCode);\n         } else {\n             if (Serializable.class.isAssignableFrom(entityAttributeJavaTypeDescriptor.getJavaType())) {\n                 jdbcTypeCode \u003d Types.BLOB;\n             } else {\n                 throw new IllegalArgumentException(String.format(Locale.ROOT, \"JDBC type-code [%s (%s)] not known to have a corresponding LOB equivalent, and Java type is not Serializable (to use BLOB)\", jdbcTypeCode, JdbcTypeNameMapper.getTypeName(jdbcTypeCode)));\n             }\n         }\n     }\n     if (isNationalized()) {\n         jdbcTypeCode \u003d NationalizedTypeMappings.INSTANCE.getCorrespondingNationalizedCode(jdbcTypeCode);\n     }\n-    final SqlTypeDescriptor sqlTypeDescriptor \u003d metadata.getMetadataBuildingOptions().getServiceRegistry().getService(JdbcServices.class).getJdbcEnvironment().getDialect().remapSqlTypeDescriptor(SqlTypeDescriptorRegistry.INSTANCE.getDescriptor(jdbcTypeCode));\n+    final SqlTypeDescriptor sqlTypeDescriptor \u003d buildingContext.getBootstrapContext().getMetadataBuildingOptions().getServiceRegistry().getService(JdbcServices.class).getJdbcEnvironment().getDialect().remapSqlTypeDescriptor(SqlTypeDescriptorRegistry.INSTANCE.getDescriptor(jdbcTypeCode));\n     final SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(jpaAttributeConverter, sqlTypeDescriptor, jpaAttributeConverter.getRelationalJavaTypeDescriptor());\n     final String name \u003d AttributeConverterTypeAdapter.NAME_PREFIX + jpaAttributeConverter.getConverterJavaTypeDescriptor().getJavaType().getName();\n     final String description \u003d String.format(\"BasicType adapter for AttributeConverter\u003c%s,%s\u003e\", jpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType().getSimpleName(), jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType().getSimpleName());\n     return new AttributeConverterTypeAdapter(name, description, jpaAttributeConverter, sqlTypeDescriptorAdapter, jpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType(), jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType(), entityAttributeJavaTypeDescriptor);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "90cabb43ad8b186d73cb6b310fb2fd6774ffe44f": {
      "type": "Ybodychange",
      "commitMessage": "HHH-12135 - Support for AttributeConverters as CDI beans\n\ninitial work to get AttributeConverter support to be able to integrate with ManagedBeanRegistry.  There is a lot of \"infrastructure\" changes because the old code assumed we could instantiate the converter as soon as we knew the class which precludes lookup in the registry later.\n",
      "commitDate": "2017/12/16 上午8:25",
      "commitName": "90cabb43ad8b186d73cb6b310fb2fd6774ffe44f",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2016/9/30 上午12:27",
      "commitNameOld": "9aa164ed27b8338f592dee504a5793bc4e5bbfd9",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 442.33,
      "commitsBetweenForRepo": 985,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate Type buildAttributeConverterTypeAdapter() {\n    final JpaAttributeConverter jpaAttributeConverter \u003d attributeConverterDescriptor.createJpaAttributeConverter(new JpaAttributeConverterCreationContext() {\n\n        @Override\n        public ManagedBeanRegistry getManagedBeanRegistry() {\n            return getMetadata().getMetadataBuildingOptions().getServiceRegistry().getService(ManagedBeanRegistry.class);\n        }\n\n        @Override\n        public JavaTypeDescriptorRegistry getJavaTypeDescriptorRegistry() {\n            return JavaTypeDescriptorRegistry.INSTANCE;\n        }\n    });\n    final JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d jpaAttributeConverter.getDomainJavaTypeDescriptor();\n    int jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass(jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType());\n    if (isLob()) {\n        if (LobTypeMappings.INSTANCE.hasCorrespondingLobCode(jdbcTypeCode)) {\n            jdbcTypeCode \u003d LobTypeMappings.INSTANCE.getCorrespondingLobCode(jdbcTypeCode);\n        } else {\n            if (Serializable.class.isAssignableFrom(entityAttributeJavaTypeDescriptor.getJavaType())) {\n                jdbcTypeCode \u003d Types.BLOB;\n            } else {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"JDBC type-code [%s (%s)] not known to have a corresponding LOB equivalent, and Java type is not Serializable (to use BLOB)\", jdbcTypeCode, JdbcTypeNameMapper.getTypeName(jdbcTypeCode)));\n            }\n        }\n    }\n    if (isNationalized()) {\n        jdbcTypeCode \u003d NationalizedTypeMappings.INSTANCE.getCorrespondingNationalizedCode(jdbcTypeCode);\n    }\n    final SqlTypeDescriptor sqlTypeDescriptor \u003d metadata.getMetadataBuildingOptions().getServiceRegistry().getService(JdbcServices.class).getJdbcEnvironment().getDialect().remapSqlTypeDescriptor(SqlTypeDescriptorRegistry.INSTANCE.getDescriptor(jdbcTypeCode));\n    final SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(jpaAttributeConverter, sqlTypeDescriptor, jpaAttributeConverter.getRelationalJavaTypeDescriptor());\n    final String name \u003d AttributeConverterTypeAdapter.NAME_PREFIX + jpaAttributeConverter.getConverterJavaTypeDescriptor().getJavaType().getName();\n    final String description \u003d String.format(\"BasicType adapter for AttributeConverter\u003c%s,%s\u003e\", jpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType().getSimpleName(), jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType().getSimpleName());\n    return new AttributeConverterTypeAdapter(name, description, jpaAttributeConverter, sqlTypeDescriptorAdapter, jpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType(), jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType(), entityAttributeJavaTypeDescriptor);\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/mapping/SimpleValue.java",
      "functionStartLine": 535,
      "functionName": "buildAttributeConverterTypeAdapter",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Build a Hibernate Type that incorporates the JPA AttributeConverter.  AttributeConverter works totally in\nmemory, meaning it converts between one Java representation (the entity attribute representation) and another\n(the value bound into JDBC statements or extracted from results).  However, the Hibernate Type system operates\nat the lower level of actually dealing directly with those JDBC objects.  So even though we have an\nAttributeConverter, we still need to \"fill out\" the rest of the BasicType data and bridge calls\nto bind/extract through the converter.\n\u003cp/\u003e\nEssentially the idea here is that an intermediate Java type needs to be used.  Let\u0027s use an example as a means\nto illustrate...  Consider an {@code AttributeConverter\u003cInteger,String\u003e}.  This tells Hibernate that the domain\nmodel defines this attribute as an Integer value (the \u0027entityAttributeJavaType\u0027), but that we need to treat the\nvalue as a String (the \u0027databaseColumnJavaType\u0027) when dealing with JDBC (aka, the database type is a\nVARCHAR/CHAR):\u003cul\u003e\n    \u003cli\u003e\n        When binding values to PreparedStatements we need to convert the Integer value from the entity\n        into a String and pass that String to setString.  The conversion is handled by calling\n        {@link AttributeConverter#convertToDatabaseColumn(Object)}\n    \u003c/li\u003e\n    \u003cli\u003e\n        When extracting values from ResultSets (or CallableStatement parameters) we need to handle the\n        value via getString, and convert that returned String to an Integer.  That conversion is handled\n        by calling {@link AttributeConverter#convertToEntityAttribute(Object)}\n    \u003c/li\u003e\n\u003c/ul\u003e\n\n@return The built AttributeConverter -\u003e Type adapter\n@todo : ultimately I want to see attributeConverterJavaType and attributeConverterJdbcTypeCode specify-able separately\nthen we can \"play them against each other\" in terms of determining proper typing\n@todo : see if we already have previously built a custom on-the-fly BasicType for this AttributeConverter; see note below about caching\n",
      "diff": "@@ -1,27 +1,36 @@\n @SuppressWarnings(\"unchecked\")\n private Type buildAttributeConverterTypeAdapter() {\n-    final Class entityAttributeJavaType \u003d attributeConverterDescriptor.getDomainType();\n-    final Class databaseColumnJavaType \u003d attributeConverterDescriptor.getJdbcType();\n-    final JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(entityAttributeJavaType);\n-    int jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass(databaseColumnJavaType);\n+    final JpaAttributeConverter jpaAttributeConverter \u003d attributeConverterDescriptor.createJpaAttributeConverter(new JpaAttributeConverterCreationContext() {\n+\n+        @Override\n+        public ManagedBeanRegistry getManagedBeanRegistry() {\n+            return getMetadata().getMetadataBuildingOptions().getServiceRegistry().getService(ManagedBeanRegistry.class);\n+        }\n+\n+        @Override\n+        public JavaTypeDescriptorRegistry getJavaTypeDescriptorRegistry() {\n+            return JavaTypeDescriptorRegistry.INSTANCE;\n+        }\n+    });\n+    final JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d jpaAttributeConverter.getDomainJavaTypeDescriptor();\n+    int jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass(jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType());\n     if (isLob()) {\n         if (LobTypeMappings.INSTANCE.hasCorrespondingLobCode(jdbcTypeCode)) {\n             jdbcTypeCode \u003d LobTypeMappings.INSTANCE.getCorrespondingLobCode(jdbcTypeCode);\n         } else {\n-            if (Serializable.class.isAssignableFrom(entityAttributeJavaType)) {\n+            if (Serializable.class.isAssignableFrom(entityAttributeJavaTypeDescriptor.getJavaType())) {\n                 jdbcTypeCode \u003d Types.BLOB;\n             } else {\n                 throw new IllegalArgumentException(String.format(Locale.ROOT, \"JDBC type-code [%s (%s)] not known to have a corresponding LOB equivalent, and Java type is not Serializable (to use BLOB)\", jdbcTypeCode, JdbcTypeNameMapper.getTypeName(jdbcTypeCode)));\n             }\n         }\n     }\n     if (isNationalized()) {\n         jdbcTypeCode \u003d NationalizedTypeMappings.INSTANCE.getCorrespondingNationalizedCode(jdbcTypeCode);\n     }\n     final SqlTypeDescriptor sqlTypeDescriptor \u003d metadata.getMetadataBuildingOptions().getServiceRegistry().getService(JdbcServices.class).getJdbcEnvironment().getDialect().remapSqlTypeDescriptor(SqlTypeDescriptorRegistry.INSTANCE.getDescriptor(jdbcTypeCode));\n-    final JavaTypeDescriptor intermediateJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(databaseColumnJavaType);\n-    final SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(attributeConverterDescriptor.getAttributeConverter(), sqlTypeDescriptor, intermediateJavaTypeDescriptor);\n-    final String name \u003d AttributeConverterTypeAdapter.NAME_PREFIX + attributeConverterDescriptor.getAttributeConverter().getClass().getName();\n-    final String description \u003d String.format(\"BasicType adapter for AttributeConverter\u003c%s,%s\u003e\", entityAttributeJavaType.getSimpleName(), databaseColumnJavaType.getSimpleName());\n-    return new AttributeConverterTypeAdapter(name, description, attributeConverterDescriptor.getAttributeConverter(), sqlTypeDescriptorAdapter, entityAttributeJavaType, databaseColumnJavaType, entityAttributeJavaTypeDescriptor);\n+    final SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(jpaAttributeConverter, sqlTypeDescriptor, jpaAttributeConverter.getRelationalJavaTypeDescriptor());\n+    final String name \u003d AttributeConverterTypeAdapter.NAME_PREFIX + jpaAttributeConverter.getConverterJavaTypeDescriptor().getJavaType().getName();\n+    final String description \u003d String.format(\"BasicType adapter for AttributeConverter\u003c%s,%s\u003e\", jpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType().getSimpleName(), jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType().getSimpleName());\n+    return new AttributeConverterTypeAdapter(name, description, jpaAttributeConverter, sqlTypeDescriptorAdapter, jpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType(), jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType(), entityAttributeJavaTypeDescriptor);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9aa164ed27b8338f592dee504a5793bc4e5bbfd9": {
      "type": "Ybodychange",
      "commitMessage": "HHH-10818 - Allow AttributeConverter on attributes marked as Lob (REALLY this time)\n",
      "commitDate": "2016/9/30 上午12:27",
      "commitName": "9aa164ed27b8338f592dee504a5793bc4e5bbfd9",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2016/7/15 上午6:16",
      "commitNameOld": "c893577efceff237f84d7200e1ef1a2895c95639",
      "commitAuthorOld": "Gail Badner",
      "daysBetweenCommits": 76.76,
      "commitsBetweenForRepo": 178,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate Type buildAttributeConverterTypeAdapter() {\n    final Class entityAttributeJavaType \u003d attributeConverterDescriptor.getDomainType();\n    final Class databaseColumnJavaType \u003d attributeConverterDescriptor.getJdbcType();\n    final JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(entityAttributeJavaType);\n    int jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass(databaseColumnJavaType);\n    if (isLob()) {\n        if (LobTypeMappings.INSTANCE.hasCorrespondingLobCode(jdbcTypeCode)) {\n            jdbcTypeCode \u003d LobTypeMappings.INSTANCE.getCorrespondingLobCode(jdbcTypeCode);\n        } else {\n            if (Serializable.class.isAssignableFrom(entityAttributeJavaType)) {\n                jdbcTypeCode \u003d Types.BLOB;\n            } else {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"JDBC type-code [%s (%s)] not known to have a corresponding LOB equivalent, and Java type is not Serializable (to use BLOB)\", jdbcTypeCode, JdbcTypeNameMapper.getTypeName(jdbcTypeCode)));\n            }\n        }\n    }\n    if (isNationalized()) {\n        jdbcTypeCode \u003d NationalizedTypeMappings.INSTANCE.getCorrespondingNationalizedCode(jdbcTypeCode);\n    }\n    final SqlTypeDescriptor sqlTypeDescriptor \u003d metadata.getMetadataBuildingOptions().getServiceRegistry().getService(JdbcServices.class).getJdbcEnvironment().getDialect().remapSqlTypeDescriptor(SqlTypeDescriptorRegistry.INSTANCE.getDescriptor(jdbcTypeCode));\n    final JavaTypeDescriptor intermediateJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(databaseColumnJavaType);\n    final SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(attributeConverterDescriptor.getAttributeConverter(), sqlTypeDescriptor, intermediateJavaTypeDescriptor);\n    final String name \u003d AttributeConverterTypeAdapter.NAME_PREFIX + attributeConverterDescriptor.getAttributeConverter().getClass().getName();\n    final String description \u003d String.format(\"BasicType adapter for AttributeConverter\u003c%s,%s\u003e\", entityAttributeJavaType.getSimpleName(), databaseColumnJavaType.getSimpleName());\n    return new AttributeConverterTypeAdapter(name, description, attributeConverterDescriptor.getAttributeConverter(), sqlTypeDescriptorAdapter, entityAttributeJavaType, databaseColumnJavaType, entityAttributeJavaTypeDescriptor);\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/mapping/SimpleValue.java",
      "functionStartLine": 526,
      "functionName": "buildAttributeConverterTypeAdapter",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Build a Hibernate Type that incorporates the JPA AttributeConverter.  AttributeConverter works totally in\nmemory, meaning it converts between one Java representation (the entity attribute representation) and another\n(the value bound into JDBC statements or extracted from results).  However, the Hibernate Type system operates\nat the lower level of actually dealing directly with those JDBC objects.  So even though we have an\nAttributeConverter, we still need to \"fill out\" the rest of the BasicType data and bridge calls\nto bind/extract through the converter.\n\u003cp/\u003e\nEssentially the idea here is that an intermediate Java type needs to be used.  Let\u0027s use an example as a means\nto illustrate...  Consider an {@code AttributeConverter\u003cInteger,String\u003e}.  This tells Hibernate that the domain\nmodel defines this attribute as an Integer value (the \u0027entityAttributeJavaType\u0027), but that we need to treat the\nvalue as a String (the \u0027databaseColumnJavaType\u0027) when dealing with JDBC (aka, the database type is a\nVARCHAR/CHAR):\u003cul\u003e\n    \u003cli\u003e\n        When binding values to PreparedStatements we need to convert the Integer value from the entity\n        into a String and pass that String to setString.  The conversion is handled by calling\n        {@link AttributeConverter#convertToDatabaseColumn(Object)}\n    \u003c/li\u003e\n    \u003cli\u003e\n        When extracting values from ResultSets (or CallableStatement parameters) we need to handle the\n        value via getString, and convert that returned String to an Integer.  That conversion is handled\n        by calling {@link AttributeConverter#convertToEntityAttribute(Object)}\n    \u003c/li\u003e\n\u003c/ul\u003e\n\n@return The built AttributeConverter -\u003e Type adapter\n@todo : ultimately I want to see attributeConverterJavaType and attributeConverterJdbcTypeCode specify-able separately\nthen we can \"play them against each other\" in terms of determining proper typing\n@todo : see if we already have previously built a custom on-the-fly BasicType for this AttributeConverter; see note below about caching\n",
      "diff": "@@ -1,27 +1,27 @@\n @SuppressWarnings(\"unchecked\")\n private Type buildAttributeConverterTypeAdapter() {\n     final Class entityAttributeJavaType \u003d attributeConverterDescriptor.getDomainType();\n     final Class databaseColumnJavaType \u003d attributeConverterDescriptor.getJdbcType();\n     final JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(entityAttributeJavaType);\n     int jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass(databaseColumnJavaType);\n     if (isLob()) {\n         if (LobTypeMappings.INSTANCE.hasCorrespondingLobCode(jdbcTypeCode)) {\n             jdbcTypeCode \u003d LobTypeMappings.INSTANCE.getCorrespondingLobCode(jdbcTypeCode);\n         } else {\n             if (Serializable.class.isAssignableFrom(entityAttributeJavaType)) {\n                 jdbcTypeCode \u003d Types.BLOB;\n             } else {\n                 throw new IllegalArgumentException(String.format(Locale.ROOT, \"JDBC type-code [%s (%s)] not known to have a corresponding LOB equivalent, and Java type is not Serializable (to use BLOB)\", jdbcTypeCode, JdbcTypeNameMapper.getTypeName(jdbcTypeCode)));\n             }\n         }\n     }\n     if (isNationalized()) {\n         jdbcTypeCode \u003d NationalizedTypeMappings.INSTANCE.getCorrespondingNationalizedCode(jdbcTypeCode);\n     }\n-    final SqlTypeDescriptor sqlTypeDescriptor \u003d SqlTypeDescriptorRegistry.INSTANCE.getDescriptor(jdbcTypeCode);\n+    final SqlTypeDescriptor sqlTypeDescriptor \u003d metadata.getMetadataBuildingOptions().getServiceRegistry().getService(JdbcServices.class).getJdbcEnvironment().getDialect().remapSqlTypeDescriptor(SqlTypeDescriptorRegistry.INSTANCE.getDescriptor(jdbcTypeCode));\n     final JavaTypeDescriptor intermediateJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(databaseColumnJavaType);\n     final SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(attributeConverterDescriptor.getAttributeConverter(), sqlTypeDescriptor, intermediateJavaTypeDescriptor);\n     final String name \u003d AttributeConverterTypeAdapter.NAME_PREFIX + attributeConverterDescriptor.getAttributeConverter().getClass().getName();\n     final String description \u003d String.format(\"BasicType adapter for AttributeConverter\u003c%s,%s\u003e\", entityAttributeJavaType.getSimpleName(), databaseColumnJavaType.getSimpleName());\n     return new AttributeConverterTypeAdapter(name, description, attributeConverterDescriptor.getAttributeConverter(), sqlTypeDescriptorAdapter, entityAttributeJavaType, databaseColumnJavaType, entityAttributeJavaTypeDescriptor);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0cf66b85e03a997dc94f8f82598ca8edac04e889": {
      "type": "Ybodychange",
      "commitMessage": "HHH-10050 - AttributeConverter should supports ParameterizedType if autoApply is true\n",
      "commitDate": "2015/10/7 上午5:07",
      "commitName": "0cf66b85e03a997dc94f8f82598ca8edac04e889",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2015/10/4 上午2:44",
      "commitNameOld": "3ac508882c89ebd7c80af71d0e65ba26a017ebe3",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 3.1,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate Type buildAttributeConverterTypeAdapter() {\n    final Class entityAttributeJavaType \u003d attributeConverterDescriptor.getDomainType();\n    final Class databaseColumnJavaType \u003d attributeConverterDescriptor.getJdbcType();\n    final JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(entityAttributeJavaType);\n    int jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass(databaseColumnJavaType);\n    if (isLob()) {\n        if (LobTypeMappings.INSTANCE.hasCorrespondingLobCode(jdbcTypeCode)) {\n            jdbcTypeCode \u003d LobTypeMappings.INSTANCE.getCorrespondingLobCode(jdbcTypeCode);\n        } else {\n            if (Serializable.class.isAssignableFrom(entityAttributeJavaType)) {\n                jdbcTypeCode \u003d Types.BLOB;\n            } else {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"JDBC type-code [%s (%s)] not known to have a corresponding LOB equivalent, and Java type is not Serializable (to use BLOB)\", jdbcTypeCode, JdbcTypeNameMapper.getTypeName(jdbcTypeCode)));\n            }\n        }\n    }\n    if (isNationalized()) {\n        jdbcTypeCode \u003d NationalizedTypeMappings.INSTANCE.getCorrespondingNationalizedCode(jdbcTypeCode);\n    }\n    final SqlTypeDescriptor sqlTypeDescriptor \u003d SqlTypeDescriptorRegistry.INSTANCE.getDescriptor(jdbcTypeCode);\n    final JavaTypeDescriptor intermediateJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(databaseColumnJavaType);\n    final SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(attributeConverterDescriptor.getAttributeConverter(), sqlTypeDescriptor, intermediateJavaTypeDescriptor);\n    final String name \u003d AttributeConverterTypeAdapter.NAME_PREFIX + attributeConverterDescriptor.getAttributeConverter().getClass().getName();\n    final String description \u003d String.format(\"BasicType adapter for AttributeConverter\u003c%s,%s\u003e\", entityAttributeJavaType.getSimpleName(), databaseColumnJavaType.getSimpleName());\n    return new AttributeConverterTypeAdapter(name, description, attributeConverterDescriptor.getAttributeConverter(), sqlTypeDescriptorAdapter, entityAttributeJavaType, databaseColumnJavaType, entityAttributeJavaTypeDescriptor);\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/mapping/SimpleValue.java",
      "functionStartLine": 476,
      "functionName": "buildAttributeConverterTypeAdapter",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Build a Hibernate Type that incorporates the JPA AttributeConverter.  AttributeConverter works totally in\nmemory, meaning it converts between one Java representation (the entity attribute representation) and another\n(the value bound into JDBC statements or extracted from results).  However, the Hibernate Type system operates\nat the lower level of actually dealing directly with those JDBC objects.  So even though we have an\nAttributeConverter, we still need to \"fill out\" the rest of the BasicType data and bridge calls\nto bind/extract through the converter.\n\u003cp/\u003e\nEssentially the idea here is that an intermediate Java type needs to be used.  Let\u0027s use an example as a means\nto illustrate...  Consider an {@code AttributeConverter\u003cInteger,String\u003e}.  This tells Hibernate that the domain\nmodel defines this attribute as an Integer value (the \u0027entityAttributeJavaType\u0027), but that we need to treat the\nvalue as a String (the \u0027databaseColumnJavaType\u0027) when dealing with JDBC (aka, the database type is a\nVARCHAR/CHAR):\u003cul\u003e\n    \u003cli\u003e\n        When binding values to PreparedStatements we need to convert the Integer value from the entity\n        into a String and pass that String to setString.  The conversion is handled by calling\n        {@link AttributeConverter#convertToDatabaseColumn(Object)}\n    \u003c/li\u003e\n    \u003cli\u003e\n        When extracting values from ResultSets (or CallableStatement parameters) we need to handle the\n        value via getString, and convert that returned String to an Integer.  That conversion is handled\n        by calling {@link AttributeConverter#convertToEntityAttribute(Object)}\n    \u003c/li\u003e\n\u003c/ul\u003e\n\n@return The built AttributeConverter -\u003e Type adapter\n@todo : ultimately I want to see attributeConverterJavaType and attributeConverterJdbcTypeCode specify-able separately\nthen we can \"play them against each other\" in terms of determining proper typing\n@todo : see if we already have previously built a custom on-the-fly BasicType for this AttributeConverter; see note below about caching\n",
      "diff": "@@ -1,27 +1,27 @@\n @SuppressWarnings(\"unchecked\")\n private Type buildAttributeConverterTypeAdapter() {\n-    final Class entityAttributeJavaType \u003d attributeConverterDefinition.getEntityAttributeType();\n-    final Class databaseColumnJavaType \u003d attributeConverterDefinition.getDatabaseColumnType();\n+    final Class entityAttributeJavaType \u003d attributeConverterDescriptor.getDomainType();\n+    final Class databaseColumnJavaType \u003d attributeConverterDescriptor.getJdbcType();\n     final JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(entityAttributeJavaType);\n     int jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass(databaseColumnJavaType);\n     if (isLob()) {\n         if (LobTypeMappings.INSTANCE.hasCorrespondingLobCode(jdbcTypeCode)) {\n             jdbcTypeCode \u003d LobTypeMappings.INSTANCE.getCorrespondingLobCode(jdbcTypeCode);\n         } else {\n             if (Serializable.class.isAssignableFrom(entityAttributeJavaType)) {\n                 jdbcTypeCode \u003d Types.BLOB;\n             } else {\n                 throw new IllegalArgumentException(String.format(Locale.ROOT, \"JDBC type-code [%s (%s)] not known to have a corresponding LOB equivalent, and Java type is not Serializable (to use BLOB)\", jdbcTypeCode, JdbcTypeNameMapper.getTypeName(jdbcTypeCode)));\n             }\n         }\n     }\n     if (isNationalized()) {\n         jdbcTypeCode \u003d NationalizedTypeMappings.INSTANCE.getCorrespondingNationalizedCode(jdbcTypeCode);\n     }\n     final SqlTypeDescriptor sqlTypeDescriptor \u003d SqlTypeDescriptorRegistry.INSTANCE.getDescriptor(jdbcTypeCode);\n     final JavaTypeDescriptor intermediateJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(databaseColumnJavaType);\n-    final SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(attributeConverterDefinition.getAttributeConverter(), sqlTypeDescriptor, intermediateJavaTypeDescriptor);\n-    final String name \u003d AttributeConverterTypeAdapter.NAME_PREFIX + attributeConverterDefinition.getAttributeConverter().getClass().getName();\n+    final SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(attributeConverterDescriptor.getAttributeConverter(), sqlTypeDescriptor, intermediateJavaTypeDescriptor);\n+    final String name \u003d AttributeConverterTypeAdapter.NAME_PREFIX + attributeConverterDescriptor.getAttributeConverter().getClass().getName();\n     final String description \u003d String.format(\"BasicType adapter for AttributeConverter\u003c%s,%s\u003e\", entityAttributeJavaType.getSimpleName(), databaseColumnJavaType.getSimpleName());\n-    return new AttributeConverterTypeAdapter(name, description, attributeConverterDefinition.getAttributeConverter(), sqlTypeDescriptorAdapter, entityAttributeJavaType, databaseColumnJavaType, entityAttributeJavaTypeDescriptor);\n+    return new AttributeConverterTypeAdapter(name, description, attributeConverterDescriptor.getAttributeConverter(), sqlTypeDescriptorAdapter, entityAttributeJavaType, databaseColumnJavaType, entityAttributeJavaTypeDescriptor);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3ac508882c89ebd7c80af71d0e65ba26a017ebe3": {
      "type": "Ybodychange",
      "commitMessage": "HHH-9615 - Allow AttributeConverter on attributes marked as Lob\n",
      "commitDate": "2015/10/4 上午2:44",
      "commitName": "3ac508882c89ebd7c80af71d0e65ba26a017ebe3",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2015/8/27 上午3:55",
      "commitNameOld": "5f5e5f82c4d3f64e799509d71acd08284e60670c",
      "commitAuthorOld": "Kamil Szymanski",
      "daysBetweenCommits": 37.95,
      "commitsBetweenForRepo": 82,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate Type buildAttributeConverterTypeAdapter() {\n    final Class entityAttributeJavaType \u003d attributeConverterDefinition.getEntityAttributeType();\n    final Class databaseColumnJavaType \u003d attributeConverterDefinition.getDatabaseColumnType();\n    final JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(entityAttributeJavaType);\n    int jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass(databaseColumnJavaType);\n    if (isLob()) {\n        if (LobTypeMappings.INSTANCE.hasCorrespondingLobCode(jdbcTypeCode)) {\n            jdbcTypeCode \u003d LobTypeMappings.INSTANCE.getCorrespondingLobCode(jdbcTypeCode);\n        } else {\n            if (Serializable.class.isAssignableFrom(entityAttributeJavaType)) {\n                jdbcTypeCode \u003d Types.BLOB;\n            } else {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"JDBC type-code [%s (%s)] not known to have a corresponding LOB equivalent, and Java type is not Serializable (to use BLOB)\", jdbcTypeCode, JdbcTypeNameMapper.getTypeName(jdbcTypeCode)));\n            }\n        }\n    }\n    if (isNationalized()) {\n        jdbcTypeCode \u003d NationalizedTypeMappings.INSTANCE.getCorrespondingNationalizedCode(jdbcTypeCode);\n    }\n    final SqlTypeDescriptor sqlTypeDescriptor \u003d SqlTypeDescriptorRegistry.INSTANCE.getDescriptor(jdbcTypeCode);\n    final JavaTypeDescriptor intermediateJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(databaseColumnJavaType);\n    final SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(attributeConverterDefinition.getAttributeConverter(), sqlTypeDescriptor, intermediateJavaTypeDescriptor);\n    final String name \u003d AttributeConverterTypeAdapter.NAME_PREFIX + attributeConverterDefinition.getAttributeConverter().getClass().getName();\n    final String description \u003d String.format(\"BasicType adapter for AttributeConverter\u003c%s,%s\u003e\", entityAttributeJavaType.getSimpleName(), databaseColumnJavaType.getSimpleName());\n    return new AttributeConverterTypeAdapter(name, description, attributeConverterDefinition.getAttributeConverter(), sqlTypeDescriptorAdapter, entityAttributeJavaType, databaseColumnJavaType, entityAttributeJavaTypeDescriptor);\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/mapping/SimpleValue.java",
      "functionStartLine": 475,
      "functionName": "buildAttributeConverterTypeAdapter",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Build a Hibernate Type that incorporates the JPA AttributeConverter.  AttributeConverter works totally in\nmemory, meaning it converts between one Java representation (the entity attribute representation) and another\n(the value bound into JDBC statements or extracted from results).  However, the Hibernate Type system operates\nat the lower level of actually dealing directly with those JDBC objects.  So even though we have an\nAttributeConverter, we still need to \"fill out\" the rest of the BasicType data and bridge calls\nto bind/extract through the converter.\n\u003cp/\u003e\nEssentially the idea here is that an intermediate Java type needs to be used.  Let\u0027s use an example as a means\nto illustrate...  Consider an {@code AttributeConverter\u003cInteger,String\u003e}.  This tells Hibernate that the domain\nmodel defines this attribute as an Integer value (the \u0027entityAttributeJavaType\u0027), but that we need to treat the\nvalue as a String (the \u0027databaseColumnJavaType\u0027) when dealing with JDBC (aka, the database type is a\nVARCHAR/CHAR):\u003cul\u003e\n    \u003cli\u003e\n        When binding values to PreparedStatements we need to convert the Integer value from the entity\n        into a String and pass that String to setString.  The conversion is handled by calling\n        {@link AttributeConverter#convertToDatabaseColumn(Object)}\n    \u003c/li\u003e\n    \u003cli\u003e\n        When extracting values from ResultSets (or CallableStatement parameters) we need to handle the\n        value via getString, and convert that returned String to an Integer.  That conversion is handled\n        by calling {@link AttributeConverter#convertToEntityAttribute(Object)}\n    \u003c/li\u003e\n\u003c/ul\u003e\n\n@return The built AttributeConverter -\u003e Type adapter\n@todo : ultimately I want to see attributeConverterJavaType and attributeConverterJdbcTypeCode specify-able separately\nthen we can \"play them against each other\" in terms of determining proper typing\n@todo : see if we already have previously built a custom on-the-fly BasicType for this AttributeConverter; see note below about caching\n",
      "diff": "@@ -1,16 +1,27 @@\n @SuppressWarnings(\"unchecked\")\n private Type buildAttributeConverterTypeAdapter() {\n     final Class entityAttributeJavaType \u003d attributeConverterDefinition.getEntityAttributeType();\n     final Class databaseColumnJavaType \u003d attributeConverterDefinition.getDatabaseColumnType();\n     final JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(entityAttributeJavaType);\n     int jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass(databaseColumnJavaType);\n+    if (isLob()) {\n+        if (LobTypeMappings.INSTANCE.hasCorrespondingLobCode(jdbcTypeCode)) {\n+            jdbcTypeCode \u003d LobTypeMappings.INSTANCE.getCorrespondingLobCode(jdbcTypeCode);\n+        } else {\n+            if (Serializable.class.isAssignableFrom(entityAttributeJavaType)) {\n+                jdbcTypeCode \u003d Types.BLOB;\n+            } else {\n+                throw new IllegalArgumentException(String.format(Locale.ROOT, \"JDBC type-code [%s (%s)] not known to have a corresponding LOB equivalent, and Java type is not Serializable (to use BLOB)\", jdbcTypeCode, JdbcTypeNameMapper.getTypeName(jdbcTypeCode)));\n+            }\n+        }\n+    }\n     if (isNationalized()) {\n         jdbcTypeCode \u003d NationalizedTypeMappings.INSTANCE.getCorrespondingNationalizedCode(jdbcTypeCode);\n     }\n     final SqlTypeDescriptor sqlTypeDescriptor \u003d SqlTypeDescriptorRegistry.INSTANCE.getDescriptor(jdbcTypeCode);\n     final JavaTypeDescriptor intermediateJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(databaseColumnJavaType);\n     final SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(attributeConverterDefinition.getAttributeConverter(), sqlTypeDescriptor, intermediateJavaTypeDescriptor);\n     final String name \u003d AttributeConverterTypeAdapter.NAME_PREFIX + attributeConverterDefinition.getAttributeConverter().getClass().getName();\n     final String description \u003d String.format(\"BasicType adapter for AttributeConverter\u003c%s,%s\u003e\", entityAttributeJavaType.getSimpleName(), databaseColumnJavaType.getSimpleName());\n     return new AttributeConverterTypeAdapter(name, description, attributeConverterDefinition.getAttributeConverter(), sqlTypeDescriptorAdapter, entityAttributeJavaType, databaseColumnJavaType, entityAttributeJavaTypeDescriptor);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "38c004431d006ac5173d0c095f97415b5e6267a6": {
      "type": "Ybodychange",
      "commitMessage": "HHH-9599 - AnnotationException occurs when applying @Nationalized and @Convert annotations to the same field\n",
      "commitDate": "2015/3/21 上午5:55",
      "commitName": "38c004431d006ac5173d0c095f97415b5e6267a6",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2015/3/21 上午12:17",
      "commitNameOld": "22730624fc267cd12bf1e6551158fa3057fd8d58",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 0.23,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate Type buildAttributeConverterTypeAdapter() {\n    final Class entityAttributeJavaType \u003d attributeConverterDefinition.getEntityAttributeType();\n    final Class databaseColumnJavaType \u003d attributeConverterDefinition.getDatabaseColumnType();\n    final JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(entityAttributeJavaType);\n    int jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass(databaseColumnJavaType);\n    if (isNationalized()) {\n        jdbcTypeCode \u003d NationalizedTypeMappings.INSTANCE.getCorrespondingNationalizedCode(jdbcTypeCode);\n    }\n    final SqlTypeDescriptor sqlTypeDescriptor \u003d SqlTypeDescriptorRegistry.INSTANCE.getDescriptor(jdbcTypeCode);\n    final JavaTypeDescriptor intermediateJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(databaseColumnJavaType);\n    final SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(attributeConverterDefinition.getAttributeConverter(), sqlTypeDescriptor, intermediateJavaTypeDescriptor);\n    final String name \u003d AttributeConverterTypeAdapter.NAME_PREFIX + attributeConverterDefinition.getAttributeConverter().getClass().getName();\n    final String description \u003d String.format(\"BasicType adapter for AttributeConverter\u003c%s,%s\u003e\", entityAttributeJavaType.getSimpleName(), databaseColumnJavaType.getSimpleName());\n    return new AttributeConverterTypeAdapter(name, description, attributeConverterDefinition.getAttributeConverter(), sqlTypeDescriptorAdapter, entityAttributeJavaType, databaseColumnJavaType, entityAttributeJavaTypeDescriptor);\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/mapping/SimpleValue.java",
      "functionStartLine": 457,
      "functionName": "buildAttributeConverterTypeAdapter",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Build a Hibernate Type that incorporates the JPA AttributeConverter.  AttributeConverter works totally in\nmemory, meaning it converts between one Java representation (the entity attribute representation) and another\n(the value bound into JDBC statements or extracted from results).  However, the Hibernate Type system operates\nat the lower level of actually dealing directly with those JDBC objects.  So even though we have an\nAttributeConverter, we still need to \"fill out\" the rest of the BasicType data and bridge calls\nto bind/extract through the converter.\n\u003cp/\u003e\nEssentially the idea here is that an intermediate Java type needs to be used.  Let\u0027s use an example as a means\nto illustrate...  Consider an {@code AttributeConverter\u003cInteger,String\u003e}.  This tells Hibernate that the domain\nmodel defines this attribute as an Integer value (the \u0027entityAttributeJavaType\u0027), but that we need to treat the\nvalue as a String (the \u0027databaseColumnJavaType\u0027) when dealing with JDBC (aka, the database type is a\nVARCHAR/CHAR):\u003cul\u003e\n    \u003cli\u003e\n        When binding values to PreparedStatements we need to convert the Integer value from the entity\n        into a String and pass that String to setString.  The conversion is handled by calling\n        {@link AttributeConverter#convertToDatabaseColumn(Object)}\n    \u003c/li\u003e\n    \u003cli\u003e\n        When extracting values from ResultSets (or CallableStatement parameters) we need to handle the\n        value via getString, and convert that returned String to an Integer.  That conversion is handled\n        by calling {@link AttributeConverter#convertToEntityAttribute(Object)}\n    \u003c/li\u003e\n\u003c/ul\u003e\n\n@return The built AttributeConverter -\u003e Type adapter\n@todo : ultimately I want to see attributeConverterJavaType and attributeConverterJdbcTypeCode specify-able separately\nthen we can \"play them against each other\" in terms of determining proper typing\n@todo : see if we already have previously built a custom on-the-fly BasicType for this AttributeConverter; see note below about caching\n",
      "diff": "@@ -1,13 +1,16 @@\n @SuppressWarnings(\"unchecked\")\n private Type buildAttributeConverterTypeAdapter() {\n     final Class entityAttributeJavaType \u003d attributeConverterDefinition.getEntityAttributeType();\n     final Class databaseColumnJavaType \u003d attributeConverterDefinition.getDatabaseColumnType();\n     final JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(entityAttributeJavaType);\n-    final int jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass(databaseColumnJavaType);\n+    int jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass(databaseColumnJavaType);\n+    if (isNationalized()) {\n+        jdbcTypeCode \u003d NationalizedTypeMappings.INSTANCE.getCorrespondingNationalizedCode(jdbcTypeCode);\n+    }\n     final SqlTypeDescriptor sqlTypeDescriptor \u003d SqlTypeDescriptorRegistry.INSTANCE.getDescriptor(jdbcTypeCode);\n     final JavaTypeDescriptor intermediateJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(databaseColumnJavaType);\n     final SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(attributeConverterDefinition.getAttributeConverter(), sqlTypeDescriptor, intermediateJavaTypeDescriptor);\n     final String name \u003d AttributeConverterTypeAdapter.NAME_PREFIX + attributeConverterDefinition.getAttributeConverter().getClass().getName();\n     final String description \u003d String.format(\"BasicType adapter for AttributeConverter\u003c%s,%s\u003e\", entityAttributeJavaType.getSimpleName(), databaseColumnJavaType.getSimpleName());\n     return new AttributeConverterTypeAdapter(name, description, attributeConverterDefinition.getAttributeConverter(), sqlTypeDescriptorAdapter, entityAttributeJavaType, databaseColumnJavaType, entityAttributeJavaTypeDescriptor);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "22730624fc267cd12bf1e6551158fa3057fd8d58": {
      "type": "Ybodychange",
      "commitMessage": "HHH-9042 - Envers fails with @Converter and AttributeConverter\n",
      "commitDate": "2015/3/21 上午12:17",
      "commitName": "22730624fc267cd12bf1e6551158fa3057fd8d58",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2015/3/11 上午5:53",
      "commitNameOld": "9caca0ce37d5a2763d476c6fa2471addcca710ca",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 9.77,
      "commitsBetweenForRepo": 28,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate Type buildAttributeConverterTypeAdapter() {\n    final Class entityAttributeJavaType \u003d attributeConverterDefinition.getEntityAttributeType();\n    final Class databaseColumnJavaType \u003d attributeConverterDefinition.getDatabaseColumnType();\n    final JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(entityAttributeJavaType);\n    final int jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass(databaseColumnJavaType);\n    final SqlTypeDescriptor sqlTypeDescriptor \u003d SqlTypeDescriptorRegistry.INSTANCE.getDescriptor(jdbcTypeCode);\n    final JavaTypeDescriptor intermediateJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(databaseColumnJavaType);\n    final SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(attributeConverterDefinition.getAttributeConverter(), sqlTypeDescriptor, intermediateJavaTypeDescriptor);\n    final String name \u003d AttributeConverterTypeAdapter.NAME_PREFIX + attributeConverterDefinition.getAttributeConverter().getClass().getName();\n    final String description \u003d String.format(\"BasicType adapter for AttributeConverter\u003c%s,%s\u003e\", entityAttributeJavaType.getSimpleName(), databaseColumnJavaType.getSimpleName());\n    return new AttributeConverterTypeAdapter(name, description, attributeConverterDefinition.getAttributeConverter(), sqlTypeDescriptorAdapter, entityAttributeJavaType, databaseColumnJavaType, entityAttributeJavaTypeDescriptor);\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/mapping/SimpleValue.java",
      "functionStartLine": 442,
      "functionName": "buildAttributeConverterTypeAdapter",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Build a Hibernate Type that incorporates the JPA AttributeConverter.  AttributeConverter works totally in\nmemory, meaning it converts between one Java representation (the entity attribute representation) and another\n(the value bound into JDBC statements or extracted from results).  However, the Hibernate Type system operates\nat the lower level of actually dealing directly with those JDBC objects.  So even though we have an\nAttributeConverter, we still need to \"fill out\" the rest of the BasicType data and bridge calls\nto bind/extract through the converter.\n\u003cp/\u003e\nEssentially the idea here is that an intermediate Java type needs to be used.  Let\u0027s use an example as a means\nto illustrate...  Consider an {@code AttributeConverter\u003cInteger,String\u003e}.  This tells Hibernate that the domain\nmodel defines this attribute as an Integer value (the \u0027entityAttributeJavaType\u0027), but that we need to treat the\nvalue as a String (the \u0027databaseColumnJavaType\u0027) when dealing with JDBC (aka, the database type is a\nVARCHAR/CHAR):\u003cul\u003e\n    \u003cli\u003e\n        When binding values to PreparedStatements we need to convert the Integer value from the entity\n        into a String and pass that String to setString.  The conversion is handled by calling\n        {@link AttributeConverter#convertToDatabaseColumn(Object)}\n    \u003c/li\u003e\n    \u003cli\u003e\n        When extracting values from ResultSets (or CallableStatement parameters) we need to handle the\n        value via getString, and convert that returned String to an Integer.  That conversion is handled\n        by calling {@link AttributeConverter#convertToEntityAttribute(Object)}\n    \u003c/li\u003e\n\u003c/ul\u003e\n\n@return The built AttributeConverter -\u003e Type adapter\n@todo : ultimately I want to see attributeConverterJavaType and attributeConverterJdbcTypeCode specify-able separately\nthen we can \"play them against each other\" in terms of determining proper typing\n@todo : see if we already have previously built a custom on-the-fly BasicType for this AttributeConverter; see note below about caching\n",
      "diff": "@@ -1,12 +1,13 @@\n @SuppressWarnings(\"unchecked\")\n private Type buildAttributeConverterTypeAdapter() {\n     final Class entityAttributeJavaType \u003d attributeConverterDefinition.getEntityAttributeType();\n     final Class databaseColumnJavaType \u003d attributeConverterDefinition.getDatabaseColumnType();\n     final JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(entityAttributeJavaType);\n     final int jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass(databaseColumnJavaType);\n     final SqlTypeDescriptor sqlTypeDescriptor \u003d SqlTypeDescriptorRegistry.INSTANCE.getDescriptor(jdbcTypeCode);\n     final JavaTypeDescriptor intermediateJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(databaseColumnJavaType);\n     final SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(attributeConverterDefinition.getAttributeConverter(), sqlTypeDescriptor, intermediateJavaTypeDescriptor);\n-    final String name \u003d String.format(\"BasicType adapter for AttributeConverter\u003c%s,%s\u003e\", entityAttributeJavaType.getSimpleName(), databaseColumnJavaType.getSimpleName());\n-    return new AttributeConverterTypeAdapter(name, attributeConverterDefinition.getAttributeConverter(), sqlTypeDescriptorAdapter, entityAttributeJavaType, databaseColumnJavaType, entityAttributeJavaTypeDescriptor);\n+    final String name \u003d AttributeConverterTypeAdapter.NAME_PREFIX + attributeConverterDefinition.getAttributeConverter().getClass().getName();\n+    final String description \u003d String.format(\"BasicType adapter for AttributeConverter\u003c%s,%s\u003e\", entityAttributeJavaType.getSimpleName(), databaseColumnJavaType.getSimpleName());\n+    return new AttributeConverterTypeAdapter(name, description, attributeConverterDefinition.getAttributeConverter(), sqlTypeDescriptorAdapter, entityAttributeJavaType, databaseColumnJavaType, entityAttributeJavaTypeDescriptor);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "498735aa3791097e0fc25e918d47336f359fa5ae": {
      "type": "Ybodychange",
      "commitMessage": "HHH-8478 - AttributeConverters need to be applied to JPQL and Criteria queries\n",
      "commitDate": "2013/9/24 上午1:55",
      "commitName": "498735aa3791097e0fc25e918d47336f359fa5ae",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2013/9/7 上午2:38",
      "commitNameOld": "1f6daa67854e1fd6c464fe3d2a98bda1047b252d",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 16.97,
      "commitsBetweenForRepo": 76,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate Type buildAttributeConverterTypeAdapter() {\n    final Class entityAttributeJavaType \u003d attributeConverterDefinition.getEntityAttributeType();\n    final Class databaseColumnJavaType \u003d attributeConverterDefinition.getDatabaseColumnType();\n    final JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(entityAttributeJavaType);\n    final int jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass(databaseColumnJavaType);\n    final SqlTypeDescriptor sqlTypeDescriptor \u003d SqlTypeDescriptorRegistry.INSTANCE.getDescriptor(jdbcTypeCode);\n    final JavaTypeDescriptor intermediateJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(databaseColumnJavaType);\n    final SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(attributeConverterDefinition.getAttributeConverter(), sqlTypeDescriptor, intermediateJavaTypeDescriptor);\n    final String name \u003d String.format(\"BasicType adapter for AttributeConverter\u003c%s,%s\u003e\", entityAttributeJavaType.getSimpleName(), databaseColumnJavaType.getSimpleName());\n    return new AttributeConverterTypeAdapter(name, attributeConverterDefinition.getAttributeConverter(), sqlTypeDescriptorAdapter, entityAttributeJavaType, databaseColumnJavaType, entityAttributeJavaTypeDescriptor);\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/mapping/SimpleValue.java",
      "functionStartLine": 405,
      "functionName": "buildAttributeConverterTypeAdapter",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Build a Hibernate Type that incorporates the JPA AttributeConverter.  AttributeConverter works totally in\nmemory, meaning it converts between one Java representation (the entity attribute representation) and another\n(the value bound into JDBC statements or extracted from results).  However, the Hibernate Type system operates\nat the lower level of actually dealing directly with those JDBC objects.  So even though we have an\nAttributeConverter, we still need to \"fill out\" the rest of the BasicType data and bridge calls\nto bind/extract through the converter.\n\u003cp/\u003e\nEssentially the idea here is that an intermediate Java type needs to be used.  Let\u0027s use an example as a means\nto illustrate...  Consider an {@code AttributeConverter\u003cInteger,String\u003e}.  This tells Hibernate that the domain\nmodel defines this attribute as an Integer value (the \u0027entityAttributeJavaType\u0027), but that we need to treat the\nvalue as a String (the \u0027databaseColumnJavaType\u0027) when dealing with JDBC (aka, the database type is a\nVARCHAR/CHAR):\u003cul\u003e\n    \u003cli\u003e\n        When binding values to PreparedStatements we need to convert the Integer value from the entity\n        into a String and pass that String to setString.  The conversion is handled by calling\n        {@link AttributeConverter#convertToDatabaseColumn(Object)}\n    \u003c/li\u003e\n    \u003cli\u003e\n        When extracting values from ResultSets (or CallableStatement parameters) we need to handle the\n        value via getString, and convert that returned String to an Integer.  That conversion is handled\n        by calling {@link AttributeConverter#convertToEntityAttribute(Object)}\n    \u003c/li\u003e\n\u003c/ul\u003e\n\n@return The built AttributeConverter -\u003e Type adapter\n@todo : ultimately I want to see attributeConverterJavaType and attributeConverterJdbcTypeCode specify-able separately\nthen we can \"play them against each other\" in terms of determining proper typing\n@todo : see if we already have previously built a custom on-the-fly BasicType for this AttributeConverter; see note below about caching\n",
      "diff": "@@ -1,12 +1,12 @@\n @SuppressWarnings(\"unchecked\")\n private Type buildAttributeConverterTypeAdapter() {\n     final Class entityAttributeJavaType \u003d attributeConverterDefinition.getEntityAttributeType();\n     final Class databaseColumnJavaType \u003d attributeConverterDefinition.getDatabaseColumnType();\n     final JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(entityAttributeJavaType);\n     final int jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass(databaseColumnJavaType);\n     final SqlTypeDescriptor sqlTypeDescriptor \u003d SqlTypeDescriptorRegistry.INSTANCE.getDescriptor(jdbcTypeCode);\n     final JavaTypeDescriptor intermediateJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(databaseColumnJavaType);\n     final SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(attributeConverterDefinition.getAttributeConverter(), sqlTypeDescriptor, intermediateJavaTypeDescriptor);\n     final String name \u003d String.format(\"BasicType adapter for AttributeConverter\u003c%s,%s\u003e\", entityAttributeJavaType.getSimpleName(), databaseColumnJavaType.getSimpleName());\n-    return new AttributeConverterTypeAdapter(name, attributeConverterDefinition.getAttributeConverter(), sqlTypeDescriptorAdapter, entityAttributeJavaTypeDescriptor);\n+    return new AttributeConverterTypeAdapter(name, attributeConverterDefinition.getAttributeConverter(), sqlTypeDescriptorAdapter, entityAttributeJavaType, databaseColumnJavaType, entityAttributeJavaTypeDescriptor);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1f6daa67854e1fd6c464fe3d2a98bda1047b252d": {
      "type": "Ybodychange",
      "commitMessage": "HHH-8469 - Application of JPA 2.1 AttributeConverters\n",
      "commitDate": "2013/9/7 上午2:38",
      "commitName": "1f6daa67854e1fd6c464fe3d2a98bda1047b252d",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2013/8/22 下午10:27",
      "commitNameOld": "9f86babd880b785b965f7f1b55d58dc6a6943ada",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 15.17,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate Type buildAttributeConverterTypeAdapter() {\n    final Class entityAttributeJavaType \u003d attributeConverterDefinition.getEntityAttributeType();\n    final Class databaseColumnJavaType \u003d attributeConverterDefinition.getDatabaseColumnType();\n    final JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(entityAttributeJavaType);\n    final int jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass(databaseColumnJavaType);\n    final SqlTypeDescriptor sqlTypeDescriptor \u003d SqlTypeDescriptorRegistry.INSTANCE.getDescriptor(jdbcTypeCode);\n    final JavaTypeDescriptor intermediateJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(databaseColumnJavaType);\n    final SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(attributeConverterDefinition.getAttributeConverter(), sqlTypeDescriptor, intermediateJavaTypeDescriptor);\n    final String name \u003d String.format(\"BasicType adapter for AttributeConverter\u003c%s,%s\u003e\", entityAttributeJavaType.getSimpleName(), databaseColumnJavaType.getSimpleName());\n    return new AttributeConverterTypeAdapter(name, attributeConverterDefinition.getAttributeConverter(), sqlTypeDescriptorAdapter, entityAttributeJavaTypeDescriptor);\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/mapping/SimpleValue.java",
      "functionStartLine": 405,
      "functionName": "buildAttributeConverterTypeAdapter",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Build a Hibernate Type that incorporates the JPA AttributeConverter.  AttributeConverter works totally in\nmemory, meaning it converts between one Java representation (the entity attribute representation) and another\n(the value bound into JDBC statements or extracted from results).  However, the Hibernate Type system operates\nat the lower level of actually dealing directly with those JDBC objects.  So even though we have an\nAttributeConverter, we still need to \"fill out\" the rest of the BasicType data and bridge calls\nto bind/extract through the converter.\n\u003cp/\u003e\nEssentially the idea here is that an intermediate Java type needs to be used.  Let\u0027s use an example as a means\nto illustrate...  Consider an {@code AttributeConverter\u003cInteger,String\u003e}.  This tells Hibernate that the domain\nmodel defines this attribute as an Integer value (the \u0027entityAttributeJavaType\u0027), but that we need to treat the\nvalue as a String (the \u0027databaseColumnJavaType\u0027) when dealing with JDBC (aka, the database type is a\nVARCHAR/CHAR):\u003cul\u003e\n    \u003cli\u003e\n        When binding values to PreparedStatements we need to convert the Integer value from the entity\n        into a String and pass that String to setString.  The conversion is handled by calling\n        {@link AttributeConverter#convertToDatabaseColumn(Object)}\n    \u003c/li\u003e\n    \u003cli\u003e\n        When extracting values from ResultSets (or CallableStatement parameters) we need to handle the\n        value via getString, and convert that returned String to an Integer.  That conversion is handled\n        by calling {@link AttributeConverter#convertToEntityAttribute(Object)}\n    \u003c/li\u003e\n\u003c/ul\u003e\n\n@return The built AttributeConverter -\u003e Type adapter\n@todo : ultimately I want to see attributeConverterJavaType and attributeConverterJdbcTypeCode specify-able separately\nthen we can \"play them against each other\" in terms of determining proper typing\n@todo : see if we already have previously built a custom on-the-fly BasicType for this AttributeConverter; see note below about caching\n",
      "diff": "@@ -1,12 +1,12 @@\n @SuppressWarnings(\"unchecked\")\n private Type buildAttributeConverterTypeAdapter() {\n-    final Class entityAttributeJavaType \u003d jpaAttributeConverterDefinition.getEntityAttributeType();\n-    final Class databaseColumnJavaType \u003d jpaAttributeConverterDefinition.getDatabaseColumnType();\n+    final Class entityAttributeJavaType \u003d attributeConverterDefinition.getEntityAttributeType();\n+    final Class databaseColumnJavaType \u003d attributeConverterDefinition.getDatabaseColumnType();\n     final JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(entityAttributeJavaType);\n     final int jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass(databaseColumnJavaType);\n     final SqlTypeDescriptor sqlTypeDescriptor \u003d SqlTypeDescriptorRegistry.INSTANCE.getDescriptor(jdbcTypeCode);\n     final JavaTypeDescriptor intermediateJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(databaseColumnJavaType);\n-    final SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(jpaAttributeConverterDefinition.getAttributeConverter(), sqlTypeDescriptor, intermediateJavaTypeDescriptor);\n+    final SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(attributeConverterDefinition.getAttributeConverter(), sqlTypeDescriptor, intermediateJavaTypeDescriptor);\n     final String name \u003d String.format(\"BasicType adapter for AttributeConverter\u003c%s,%s\u003e\", entityAttributeJavaType.getSimpleName(), databaseColumnJavaType.getSimpleName());\n-    return new AttributeConverterTypeAdapter(name, jpaAttributeConverterDefinition.getAttributeConverter(), sqlTypeDescriptorAdapter, entityAttributeJavaTypeDescriptor);\n+    return new AttributeConverterTypeAdapter(name, attributeConverterDefinition.getAttributeConverter(), sqlTypeDescriptorAdapter, entityAttributeJavaTypeDescriptor);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9f86babd880b785b965f7f1b55d58dc6a6943ada": {
      "type": "Ybodychange",
      "commitMessage": "HHH-8111 - AttributeConverter doesn\u0027t override built-in type mappings\n",
      "commitDate": "2013/8/22 下午10:27",
      "commitName": "9f86babd880b785b965f7f1b55d58dc6a6943ada",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2013/8/20 上午5:07",
      "commitNameOld": "bf168ca24ef0c328bd53d6d32e79f66b99ac56db",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 2.72,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate Type buildAttributeConverterTypeAdapter() {\n    final Class entityAttributeJavaType \u003d jpaAttributeConverterDefinition.getEntityAttributeType();\n    final Class databaseColumnJavaType \u003d jpaAttributeConverterDefinition.getDatabaseColumnType();\n    final JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(entityAttributeJavaType);\n    final int jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass(databaseColumnJavaType);\n    final SqlTypeDescriptor sqlTypeDescriptor \u003d SqlTypeDescriptorRegistry.INSTANCE.getDescriptor(jdbcTypeCode);\n    final JavaTypeDescriptor intermediateJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(databaseColumnJavaType);\n    final SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(jpaAttributeConverterDefinition.getAttributeConverter(), sqlTypeDescriptor, intermediateJavaTypeDescriptor);\n    final String name \u003d String.format(\"BasicType adapter for AttributeConverter\u003c%s,%s\u003e\", entityAttributeJavaType.getSimpleName(), databaseColumnJavaType.getSimpleName());\n    return new AttributeConverterTypeAdapter(name, jpaAttributeConverterDefinition.getAttributeConverter(), sqlTypeDescriptorAdapter, entityAttributeJavaTypeDescriptor);\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/mapping/SimpleValue.java",
      "functionStartLine": 405,
      "functionName": "buildAttributeConverterTypeAdapter",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Build a Hibernate Type that incorporates the JPA AttributeConverter.  AttributeConverter works totally in\nmemory, meaning it converts between one Java representation (the entity attribute representation) and another\n(the value bound into JDBC statements or extracted from results).  However, the Hibernate Type system operates\nat the lower level of actually dealing directly with those JDBC objects.  So even though we have an\nAttributeConverter, we still need to \"fill out\" the rest of the BasicType data and bridge calls\nto bind/extract through the converter.\n\u003cp/\u003e\nEssentially the idea here is that an intermediate Java type needs to be used.  Let\u0027s use an example as a means\nto illustrate...  Consider an {@code AttributeConverter\u003cInteger,String\u003e}.  This tells Hibernate that the domain\nmodel defines this attribute as an Integer value (the \u0027entityAttributeJavaType\u0027), but that we need to treat the\nvalue as a String (the \u0027databaseColumnJavaType\u0027) when dealing with JDBC (aka, the database type is a\nVARCHAR/CHAR):\u003cul\u003e\n    \u003cli\u003e\n        When binding values to PreparedStatements we need to convert the Integer value from the entity\n        into a String and pass that String to setString.  The conversion is handled by calling\n        {@link AttributeConverter#convertToDatabaseColumn(Object)}\n    \u003c/li\u003e\n    \u003cli\u003e\n        When extracting values from ResultSets (or CallableStatement parameters) we need to handle the\n        value via getString, and convert that returned String to an Integer.  That conversion is handled\n        by calling {@link AttributeConverter#convertToEntityAttribute(Object)}\n    \u003c/li\u003e\n\u003c/ul\u003e\n\n@return The built AttributeConverter -\u003e Type adapter\n@todo : ultimately I want to see attributeConverterJavaType and attributeConverterJdbcTypeCode specify-able separately\nthen we can \"play them against each other\" in terms of determining proper typing\n@todo : see if we already have previously built a custom on-the-fly BasicType for this AttributeConverter; see note below about caching\n",
      "diff": "@@ -1,12 +1,12 @@\n @SuppressWarnings(\"unchecked\")\n private Type buildAttributeConverterTypeAdapter() {\n     final Class entityAttributeJavaType \u003d jpaAttributeConverterDefinition.getEntityAttributeType();\n     final Class databaseColumnJavaType \u003d jpaAttributeConverterDefinition.getDatabaseColumnType();\n     final JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(entityAttributeJavaType);\n     final int jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass(databaseColumnJavaType);\n     final SqlTypeDescriptor sqlTypeDescriptor \u003d SqlTypeDescriptorRegistry.INSTANCE.getDescriptor(jdbcTypeCode);\n     final JavaTypeDescriptor intermediateJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(databaseColumnJavaType);\n     final SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(jpaAttributeConverterDefinition.getAttributeConverter(), sqlTypeDescriptor, intermediateJavaTypeDescriptor);\n-    final String name \u003d \"BasicType adapter for AttributeConverter\u003c\" + entityAttributeJavaType + \",\" + databaseColumnJavaType + \"\u003e\";\n-    return new AttributeConverterTypeAdapter(sqlTypeDescriptorAdapter, entityAttributeJavaTypeDescriptor, name);\n+    final String name \u003d String.format(\"BasicType adapter for AttributeConverter\u003c%s,%s\u003e\", entityAttributeJavaType.getSimpleName(), databaseColumnJavaType.getSimpleName());\n+    return new AttributeConverterTypeAdapter(name, jpaAttributeConverterDefinition.getAttributeConverter(), sqlTypeDescriptorAdapter, entityAttributeJavaTypeDescriptor);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "bf168ca24ef0c328bd53d6d32e79f66b99ac56db": {
      "type": "Ymultichange(Ybodychange,Ydocchange)",
      "commitMessage": "HHH-8111 - AttributeConverter doesn\u0027t override built-in type mappings\n",
      "commitDate": "2013/8/20 上午5:07",
      "commitName": "bf168ca24ef0c328bd53d6d32e79f66b99ac56db",
      "commitAuthor": "Steve Ebersole",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "HHH-8111 - AttributeConverter doesn\u0027t override built-in type mappings\n",
          "commitDate": "2013/8/20 上午5:07",
          "commitName": "bf168ca24ef0c328bd53d6d32e79f66b99ac56db",
          "commitAuthor": "Steve Ebersole",
          "commitDateOld": "2013/8/20 上午3:54",
          "commitNameOld": "7bcf161d36d5b1e59fba1ae32e8e2d692c2fd33d",
          "commitAuthorOld": "Steve Ebersole",
          "daysBetweenCommits": 0.05,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate Type buildAttributeConverterTypeAdapter() {\n    final Class entityAttributeJavaType \u003d jpaAttributeConverterDefinition.getEntityAttributeType();\n    final Class databaseColumnJavaType \u003d jpaAttributeConverterDefinition.getDatabaseColumnType();\n    final JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(entityAttributeJavaType);\n    final int jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass(databaseColumnJavaType);\n    final SqlTypeDescriptor sqlTypeDescriptor \u003d SqlTypeDescriptorRegistry.INSTANCE.getDescriptor(jdbcTypeCode);\n    final JavaTypeDescriptor intermediateJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(databaseColumnJavaType);\n    final SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(jpaAttributeConverterDefinition.getAttributeConverter(), sqlTypeDescriptor, intermediateJavaTypeDescriptor);\n    final String name \u003d \"BasicType adapter for AttributeConverter\u003c\" + entityAttributeJavaType + \",\" + databaseColumnJavaType + \"\u003e\";\n    return new AttributeConverterTypeAdapter(sqlTypeDescriptorAdapter, entityAttributeJavaTypeDescriptor, name);\n}",
          "path": "hibernate-core/src/main/java/org/hibernate/mapping/SimpleValue.java",
          "functionStartLine": 405,
          "functionName": "buildAttributeConverterTypeAdapter",
          "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
          "functionDoc": "Build a Hibernate Type that incorporates the JPA AttributeConverter.  AttributeConverter works totally in\nmemory, meaning it converts between one Java representation (the entity attribute representation) and another\n(the value bound into JDBC statements or extracted from results).  However, the Hibernate Type system operates\nat the lower level of actually dealing directly with those JDBC objects.  So even though we have an\nAttributeConverter, we still need to \"fill out\" the rest of the BasicType data and bridge calls\nto bind/extract through the converter.\n\u003cp/\u003e\nEssentially the idea here is that an intermediate Java type needs to be used.  Let\u0027s use an example as a means\nto illustrate...  Consider an {@code AttributeConverter\u003cInteger,String\u003e}.  This tells Hibernate that the domain\nmodel defines this attribute as an Integer value (the \u0027entityAttributeJavaType\u0027), but that we need to treat the\nvalue as a String (the \u0027databaseColumnJavaType\u0027) when dealing with JDBC (aka, the database type is a\nVARCHAR/CHAR):\u003cul\u003e\n    \u003cli\u003e\n        When binding values to PreparedStatements we need to convert the Integer value from the entity\n        into a String and pass that String to setString.  The conversion is handled by calling\n        {@link AttributeConverter#convertToDatabaseColumn(Object)}\n    \u003c/li\u003e\n    \u003cli\u003e\n        When extracting values from ResultSets (or CallableStatement parameters) we need to handle the\n        value via getString, and convert that returned String to an Integer.  That conversion is handled\n        by calling {@link AttributeConverter#convertToEntityAttribute(Object)}\n    \u003c/li\u003e\n\u003c/ul\u003e\n\n@return The built AttributeConverter -\u003e Type adapter\n@todo : ultimately I want to see attributeConverterJavaType and attributeConverterJdbcTypeCode specify-able separately\nthen we can \"play them against each other\" in terms of determining proper typing\n@todo : see if we already have previously built a custom on-the-fly BasicType for this AttributeConverter; see note below about caching\n",
          "diff": "@@ -1,20 +1,12 @@\n @SuppressWarnings(\"unchecked\")\n private Type buildAttributeConverterTypeAdapter() {\n     final Class entityAttributeJavaType \u003d jpaAttributeConverterDefinition.getEntityAttributeType();\n     final Class databaseColumnJavaType \u003d jpaAttributeConverterDefinition.getDatabaseColumnType();\n     final JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(entityAttributeJavaType);\n     final int jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass(databaseColumnJavaType);\n     final SqlTypeDescriptor sqlTypeDescriptor \u003d SqlTypeDescriptorRegistry.INSTANCE.getDescriptor(jdbcTypeCode);\n     final JavaTypeDescriptor intermediateJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(databaseColumnJavaType);\n     final SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(jpaAttributeConverterDefinition.getAttributeConverter(), sqlTypeDescriptor, intermediateJavaTypeDescriptor);\n     final String name \u003d \"BasicType adapter for AttributeConverter\u003c\" + entityAttributeJavaType + \",\" + databaseColumnJavaType + \"\u003e\";\n-    final Type type \u003d new AbstractSingleColumnStandardBasicType(sqlTypeDescriptorAdapter, entityAttributeJavaTypeDescriptor) {\n-\n-        @Override\n-        public String getName() {\n-            return name;\n-        }\n-    };\n-    log.debug(\"Created : \" + name);\n-    return type;\n+    return new AttributeConverterTypeAdapter(sqlTypeDescriptorAdapter, entityAttributeJavaTypeDescriptor, name);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "HHH-8111 - AttributeConverter doesn\u0027t override built-in type mappings\n",
          "commitDate": "2013/8/20 上午5:07",
          "commitName": "bf168ca24ef0c328bd53d6d32e79f66b99ac56db",
          "commitAuthor": "Steve Ebersole",
          "commitDateOld": "2013/8/20 上午3:54",
          "commitNameOld": "7bcf161d36d5b1e59fba1ae32e8e2d692c2fd33d",
          "commitAuthorOld": "Steve Ebersole",
          "daysBetweenCommits": 0.05,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate Type buildAttributeConverterTypeAdapter() {\n    final Class entityAttributeJavaType \u003d jpaAttributeConverterDefinition.getEntityAttributeType();\n    final Class databaseColumnJavaType \u003d jpaAttributeConverterDefinition.getDatabaseColumnType();\n    final JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(entityAttributeJavaType);\n    final int jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass(databaseColumnJavaType);\n    final SqlTypeDescriptor sqlTypeDescriptor \u003d SqlTypeDescriptorRegistry.INSTANCE.getDescriptor(jdbcTypeCode);\n    final JavaTypeDescriptor intermediateJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(databaseColumnJavaType);\n    final SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(jpaAttributeConverterDefinition.getAttributeConverter(), sqlTypeDescriptor, intermediateJavaTypeDescriptor);\n    final String name \u003d \"BasicType adapter for AttributeConverter\u003c\" + entityAttributeJavaType + \",\" + databaseColumnJavaType + \"\u003e\";\n    return new AttributeConverterTypeAdapter(sqlTypeDescriptorAdapter, entityAttributeJavaTypeDescriptor, name);\n}",
          "path": "hibernate-core/src/main/java/org/hibernate/mapping/SimpleValue.java",
          "functionStartLine": 405,
          "functionName": "buildAttributeConverterTypeAdapter",
          "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
          "functionDoc": "Build a Hibernate Type that incorporates the JPA AttributeConverter.  AttributeConverter works totally in\nmemory, meaning it converts between one Java representation (the entity attribute representation) and another\n(the value bound into JDBC statements or extracted from results).  However, the Hibernate Type system operates\nat the lower level of actually dealing directly with those JDBC objects.  So even though we have an\nAttributeConverter, we still need to \"fill out\" the rest of the BasicType data and bridge calls\nto bind/extract through the converter.\n\u003cp/\u003e\nEssentially the idea here is that an intermediate Java type needs to be used.  Let\u0027s use an example as a means\nto illustrate...  Consider an {@code AttributeConverter\u003cInteger,String\u003e}.  This tells Hibernate that the domain\nmodel defines this attribute as an Integer value (the \u0027entityAttributeJavaType\u0027), but that we need to treat the\nvalue as a String (the \u0027databaseColumnJavaType\u0027) when dealing with JDBC (aka, the database type is a\nVARCHAR/CHAR):\u003cul\u003e\n    \u003cli\u003e\n        When binding values to PreparedStatements we need to convert the Integer value from the entity\n        into a String and pass that String to setString.  The conversion is handled by calling\n        {@link AttributeConverter#convertToDatabaseColumn(Object)}\n    \u003c/li\u003e\n    \u003cli\u003e\n        When extracting values from ResultSets (or CallableStatement parameters) we need to handle the\n        value via getString, and convert that returned String to an Integer.  That conversion is handled\n        by calling {@link AttributeConverter#convertToEntityAttribute(Object)}\n    \u003c/li\u003e\n\u003c/ul\u003e\n\n@return The built AttributeConverter -\u003e Type adapter\n@todo : ultimately I want to see attributeConverterJavaType and attributeConverterJdbcTypeCode specify-able separately\nthen we can \"play them against each other\" in terms of determining proper typing\n@todo : see if we already have previously built a custom on-the-fly BasicType for this AttributeConverter; see note below about caching\n",
          "diff": "@@ -1,20 +1,12 @@\n @SuppressWarnings(\"unchecked\")\n private Type buildAttributeConverterTypeAdapter() {\n     final Class entityAttributeJavaType \u003d jpaAttributeConverterDefinition.getEntityAttributeType();\n     final Class databaseColumnJavaType \u003d jpaAttributeConverterDefinition.getDatabaseColumnType();\n     final JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(entityAttributeJavaType);\n     final int jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass(databaseColumnJavaType);\n     final SqlTypeDescriptor sqlTypeDescriptor \u003d SqlTypeDescriptorRegistry.INSTANCE.getDescriptor(jdbcTypeCode);\n     final JavaTypeDescriptor intermediateJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(databaseColumnJavaType);\n     final SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(jpaAttributeConverterDefinition.getAttributeConverter(), sqlTypeDescriptor, intermediateJavaTypeDescriptor);\n     final String name \u003d \"BasicType adapter for AttributeConverter\u003c\" + entityAttributeJavaType + \",\" + databaseColumnJavaType + \"\u003e\";\n-    final Type type \u003d new AbstractSingleColumnStandardBasicType(sqlTypeDescriptorAdapter, entityAttributeJavaTypeDescriptor) {\n-\n-        @Override\n-        public String getName() {\n-            return name;\n-        }\n-    };\n-    log.debug(\"Created : \" + name);\n-    return type;\n+    return new AttributeConverterTypeAdapter(sqlTypeDescriptorAdapter, entityAttributeJavaTypeDescriptor, name);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Build a Hibernate Type that incorporates the JPA AttributeConverter.  AttributeConverter works totally in\nmemory, meaning it converts between one Java representation (the entity attribute representation) and another\n(the value bound into JDBC statements or extracted from results).  However, the Hibernate Type system operates\nat the lower level of actually dealing directly with those JDBC objects.  So even though we have an\nAttributeConverter, we still need to \"fill out\" the rest of the BasicType data and bridge calls\nto bind/extract through the converter.\n\u003cp/\u003e\nEssentially the idea here is that an intermediate Java type needs to be used.  Let\u0027s use an example as a means\nto illustrate...  Consider an {@code AttributeConverter\u003cInteger,String\u003e}.  This tells Hibernate that the domain\nmodel defines this attribute as an Integer value (the \u0027entityAttributeJavaType\u0027), but that we need to treat the\nvalue as a String (the \u0027databaseColumnJavaType\u0027) when dealing with JDBC (aka, the database type is a\nVARCHAR/CHAR):\u003cul\u003e\n    \u003cli\u003e\n        When binding values to PreparedStatements we need to convert the Integer value from the entity\n        into a String and pass that String to setString.  The conversion is handled by calling\n        {@link AttributeConverter#convertToDatabaseColumn(Object)}\n    \u003c/li\u003e\n    \u003cli\u003e\n        When extracting values from ResultSets (or CallableStatement parameters) we need to handle the\n        value via getString, and convert that returned String to an Integer.  That conversion is handled\n        by calling {@link AttributeConverter#convertToEntityAttribute(Object)}\n    \u003c/li\u003e\n\u003c/ul\u003e\n\nFor the JavaTypeDescriptor portion we simply resolve the \"entity attribute representation\" part of\n\t // the AttributeConverter to resolve the corresponding descriptor.  For the SqlTypeDescriptor portion we use the\n\t // \"database column representation\" part of the AttributeConverter to resolve the \"recommended\" JDBC type-code\n\t // and use that type-code to resolve the SqlTypeDescriptor to use.\n\n\n\u003cp/\u003e\n\n\u003cp/\u003e\n\u003cp/\u003e\n\n@todo : ultimately I want to see attributeConverterJavaType and attributeConverterJdbcTypeCode specify-able separately\nthen we can \"play them against each other\" in terms of determining proper typing\n@todo : see if we already have previously built a custom on-the-fly BasicType for this AttributeConverter; see note below about caching\n@return The built AttributeConverter -\u003e Type adapter\n",
            "newValue": "Build a Hibernate Type that incorporates the JPA AttributeConverter.  AttributeConverter works totally in\nmemory, meaning it converts between one Java representation (the entity attribute representation) and another\n(the value bound into JDBC statements or extracted from results).  However, the Hibernate Type system operates\nat the lower level of actually dealing directly with those JDBC objects.  So even though we have an\nAttributeConverter, we still need to \"fill out\" the rest of the BasicType data and bridge calls\nto bind/extract through the converter.\n\u003cp/\u003e\nEssentially the idea here is that an intermediate Java type needs to be used.  Let\u0027s use an example as a means\nto illustrate...  Consider an {@code AttributeConverter\u003cInteger,String\u003e}.  This tells Hibernate that the domain\nmodel defines this attribute as an Integer value (the \u0027entityAttributeJavaType\u0027), but that we need to treat the\nvalue as a String (the \u0027databaseColumnJavaType\u0027) when dealing with JDBC (aka, the database type is a\nVARCHAR/CHAR):\u003cul\u003e\n    \u003cli\u003e\n        When binding values to PreparedStatements we need to convert the Integer value from the entity\n        into a String and pass that String to setString.  The conversion is handled by calling\n        {@link AttributeConverter#convertToDatabaseColumn(Object)}\n    \u003c/li\u003e\n    \u003cli\u003e\n        When extracting values from ResultSets (or CallableStatement parameters) we need to handle the\n        value via getString, and convert that returned String to an Integer.  That conversion is handled\n        by calling {@link AttributeConverter#convertToEntityAttribute(Object)}\n    \u003c/li\u003e\n\u003c/ul\u003e\n\n@return The built AttributeConverter -\u003e Type adapter\n@todo : ultimately I want to see attributeConverterJavaType and attributeConverterJdbcTypeCode specify-able separately\nthen we can \"play them against each other\" in terms of determining proper typing\n@todo : see if we already have previously built a custom on-the-fly BasicType for this AttributeConverter; see note below about caching\n"
          }
        }
      ]
    },
    "7bcf161d36d5b1e59fba1ae32e8e2d692c2fd33d": {
      "type": "Yintroduced",
      "commitMessage": "HHH-8111 - AttributeConverter doesn\u0027t override built-in type mappings\n",
      "commitDate": "2013/8/20 上午3:54",
      "commitName": "7bcf161d36d5b1e59fba1ae32e8e2d692c2fd33d",
      "commitAuthor": "Steve Ebersole",
      "diff": "@@ -0,0 +1,20 @@\n+@SuppressWarnings(\"unchecked\")\n+private Type buildAttributeConverterTypeAdapter() {\n+    final Class entityAttributeJavaType \u003d jpaAttributeConverterDefinition.getEntityAttributeType();\n+    final Class databaseColumnJavaType \u003d jpaAttributeConverterDefinition.getDatabaseColumnType();\n+    final JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(entityAttributeJavaType);\n+    final int jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass(databaseColumnJavaType);\n+    final SqlTypeDescriptor sqlTypeDescriptor \u003d SqlTypeDescriptorRegistry.INSTANCE.getDescriptor(jdbcTypeCode);\n+    final JavaTypeDescriptor intermediateJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(databaseColumnJavaType);\n+    final SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(jpaAttributeConverterDefinition.getAttributeConverter(), sqlTypeDescriptor, intermediateJavaTypeDescriptor);\n+    final String name \u003d \"BasicType adapter for AttributeConverter\u003c\" + entityAttributeJavaType + \",\" + databaseColumnJavaType + \"\u003e\";\n+    final Type type \u003d new AbstractSingleColumnStandardBasicType(sqlTypeDescriptorAdapter, entityAttributeJavaTypeDescriptor) {\n+\n+        @Override\n+        public String getName() {\n+            return name;\n+        }\n+    };\n+    log.debug(\"Created : \" + name);\n+    return type;\n+}\n\\ No newline at end of file\n",
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate Type buildAttributeConverterTypeAdapter() {\n    final Class entityAttributeJavaType \u003d jpaAttributeConverterDefinition.getEntityAttributeType();\n    final Class databaseColumnJavaType \u003d jpaAttributeConverterDefinition.getDatabaseColumnType();\n    final JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(entityAttributeJavaType);\n    final int jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass(databaseColumnJavaType);\n    final SqlTypeDescriptor sqlTypeDescriptor \u003d SqlTypeDescriptorRegistry.INSTANCE.getDescriptor(jdbcTypeCode);\n    final JavaTypeDescriptor intermediateJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(databaseColumnJavaType);\n    final SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(jpaAttributeConverterDefinition.getAttributeConverter(), sqlTypeDescriptor, intermediateJavaTypeDescriptor);\n    final String name \u003d \"BasicType adapter for AttributeConverter\u003c\" + entityAttributeJavaType + \",\" + databaseColumnJavaType + \"\u003e\";\n    final Type type \u003d new AbstractSingleColumnStandardBasicType(sqlTypeDescriptorAdapter, entityAttributeJavaTypeDescriptor) {\n\n        @Override\n        public String getName() {\n            return name;\n        }\n    };\n    log.debug(\"Created : \" + name);\n    return type;\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/mapping/SimpleValue.java",
      "functionStartLine": 415,
      "functionName": "buildAttributeConverterTypeAdapter",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Build a Hibernate Type that incorporates the JPA AttributeConverter.  AttributeConverter works totally in\nmemory, meaning it converts between one Java representation (the entity attribute representation) and another\n(the value bound into JDBC statements or extracted from results).  However, the Hibernate Type system operates\nat the lower level of actually dealing directly with those JDBC objects.  So even though we have an\nAttributeConverter, we still need to \"fill out\" the rest of the BasicType data and bridge calls\nto bind/extract through the converter.\n\u003cp/\u003e\nEssentially the idea here is that an intermediate Java type needs to be used.  Let\u0027s use an example as a means\nto illustrate...  Consider an {@code AttributeConverter\u003cInteger,String\u003e}.  This tells Hibernate that the domain\nmodel defines this attribute as an Integer value (the \u0027entityAttributeJavaType\u0027), but that we need to treat the\nvalue as a String (the \u0027databaseColumnJavaType\u0027) when dealing with JDBC (aka, the database type is a\nVARCHAR/CHAR):\u003cul\u003e\n    \u003cli\u003e\n        When binding values to PreparedStatements we need to convert the Integer value from the entity\n        into a String and pass that String to setString.  The conversion is handled by calling\n        {@link AttributeConverter#convertToDatabaseColumn(Object)}\n    \u003c/li\u003e\n    \u003cli\u003e\n        When extracting values from ResultSets (or CallableStatement parameters) we need to handle the\n        value via getString, and convert that returned String to an Integer.  That conversion is handled\n        by calling {@link AttributeConverter#convertToEntityAttribute(Object)}\n    \u003c/li\u003e\n\u003c/ul\u003e\n\nFor the JavaTypeDescriptor portion we simply resolve the \"entity attribute representation\" part of\n\t // the AttributeConverter to resolve the corresponding descriptor.  For the SqlTypeDescriptor portion we use the\n\t // \"database column representation\" part of the AttributeConverter to resolve the \"recommended\" JDBC type-code\n\t // and use that type-code to resolve the SqlTypeDescriptor to use.\n\n\n\u003cp/\u003e\n\n\u003cp/\u003e\n\u003cp/\u003e\n\n@todo : ultimately I want to see attributeConverterJavaType and attributeConverterJdbcTypeCode specify-able separately\nthen we can \"play them against each other\" in terms of determining proper typing\n@todo : see if we already have previously built a custom on-the-fly BasicType for this AttributeConverter; see note below about caching\n@return The built AttributeConverter -\u003e Type adapter\n"
    }
  }
}