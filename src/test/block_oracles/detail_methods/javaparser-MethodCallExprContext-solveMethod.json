{
  "origin": "codeshovel",
  "repositoryName": "javaparser",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/javaparser/.git",
  "startCommitName": "97555053af3025556efe1a168fd7943dac28a2a6",
  "sourceFileName": "MethodCallExprContext.java",
  "functionName": "solveMethod",
  "functionId": "solveMethod___name-String__argumentsTypes-List__ResolvedType____staticOnly-boolean__typeSolver-TypeSolver",
  "sourceFilePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
  "functionAnnotation": "@Override",
  "functionDoc": "",
  "functionStartLine": 153,
  "functionEndLine": 162,
  "numCommitsSeen": 230,
  "timeTaken": 1475,
  "changeHistory": [
    "09232ff6b0ea19e850482f3a87ac6ef1c063c759",
    "1db4cd7914d4f36224a4a8944e546650d5fc5a4d",
    "5d8d0cb7947efcf2282f7d056302dd905f348532",
    "acdac6790f4424f8097b3aa6c888e825cac485f9",
    "17ac5ada0476c72aa79a2e0c39311e90bfa0fe60",
    "e5fe2b597be66d230f8824277c1d4167fa2bb609",
    "065875981b4d1ffa4bf3535d7c89319a4a3345f1",
    "e47162df70ac5344d1a7b8c08220474224e64536",
    "c990d23490f5c4ac4322119b03d5951b63eef055",
    "6e1380f412d334f1c887d15edf0b4610c3cf0da2",
    "ca3e3a946698cf3a4f93e6fb7b4d2b16ee2e3ed5",
    "9c53c2cbc607ea694438ade8630be0c155a33162",
    "0d14741fef3a17451db153cfe379e398da4b4b79",
    "341e081a5f8909a3a467671befcca2941b786d3d",
    "88db8b2a8b93bcc692cb8fd5085ba68b8bcf1968",
    "656bb37a1dba87d61d24e69f2346f35dbc73d81d",
    "051dbd94c17c4f142d3fe9e8fbd03c29d09ace54",
    "ecc78c8b480ceb41019f764c983aaa69c2dabfe3",
    "82eb44707b620803d424188a1eb8708fcaf093cb",
    "401a56f412ca186a00a2282d9088e8cb7b67e0e5",
    "a16d5b37001074f2fa6eea4d1d1ef7e0466ca51b",
    "cb7655f9661f11dab8ec9e2533722d649a16e715",
    "2c3f615e6b24358b86d6453e24dac35849ffde26",
    "8e655d386a595ea1927ebeded58939d7b8a7ce0c",
    "4a18b1ee8ed716d6e32e190f728f1eee57148872",
    "f4b07b1a2deac6d1b562424ac2380b92cec77a90",
    "40ddb5e17127d2139e4b66b980ad11004749e86a",
    "965ab8585c3e8be1dff784e749e37dad31151ec8",
    "362cdf49fd4c7ea6d60f3172fd2804f8aa765f4c",
    "b36f33050149a62a5b3c8c7451ae93f736715029",
    "d393205e2ee874242b73e4fe819d1bc874587d8a",
    "627b56302d259409e9bc50b20d77803484f18b5c",
    "80f951258992f75441239c79e0f31eda7d47e107",
    "8415b0bc2abfc2eb094745336a1cd27a4c96fa4b",
    "8b8cc6cddbf5af0c93c4ceffd015f6328c932149",
    "2f49331fb22511346eea8800d27907de44409d5b"
  ],
  "changeHistoryShort": {
    "09232ff6b0ea19e850482f3a87ac6ef1c063c759": "Yfilerename",
    "1db4cd7914d4f36224a4a8944e546650d5fc5a4d": "Ybodychange",
    "5d8d0cb7947efcf2282f7d056302dd905f348532": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
    "acdac6790f4424f8097b3aa6c888e825cac485f9": "Ybodychange",
    "17ac5ada0476c72aa79a2e0c39311e90bfa0fe60": "Ymultichange(Yparameterchange,Ybodychange)",
    "e5fe2b597be66d230f8824277c1d4167fa2bb609": "Ybodychange",
    "065875981b4d1ffa4bf3535d7c89319a4a3345f1": "Ybodychange",
    "e47162df70ac5344d1a7b8c08220474224e64536": "Ybodychange",
    "c990d23490f5c4ac4322119b03d5951b63eef055": "Ybodychange",
    "6e1380f412d334f1c887d15edf0b4610c3cf0da2": "Ybodychange",
    "ca3e3a946698cf3a4f93e6fb7b4d2b16ee2e3ed5": "Ybodychange",
    "9c53c2cbc607ea694438ade8630be0c155a33162": "Yfilerename",
    "0d14741fef3a17451db153cfe379e398da4b4b79": "Ybodychange",
    "341e081a5f8909a3a467671befcca2941b786d3d": "Ybodychange",
    "88db8b2a8b93bcc692cb8fd5085ba68b8bcf1968": "Ymultichange(Yparameterchange,Ybodychange)",
    "656bb37a1dba87d61d24e69f2346f35dbc73d81d": "Ybodychange",
    "051dbd94c17c4f142d3fe9e8fbd03c29d09ace54": "Ybodychange",
    "ecc78c8b480ceb41019f764c983aaa69c2dabfe3": "Ybodychange",
    "82eb44707b620803d424188a1eb8708fcaf093cb": "Ymultichange(Yparameterchange,Ybodychange)",
    "401a56f412ca186a00a2282d9088e8cb7b67e0e5": "Ybodychange",
    "a16d5b37001074f2fa6eea4d1d1ef7e0466ca51b": "Ybodychange",
    "cb7655f9661f11dab8ec9e2533722d649a16e715": "Ybodychange",
    "2c3f615e6b24358b86d6453e24dac35849ffde26": "Ybodychange",
    "8e655d386a595ea1927ebeded58939d7b8a7ce0c": "Yfilerename",
    "4a18b1ee8ed716d6e32e190f728f1eee57148872": "Ybodychange",
    "f4b07b1a2deac6d1b562424ac2380b92cec77a90": "Yfilerename",
    "40ddb5e17127d2139e4b66b980ad11004749e86a": "Ybodychange",
    "965ab8585c3e8be1dff784e749e37dad31151ec8": "Ybodychange",
    "362cdf49fd4c7ea6d60f3172fd2804f8aa765f4c": "Ybodychange",
    "b36f33050149a62a5b3c8c7451ae93f736715029": "Yfilerename",
    "d393205e2ee874242b73e4fe819d1bc874587d8a": "Ybodychange",
    "627b56302d259409e9bc50b20d77803484f18b5c": "Ybodychange",
    "80f951258992f75441239c79e0f31eda7d47e107": "Ybodychange",
    "8415b0bc2abfc2eb094745336a1cd27a4c96fa4b": "Ybodychange",
    "8b8cc6cddbf5af0c93c4ceffd015f6328c932149": "Ymultichange(Yparameterchange,Ybodychange)",
    "2f49331fb22511346eea8800d27907de44409d5b": "Yintroduced"
  },
  "changeHistoryDetails": {
    "09232ff6b0ea19e850482f3a87ac6ef1c063c759": {
      "type": "Yfilerename",
      "commitMessage": "rename JSS modules\n",
      "commitDate": "2018/1/10 下午8:52",
      "commitName": "09232ff6b0ea19e850482f3a87ac6ef1c063c759",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2018/1/10 下午4:01",
      "commitNameOld": "30c04db173cc439556df2a238c99cd81ada320ff",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.2,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic SymbolReference\u003cResolvedMethodDeclaration\u003e solveMethod(String name, List\u003cResolvedType\u003e argumentsTypes, boolean staticOnly, TypeSolver typeSolver) {\n    Collection\u003cResolvedReferenceTypeDeclaration\u003e rrtds \u003d findTypeDeclarations(wrappedNode.getScope(), typeSolver);\n    for (ResolvedReferenceTypeDeclaration rrtd : rrtds) {\n        SymbolReference\u003cResolvedMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(rrtd, name, argumentsTypes, false, typeSolver);\n        if (res.isSolved()) {\n            return res;\n        }\n    }\n    return SymbolReference.unsolved(ResolvedMethodDeclaration.class);\n}",
      "path": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 151,
      "functionName": "solveMethod",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
        "newPath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java"
      }
    },
    "1db4cd7914d4f36224a4a8944e546650d5fc5a4d": {
      "type": "Ybodychange",
      "commitMessage": "Fix issue #300\n",
      "commitDate": "2017/12/10 下午10:34",
      "commitName": "1db4cd7914d4f36224a4a8944e546650d5fc5a4d",
      "commitAuthor": "Marcos César de Oliveira",
      "commitDateOld": "2017/9/29 上午4:36",
      "commitNameOld": "5d8d0cb7947efcf2282f7d056302dd905f348532",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 72.75,
      "commitsBetweenForRepo": 81,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic SymbolReference\u003cResolvedMethodDeclaration\u003e solveMethod(String name, List\u003cResolvedType\u003e argumentsTypes, boolean staticOnly, TypeSolver typeSolver) {\n    Collection\u003cResolvedReferenceTypeDeclaration\u003e rrtds \u003d findTypeDeclarations(wrappedNode.getScope(), typeSolver);\n    for (ResolvedReferenceTypeDeclaration rrtd : rrtds) {\n        SymbolReference\u003cResolvedMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(rrtd, name, argumentsTypes, false, typeSolver);\n        if (res.isSolved()) {\n            return res;\n        }\n    }\n    return SymbolReference.unsolved(ResolvedMethodDeclaration.class);\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 151,
      "functionName": "solveMethod",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,44 +1,11 @@\n @Override\n public SymbolReference\u003cResolvedMethodDeclaration\u003e solveMethod(String name, List\u003cResolvedType\u003e argumentsTypes, boolean staticOnly, TypeSolver typeSolver) {\n-    if (wrappedNode.getScope().isPresent()) {\n-        Expression scope \u003d wrappedNode.getScope().get();\n-        if (scope instanceof NameExpr) {\n-            NameExpr scopeAsName \u003d (NameExpr) scope;\n-            SymbolReference\u003cResolvedTypeDeclaration\u003e symbolReference \u003d this.solveType(scopeAsName.getName().getId(), typeSolver);\n-            if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n-                ResolvedTypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n-                return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, false, typeSolver);\n-            }\n+    Collection\u003cResolvedReferenceTypeDeclaration\u003e rrtds \u003d findTypeDeclarations(wrappedNode.getScope(), typeSolver);\n+    for (ResolvedReferenceTypeDeclaration rrtd : rrtds) {\n+        SymbolReference\u003cResolvedMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(rrtd, name, argumentsTypes, false, typeSolver);\n+        if (res.isSolved()) {\n+            return res;\n         }\n-        ResolvedType typeOfScope \u003d null;\n-        try {\n-            typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n-        } catch (Exception e) {\n-            throw new RuntimeException(String.format(\"Issue calculating the type of the scope of \" + this), e);\n-        }\n-        if (typeOfScope.isWildcard()) {\n-            if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n-                return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n-            } else {\n-                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, false, typeSolver);\n-            }\n-        } else if (typeOfScope.isArray()) {\n-            return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, false, typeSolver);\n-        } else if (typeOfScope.isTypeVariable()) {\n-            for (ResolvedTypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds()) {\n-                SymbolReference\u003cResolvedMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n-                if (res.isSolved()) {\n-                    return res;\n-                }\n-            }\n-            return SymbolReference.unsolved(ResolvedMethodDeclaration.class);\n-        } else if (typeOfScope.isConstraint()) {\n-            return MethodResolutionLogic.solveMethodInType(typeOfScope.asConstraintType().getBound().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n-        } else {\n-            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n-        }\n-    } else {\n-        ResolvedType typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n-        return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n     }\n+    return SymbolReference.unsolved(ResolvedMethodDeclaration.class);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5d8d0cb7947efcf2282f7d056302dd905f348532": {
      "type": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
      "commitMessage": "more work on converting to moved classes\n",
      "commitDate": "2017/9/29 上午4:36",
      "commitName": "5d8d0cb7947efcf2282f7d056302dd905f348532",
      "commitAuthor": "Federico Tomassetti",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "more work on converting to moved classes\n",
          "commitDate": "2017/9/29 上午4:36",
          "commitName": "5d8d0cb7947efcf2282f7d056302dd905f348532",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2017/8/28 下午5:15",
          "commitNameOld": "abec22a71cd36e52d79a4575c21294ffd48c7016",
          "commitAuthorOld": "mlangkabel",
          "daysBetweenCommits": 31.47,
          "commitsBetweenForRepo": 14,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\npublic SymbolReference\u003cResolvedMethodDeclaration\u003e solveMethod(String name, List\u003cResolvedType\u003e argumentsTypes, boolean staticOnly, TypeSolver typeSolver) {\n    if (wrappedNode.getScope().isPresent()) {\n        Expression scope \u003d wrappedNode.getScope().get();\n        if (scope instanceof NameExpr) {\n            NameExpr scopeAsName \u003d (NameExpr) scope;\n            SymbolReference\u003cResolvedTypeDeclaration\u003e symbolReference \u003d this.solveType(scopeAsName.getName().getId(), typeSolver);\n            if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                ResolvedTypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, false, typeSolver);\n            }\n        }\n        ResolvedType typeOfScope \u003d null;\n        try {\n            typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n        } catch (Exception e) {\n            throw new RuntimeException(String.format(\"Issue calculating the type of the scope of \" + this), e);\n        }\n        if (typeOfScope.isWildcard()) {\n            if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n            } else {\n                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, false, typeSolver);\n            }\n        } else if (typeOfScope.isArray()) {\n            return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, false, typeSolver);\n        } else if (typeOfScope.isTypeVariable()) {\n            for (ResolvedTypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds()) {\n                SymbolReference\u003cResolvedMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n                if (res.isSolved()) {\n                    return res;\n                }\n            }\n            return SymbolReference.unsolved(ResolvedMethodDeclaration.class);\n        } else if (typeOfScope.isConstraint()) {\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asConstraintType().getBound().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n        } else {\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n        }\n    } else {\n        ResolvedType typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n    }\n}",
          "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
          "functionStartLine": 150,
          "functionName": "solveMethod",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,44 +1,44 @@\n @Override\n-public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, boolean staticOnly, TypeSolver typeSolver) {\n+public SymbolReference\u003cResolvedMethodDeclaration\u003e solveMethod(String name, List\u003cResolvedType\u003e argumentsTypes, boolean staticOnly, TypeSolver typeSolver) {\n     if (wrappedNode.getScope().isPresent()) {\n         Expression scope \u003d wrappedNode.getScope().get();\n         if (scope instanceof NameExpr) {\n             NameExpr scopeAsName \u003d (NameExpr) scope;\n-            SymbolReference\u003cTypeDeclaration\u003e symbolReference \u003d this.solveType(scopeAsName.getName().getId(), typeSolver);\n+            SymbolReference\u003cResolvedTypeDeclaration\u003e symbolReference \u003d this.solveType(scopeAsName.getName().getId(), typeSolver);\n             if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n-                TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n+                ResolvedTypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                 return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, false, typeSolver);\n             }\n         }\n-        Type typeOfScope \u003d null;\n+        ResolvedType typeOfScope \u003d null;\n         try {\n             typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n         } catch (Exception e) {\n             throw new RuntimeException(String.format(\"Issue calculating the type of the scope of \" + this), e);\n         }\n         if (typeOfScope.isWildcard()) {\n             if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                 return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n             } else {\n                 return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, false, typeSolver);\n             }\n         } else if (typeOfScope.isArray()) {\n             return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, false, typeSolver);\n         } else if (typeOfScope.isTypeVariable()) {\n-            for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n-                SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n+            for (ResolvedTypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds()) {\n+                SymbolReference\u003cResolvedMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n                 if (res.isSolved()) {\n                     return res;\n                 }\n             }\n-            return SymbolReference.unsolved(MethodDeclaration.class);\n+            return SymbolReference.unsolved(ResolvedMethodDeclaration.class);\n         } else if (typeOfScope.isConstraint()) {\n             return MethodResolutionLogic.solveMethodInType(typeOfScope.asConstraintType().getBound().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n         } else {\n             return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n         }\n     } else {\n-        Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n+        ResolvedType typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n         return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[name-String, argumentsTypes-List\u003cType\u003e, staticOnly-boolean, typeSolver-TypeSolver]",
            "newValue": "[name-String, argumentsTypes-List\u003cResolvedType\u003e, staticOnly-boolean, typeSolver-TypeSolver]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "more work on converting to moved classes\n",
          "commitDate": "2017/9/29 上午4:36",
          "commitName": "5d8d0cb7947efcf2282f7d056302dd905f348532",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2017/8/28 下午5:15",
          "commitNameOld": "abec22a71cd36e52d79a4575c21294ffd48c7016",
          "commitAuthorOld": "mlangkabel",
          "daysBetweenCommits": 31.47,
          "commitsBetweenForRepo": 14,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\npublic SymbolReference\u003cResolvedMethodDeclaration\u003e solveMethod(String name, List\u003cResolvedType\u003e argumentsTypes, boolean staticOnly, TypeSolver typeSolver) {\n    if (wrappedNode.getScope().isPresent()) {\n        Expression scope \u003d wrappedNode.getScope().get();\n        if (scope instanceof NameExpr) {\n            NameExpr scopeAsName \u003d (NameExpr) scope;\n            SymbolReference\u003cResolvedTypeDeclaration\u003e symbolReference \u003d this.solveType(scopeAsName.getName().getId(), typeSolver);\n            if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                ResolvedTypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, false, typeSolver);\n            }\n        }\n        ResolvedType typeOfScope \u003d null;\n        try {\n            typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n        } catch (Exception e) {\n            throw new RuntimeException(String.format(\"Issue calculating the type of the scope of \" + this), e);\n        }\n        if (typeOfScope.isWildcard()) {\n            if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n            } else {\n                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, false, typeSolver);\n            }\n        } else if (typeOfScope.isArray()) {\n            return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, false, typeSolver);\n        } else if (typeOfScope.isTypeVariable()) {\n            for (ResolvedTypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds()) {\n                SymbolReference\u003cResolvedMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n                if (res.isSolved()) {\n                    return res;\n                }\n            }\n            return SymbolReference.unsolved(ResolvedMethodDeclaration.class);\n        } else if (typeOfScope.isConstraint()) {\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asConstraintType().getBound().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n        } else {\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n        }\n    } else {\n        ResolvedType typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n    }\n}",
          "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
          "functionStartLine": 150,
          "functionName": "solveMethod",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,44 +1,44 @@\n @Override\n-public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, boolean staticOnly, TypeSolver typeSolver) {\n+public SymbolReference\u003cResolvedMethodDeclaration\u003e solveMethod(String name, List\u003cResolvedType\u003e argumentsTypes, boolean staticOnly, TypeSolver typeSolver) {\n     if (wrappedNode.getScope().isPresent()) {\n         Expression scope \u003d wrappedNode.getScope().get();\n         if (scope instanceof NameExpr) {\n             NameExpr scopeAsName \u003d (NameExpr) scope;\n-            SymbolReference\u003cTypeDeclaration\u003e symbolReference \u003d this.solveType(scopeAsName.getName().getId(), typeSolver);\n+            SymbolReference\u003cResolvedTypeDeclaration\u003e symbolReference \u003d this.solveType(scopeAsName.getName().getId(), typeSolver);\n             if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n-                TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n+                ResolvedTypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                 return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, false, typeSolver);\n             }\n         }\n-        Type typeOfScope \u003d null;\n+        ResolvedType typeOfScope \u003d null;\n         try {\n             typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n         } catch (Exception e) {\n             throw new RuntimeException(String.format(\"Issue calculating the type of the scope of \" + this), e);\n         }\n         if (typeOfScope.isWildcard()) {\n             if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                 return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n             } else {\n                 return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, false, typeSolver);\n             }\n         } else if (typeOfScope.isArray()) {\n             return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, false, typeSolver);\n         } else if (typeOfScope.isTypeVariable()) {\n-            for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n-                SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n+            for (ResolvedTypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds()) {\n+                SymbolReference\u003cResolvedMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n                 if (res.isSolved()) {\n                     return res;\n                 }\n             }\n-            return SymbolReference.unsolved(MethodDeclaration.class);\n+            return SymbolReference.unsolved(ResolvedMethodDeclaration.class);\n         } else if (typeOfScope.isConstraint()) {\n             return MethodResolutionLogic.solveMethodInType(typeOfScope.asConstraintType().getBound().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n         } else {\n             return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n         }\n     } else {\n-        Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n+        ResolvedType typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n         return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "SymbolReference\u003cMethodDeclaration\u003e",
            "newValue": "SymbolReference\u003cResolvedMethodDeclaration\u003e"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "more work on converting to moved classes\n",
          "commitDate": "2017/9/29 上午4:36",
          "commitName": "5d8d0cb7947efcf2282f7d056302dd905f348532",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2017/8/28 下午5:15",
          "commitNameOld": "abec22a71cd36e52d79a4575c21294ffd48c7016",
          "commitAuthorOld": "mlangkabel",
          "daysBetweenCommits": 31.47,
          "commitsBetweenForRepo": 14,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\npublic SymbolReference\u003cResolvedMethodDeclaration\u003e solveMethod(String name, List\u003cResolvedType\u003e argumentsTypes, boolean staticOnly, TypeSolver typeSolver) {\n    if (wrappedNode.getScope().isPresent()) {\n        Expression scope \u003d wrappedNode.getScope().get();\n        if (scope instanceof NameExpr) {\n            NameExpr scopeAsName \u003d (NameExpr) scope;\n            SymbolReference\u003cResolvedTypeDeclaration\u003e symbolReference \u003d this.solveType(scopeAsName.getName().getId(), typeSolver);\n            if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                ResolvedTypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, false, typeSolver);\n            }\n        }\n        ResolvedType typeOfScope \u003d null;\n        try {\n            typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n        } catch (Exception e) {\n            throw new RuntimeException(String.format(\"Issue calculating the type of the scope of \" + this), e);\n        }\n        if (typeOfScope.isWildcard()) {\n            if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n            } else {\n                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, false, typeSolver);\n            }\n        } else if (typeOfScope.isArray()) {\n            return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, false, typeSolver);\n        } else if (typeOfScope.isTypeVariable()) {\n            for (ResolvedTypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds()) {\n                SymbolReference\u003cResolvedMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n                if (res.isSolved()) {\n                    return res;\n                }\n            }\n            return SymbolReference.unsolved(ResolvedMethodDeclaration.class);\n        } else if (typeOfScope.isConstraint()) {\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asConstraintType().getBound().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n        } else {\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n        }\n    } else {\n        ResolvedType typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n    }\n}",
          "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
          "functionStartLine": 150,
          "functionName": "solveMethod",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,44 +1,44 @@\n @Override\n-public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, boolean staticOnly, TypeSolver typeSolver) {\n+public SymbolReference\u003cResolvedMethodDeclaration\u003e solveMethod(String name, List\u003cResolvedType\u003e argumentsTypes, boolean staticOnly, TypeSolver typeSolver) {\n     if (wrappedNode.getScope().isPresent()) {\n         Expression scope \u003d wrappedNode.getScope().get();\n         if (scope instanceof NameExpr) {\n             NameExpr scopeAsName \u003d (NameExpr) scope;\n-            SymbolReference\u003cTypeDeclaration\u003e symbolReference \u003d this.solveType(scopeAsName.getName().getId(), typeSolver);\n+            SymbolReference\u003cResolvedTypeDeclaration\u003e symbolReference \u003d this.solveType(scopeAsName.getName().getId(), typeSolver);\n             if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n-                TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n+                ResolvedTypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                 return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, false, typeSolver);\n             }\n         }\n-        Type typeOfScope \u003d null;\n+        ResolvedType typeOfScope \u003d null;\n         try {\n             typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n         } catch (Exception e) {\n             throw new RuntimeException(String.format(\"Issue calculating the type of the scope of \" + this), e);\n         }\n         if (typeOfScope.isWildcard()) {\n             if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                 return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n             } else {\n                 return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, false, typeSolver);\n             }\n         } else if (typeOfScope.isArray()) {\n             return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, false, typeSolver);\n         } else if (typeOfScope.isTypeVariable()) {\n-            for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n-                SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n+            for (ResolvedTypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds()) {\n+                SymbolReference\u003cResolvedMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n                 if (res.isSolved()) {\n                     return res;\n                 }\n             }\n-            return SymbolReference.unsolved(MethodDeclaration.class);\n+            return SymbolReference.unsolved(ResolvedMethodDeclaration.class);\n         } else if (typeOfScope.isConstraint()) {\n             return MethodResolutionLogic.solveMethodInType(typeOfScope.asConstraintType().getBound().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n         } else {\n             return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n         }\n     } else {\n-        Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n+        ResolvedType typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n         return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "acdac6790f4424f8097b3aa6c888e825cac485f9": {
      "type": "Ybodychange",
      "commitMessage": "Fixes for type inference\n",
      "commitDate": "2017/3/10 上午9:22",
      "commitName": "acdac6790f4424f8097b3aa6c888e825cac485f9",
      "commitAuthor": "xdrop",
      "commitDateOld": "2017/3/9 上午11:31",
      "commitNameOld": "17ac5ada0476c72aa79a2e0c39311e90bfa0fe60",
      "commitAuthorOld": "xdrop",
      "daysBetweenCommits": 0.91,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, boolean staticOnly, TypeSolver typeSolver) {\n    if (wrappedNode.getScope().isPresent()) {\n        Expression scope \u003d wrappedNode.getScope().get();\n        if (scope instanceof NameExpr) {\n            NameExpr scopeAsName \u003d (NameExpr) scope;\n            SymbolReference\u003cTypeDeclaration\u003e symbolReference \u003d this.solveType(scopeAsName.getName().getId(), typeSolver);\n            if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, false, typeSolver);\n            }\n        }\n        Type typeOfScope \u003d null;\n        try {\n            typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n        } catch (Exception e) {\n            throw new RuntimeException(String.format(\"Issue calculating the type of the scope of \" + this), e);\n        }\n        if (typeOfScope.isWildcard()) {\n            if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n            } else {\n                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, false, typeSolver);\n            }\n        } else if (typeOfScope.isArray()) {\n            return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, false, typeSolver);\n        } else if (typeOfScope.isTypeVariable()) {\n            for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n                if (res.isSolved()) {\n                    return res;\n                }\n            }\n            return SymbolReference.unsolved(MethodDeclaration.class);\n        } else if (typeOfScope.isConstraint()) {\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asConstraintType().getBound().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n        } else {\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n        }\n    } else {\n        Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 133,
      "functionName": "solveMethod",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,42 +1,44 @@\n @Override\n public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, boolean staticOnly, TypeSolver typeSolver) {\n     if (wrappedNode.getScope().isPresent()) {\n         Expression scope \u003d wrappedNode.getScope().get();\n         if (scope instanceof NameExpr) {\n             NameExpr scopeAsName \u003d (NameExpr) scope;\n             SymbolReference\u003cTypeDeclaration\u003e symbolReference \u003d this.solveType(scopeAsName.getName().getId(), typeSolver);\n             if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                 TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n-                return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver, false);\n+                return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, false, typeSolver);\n             }\n         }\n         Type typeOfScope \u003d null;\n         try {\n             typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n         } catch (Exception e) {\n             throw new RuntimeException(String.format(\"Issue calculating the type of the scope of \" + this), e);\n         }\n         if (typeOfScope.isWildcard()) {\n             if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n-                return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver, false);\n+                return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n             } else {\n-                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver, false);\n+                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, false, typeSolver);\n             }\n         } else if (typeOfScope.isArray()) {\n-            return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver, false);\n+            return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, false, typeSolver);\n         } else if (typeOfScope.isTypeVariable()) {\n             for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n-                SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver, false);\n+                SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n                 if (res.isSolved()) {\n                     return res;\n                 }\n             }\n             return SymbolReference.unsolved(MethodDeclaration.class);\n+        } else if (typeOfScope.isConstraint()) {\n+            return MethodResolutionLogic.solveMethodInType(typeOfScope.asConstraintType().getBound().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n         } else {\n-            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver, false);\n+            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n         }\n     } else {\n         Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n-        return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver, false);\n+        return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "17ac5ada0476c72aa79a2e0c39311e90bfa0fe60": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Fix issues with inherited methods in interfaces not being resolved\n",
      "commitDate": "2017/3/9 上午11:31",
      "commitName": "17ac5ada0476c72aa79a2e0c39311e90bfa0fe60",
      "commitAuthor": "xdrop",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Fix issues with inherited methods in interfaces not being resolved\n",
          "commitDate": "2017/3/9 上午11:31",
          "commitName": "17ac5ada0476c72aa79a2e0c39311e90bfa0fe60",
          "commitAuthor": "xdrop",
          "commitDateOld": "2017/3/9 上午5:40",
          "commitNameOld": "e5fe2b597be66d230f8824277c1d4167fa2bb609",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.24,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\npublic SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, boolean staticOnly, TypeSolver typeSolver) {\n    if (wrappedNode.getScope().isPresent()) {\n        Expression scope \u003d wrappedNode.getScope().get();\n        if (scope instanceof NameExpr) {\n            NameExpr scopeAsName \u003d (NameExpr) scope;\n            SymbolReference\u003cTypeDeclaration\u003e symbolReference \u003d this.solveType(scopeAsName.getName().getId(), typeSolver);\n            if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver, false);\n            }\n        }\n        Type typeOfScope \u003d null;\n        try {\n            typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n        } catch (Exception e) {\n            throw new RuntimeException(String.format(\"Issue calculating the type of the scope of \" + this), e);\n        }\n        if (typeOfScope.isWildcard()) {\n            if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver, false);\n            } else {\n                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver, false);\n            }\n        } else if (typeOfScope.isArray()) {\n            return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver, false);\n        } else if (typeOfScope.isTypeVariable()) {\n            for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver, false);\n                if (res.isSolved()) {\n                    return res;\n                }\n            }\n            return SymbolReference.unsolved(MethodDeclaration.class);\n        } else {\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver, false);\n        }\n    } else {\n        Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver, false);\n    }\n}",
          "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
          "functionStartLine": 133,
          "functionName": "solveMethod",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,42 +1,42 @@\n @Override\n-public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n+public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, boolean staticOnly, TypeSolver typeSolver) {\n     if (wrappedNode.getScope().isPresent()) {\n         Expression scope \u003d wrappedNode.getScope().get();\n         if (scope instanceof NameExpr) {\n             NameExpr scopeAsName \u003d (NameExpr) scope;\n             SymbolReference\u003cTypeDeclaration\u003e symbolReference \u003d this.solveType(scopeAsName.getName().getId(), typeSolver);\n             if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                 TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n-                return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n+                return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver, false);\n             }\n         }\n         Type typeOfScope \u003d null;\n         try {\n             typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n         } catch (Exception e) {\n             throw new RuntimeException(String.format(\"Issue calculating the type of the scope of \" + this), e);\n         }\n         if (typeOfScope.isWildcard()) {\n             if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n-                return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n+                return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver, false);\n             } else {\n-                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n+                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver, false);\n             }\n         } else if (typeOfScope.isArray()) {\n-            return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n+            return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver, false);\n         } else if (typeOfScope.isTypeVariable()) {\n             for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n-                SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n+                SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver, false);\n                 if (res.isSolved()) {\n                     return res;\n                 }\n             }\n             return SymbolReference.unsolved(MethodDeclaration.class);\n         } else {\n-            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n+            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver, false);\n         }\n     } else {\n         Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n-        return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n+        return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver, false);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[name-String, argumentsTypes-List\u003cType\u003e, typeSolver-TypeSolver]",
            "newValue": "[name-String, argumentsTypes-List\u003cType\u003e, staticOnly-boolean, typeSolver-TypeSolver]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Fix issues with inherited methods in interfaces not being resolved\n",
          "commitDate": "2017/3/9 上午11:31",
          "commitName": "17ac5ada0476c72aa79a2e0c39311e90bfa0fe60",
          "commitAuthor": "xdrop",
          "commitDateOld": "2017/3/9 上午5:40",
          "commitNameOld": "e5fe2b597be66d230f8824277c1d4167fa2bb609",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.24,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\npublic SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, boolean staticOnly, TypeSolver typeSolver) {\n    if (wrappedNode.getScope().isPresent()) {\n        Expression scope \u003d wrappedNode.getScope().get();\n        if (scope instanceof NameExpr) {\n            NameExpr scopeAsName \u003d (NameExpr) scope;\n            SymbolReference\u003cTypeDeclaration\u003e symbolReference \u003d this.solveType(scopeAsName.getName().getId(), typeSolver);\n            if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver, false);\n            }\n        }\n        Type typeOfScope \u003d null;\n        try {\n            typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n        } catch (Exception e) {\n            throw new RuntimeException(String.format(\"Issue calculating the type of the scope of \" + this), e);\n        }\n        if (typeOfScope.isWildcard()) {\n            if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver, false);\n            } else {\n                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver, false);\n            }\n        } else if (typeOfScope.isArray()) {\n            return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver, false);\n        } else if (typeOfScope.isTypeVariable()) {\n            for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver, false);\n                if (res.isSolved()) {\n                    return res;\n                }\n            }\n            return SymbolReference.unsolved(MethodDeclaration.class);\n        } else {\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver, false);\n        }\n    } else {\n        Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver, false);\n    }\n}",
          "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
          "functionStartLine": 133,
          "functionName": "solveMethod",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,42 +1,42 @@\n @Override\n-public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n+public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, boolean staticOnly, TypeSolver typeSolver) {\n     if (wrappedNode.getScope().isPresent()) {\n         Expression scope \u003d wrappedNode.getScope().get();\n         if (scope instanceof NameExpr) {\n             NameExpr scopeAsName \u003d (NameExpr) scope;\n             SymbolReference\u003cTypeDeclaration\u003e symbolReference \u003d this.solveType(scopeAsName.getName().getId(), typeSolver);\n             if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                 TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n-                return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n+                return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver, false);\n             }\n         }\n         Type typeOfScope \u003d null;\n         try {\n             typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n         } catch (Exception e) {\n             throw new RuntimeException(String.format(\"Issue calculating the type of the scope of \" + this), e);\n         }\n         if (typeOfScope.isWildcard()) {\n             if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n-                return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n+                return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver, false);\n             } else {\n-                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n+                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver, false);\n             }\n         } else if (typeOfScope.isArray()) {\n-            return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n+            return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver, false);\n         } else if (typeOfScope.isTypeVariable()) {\n             for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n-                SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n+                SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver, false);\n                 if (res.isSolved()) {\n                     return res;\n                 }\n             }\n             return SymbolReference.unsolved(MethodDeclaration.class);\n         } else {\n-            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n+            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver, false);\n         }\n     } else {\n         Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n-        return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n+        return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver, false);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "e5fe2b597be66d230f8824277c1d4167fa2bb609": {
      "type": "Ybodychange",
      "commitMessage": "typo\n",
      "commitDate": "2017/3/9 上午5:40",
      "commitName": "e5fe2b597be66d230f8824277c1d4167fa2bb609",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017/1/12 上午8:45",
      "commitNameOld": "065875981b4d1ffa4bf3535d7c89319a4a3345f1",
      "commitAuthorOld": "xdrop",
      "daysBetweenCommits": 55.87,
      "commitsBetweenForRepo": 52,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope().isPresent()) {\n        Expression scope \u003d wrappedNode.getScope().get();\n        if (scope instanceof NameExpr) {\n            NameExpr scopeAsName \u003d (NameExpr) scope;\n            SymbolReference\u003cTypeDeclaration\u003e symbolReference \u003d this.solveType(scopeAsName.getName().getId(), typeSolver);\n            if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n            }\n        }\n        Type typeOfScope \u003d null;\n        try {\n            typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n        } catch (Exception e) {\n            throw new RuntimeException(String.format(\"Issue calculating the type of the scope of \" + this), e);\n        }\n        if (typeOfScope.isWildcard()) {\n            if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n            } else {\n                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n            }\n        } else if (typeOfScope.isArray()) {\n            return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n        } else if (typeOfScope.isTypeVariable()) {\n            for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                if (res.isSolved()) {\n                    return res;\n                }\n            }\n            return SymbolReference.unsolved(MethodDeclaration.class);\n        } else {\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n        }\n    } else {\n        Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 133,
      "functionName": "solveMethod",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,42 +1,42 @@\n @Override\n public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope().isPresent()) {\n         Expression scope \u003d wrappedNode.getScope().get();\n         if (scope instanceof NameExpr) {\n             NameExpr scopeAsName \u003d (NameExpr) scope;\n             SymbolReference\u003cTypeDeclaration\u003e symbolReference \u003d this.solveType(scopeAsName.getName().getId(), typeSolver);\n             if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                 TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                 return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n             }\n         }\n         Type typeOfScope \u003d null;\n         try {\n             typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n         } catch (Exception e) {\n-            throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n+            throw new RuntimeException(String.format(\"Issue calculating the type of the scope of \" + this), e);\n         }\n         if (typeOfScope.isWildcard()) {\n             if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                 return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n             } else {\n                 return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n             }\n         } else if (typeOfScope.isArray()) {\n             return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n         } else if (typeOfScope.isTypeVariable()) {\n             for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                 SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                 if (res.isSolved()) {\n                     return res;\n                 }\n             }\n             return SymbolReference.unsolved(MethodDeclaration.class);\n         } else {\n             return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n         }\n     } else {\n         Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n         return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "065875981b4d1ffa4bf3535d7c89319a4a3345f1": {
      "type": "Ybodychange",
      "commitMessage": "Update for JavaParser 3.0.0\n",
      "commitDate": "2017/1/12 上午8:45",
      "commitName": "065875981b4d1ffa4bf3535d7c89319a4a3345f1",
      "commitAuthor": "xdrop",
      "commitDateOld": "2017/1/6 下午5:11",
      "commitNameOld": "860a4c0c034e1b8232e3d1ec17e7f11879850470",
      "commitAuthorOld": "",
      "daysBetweenCommits": 5.65,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope().isPresent()) {\n        Expression scope \u003d wrappedNode.getScope().get();\n        if (scope instanceof NameExpr) {\n            NameExpr scopeAsName \u003d (NameExpr) scope;\n            SymbolReference\u003cTypeDeclaration\u003e symbolReference \u003d this.solveType(scopeAsName.getName().getId(), typeSolver);\n            if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n            }\n        }\n        Type typeOfScope \u003d null;\n        try {\n            typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n        } catch (Exception e) {\n            throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n        }\n        if (typeOfScope.isWildcard()) {\n            if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n            } else {\n                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n            }\n        } else if (typeOfScope.isArray()) {\n            return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n        } else if (typeOfScope.isTypeVariable()) {\n            for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                if (res.isSolved()) {\n                    return res;\n                }\n            }\n            return SymbolReference.unsolved(MethodDeclaration.class);\n        } else {\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n        }\n    } else {\n        Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 133,
      "functionName": "solveMethod",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,41 +1,42 @@\n @Override\n public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n-    if (wrappedNode.getScope() !\u003d null) {\n-        if (wrappedNode.getScope() instanceof NameExpr) {\n-            NameExpr scopeAsName \u003d (NameExpr) wrappedNode.getScope();\n+    if (wrappedNode.getScope().isPresent()) {\n+        Expression scope \u003d wrappedNode.getScope().get();\n+        if (scope instanceof NameExpr) {\n+            NameExpr scopeAsName \u003d (NameExpr) scope;\n             SymbolReference\u003cTypeDeclaration\u003e symbolReference \u003d this.solveType(scopeAsName.getName().getId(), typeSolver);\n             if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                 TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                 return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n             }\n         }\n         Type typeOfScope \u003d null;\n         try {\n-            typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n+            typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n         } catch (Exception e) {\n             throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n         }\n         if (typeOfScope.isWildcard()) {\n             if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                 return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n             } else {\n                 return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n             }\n         } else if (typeOfScope.isArray()) {\n             return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n         } else if (typeOfScope.isTypeVariable()) {\n             for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                 SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                 if (res.isSolved()) {\n                     return res;\n                 }\n             }\n             return SymbolReference.unsolved(MethodDeclaration.class);\n         } else {\n             return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n         }\n     } else {\n         Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n         return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e47162df70ac5344d1a7b8c08220474224e64536": {
      "type": "Ybodychange",
      "commitMessage": "minor\n",
      "commitDate": "2016/12/14 上午12:55",
      "commitName": "e47162df70ac5344d1a7b8c08220474224e64536",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/12/14 上午12:45",
      "commitNameOld": "cb5ffb7fdd56f1b768d25da330fa3b29ecb74eaf",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        if (wrappedNode.getScope() instanceof NameExpr) {\n            NameExpr scopeAsName \u003d (NameExpr) wrappedNode.getScope();\n            SymbolReference\u003cTypeDeclaration\u003e symbolReference \u003d this.solveType(scopeAsName.getName().getId(), typeSolver);\n            if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n            }\n        }\n        Type typeOfScope \u003d null;\n        try {\n            typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n        } catch (Exception e) {\n            throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n        }\n        if (typeOfScope.isWildcard()) {\n            if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n            } else {\n                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n            }\n        } else if (typeOfScope.isArray()) {\n            return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n        } else if (typeOfScope.isTypeVariable()) {\n            for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                if (res.isSolved()) {\n                    return res;\n                }\n            }\n            return SymbolReference.unsolved(MethodDeclaration.class);\n        } else {\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n        }\n    } else {\n        Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 127,
      "functionName": "solveMethod",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {}
    },
    "c990d23490f5c4ac4322119b03d5951b63eef055": {
      "type": "Ybodychange",
      "commitMessage": "loads of changes to support our code",
      "commitDate": "2016/12/13 下午9:10",
      "commitName": "c990d23490f5c4ac4322119b03d5951b63eef055",
      "commitAuthor": "Fred Lefévère-Laoide",
      "commitDateOld": "2016/11/22 上午2:58",
      "commitNameOld": "6e1380f412d334f1c887d15edf0b4610c3cf0da2",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 21.76,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        if (wrappedNode.getScope() instanceof NameExpr) {\n            NameExpr scopeAsName \u003d (NameExpr) wrappedNode.getScope();\n            SymbolReference\u003cTypeDeclaration\u003e symbolReference \u003d this.solveType(scopeAsName.getName().getId(), typeSolver);\n            if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n            }\n        }\n        Type typeOfScope \u003d null;\n        try {\n            typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n        } catch (Exception e) {\n            throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n        }\n        if (typeOfScope.isWildcard()) {\n            if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n            } else {\n                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n            }\n        } else if (typeOfScope.isArray()) {\n            return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n        } else if (typeOfScope.isTypeVariable()) {\n            for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                if (res.isSolved()) {\n                    return res;\n                }\n            }\n            return SymbolReference.unsolved(MethodDeclaration.class);\n        } else {\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n        }\n    } else {\n        Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 133,
      "functionName": "solveMethod",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,41 +1,41 @@\n @Override\n public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope() !\u003d null) {\n         if (wrappedNode.getScope() instanceof NameExpr) {\n             NameExpr scopeAsName \u003d (NameExpr) wrappedNode.getScope();\n-            SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName().getId(), typeSolver);\n+            SymbolReference\u003cTypeDeclaration\u003e symbolReference \u003d this.solveType(scopeAsName.getName().getId(), typeSolver);\n             if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                 TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                 return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n             }\n         }\n         Type typeOfScope \u003d null;\n         try {\n             typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n         } catch (Exception e) {\n             throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n         }\n         if (typeOfScope.isWildcard()) {\n             if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                 return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n             } else {\n                 return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n             }\n-        } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayType().getComponentType().isReferenceType()) {\n-            return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n+        } else if (typeOfScope.isArray()) {\n+            return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n         } else if (typeOfScope.isTypeVariable()) {\n             for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                 SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                 if (res.isSolved()) {\n                     return res;\n                 }\n             }\n             return SymbolReference.unsolved(MethodDeclaration.class);\n         } else {\n             return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n         }\n     } else {\n         Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n         return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6e1380f412d334f1c887d15edf0b4610c3cf0da2": {
      "type": "Ybodychange",
      "commitMessage": "adapt to alpha.10\n",
      "commitDate": "2016/11/22 上午2:58",
      "commitName": "6e1380f412d334f1c887d15edf0b4610c3cf0da2",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/11/10 上午1:15",
      "commitNameOld": "ca3e3a946698cf3a4f93e6fb7b4d2b16ee2e3ed5",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 12.07,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        if (wrappedNode.getScope() instanceof NameExpr) {\n            NameExpr scopeAsName \u003d (NameExpr) wrappedNode.getScope();\n            SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName().getId(), typeSolver);\n            if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n            }\n        }\n        Type typeOfScope \u003d null;\n        try {\n            typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n        } catch (Exception e) {\n            throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n        }\n        if (typeOfScope.isWildcard()) {\n            if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n            } else {\n                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n            }\n        } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayType().getComponentType().isReferenceType()) {\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n        } else if (typeOfScope.isTypeVariable()) {\n            for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                if (res.isSolved()) {\n                    return res;\n                }\n            }\n            return SymbolReference.unsolved(MethodDeclaration.class);\n        } else {\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n        }\n    } else {\n        Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 124,
      "functionName": "solveMethod",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,41 +1,41 @@\n @Override\n public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope() !\u003d null) {\n         if (wrappedNode.getScope() instanceof NameExpr) {\n             NameExpr scopeAsName \u003d (NameExpr) wrappedNode.getScope();\n-            SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName(), typeSolver);\n+            SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName().getId(), typeSolver);\n             if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                 TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                 return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n             }\n         }\n         Type typeOfScope \u003d null;\n         try {\n             typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n         } catch (Exception e) {\n             throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n         }\n         if (typeOfScope.isWildcard()) {\n             if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                 return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n             } else {\n                 return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n             }\n         } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayType().getComponentType().isReferenceType()) {\n             return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n         } else if (typeOfScope.isTypeVariable()) {\n             for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                 SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                 if (res.isSolved()) {\n                     return res;\n                 }\n             }\n             return SymbolReference.unsolved(MethodDeclaration.class);\n         } else {\n             return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n         }\n     } else {\n         Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n         return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ca3e3a946698cf3a4f93e6fb7b4d2b16ee2e3ed5": {
      "type": "Ybodychange",
      "commitMessage": "changes necessary to support jpalpha8\n",
      "commitDate": "2016/11/10 上午1:15",
      "commitName": "ca3e3a946698cf3a4f93e6fb7b4d2b16ee2e3ed5",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/11/6 下午9:49",
      "commitNameOld": "03055f925053b3970b9d14cce3a3b9a0d002366d",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 3.14,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        if (wrappedNode.getScope() instanceof NameExpr) {\n            NameExpr scopeAsName \u003d (NameExpr) wrappedNode.getScope();\n            SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName(), typeSolver);\n            if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n            }\n        }\n        Type typeOfScope \u003d null;\n        try {\n            typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n        } catch (Exception e) {\n            throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n        }\n        if (typeOfScope.isWildcard()) {\n            if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n            } else {\n                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n            }\n        } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayType().getComponentType().isReferenceType()) {\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n        } else if (typeOfScope.isTypeVariable()) {\n            for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                if (res.isSolved()) {\n                    return res;\n                }\n            }\n            return SymbolReference.unsolved(MethodDeclaration.class);\n        } else {\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n        }\n    } else {\n        Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 124,
      "functionName": "solveMethod",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,41 +1,41 @@\n @Override\n public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n-    if (wrappedNode.getScope().isPresent()) {\n-        if (wrappedNode.getScope().get() instanceof NameExpr) {\n-            NameExpr scopeAsName \u003d (NameExpr) wrappedNode.getScope().get();\n+    if (wrappedNode.getScope() !\u003d null) {\n+        if (wrappedNode.getScope() instanceof NameExpr) {\n+            NameExpr scopeAsName \u003d (NameExpr) wrappedNode.getScope();\n             SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName(), typeSolver);\n             if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                 TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                 return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n             }\n         }\n         Type typeOfScope \u003d null;\n         try {\n-            typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n+            typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n         } catch (Exception e) {\n             throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n         }\n         if (typeOfScope.isWildcard()) {\n             if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                 return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n             } else {\n                 return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n             }\n         } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayType().getComponentType().isReferenceType()) {\n             return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n         } else if (typeOfScope.isTypeVariable()) {\n             for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                 SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                 if (res.isSolved()) {\n                     return res;\n                 }\n             }\n             return SymbolReference.unsolved(MethodDeclaration.class);\n         } else {\n             return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n         }\n     } else {\n         Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n         return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9c53c2cbc607ea694438ade8630be0c155a33162": {
      "type": "Yfilerename",
      "commitMessage": "renamed packages to com.github.javapaerser\n",
      "commitDate": "2016/10/20 下午2:39",
      "commitName": "9c53c2cbc607ea694438ade8630be0c155a33162",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/20 下午2:32",
      "commitNameOld": "b1da215b407e8cfc2c77182f0ab3e67e0ab16ef3",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope().isPresent()) {\n        if (wrappedNode.getScope().get() instanceof NameExpr) {\n            NameExpr scopeAsName \u003d (NameExpr) wrappedNode.getScope().get();\n            SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName(), typeSolver);\n            if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n            }\n        }\n        Type typeOfScope \u003d null;\n        try {\n            typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n        } catch (Exception e) {\n            throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n        }\n        if (typeOfScope.isWildcard()) {\n            if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n            } else {\n                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n            }\n        } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayType().getComponentType().isReferenceType()) {\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n        } else if (typeOfScope.isTypeVariable()) {\n            for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                if (res.isSolved()) {\n                    return res;\n                }\n            }\n            return SymbolReference.unsolved(MethodDeclaration.class);\n        } else {\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n        }\n    } else {\n        Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 243,
      "functionName": "solveMethod",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
        "newPath": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java"
      }
    },
    "0d14741fef3a17451db153cfe379e398da4b4b79": {
      "type": "Ybodychange",
      "commitMessage": "minor fix\n",
      "commitDate": "2016/10/20 上午1:35",
      "commitName": "0d14741fef3a17451db153cfe379e398da4b4b79",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/20 上午1:35",
      "commitNameOld": "4601dfb9d1acf7f564948b7ddbb9201d62849ad7",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope().isPresent()) {\n        if (wrappedNode.getScope().get() instanceof NameExpr) {\n            NameExpr scopeAsName \u003d (NameExpr) wrappedNode.getScope().get();\n            SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName(), typeSolver);\n            if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n            }\n        }\n        Type typeOfScope \u003d null;\n        try {\n            typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n        } catch (Exception e) {\n            throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n        }\n        if (typeOfScope.isWildcard()) {\n            if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n            } else {\n                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n            }\n        } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayType().getComponentType().isReferenceType()) {\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n        } else if (typeOfScope.isTypeVariable()) {\n            for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                if (res.isSolved()) {\n                    return res;\n                }\n            }\n            return SymbolReference.unsolved(MethodDeclaration.class);\n        } else {\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n        }\n    } else {\n        Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 245,
      "functionName": "solveMethod",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,41 +1,41 @@\n @Override\n public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n-    if (wrappedNode.getScope() !\u003d null) {\n+    if (wrappedNode.getScope().isPresent()) {\n         if (wrappedNode.getScope().get() instanceof NameExpr) {\n             NameExpr scopeAsName \u003d (NameExpr) wrappedNode.getScope().get();\n             SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName(), typeSolver);\n             if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                 TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                 return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n             }\n         }\n         Type typeOfScope \u003d null;\n         try {\n             typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n         } catch (Exception e) {\n             throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n         }\n         if (typeOfScope.isWildcard()) {\n             if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                 return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n             } else {\n                 return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n             }\n         } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayType().getComponentType().isReferenceType()) {\n             return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n         } else if (typeOfScope.isTypeVariable()) {\n             for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                 SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                 if (res.isSolved()) {\n                     return res;\n                 }\n             }\n             return SymbolReference.unsolved(MethodDeclaration.class);\n         } else {\n             return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n         }\n     } else {\n         Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n         return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "341e081a5f8909a3a467671befcca2941b786d3d": {
      "type": "Ybodychange",
      "commitMessage": "issue91: solve compilation issues\n",
      "commitDate": "2016/10/20 上午1:33",
      "commitName": "341e081a5f8909a3a467671befcca2941b786d3d",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/19 下午11:04",
      "commitNameOld": "683012de2a3a28358e848f8b145d462eb8b322ba",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        if (wrappedNode.getScope().get() instanceof NameExpr) {\n            NameExpr scopeAsName \u003d (NameExpr) wrappedNode.getScope().get();\n            SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName(), typeSolver);\n            if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n            }\n        }\n        Type typeOfScope \u003d null;\n        try {\n            typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n        } catch (Exception e) {\n            throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n        }\n        if (typeOfScope.isWildcard()) {\n            if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n            } else {\n                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n            }\n        } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayType().getComponentType().isReferenceType()) {\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n        } else if (typeOfScope.isTypeVariable()) {\n            for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                if (res.isSolved()) {\n                    return res;\n                }\n            }\n            return SymbolReference.unsolved(MethodDeclaration.class);\n        } else {\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n        }\n    } else {\n        Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 245,
      "functionName": "solveMethod",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,41 +1,41 @@\n @Override\n public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope() !\u003d null) {\n-        if (wrappedNode.getScope() instanceof NameExpr) {\n-            NameExpr scopeAsName \u003d (NameExpr) wrappedNode.getScope();\n+        if (wrappedNode.getScope().get() instanceof NameExpr) {\n+            NameExpr scopeAsName \u003d (NameExpr) wrappedNode.getScope().get();\n             SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName(), typeSolver);\n             if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                 TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                 return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n             }\n         }\n         Type typeOfScope \u003d null;\n         try {\n-            typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n+            typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n         } catch (Exception e) {\n             throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n         }\n         if (typeOfScope.isWildcard()) {\n             if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                 return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n             } else {\n                 return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n             }\n         } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayType().getComponentType().isReferenceType()) {\n             return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n         } else if (typeOfScope.isTypeVariable()) {\n             for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                 SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                 if (res.isSolved()) {\n                     return res;\n                 }\n             }\n             return SymbolReference.unsolved(MethodDeclaration.class);\n         } else {\n             return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n         }\n     } else {\n         Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n         return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "88db8b2a8b93bcc692cb8fd5085ba68b8bcf1968": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "issue90: using the right terminology for parameters and arguments\n",
      "commitDate": "2016/10/18 上午1:25",
      "commitName": "88db8b2a8b93bcc692cb8fd5085ba68b8bcf1968",
      "commitAuthor": "Federico Tomassetti",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "issue90: using the right terminology for parameters and arguments\n",
          "commitDate": "2016/10/18 上午1:25",
          "commitName": "88db8b2a8b93bcc692cb8fd5085ba68b8bcf1968",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2016/10/17 上午12:48",
          "commitNameOld": "f271890077d290431fd7cdc45e3bf172fb2f834c",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 1.03,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\npublic SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        if (wrappedNode.getScope() instanceof NameExpr) {\n            NameExpr scopeAsName \u003d (NameExpr) wrappedNode.getScope();\n            SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName(), typeSolver);\n            if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n            }\n        }\n        Type typeOfScope \u003d null;\n        try {\n            typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n        } catch (Exception e) {\n            throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n        }\n        if (typeOfScope.isWildcard()) {\n            if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n            } else {\n                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n            }\n        } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayType().getComponentType().isReferenceType()) {\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n        } else if (typeOfScope.isTypeVariable()) {\n            for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                if (res.isSolved()) {\n                    return res;\n                }\n            }\n            return SymbolReference.unsolved(MethodDeclaration.class);\n        } else {\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n        }\n    } else {\n        Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n    }\n}",
          "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
          "functionStartLine": 229,
          "functionName": "solveMethod",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,41 +1,41 @@\n @Override\n-public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e parameterTypes, TypeSolver typeSolver) {\n+public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope() !\u003d null) {\n         if (wrappedNode.getScope() instanceof NameExpr) {\n             NameExpr scopeAsName \u003d (NameExpr) wrappedNode.getScope();\n             SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName(), typeSolver);\n             if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                 TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n-                return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, parameterTypes, typeSolver);\n+                return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n             }\n         }\n         Type typeOfScope \u003d null;\n         try {\n             typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n         } catch (Exception e) {\n             throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n         }\n         if (typeOfScope.isWildcard()) {\n             if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n-                return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n+                return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n             } else {\n-                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, parameterTypes, typeSolver);\n+                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n             }\n         } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayType().getComponentType().isReferenceType()) {\n-            return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n+            return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n         } else if (typeOfScope.isTypeVariable()) {\n             for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n-                SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n+                SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                 if (res.isSolved()) {\n                     return res;\n                 }\n             }\n             return SymbolReference.unsolved(MethodDeclaration.class);\n         } else {\n-            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n+            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n         }\n     } else {\n         Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n-        return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n+        return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[name-String, parameterTypes-List\u003cType\u003e, typeSolver-TypeSolver]",
            "newValue": "[name-String, argumentsTypes-List\u003cType\u003e, typeSolver-TypeSolver]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "issue90: using the right terminology for parameters and arguments\n",
          "commitDate": "2016/10/18 上午1:25",
          "commitName": "88db8b2a8b93bcc692cb8fd5085ba68b8bcf1968",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2016/10/17 上午12:48",
          "commitNameOld": "f271890077d290431fd7cdc45e3bf172fb2f834c",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 1.03,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\npublic SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        if (wrappedNode.getScope() instanceof NameExpr) {\n            NameExpr scopeAsName \u003d (NameExpr) wrappedNode.getScope();\n            SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName(), typeSolver);\n            if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n            }\n        }\n        Type typeOfScope \u003d null;\n        try {\n            typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n        } catch (Exception e) {\n            throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n        }\n        if (typeOfScope.isWildcard()) {\n            if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n            } else {\n                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n            }\n        } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayType().getComponentType().isReferenceType()) {\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n        } else if (typeOfScope.isTypeVariable()) {\n            for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                if (res.isSolved()) {\n                    return res;\n                }\n            }\n            return SymbolReference.unsolved(MethodDeclaration.class);\n        } else {\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n        }\n    } else {\n        Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n    }\n}",
          "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
          "functionStartLine": 229,
          "functionName": "solveMethod",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,41 +1,41 @@\n @Override\n-public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e parameterTypes, TypeSolver typeSolver) {\n+public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope() !\u003d null) {\n         if (wrappedNode.getScope() instanceof NameExpr) {\n             NameExpr scopeAsName \u003d (NameExpr) wrappedNode.getScope();\n             SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName(), typeSolver);\n             if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                 TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n-                return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, parameterTypes, typeSolver);\n+                return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n             }\n         }\n         Type typeOfScope \u003d null;\n         try {\n             typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n         } catch (Exception e) {\n             throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n         }\n         if (typeOfScope.isWildcard()) {\n             if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n-                return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n+                return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n             } else {\n-                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, parameterTypes, typeSolver);\n+                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n             }\n         } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayType().getComponentType().isReferenceType()) {\n-            return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n+            return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n         } else if (typeOfScope.isTypeVariable()) {\n             for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n-                SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n+                SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                 if (res.isSolved()) {\n                     return res;\n                 }\n             }\n             return SymbolReference.unsolved(MethodDeclaration.class);\n         } else {\n-            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n+            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n         }\n     } else {\n         Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n-        return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n+        return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "656bb37a1dba87d61d24e69f2346f35dbc73d81d": {
      "type": "Ybodychange",
      "commitMessage": "remove TypeDeclaration.solveMethod\n",
      "commitDate": "2016/10/17 上午12:13",
      "commitName": "656bb37a1dba87d61d24e69f2346f35dbc73d81d",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/15 上午4:57",
      "commitNameOld": "051dbd94c17c4f142d3fe9e8fbd03c29d09ace54",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 1.8,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        if (wrappedNode.getScope() instanceof NameExpr) {\n            NameExpr scopeAsName \u003d (NameExpr) wrappedNode.getScope();\n            SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName(), typeSolver);\n            if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, parameterTypes, typeSolver);\n            }\n        }\n        Type typeOfScope \u003d null;\n        try {\n            typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n        } catch (Exception e) {\n            throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n        }\n        if (typeOfScope.isWildcard()) {\n            if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n            } else {\n                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, parameterTypes, typeSolver);\n            }\n        } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayType().getComponentType().isReferenceType()) {\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n        } else if (typeOfScope.isTypeVariable()) {\n            for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n                if (res.isSolved()) {\n                    return res;\n                }\n            }\n            return SymbolReference.unsolved(MethodDeclaration.class);\n        } else {\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n        }\n    } else {\n        Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 237,
      "functionName": "solveMethod",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,41 +1,41 @@\n @Override\n public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e parameterTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope() !\u003d null) {\n         if (wrappedNode.getScope() instanceof NameExpr) {\n             NameExpr scopeAsName \u003d (NameExpr) wrappedNode.getScope();\n             SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName(), typeSolver);\n             if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                 TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n-                return typeDeclaration.solveMethod(name, parameterTypes);\n+                return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, parameterTypes, typeSolver);\n             }\n         }\n         Type typeOfScope \u003d null;\n         try {\n             typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n         } catch (Exception e) {\n             throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n         }\n         if (typeOfScope.isWildcard()) {\n             if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n-                return typeOfScope.asWildcard().getBoundedType().asReferenceType().solveMethod(name, parameterTypes);\n+                return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n             } else {\n-                return new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n+                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, parameterTypes, typeSolver);\n             }\n         } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayType().getComponentType().isReferenceType()) {\n-            return typeOfScope.asArrayType().getComponentType().asReferenceType().solveMethod(name, parameterTypes);\n+            return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n         } else if (typeOfScope.isTypeVariable()) {\n             for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n-                SymbolReference\u003cMethodDeclaration\u003e res \u003d bound.getType().asReferenceType().solveMethod(name, parameterTypes);\n+                SymbolReference\u003cMethodDeclaration\u003e res \u003d MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n                 if (res.isSolved()) {\n                     return res;\n                 }\n             }\n             return SymbolReference.unsolved(MethodDeclaration.class);\n         } else {\n-            return typeOfScope.asReferenceType().solveMethod(name, parameterTypes);\n+            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n         }\n     } else {\n         Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n-        return typeOfScope.asReferenceType().solveMethod(name, parameterTypes);\n+        return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "051dbd94c17c4f142d3fe9e8fbd03c29d09ace54": {
      "type": "Ybodychange",
      "commitMessage": "add test JavaParserClassDeclarationTest.testGetSuperclassWithTypeParameters\n",
      "commitDate": "2016/10/15 上午4:57",
      "commitName": "051dbd94c17c4f142d3fe9e8fbd03c29d09ace54",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/15 上午1:24",
      "commitNameOld": "70f3e66c944670a818922f101162226ef604b263",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.15,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        if (wrappedNode.getScope() instanceof NameExpr) {\n            NameExpr scopeAsName \u003d (NameExpr) wrappedNode.getScope();\n            SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName(), typeSolver);\n            if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                return typeDeclaration.solveMethod(name, parameterTypes);\n            }\n        }\n        Type typeOfScope \u003d null;\n        try {\n            typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n        } catch (Exception e) {\n            throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n        }\n        if (typeOfScope.isWildcard()) {\n            if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                return typeOfScope.asWildcard().getBoundedType().asReferenceType().solveMethod(name, parameterTypes);\n            } else {\n                return new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n            }\n        } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayType().getComponentType().isReferenceType()) {\n            return typeOfScope.asArrayType().getComponentType().asReferenceType().solveMethod(name, parameterTypes);\n        } else if (typeOfScope.isTypeVariable()) {\n            for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                SymbolReference\u003cMethodDeclaration\u003e res \u003d bound.getType().asReferenceType().solveMethod(name, parameterTypes);\n                if (res.isSolved()) {\n                    return res;\n                }\n            }\n            return SymbolReference.unsolved(MethodDeclaration.class);\n        } else {\n            return typeOfScope.asReferenceType().solveMethod(name, parameterTypes);\n        }\n    } else {\n        Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return typeOfScope.asReferenceType().solveMethod(name, parameterTypes);\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 237,
      "functionName": "solveMethod",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,41 +1,41 @@\n @Override\n public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e parameterTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope() !\u003d null) {\n         if (wrappedNode.getScope() instanceof NameExpr) {\n             NameExpr scopeAsName \u003d (NameExpr) wrappedNode.getScope();\n             SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName(), typeSolver);\n             if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                 TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                 return typeDeclaration.solveMethod(name, parameterTypes);\n             }\n         }\n         Type typeOfScope \u003d null;\n         try {\n             typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n         } catch (Exception e) {\n             throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n         }\n         if (typeOfScope.isWildcard()) {\n             if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n-                return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n+                return typeOfScope.asWildcard().getBoundedType().asReferenceType().solveMethod(name, parameterTypes);\n             } else {\n                 return new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n             }\n-        } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayTypeUsage().getComponentType().isReferenceType()) {\n-            return typeOfScope.asArrayTypeUsage().getComponentType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n+        } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayType().getComponentType().isReferenceType()) {\n+            return typeOfScope.asArrayType().getComponentType().asReferenceType().solveMethod(name, parameterTypes);\n         } else if (typeOfScope.isTypeVariable()) {\n             for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n-                SymbolReference\u003cMethodDeclaration\u003e res \u003d bound.getType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n+                SymbolReference\u003cMethodDeclaration\u003e res \u003d bound.getType().asReferenceType().solveMethod(name, parameterTypes);\n                 if (res.isSolved()) {\n                     return res;\n                 }\n             }\n             return SymbolReference.unsolved(MethodDeclaration.class);\n         } else {\n-            return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n+            return typeOfScope.asReferenceType().solveMethod(name, parameterTypes);\n         }\n     } else {\n         Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n-        return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n+        return typeOfScope.asReferenceType().solveMethod(name, parameterTypes);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ecc78c8b480ceb41019f764c983aaa69c2dabfe3": {
      "type": "Ybodychange",
      "commitMessage": "reorganize packages in model\n",
      "commitDate": "2016/10/15 上午12:51",
      "commitName": "ecc78c8b480ceb41019f764c983aaa69c2dabfe3",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/14 下午2:36",
      "commitNameOld": "8d234965b572759181da7787fead07b225e9e5ca",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.43,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        if (wrappedNode.getScope() instanceof NameExpr) {\n            NameExpr scopeAsName \u003d (NameExpr) wrappedNode.getScope();\n            SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName(), typeSolver);\n            if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                return typeDeclaration.solveMethod(name, parameterTypes);\n            }\n        }\n        Type typeOfScope \u003d null;\n        try {\n            typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n        } catch (Exception e) {\n            throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n        }\n        if (typeOfScope.isWildcard()) {\n            if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n            } else {\n                return new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n            }\n        } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayTypeUsage().getComponentType().isReferenceType()) {\n            return typeOfScope.asArrayTypeUsage().getComponentType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n        } else if (typeOfScope.isTypeVariable()) {\n            for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                SymbolReference\u003cMethodDeclaration\u003e res \u003d bound.getType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n                if (res.isSolved()) {\n                    return res;\n                }\n            }\n            return SymbolReference.unsolved(MethodDeclaration.class);\n        } else {\n            return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n        }\n    } else {\n        Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 237,
      "functionName": "solveMethod",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,41 +1,41 @@\n @Override\n public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e parameterTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope() !\u003d null) {\n         if (wrappedNode.getScope() instanceof NameExpr) {\n             NameExpr scopeAsName \u003d (NameExpr) wrappedNode.getScope();\n             SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName(), typeSolver);\n             if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                 TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                 return typeDeclaration.solveMethod(name, parameterTypes);\n             }\n         }\n         Type typeOfScope \u003d null;\n         try {\n             typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n         } catch (Exception e) {\n             throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n         }\n         if (typeOfScope.isWildcard()) {\n             if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                 return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n             } else {\n                 return new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n             }\n         } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayTypeUsage().getComponentType().isReferenceType()) {\n             return typeOfScope.asArrayTypeUsage().getComponentType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n         } else if (typeOfScope.isTypeVariable()) {\n-            for (me.tomassetti.symbolsolver.model.resolution.TypeParameter.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n+            for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                 SymbolReference\u003cMethodDeclaration\u003e res \u003d bound.getType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n                 if (res.isSolved()) {\n                     return res;\n                 }\n             }\n             return SymbolReference.unsolved(MethodDeclaration.class);\n         } else {\n             return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n         }\n     } else {\n         Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n         return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "82eb44707b620803d424188a1eb8708fcaf093cb": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "rename TypeUsage into Type\n",
      "commitDate": "2016/10/14 上午4:11",
      "commitName": "82eb44707b620803d424188a1eb8708fcaf093cb",
      "commitAuthor": "Federico Tomassetti",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "rename TypeUsage into Type\n",
          "commitDate": "2016/10/14 上午4:11",
          "commitName": "82eb44707b620803d424188a1eb8708fcaf093cb",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2016/10/13 上午5:43",
          "commitNameOld": "401a56f412ca186a00a2282d9088e8cb7b67e0e5",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.94,
          "commitsBetweenForRepo": 21,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\npublic SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        if (wrappedNode.getScope() instanceof NameExpr) {\n            NameExpr scopeAsName \u003d (NameExpr) wrappedNode.getScope();\n            SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName(), typeSolver);\n            if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                return typeDeclaration.solveMethod(name, parameterTypes);\n            }\n        }\n        Type typeOfScope \u003d null;\n        try {\n            typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n        } catch (Exception e) {\n            throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n        }\n        if (typeOfScope.isWildcard()) {\n            if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n            } else {\n                return new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n            }\n        } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayTypeUsage().getComponentType().isReferenceType()) {\n            return typeOfScope.asArrayTypeUsage().getComponentType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n        } else if (typeOfScope.isTypeVariable()) {\n            for (me.tomassetti.symbolsolver.model.resolution.TypeParameter.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                SymbolReference\u003cMethodDeclaration\u003e res \u003d bound.getType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n                if (res.isSolved()) {\n                    return res;\n                }\n            }\n            return SymbolReference.unsolved(MethodDeclaration.class);\n        } else {\n            return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n        }\n    } else {\n        Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n    }\n}",
          "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
          "functionStartLine": 235,
          "functionName": "solveMethod",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,41 +1,41 @@\n @Override\n-public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n+public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e parameterTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope() !\u003d null) {\n         if (wrappedNode.getScope() instanceof NameExpr) {\n             NameExpr scopeAsName \u003d (NameExpr) wrappedNode.getScope();\n             SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName(), typeSolver);\n             if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                 TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                 return typeDeclaration.solveMethod(name, parameterTypes);\n             }\n         }\n-        TypeUsage typeOfScope \u003d null;\n+        Type typeOfScope \u003d null;\n         try {\n             typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n         } catch (Exception e) {\n             throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n         }\n         if (typeOfScope.isWildcard()) {\n             if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                 return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n             } else {\n-                return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n+                return new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n             }\n         } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayTypeUsage().getComponentType().isReferenceType()) {\n             return typeOfScope.asArrayTypeUsage().getComponentType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n         } else if (typeOfScope.isTypeVariable()) {\n-            for (TypeParameter.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n+            for (me.tomassetti.symbolsolver.model.resolution.TypeParameter.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                 SymbolReference\u003cMethodDeclaration\u003e res \u003d bound.getType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n                 if (res.isSolved()) {\n                     return res;\n                 }\n             }\n             return SymbolReference.unsolved(MethodDeclaration.class);\n         } else {\n             return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n         }\n     } else {\n-        TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n+        Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n         return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[name-String, parameterTypes-List\u003cTypeUsage\u003e, typeSolver-TypeSolver]",
            "newValue": "[name-String, parameterTypes-List\u003cType\u003e, typeSolver-TypeSolver]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "rename TypeUsage into Type\n",
          "commitDate": "2016/10/14 上午4:11",
          "commitName": "82eb44707b620803d424188a1eb8708fcaf093cb",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2016/10/13 上午5:43",
          "commitNameOld": "401a56f412ca186a00a2282d9088e8cb7b67e0e5",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.94,
          "commitsBetweenForRepo": 21,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\npublic SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        if (wrappedNode.getScope() instanceof NameExpr) {\n            NameExpr scopeAsName \u003d (NameExpr) wrappedNode.getScope();\n            SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName(), typeSolver);\n            if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                return typeDeclaration.solveMethod(name, parameterTypes);\n            }\n        }\n        Type typeOfScope \u003d null;\n        try {\n            typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n        } catch (Exception e) {\n            throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n        }\n        if (typeOfScope.isWildcard()) {\n            if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n            } else {\n                return new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n            }\n        } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayTypeUsage().getComponentType().isReferenceType()) {\n            return typeOfScope.asArrayTypeUsage().getComponentType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n        } else if (typeOfScope.isTypeVariable()) {\n            for (me.tomassetti.symbolsolver.model.resolution.TypeParameter.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                SymbolReference\u003cMethodDeclaration\u003e res \u003d bound.getType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n                if (res.isSolved()) {\n                    return res;\n                }\n            }\n            return SymbolReference.unsolved(MethodDeclaration.class);\n        } else {\n            return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n        }\n    } else {\n        Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n    }\n}",
          "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
          "functionStartLine": 235,
          "functionName": "solveMethod",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,41 +1,41 @@\n @Override\n-public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n+public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cType\u003e parameterTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope() !\u003d null) {\n         if (wrappedNode.getScope() instanceof NameExpr) {\n             NameExpr scopeAsName \u003d (NameExpr) wrappedNode.getScope();\n             SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName(), typeSolver);\n             if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                 TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                 return typeDeclaration.solveMethod(name, parameterTypes);\n             }\n         }\n-        TypeUsage typeOfScope \u003d null;\n+        Type typeOfScope \u003d null;\n         try {\n             typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n         } catch (Exception e) {\n             throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n         }\n         if (typeOfScope.isWildcard()) {\n             if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                 return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n             } else {\n-                return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n+                return new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n             }\n         } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayTypeUsage().getComponentType().isReferenceType()) {\n             return typeOfScope.asArrayTypeUsage().getComponentType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n         } else if (typeOfScope.isTypeVariable()) {\n-            for (TypeParameter.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n+            for (me.tomassetti.symbolsolver.model.resolution.TypeParameter.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                 SymbolReference\u003cMethodDeclaration\u003e res \u003d bound.getType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n                 if (res.isSolved()) {\n                     return res;\n                 }\n             }\n             return SymbolReference.unsolved(MethodDeclaration.class);\n         } else {\n             return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n         }\n     } else {\n-        TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n+        Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n         return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "401a56f412ca186a00a2282d9088e8cb7b67e0e5": {
      "type": "Ybodychange",
      "commitMessage": "issue80: working on lambdas assigned to variables\n",
      "commitDate": "2016/10/13 上午5:43",
      "commitName": "401a56f412ca186a00a2282d9088e8cb7b67e0e5",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/13 上午4:53",
      "commitNameOld": "38d780df85a22c9baffb1f772a45b063cad73aab",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        if (wrappedNode.getScope() instanceof NameExpr) {\n            NameExpr scopeAsName \u003d (NameExpr) wrappedNode.getScope();\n            SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName(), typeSolver);\n            if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                return typeDeclaration.solveMethod(name, parameterTypes);\n            }\n        }\n        TypeUsage typeOfScope \u003d null;\n        try {\n            typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n        } catch (Exception e) {\n            throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n        }\n        if (typeOfScope.isWildcard()) {\n            if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n            } else {\n                return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n            }\n        } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayTypeUsage().getComponentType().isReferenceType()) {\n            return typeOfScope.asArrayTypeUsage().getComponentType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n        } else if (typeOfScope.isTypeVariable()) {\n            for (TypeParameter.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                SymbolReference\u003cMethodDeclaration\u003e res \u003d bound.getType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n                if (res.isSolved()) {\n                    return res;\n                }\n            }\n            return SymbolReference.unsolved(MethodDeclaration.class);\n        } else {\n            return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n        }\n    } else {\n        TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 234,
      "functionName": "solveMethod",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,36 +1,41 @@\n @Override\n public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope() !\u003d null) {\n         if (wrappedNode.getScope() instanceof NameExpr) {\n             NameExpr scopeAsName \u003d (NameExpr) wrappedNode.getScope();\n             SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName(), typeSolver);\n             if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                 TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                 return typeDeclaration.solveMethod(name, parameterTypes);\n             }\n         }\n-        TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n+        TypeUsage typeOfScope \u003d null;\n+        try {\n+            typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n+        } catch (Exception e) {\n+            throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n+        }\n         if (typeOfScope.isWildcard()) {\n             if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                 return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n             } else {\n                 return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n             }\n         } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayTypeUsage().getComponentType().isReferenceType()) {\n             return typeOfScope.asArrayTypeUsage().getComponentType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n         } else if (typeOfScope.isTypeVariable()) {\n             for (TypeParameter.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                 SymbolReference\u003cMethodDeclaration\u003e res \u003d bound.getType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n                 if (res.isSolved()) {\n                     return res;\n                 }\n             }\n             return SymbolReference.unsolved(MethodDeclaration.class);\n         } else {\n             return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n         }\n     } else {\n         TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n         return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a16d5b37001074f2fa6eea4d1d1ef7e0466ca51b": {
      "type": "Ybodychange",
      "commitMessage": "issue80: improving resolution of methods on type parameters\n",
      "commitDate": "2016/10/9 下午5:06",
      "commitName": "a16d5b37001074f2fa6eea4d1d1ef7e0466ca51b",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/9 上午4:17",
      "commitNameOld": "cb7655f9661f11dab8ec9e2533722d649a16e715",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.53,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        if (wrappedNode.getScope() instanceof NameExpr) {\n            NameExpr scopeAsName \u003d (NameExpr) wrappedNode.getScope();\n            SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName(), typeSolver);\n            if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                return typeDeclaration.solveMethod(name, parameterTypes);\n            }\n        }\n        TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n        if (typeOfScope.isWildcard()) {\n            if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n            } else {\n                return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n            }\n        } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayTypeUsage().getComponentType().isReferenceType()) {\n            return typeOfScope.asArrayTypeUsage().getComponentType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n        } else if (typeOfScope.isTypeVariable()) {\n            for (TypeParameter.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                SymbolReference\u003cMethodDeclaration\u003e res \u003d bound.getType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n                if (res.isSolved()) {\n                    return res;\n                }\n            }\n            return SymbolReference.unsolved(MethodDeclaration.class);\n        } else {\n            return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n        }\n    } else {\n        TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 201,
      "functionName": "solveMethod",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,28 +1,36 @@\n @Override\n public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope() !\u003d null) {\n         if (wrappedNode.getScope() instanceof NameExpr) {\n             NameExpr scopeAsName \u003d (NameExpr) wrappedNode.getScope();\n             SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName(), typeSolver);\n             if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                 TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                 return typeDeclaration.solveMethod(name, parameterTypes);\n             }\n         }\n         TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n         if (typeOfScope.isWildcard()) {\n             if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                 return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n             } else {\n                 return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n             }\n         } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayTypeUsage().getComponentType().isReferenceType()) {\n             return typeOfScope.asArrayTypeUsage().getComponentType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n+        } else if (typeOfScope.isTypeVariable()) {\n+            for (TypeParameter.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n+                SymbolReference\u003cMethodDeclaration\u003e res \u003d bound.getType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n+                if (res.isSolved()) {\n+                    return res;\n+                }\n+            }\n+            return SymbolReference.unsolved(MethodDeclaration.class);\n         } else {\n             return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n         }\n     } else {\n         TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n         return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cb7655f9661f11dab8ec9e2533722d649a16e715": {
      "type": "Ybodychange",
      "commitMessage": "issue80: improving resolution of static methods\n",
      "commitDate": "2016/10/9 上午4:17",
      "commitName": "cb7655f9661f11dab8ec9e2533722d649a16e715",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/5 下午9:04",
      "commitNameOld": "84afc7be2fabd511eccc69e29fca9c4238c9469e",
      "commitAuthorOld": "rpau",
      "daysBetweenCommits": 3.3,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        if (wrappedNode.getScope() instanceof NameExpr) {\n            NameExpr scopeAsName \u003d (NameExpr) wrappedNode.getScope();\n            SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName(), typeSolver);\n            if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n                TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n                return typeDeclaration.solveMethod(name, parameterTypes);\n            }\n        }\n        TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n        if (typeOfScope.isWildcard()) {\n            if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n            } else {\n                return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n            }\n        } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayTypeUsage().getComponentType().isReferenceType()) {\n            return typeOfScope.asArrayTypeUsage().getComponentType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n        } else {\n            return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n        }\n    } else {\n        TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 201,
      "functionName": "solveMethod",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,20 +1,28 @@\n @Override\n public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope() !\u003d null) {\n+        if (wrappedNode.getScope() instanceof NameExpr) {\n+            NameExpr scopeAsName \u003d (NameExpr) wrappedNode.getScope();\n+            SymbolReference symbolReference \u003d this.solveType(scopeAsName.getName(), typeSolver);\n+            if (symbolReference.isSolved() \u0026\u0026 symbolReference.getCorrespondingDeclaration().isType()) {\n+                TypeDeclaration typeDeclaration \u003d symbolReference.getCorrespondingDeclaration().asType();\n+                return typeDeclaration.solveMethod(name, parameterTypes);\n+            }\n+        }\n         TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n         if (typeOfScope.isWildcard()) {\n             if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                 return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n             } else {\n                 return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n             }\n         } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayTypeUsage().getComponentType().isReferenceType()) {\n             return typeOfScope.asArrayTypeUsage().getComponentType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n         } else {\n             return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n         }\n     } else {\n         TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n         return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2c3f615e6b24358b86d6453e24dac35849ffde26": {
      "type": "Ybodychange",
      "commitMessage": "added another fix and tests for method call on array access\n",
      "commitDate": "2016/9/23 下午6:10",
      "commitName": "2c3f615e6b24358b86d6453e24dac35849ffde26",
      "commitAuthor": "malte_langkabel",
      "commitDateOld": "2016/9/22 下午8:06",
      "commitNameOld": "a541f77a5a66a911e347d294aa76d8703e72e7db",
      "commitAuthorOld": "malte_langkabel",
      "daysBetweenCommits": 0.92,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n        if (typeOfScope.isWildcard()) {\n            if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n            } else {\n                return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n            }\n        } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayTypeUsage().getComponentType().isReferenceType()) {\n            return typeOfScope.asArrayTypeUsage().getComponentType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n        } else {\n            return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n        }\n    } else {\n        TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 206,
      "functionName": "solveMethod",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,18 +1,20 @@\n @Override\n public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope() !\u003d null) {\n         TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n         if (typeOfScope.isWildcard()) {\n             if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                 return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n             } else {\n                 return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n             }\n+        } else if (typeOfScope.isArray() \u0026\u0026 typeOfScope.asArrayTypeUsage().getComponentType().isReferenceType()) {\n+            return typeOfScope.asArrayTypeUsage().getComponentType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n         } else {\n             return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n         }\n     } else {\n         TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n         return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8e655d386a595ea1927ebeded58939d7b8a7ce0c": {
      "type": "Yfilerename",
      "commitMessage": "test JavaParserClassDeclaration\n",
      "commitDate": "2015/11/22 下午6:45",
      "commitName": "8e655d386a595ea1927ebeded58939d7b8a7ce0c",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/11/22 下午6:03",
      "commitNameOld": "68d87977d826a8c48711297732b7ae10f3dc1f1f",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n        if (typeOfScope.isWildcard()) {\n            if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n            } else {\n                return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n            }\n        } else {\n            return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n        }\n    } else {\n        TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 201,
      "functionName": "solveMethod",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/MethodCallExprContext.java",
        "newPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java"
      }
    },
    "4a18b1ee8ed716d6e32e190f728f1eee57148872": {
      "type": "Ybodychange",
      "commitMessage": "modules: extraction of the model module\n",
      "commitDate": "2015/11/13 下午5:59",
      "commitName": "4a18b1ee8ed716d6e32e190f728f1eee57148872",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/11/13 下午5:12",
      "commitNameOld": "f4b07b1a2deac6d1b562424ac2380b92cec77a90",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n        if (typeOfScope.isWildcard()) {\n            if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n            } else {\n                return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n            }\n        } else {\n            return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n        }\n    } else {\n        TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 128,
      "functionName": "solveMethod",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,18 +1,18 @@\n @Override\n public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope() !\u003d null) {\n         TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n         if (typeOfScope.isWildcard()) {\n             if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                 return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n             } else {\n-                return new ReferenceTypeUsage(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n+                return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n             }\n         } else {\n             return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n         }\n     } else {\n         TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n         return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f4b07b1a2deac6d1b562424ac2380b92cec77a90": {
      "type": "Yfilerename",
      "commitMessage": "modules: organization in modules\n",
      "commitDate": "2015/11/13 下午5:12",
      "commitName": "f4b07b1a2deac6d1b562424ac2380b92cec77a90",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/11/13 下午4:53",
      "commitNameOld": "d96a8ff67d857a2988488f1fc31202f0e2ed8061",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n        if (typeOfScope.isWildcard()) {\n            if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n            } else {\n                return new ReferenceTypeUsage(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n            }\n        } else {\n            return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n        }\n    } else {\n        TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 128,
      "functionName": "solveMethod",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/MethodCallExprContext.java",
        "newPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/MethodCallExprContext.java"
      }
    },
    "40ddb5e17127d2139e4b66b980ad11004749e86a": {
      "type": "Ybodychange",
      "commitMessage": "remove TypeSolver from ReferenceTypeUsage interface\n",
      "commitDate": "2015/11/3 上午4:14",
      "commitName": "40ddb5e17127d2139e4b66b980ad11004749e86a",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/11/3 上午4:11",
      "commitNameOld": "e21fca16e413a8bf31d613aa97a744d075c374dd",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n        if (typeOfScope.isWildcard()) {\n            if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n            } else {\n                return new ReferenceTypeUsage(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n            }\n        } else {\n            return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n        }\n    } else {\n        TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 129,
      "functionName": "solveMethod",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,18 +1,18 @@\n @Override\n public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope() !\u003d null) {\n         TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n         if (typeOfScope.isWildcard()) {\n             if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n-                return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes, typeSolver);\n+                return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n             } else {\n-                return new ReferenceTypeUsage(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes, typeSolver);\n+                return new ReferenceTypeUsage(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n             }\n         } else {\n-            return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes, typeSolver);\n+            return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n         }\n     } else {\n         TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n-        return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes, typeSolver);\n+        return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "965ab8585c3e8be1dff784e749e37dad31151ec8": {
      "type": "Ybodychange",
      "commitMessage": "wip\n",
      "commitDate": "2015/11/1 下午10:57",
      "commitName": "965ab8585c3e8be1dff784e749e37dad31151ec8",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/11/1 下午7:29",
      "commitNameOld": "26c12a20f1206e2a1f63c46b6b41c304af8c7389",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.14,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n        if (typeOfScope.isWildcard()) {\n            if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes, typeSolver);\n            } else {\n                return new ReferenceTypeUsage(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes, typeSolver);\n            }\n        } else {\n            return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes, typeSolver);\n        }\n    } else {\n        TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes, typeSolver);\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 129,
      "functionName": "solveMethod",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,10 +1,18 @@\n @Override\n public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope() !\u003d null) {\n         TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n-        return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes, typeSolver);\n+        if (typeOfScope.isWildcard()) {\n+            if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n+                return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes, typeSolver);\n+            } else {\n+                return new ReferenceTypeUsage(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes, typeSolver);\n+            }\n+        } else {\n+            return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes, typeSolver);\n+        }\n     } else {\n         TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n         return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes, typeSolver);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "362cdf49fd4c7ea6d60f3172fd2804f8aa765f4c": {
      "type": "Ybodychange",
      "commitMessage": "simpligy TypeUsage\n",
      "commitDate": "2015/10/30 下午9:30",
      "commitName": "362cdf49fd4c7ea6d60f3172fd2804f8aa765f4c",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/10/30 下午8:49",
      "commitNameOld": "392bb1e6e3f4b86c3bb812a95752e4921772c705",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n        return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes, typeSolver);\n    } else {\n        TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes, typeSolver);\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 86,
      "functionName": "solveMethod",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,10 +1,10 @@\n @Override\n public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope() !\u003d null) {\n         TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n-        return typeOfScope.solveMethod(name, parameterTypes, typeSolver);\n+        return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes, typeSolver);\n     } else {\n         TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n-        return typeOfScope.solveMethod(name, parameterTypes, typeSolver);\n+        return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes, typeSolver);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b36f33050149a62a5b3c8c7451ae93f736715029": {
      "type": "Yfilerename",
      "commitMessage": "reorganize packages\n",
      "commitDate": "2015/10/30 下午5:53",
      "commitName": "b36f33050149a62a5b3c8c7451ae93f736715029",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/10/30 下午5:29",
      "commitNameOld": "90999800bdc73eacb5ef25dafcd36c8518af3072",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n        return typeOfScope.solveMethod(name, parameterTypes, typeSolver);\n    } else {\n        TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return typeOfScope.solveMethod(name, parameterTypes, typeSolver);\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 86,
      "functionName": "solveMethod",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/main/java/me/tomassetti/symbolsolver/model/javaparser/contexts/MethodCallExprContext.java",
        "newPath": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/MethodCallExprContext.java"
      }
    },
    "d393205e2ee874242b73e4fe819d1bc874587d8a": {
      "type": "Ybodychange",
      "commitMessage": "wip\n",
      "commitDate": "2015/8/18 上午12:43",
      "commitName": "d393205e2ee874242b73e4fe819d1bc874587d8a",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/17 下午2:28",
      "commitNameOld": "542ea71d2308fcf66c1942862737bfcf04178797",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.43,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n        return typeOfScope.solveMethod(name, parameterTypes, typeSolver);\n    } else {\n        TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return typeOfScope.solveMethod(name, parameterTypes, typeSolver);\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/model/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 61,
      "functionName": "solveMethod",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,9 +1,10 @@\n @Override\n public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope() !\u003d null) {\n         TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n         return typeOfScope.solveMethod(name, parameterTypes, typeSolver);\n     } else {\n-        throw new UnsupportedOperationException();\n+        TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n+        return typeOfScope.solveMethod(name, parameterTypes, typeSolver);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "627b56302d259409e9bc50b20d77803484f18b5c": {
      "type": "Ybodychange",
      "commitMessage": "introduce cache in JavaParserFacade\n",
      "commitDate": "2015/8/5 下午10:25",
      "commitName": "627b56302d259409e9bc50b20d77803484f18b5c",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/5 下午9:30",
      "commitNameOld": "fd2e083224d3ee0e9ccca4431d63a84601e0d606",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n        return typeOfScope.solveMethod(name, parameterTypes, typeSolver);\n    } else {\n        throw new UnsupportedOperationException();\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/model/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 52,
      "functionName": "solveMethod",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,9 +1,9 @@\n @Override\n public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope() !\u003d null) {\n-        TypeUsage typeOfScope \u003d new JavaParserFacade(typeSolver).getType(wrappedNode.getScope());\n+        TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n         return typeOfScope.solveMethod(name, parameterTypes, typeSolver);\n     } else {\n         throw new UnsupportedOperationException();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "80f951258992f75441239c79e0f31eda7d47e107": {
      "type": "Ybodychange",
      "commitMessage": "wip\n",
      "commitDate": "2015/8/4 下午9:54",
      "commitName": "80f951258992f75441239c79e0f31eda7d47e107",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/3 下午2:53",
      "commitNameOld": "8415b0bc2abfc2eb094745336a1cd27a4c96fa4b",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 1.29,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        TypeUsage typeOfScope \u003d new JavaParserFacade(typeSolver).getType(wrappedNode.getScope());\n        return typeOfScope.solveMethod(name, parameterTypes, typeSolver);\n    } else {\n        throw new UnsupportedOperationException();\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/model/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 34,
      "functionName": "solveMethod",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,9 +1,9 @@\n @Override\n public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope() !\u003d null) {\n         TypeUsage typeOfScope \u003d new JavaParserFacade(typeSolver).getType(wrappedNode.getScope());\n-        return typeOfScope.solveMethod(name, parameterTypes);\n+        return typeOfScope.solveMethod(name, parameterTypes, typeSolver);\n     } else {\n         throw new UnsupportedOperationException();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8415b0bc2abfc2eb094745336a1cd27a4c96fa4b": {
      "type": "Ybodychange",
      "commitMessage": "wip\n",
      "commitDate": "2015/8/3 下午2:53",
      "commitName": "8415b0bc2abfc2eb094745336a1cd27a4c96fa4b",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/3 下午2:37",
      "commitNameOld": "630eb94d43670f2080c7273584d49c0b0d4162f1",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        TypeUsage typeOfScope \u003d new JavaParserFacade(typeSolver).getType(wrappedNode.getScope());\n        return typeOfScope.solveMethod(name, parameterTypes);\n    } else {\n        throw new UnsupportedOperationException();\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/model/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 34,
      "functionName": "solveMethod",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,9 +1,9 @@\n @Override\n public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope() !\u003d null) {\n         TypeUsage typeOfScope \u003d new JavaParserFacade(typeSolver).getType(wrappedNode.getScope());\n         return typeOfScope.solveMethod(name, parameterTypes);\n     } else {\n-        return JavaParserFactory.getContext(wrappedNode.getParentNode()).solveSymbol(name, typeSolver);\n+        throw new UnsupportedOperationException();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8b8cc6cddbf5af0c93c4ceffd015f6328c932149": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "wip\n",
      "commitDate": "2015/8/1 上午2:52",
      "commitName": "8b8cc6cddbf5af0c93c4ceffd015f6328c932149",
      "commitAuthor": "Federico Tomassetti",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "wip\n",
          "commitDate": "2015/8/1 上午2:52",
          "commitName": "8b8cc6cddbf5af0c93c4ceffd015f6328c932149",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2015/8/1 上午12:08",
          "commitNameOld": "2f49331fb22511346eea8800d27907de44409d5b",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.11,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\npublic SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        TypeUsage typeOfScope \u003d new JavaParserFacade(typeSolver).getType(wrappedNode.getScope());\n        return typeOfScope.solveMethod(name, parameterTypes);\n    } else {\n        return JavaParserFactory.getContext(wrappedNode.getParentNode()).solveSymbol(name, typeSolver);\n    }\n}",
          "path": "src/main/java/me/tomassetti/symbolsolver/model/javaparser/contexts/MethodCallExprContext.java",
          "functionStartLine": 30,
          "functionName": "solveMethod",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,14 +1,9 @@\n @Override\n-public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeReference\u003e parameterTypes, TypeSolver typeSolver) {\n+public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope() !\u003d null) {\n-        SymbolReference\u003cSymbolDeclaration\u003e declScope \u003d new JavaParserFacade(typeSolver).solve(wrappedNode.getScope());\n-        if (declScope.isSolved()) {\n-            TypeDeclaration typeOfDeclScope \u003d declScope.getCorrespondingDeclaration().getType();\n-            return typeOfDeclScope.getContext().solveMethod(name, parameterTypes, typeSolver);\n-        } else {\n-            throw new UnsolvedSymbolException(this, name);\n-        }\n+        TypeUsage typeOfScope \u003d new JavaParserFacade(typeSolver).getType(wrappedNode.getScope());\n+        return typeOfScope.solveMethod(name, parameterTypes);\n     } else {\n         return JavaParserFactory.getContext(wrappedNode.getParentNode()).solveSymbol(name, typeSolver);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[name-String, parameterTypes-List\u003cTypeReference\u003e, typeSolver-TypeSolver]",
            "newValue": "[name-String, parameterTypes-List\u003cTypeUsage\u003e, typeSolver-TypeSolver]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "wip\n",
          "commitDate": "2015/8/1 上午2:52",
          "commitName": "8b8cc6cddbf5af0c93c4ceffd015f6328c932149",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2015/8/1 上午12:08",
          "commitNameOld": "2f49331fb22511346eea8800d27907de44409d5b",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.11,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\npublic SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        TypeUsage typeOfScope \u003d new JavaParserFacade(typeSolver).getType(wrappedNode.getScope());\n        return typeOfScope.solveMethod(name, parameterTypes);\n    } else {\n        return JavaParserFactory.getContext(wrappedNode.getParentNode()).solveSymbol(name, typeSolver);\n    }\n}",
          "path": "src/main/java/me/tomassetti/symbolsolver/model/javaparser/contexts/MethodCallExprContext.java",
          "functionStartLine": 30,
          "functionName": "solveMethod",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,14 +1,9 @@\n @Override\n-public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeReference\u003e parameterTypes, TypeSolver typeSolver) {\n+public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope() !\u003d null) {\n-        SymbolReference\u003cSymbolDeclaration\u003e declScope \u003d new JavaParserFacade(typeSolver).solve(wrappedNode.getScope());\n-        if (declScope.isSolved()) {\n-            TypeDeclaration typeOfDeclScope \u003d declScope.getCorrespondingDeclaration().getType();\n-            return typeOfDeclScope.getContext().solveMethod(name, parameterTypes, typeSolver);\n-        } else {\n-            throw new UnsolvedSymbolException(this, name);\n-        }\n+        TypeUsage typeOfScope \u003d new JavaParserFacade(typeSolver).getType(wrappedNode.getScope());\n+        return typeOfScope.solveMethod(name, parameterTypes);\n     } else {\n         return JavaParserFactory.getContext(wrappedNode.getParentNode()).solveSymbol(name, typeSolver);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "2f49331fb22511346eea8800d27907de44409d5b": {
      "type": "Yintroduced",
      "commitMessage": "start to resolve references to method\n",
      "commitDate": "2015/8/1 上午12:08",
      "commitName": "2f49331fb22511346eea8800d27907de44409d5b",
      "commitAuthor": "Federico Tomassetti",
      "diff": "@@ -0,0 +1,14 @@\n+@Override\n+public SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeReference\u003e parameterTypes, TypeSolver typeSolver) {\n+    if (wrappedNode.getScope() !\u003d null) {\n+        SymbolReference\u003cSymbolDeclaration\u003e declScope \u003d new JavaParserFacade(typeSolver).solve(wrappedNode.getScope());\n+        if (declScope.isSolved()) {\n+            TypeDeclaration typeOfDeclScope \u003d declScope.getCorrespondingDeclaration().getType();\n+            return typeOfDeclScope.getContext().solveMethod(name, parameterTypes, typeSolver);\n+        } else {\n+            throw new UnsolvedSymbolException(this, name);\n+        }\n+    } else {\n+        return JavaParserFactory.getContext(wrappedNode.getParentNode()).solveSymbol(name, typeSolver);\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "@Override\npublic SymbolReference\u003cMethodDeclaration\u003e solveMethod(String name, List\u003cTypeReference\u003e parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        SymbolReference\u003cSymbolDeclaration\u003e declScope \u003d new JavaParserFacade(typeSolver).solve(wrappedNode.getScope());\n        if (declScope.isSolved()) {\n            TypeDeclaration typeOfDeclScope \u003d declScope.getCorrespondingDeclaration().getType();\n            return typeOfDeclScope.getContext().solveMethod(name, parameterTypes, typeSolver);\n        } else {\n            throw new UnsolvedSymbolException(this, name);\n        }\n    } else {\n        return JavaParserFactory.getContext(wrappedNode.getParentNode()).solveSymbol(name, typeSolver);\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/model/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 31,
      "functionName": "solveMethod",
      "functionAnnotation": "@Override",
      "functionDoc": ""
    }
  }
}