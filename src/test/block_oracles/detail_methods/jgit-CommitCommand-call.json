{
  "origin": "codeshovel",
  "repositoryName": "jgit",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/jgit/.git",
  "startCommitName": "bd1a82502680b5de5bf86f6c4470185fd1602386",
  "sourceFileName": "CommitCommand.java",
  "functionName": "call",
  "functionId": "call",
  "sourceFilePath": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
  "functionAnnotation": "@Override",
  "functionDoc": "@inheritDoc}\n\u003cp\u003e\nExecutes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n",
  "functionStartLine": 161,
  "functionEndLine": 315,
  "numCommitsSeen": 64,
  "timeTaken": 3182,
  "changeHistory": [
    "9441508682b7d7c935dd976e4082cacff4a5efeb",
    "0210e0e299bed69176e0a929d0b67f3cf9fb1e37",
    "7ac182f4e427e0d5a986b8ca67a56fc22828b1a0",
    "57a263f1823d164142235a72072154f0568cb61c",
    "4c236ff4bbf664fd177a33f42517b0eef52510c8",
    "36a53d1a3cdd66c40b6db241a75a28293f22f5e1",
    "da43d8d79890e561a993a4d90e6a2724a04cd60f",
    "1ed5382b37453309580e11a11cf4c3bb134813fa",
    "d726f0c1e02c196e2dd87de53b54338be15503f1",
    "efeb02bf2bed32ef94d5c4891404f551cdc6957f",
    "26fd56f167e6377777e6d46c14779183e4bcb55a",
    "494e893c541b5cf465b362c69354c08d7a81c249",
    "e0fbae5dc3fc2345383ec373b384fcca10e64f24",
    "a2b33a8ac33c63eea82f300b802a26af54a3d61d",
    "c93a59330249677cd990820b59558a39f747009f",
    "65027d8bb429581635f51d0c588493e5c458cc25",
    "1f51aecf95d61e48618d478a693f73dcf1ec1146",
    "549034500a55ffc8f401fd73a74d8dc55f096d2f",
    "315f1cfa5c63f4d3355704c80d00ac1323a36171",
    "c310fa0c802f40a774edb58641de3ac5bfad0e2c",
    "79f33419ec073edf31a1db16ae9b11e69ee997a1",
    "c96b40d5921d68edb96afad38b9c171388af4e05",
    "4e1454ded6e2fcf6cb789c004756883c3ea5f77e",
    "2539b1ee096266b7fcca64545f93d7c08ab30f53",
    "4f4e468f6f344ed7c106b86b850d2c9171dd1a0f",
    "6e10aa42e90a25b82f00f0c27574f57ffa9e4a25",
    "fd963a9180af73b6a05a5c1a2af6dd7168899170",
    "9830baf48dd5b3feb9780a3cc1d83b79e1d4c46b",
    "a490afedba12676a53338bc52b729b9bb779f3a1",
    "cda64073fd45d3056486b96877e4ff6dd12dbaa5",
    "e43887b69e27672b80e55391e0ee255efe715ab9",
    "6df5d3397c5c9354409d21a8e207a061f2e6efc2",
    "22b285695a2980824c15363ef5fec709ebc3d434",
    "b46b635c0389e01a55b2f9c490e5b6c54a8ce640",
    "ab57af08e83d5d042bb954ad280389b34ca36d0e",
    "94207f0a43a44261b8170d3cdba3028059775d9d",
    "a1d5f5b6b526d086a0963c634a38edb6789a4594",
    "515deaf7e503738b4c53c3c2dfd6d7acab3bef18",
    "ffe0614d4db653cbcd48c19e9f599fd87cdcfaba",
    "88530a179e2ddfa81de5cc441a27d66521334608",
    "6ca9843f3ebbea152969a8b795efce1d4ff15dbf",
    "f3d8a8ecad614906a2c4ec0077cdb24129da6c6d",
    "f3fb5824ba45197787bc4ffb81fafcd576c60291"
  ],
  "changeHistoryShort": {
    "9441508682b7d7c935dd976e4082cacff4a5efeb": "Ybodychange",
    "0210e0e299bed69176e0a929d0b67f3cf9fb1e37": "Ydocchange",
    "7ac182f4e427e0d5a986b8ca67a56fc22828b1a0": "Yannotationchange",
    "57a263f1823d164142235a72072154f0568cb61c": "Ybodychange",
    "4c236ff4bbf664fd177a33f42517b0eef52510c8": "Ybodychange",
    "36a53d1a3cdd66c40b6db241a75a28293f22f5e1": "Ybodychange",
    "da43d8d79890e561a993a4d90e6a2724a04cd60f": "Ybodychange",
    "1ed5382b37453309580e11a11cf4c3bb134813fa": "Ybodychange",
    "d726f0c1e02c196e2dd87de53b54338be15503f1": "Ybodychange",
    "efeb02bf2bed32ef94d5c4891404f551cdc6957f": "Ybodychange",
    "26fd56f167e6377777e6d46c14779183e4bcb55a": "Ymultichange(Yexceptionschange,Ybodychange,Ydocchange)",
    "494e893c541b5cf465b362c69354c08d7a81c249": "Ymultichange(Yexceptionschange,Ybodychange,Ydocchange)",
    "e0fbae5dc3fc2345383ec373b384fcca10e64f24": "Ybodychange",
    "a2b33a8ac33c63eea82f300b802a26af54a3d61d": "Ybodychange",
    "c93a59330249677cd990820b59558a39f747009f": "Ybodychange",
    "65027d8bb429581635f51d0c588493e5c458cc25": "Ybodychange",
    "1f51aecf95d61e48618d478a693f73dcf1ec1146": "Ybodychange",
    "549034500a55ffc8f401fd73a74d8dc55f096d2f": "Ybodychange",
    "315f1cfa5c63f4d3355704c80d00ac1323a36171": "Ybodychange",
    "c310fa0c802f40a774edb58641de3ac5bfad0e2c": "Ybodychange",
    "79f33419ec073edf31a1db16ae9b11e69ee997a1": "Ybodychange",
    "c96b40d5921d68edb96afad38b9c171388af4e05": "Ybodychange",
    "4e1454ded6e2fcf6cb789c004756883c3ea5f77e": "Ymultichange(Yexceptionschange,Ybodychange,Ydocchange)",
    "2539b1ee096266b7fcca64545f93d7c08ab30f53": "Ybodychange",
    "4f4e468f6f344ed7c106b86b850d2c9171dd1a0f": "Ybodychange",
    "6e10aa42e90a25b82f00f0c27574f57ffa9e4a25": "Ybodychange",
    "fd963a9180af73b6a05a5c1a2af6dd7168899170": "Ybodychange",
    "9830baf48dd5b3feb9780a3cc1d83b79e1d4c46b": "Ybodychange",
    "a490afedba12676a53338bc52b729b9bb779f3a1": "Ybodychange",
    "cda64073fd45d3056486b96877e4ff6dd12dbaa5": "Ybodychange",
    "e43887b69e27672b80e55391e0ee255efe715ab9": "Ydocchange",
    "6df5d3397c5c9354409d21a8e207a061f2e6efc2": "Ybodychange",
    "22b285695a2980824c15363ef5fec709ebc3d434": "Ymultichange(Ybodychange,Ydocchange)",
    "b46b635c0389e01a55b2f9c490e5b6c54a8ce640": "Ybodychange",
    "ab57af08e83d5d042bb954ad280389b34ca36d0e": "Ybodychange",
    "94207f0a43a44261b8170d3cdba3028059775d9d": "Ybodychange",
    "a1d5f5b6b526d086a0963c634a38edb6789a4594": "Ybodychange",
    "515deaf7e503738b4c53c3c2dfd6d7acab3bef18": "Ybodychange",
    "ffe0614d4db653cbcd48c19e9f599fd87cdcfaba": "Ybodychange",
    "88530a179e2ddfa81de5cc441a27d66521334608": "Ybodychange",
    "6ca9843f3ebbea152969a8b795efce1d4ff15dbf": "Ymultichange(Yexceptionschange,Ybodychange,Ydocchange)",
    "f3d8a8ecad614906a2c4ec0077cdb24129da6c6d": "Ybodychange",
    "f3fb5824ba45197787bc4ffb81fafcd576c60291": "Yintroduced"
  },
  "changeHistoryDetails": {
    "9441508682b7d7c935dd976e4082cacff4a5efeb": {
      "type": "Ybodychange",
      "commitMessage": "Fix misspelled class name: EmtpyCommitException -\u003e EmptyCommitException\n\nChange-Id: I55196020146f26951988988c14ac9a6f85061ae2\nSigned-off-by: David Pursehouse \u003cdavid.pursehouse@gmail.com\u003e\n",
      "commitDate": "2018/3/11 上午2:40",
      "commitName": "9441508682b7d7c935dd976e4082cacff4a5efeb",
      "commitAuthor": "David Pursehouse",
      "commitDateOld": "2018/3/6 上午8:48",
      "commitNameOld": "3393f78210862b3ccd954f029d831ef783b35c89",
      "commitAuthorOld": "David Pursehouse",
      "daysBetweenCommits": 4.74,
      "commitsBetweenForRepo": 45,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException, AbortedByHookException {\n    checkCallable();\n    Collections.sort(only);\n    try (RevWalk rw \u003d new RevWalk(repo)) {\n        RepositoryState state \u003d repo.getRepositoryState();\n        if (!state.canCommit())\n            throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n        if (!noVerify) {\n            Hooks.preCommit(repo, hookOutRedirect.get(PreCommitHook.NAME)).call();\n        }\n        processOptions(state, rw);\n        if (all \u0026\u0026 !repo.isBare()) {\n            try (Git git \u003d new Git(repo)) {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head \u003d repo.exactRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId \u003d\u003d null \u0026\u0026 amend)\n            throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n        if (headId !\u003d null)\n            if (amend) {\n                RevCommit previousCommit \u003d rw.parseCommit(headId);\n                for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                if (author \u003d\u003d null)\n                    author \u003d previousCommit.getAuthorIdent();\n            } else {\n                parents.add(0, headId);\n            }\n        if (!noVerify) {\n            message \u003d Hooks.commitMsg(repo, hookOutRedirect.get(CommitMsgHook.NAME)).setCommitMessage(message).call();\n        }\n        DirCache index \u003d repo.lockDirCache();\n        try (ObjectInserter odi \u003d repo.newObjectInserter()) {\n            if (!only.isEmpty())\n                index \u003d createTemporaryIndex(headId, index, rw);\n            ObjectId indexTreeId \u003d index.writeTree(odi);\n            if (insertChangeId)\n                insertChangeId(indexTreeId);\n            if (headId !\u003d null \u0026\u0026 !allowEmpty.booleanValue()) {\n                RevCommit headCommit \u003d rw.parseCommit(headId);\n                headCommit.getTree();\n                if (indexTreeId.equals(headCommit.getTree())) {\n                    throw new EmptyCommitException(JGitText.get().emptyCommit);\n                }\n            }\n            CommitBuilder commit \u003d new CommitBuilder();\n            commit.setCommitter(committer);\n            commit.setAuthor(author);\n            commit.setMessage(message);\n            commit.setParentIds(parents);\n            commit.setTreeId(indexTreeId);\n            ObjectId commitId \u003d odi.insert(commit);\n            odi.flush();\n            RevCommit revCommit \u003d rw.parseCommit(commitId);\n            RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n            ru.setNewObjectId(commitId);\n            if (!useDefaultReflogMessage) {\n                ru.setRefLogMessage(reflogComment, false);\n            } else {\n                String prefix \u003d amend ? \"commit (amend): \" : parents.size() \u003d\u003d 0 ? \"commit (initial): \" : \"commit: \";\n                ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n            }\n            if (headId !\u003d null)\n                ru.setExpectedOldObjectId(headId);\n            else\n                ru.setExpectedOldObjectId(ObjectId.zeroId());\n            Result rc \u003d ru.forceUpdate();\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    {\n                        setCallable(false);\n                        if (state \u003d\u003d RepositoryState.MERGING_RESOLVED || isMergeDuringRebase(state)) {\n                            repo.writeMergeCommitMsg(null);\n                            repo.writeMergeHeads(null);\n                        } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                            repo.writeMergeCommitMsg(null);\n                            repo.writeCherryPickHead(null);\n                        } else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n                            repo.writeMergeCommitMsg(null);\n                            repo.writeRevertHead(null);\n                        }\n                        Hooks.postCommit(repo, hookOutRedirect.get(PostCommitHook.NAME)).call();\n                        return revCommit;\n                    }\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw new UnmergedPathsException(e);\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 161,
      "functionName": "call",
      "functionAnnotation": "@Override",
      "functionDoc": "@inheritDoc}\n\u003cp\u003e\nExecutes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n",
      "diff": "@@ -1,107 +1,107 @@\n @Override\n public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException, AbortedByHookException {\n     checkCallable();\n     Collections.sort(only);\n     try (RevWalk rw \u003d new RevWalk(repo)) {\n         RepositoryState state \u003d repo.getRepositoryState();\n         if (!state.canCommit())\n             throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n         if (!noVerify) {\n             Hooks.preCommit(repo, hookOutRedirect.get(PreCommitHook.NAME)).call();\n         }\n         processOptions(state, rw);\n         if (all \u0026\u0026 !repo.isBare()) {\n             try (Git git \u003d new Git(repo)) {\n                 git.add().addFilepattern(\".\").setUpdate(true).call();\n             } catch (NoFilepatternException e) {\n                 throw new JGitInternalException(e.getMessage(), e);\n             }\n         }\n         Ref head \u003d repo.exactRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n         if (headId \u003d\u003d null \u0026\u0026 amend)\n             throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n         if (headId !\u003d null)\n             if (amend) {\n                 RevCommit previousCommit \u003d rw.parseCommit(headId);\n                 for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                 if (author \u003d\u003d null)\n                     author \u003d previousCommit.getAuthorIdent();\n             } else {\n                 parents.add(0, headId);\n             }\n         if (!noVerify) {\n             message \u003d Hooks.commitMsg(repo, hookOutRedirect.get(CommitMsgHook.NAME)).setCommitMessage(message).call();\n         }\n         DirCache index \u003d repo.lockDirCache();\n         try (ObjectInserter odi \u003d repo.newObjectInserter()) {\n             if (!only.isEmpty())\n                 index \u003d createTemporaryIndex(headId, index, rw);\n             ObjectId indexTreeId \u003d index.writeTree(odi);\n             if (insertChangeId)\n                 insertChangeId(indexTreeId);\n             if (headId !\u003d null \u0026\u0026 !allowEmpty.booleanValue()) {\n                 RevCommit headCommit \u003d rw.parseCommit(headId);\n                 headCommit.getTree();\n                 if (indexTreeId.equals(headCommit.getTree())) {\n-                    throw new EmtpyCommitException(JGitText.get().emptyCommit);\n+                    throw new EmptyCommitException(JGitText.get().emptyCommit);\n                 }\n             }\n             CommitBuilder commit \u003d new CommitBuilder();\n             commit.setCommitter(committer);\n             commit.setAuthor(author);\n             commit.setMessage(message);\n             commit.setParentIds(parents);\n             commit.setTreeId(indexTreeId);\n             ObjectId commitId \u003d odi.insert(commit);\n             odi.flush();\n             RevCommit revCommit \u003d rw.parseCommit(commitId);\n             RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n             ru.setNewObjectId(commitId);\n             if (!useDefaultReflogMessage) {\n                 ru.setRefLogMessage(reflogComment, false);\n             } else {\n                 String prefix \u003d amend ? \"commit (amend): \" : parents.size() \u003d\u003d 0 ? \"commit (initial): \" : \"commit: \";\n                 ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n             }\n             if (headId !\u003d null)\n                 ru.setExpectedOldObjectId(headId);\n             else\n                 ru.setExpectedOldObjectId(ObjectId.zeroId());\n             Result rc \u003d ru.forceUpdate();\n             switch(rc) {\n                 case NEW:\n                 case FORCED:\n                 case FAST_FORWARD:\n                     {\n                         setCallable(false);\n                         if (state \u003d\u003d RepositoryState.MERGING_RESOLVED || isMergeDuringRebase(state)) {\n                             repo.writeMergeCommitMsg(null);\n                             repo.writeMergeHeads(null);\n                         } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                             repo.writeMergeCommitMsg(null);\n                             repo.writeCherryPickHead(null);\n                         } else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n                             repo.writeMergeCommitMsg(null);\n                             repo.writeRevertHead(null);\n                         }\n                         Hooks.postCommit(repo, hookOutRedirect.get(PostCommitHook.NAME)).call();\n                         return revCommit;\n                     }\n                 case REJECTED:\n                 case LOCK_FAILURE:\n                     throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                 default:\n                     throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n             }\n         } finally {\n             index.unlock();\n         }\n     } catch (UnmergedPathException e) {\n         throw new UnmergedPathsException(e);\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0210e0e299bed69176e0a929d0b67f3cf9fb1e37": {
      "type": "Ydocchange",
      "commitMessage": "Fix javadoc in org.eclipse.jgit annotations and api packages\n\nChange-Id: I2761ea91f8dfed16ea54e7a6646af03a30c15ec9\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2017/12/18 下午5:45",
      "commitName": "0210e0e299bed69176e0a929d0b67f3cf9fb1e37",
      "commitAuthor": "Matthias Sohn",
      "commitDateOld": "2017/7/28 下午5:46",
      "commitNameOld": "da0770fdec64b00be7c4c22d5acebee622bbf5f3",
      "commitAuthorOld": "Christian Halstrick",
      "daysBetweenCommits": 143.0,
      "commitsBetweenForRepo": 258,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException, AbortedByHookException {\n    checkCallable();\n    Collections.sort(only);\n    try (RevWalk rw \u003d new RevWalk(repo)) {\n        RepositoryState state \u003d repo.getRepositoryState();\n        if (!state.canCommit())\n            throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n        if (!noVerify) {\n            Hooks.preCommit(repo, hookOutRedirect.get(PreCommitHook.NAME)).call();\n        }\n        processOptions(state, rw);\n        if (all \u0026\u0026 !repo.isBare()) {\n            try (Git git \u003d new Git(repo)) {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head \u003d repo.exactRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId \u003d\u003d null \u0026\u0026 amend)\n            throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n        if (headId !\u003d null)\n            if (amend) {\n                RevCommit previousCommit \u003d rw.parseCommit(headId);\n                for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                if (author \u003d\u003d null)\n                    author \u003d previousCommit.getAuthorIdent();\n            } else {\n                parents.add(0, headId);\n            }\n        if (!noVerify) {\n            message \u003d Hooks.commitMsg(repo, hookOutRedirect.get(CommitMsgHook.NAME)).setCommitMessage(message).call();\n        }\n        DirCache index \u003d repo.lockDirCache();\n        try (ObjectInserter odi \u003d repo.newObjectInserter()) {\n            if (!only.isEmpty())\n                index \u003d createTemporaryIndex(headId, index, rw);\n            ObjectId indexTreeId \u003d index.writeTree(odi);\n            if (insertChangeId)\n                insertChangeId(indexTreeId);\n            if (headId !\u003d null \u0026\u0026 !allowEmpty.booleanValue()) {\n                RevCommit headCommit \u003d rw.parseCommit(headId);\n                headCommit.getTree();\n                if (indexTreeId.equals(headCommit.getTree())) {\n                    throw new EmtpyCommitException(JGitText.get().emptyCommit);\n                }\n            }\n            CommitBuilder commit \u003d new CommitBuilder();\n            commit.setCommitter(committer);\n            commit.setAuthor(author);\n            commit.setMessage(message);\n            commit.setParentIds(parents);\n            commit.setTreeId(indexTreeId);\n            ObjectId commitId \u003d odi.insert(commit);\n            odi.flush();\n            RevCommit revCommit \u003d rw.parseCommit(commitId);\n            RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n            ru.setNewObjectId(commitId);\n            if (!useDefaultReflogMessage) {\n                ru.setRefLogMessage(reflogComment, false);\n            } else {\n                String prefix \u003d amend ? \"commit (amend): \" : parents.size() \u003d\u003d 0 ? \"commit (initial): \" : \"commit: \";\n                ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n            }\n            if (headId !\u003d null)\n                ru.setExpectedOldObjectId(headId);\n            else\n                ru.setExpectedOldObjectId(ObjectId.zeroId());\n            Result rc \u003d ru.forceUpdate();\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    {\n                        setCallable(false);\n                        if (state \u003d\u003d RepositoryState.MERGING_RESOLVED || isMergeDuringRebase(state)) {\n                            repo.writeMergeCommitMsg(null);\n                            repo.writeMergeHeads(null);\n                        } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                            repo.writeMergeCommitMsg(null);\n                            repo.writeCherryPickHead(null);\n                        } else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n                            repo.writeMergeCommitMsg(null);\n                            repo.writeRevertHead(null);\n                        }\n                        Hooks.postCommit(repo, hookOutRedirect.get(PostCommitHook.NAME)).call();\n                        return revCommit;\n                    }\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw new UnmergedPathsException(e);\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 161,
      "functionName": "call",
      "functionAnnotation": "@Override",
      "functionDoc": "@inheritDoc}\n\u003cp\u003e\nExecutes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link RevCommit} object representing the successful commit.\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathsException\n            when the current index contained unmerged paths (conflicts)\n@throws ConcurrentRefUpdateException\n            when HEAD or branch ref is updated concurrently by someone\n            else\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n@throws AbortedByHookException\n            if there are either pre-commit or commit-msg hooks present in\n            the repository and one of them rejects the commit.\n",
        "newValue": "@inheritDoc}\n\u003cp\u003e\nExecutes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n"
      }
    },
    "7ac182f4e427e0d5a986b8ca67a56fc22828b1a0": {
      "type": "Yannotationchange",
      "commitMessage": "Enable and fix \u0027Should be tagged with @Override\u0027 warning\n\nSet missingOverrideAnnotation\u003dwarning in Eclipse compiler preferences\nwhich enables the warning:\n\n  The method \u003cmethod\u003e of type \u003ctype\u003e should be tagged with @Override\n  since it actually overrides a superclass method\n\nJustification for this warning is described in:\n\n  http://stackoverflow.com/a/94411/381622\n\nEnabling this causes in excess of 1000 warnings across the entire\ncode-base. They are very easy to fix automatically with Eclipse\u0027s\n\"Quick Fix\" tool.\n\nFix all of them except 2 which cause compilation failure when the\nproject is built with mvn; add TODO comments on those for further\ninvestigation.\n\nChange-Id: I5772061041fd361fe93137fd8b0ad356e748a29c\nSigned-off-by: David Pursehouse \u003cdavid.pursehouse@gmail.com\u003e\n",
      "commitDate": "2017/2/20 上午8:05",
      "commitName": "7ac182f4e427e0d5a986b8ca67a56fc22828b1a0",
      "commitAuthor": "David Pursehouse",
      "commitDateOld": "2016/9/13 下午11:13",
      "commitNameOld": "57a263f1823d164142235a72072154f0568cb61c",
      "commitAuthorOld": "Martin Goellnitz",
      "daysBetweenCommits": 159.37,
      "commitsBetweenForRepo": 226,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException, AbortedByHookException {\n    checkCallable();\n    Collections.sort(only);\n    try (RevWalk rw \u003d new RevWalk(repo)) {\n        RepositoryState state \u003d repo.getRepositoryState();\n        if (!state.canCommit())\n            throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n        if (!noVerify) {\n            Hooks.preCommit(repo, hookOutRedirect.get(PreCommitHook.NAME)).call();\n        }\n        processOptions(state, rw);\n        if (all \u0026\u0026 !repo.isBare()) {\n            try (Git git \u003d new Git(repo)) {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head \u003d repo.exactRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId \u003d\u003d null \u0026\u0026 amend)\n            throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n        if (headId !\u003d null)\n            if (amend) {\n                RevCommit previousCommit \u003d rw.parseCommit(headId);\n                for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                if (author \u003d\u003d null)\n                    author \u003d previousCommit.getAuthorIdent();\n            } else {\n                parents.add(0, headId);\n            }\n        if (!noVerify) {\n            message \u003d Hooks.commitMsg(repo, hookOutRedirect.get(CommitMsgHook.NAME)).setCommitMessage(message).call();\n        }\n        DirCache index \u003d repo.lockDirCache();\n        try (ObjectInserter odi \u003d repo.newObjectInserter()) {\n            if (!only.isEmpty())\n                index \u003d createTemporaryIndex(headId, index, rw);\n            ObjectId indexTreeId \u003d index.writeTree(odi);\n            if (insertChangeId)\n                insertChangeId(indexTreeId);\n            if (headId !\u003d null \u0026\u0026 !allowEmpty.booleanValue()) {\n                RevCommit headCommit \u003d rw.parseCommit(headId);\n                headCommit.getTree();\n                if (indexTreeId.equals(headCommit.getTree())) {\n                    throw new EmtpyCommitException(JGitText.get().emptyCommit);\n                }\n            }\n            CommitBuilder commit \u003d new CommitBuilder();\n            commit.setCommitter(committer);\n            commit.setAuthor(author);\n            commit.setMessage(message);\n            commit.setParentIds(parents);\n            commit.setTreeId(indexTreeId);\n            ObjectId commitId \u003d odi.insert(commit);\n            odi.flush();\n            RevCommit revCommit \u003d rw.parseCommit(commitId);\n            RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n            ru.setNewObjectId(commitId);\n            if (!useDefaultReflogMessage) {\n                ru.setRefLogMessage(reflogComment, false);\n            } else {\n                String prefix \u003d amend ? \"commit (amend): \" : parents.size() \u003d\u003d 0 ? \"commit (initial): \" : \"commit: \";\n                ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n            }\n            if (headId !\u003d null)\n                ru.setExpectedOldObjectId(headId);\n            else\n                ru.setExpectedOldObjectId(ObjectId.zeroId());\n            Result rc \u003d ru.forceUpdate();\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    {\n                        setCallable(false);\n                        if (state \u003d\u003d RepositoryState.MERGING_RESOLVED || isMergeDuringRebase(state)) {\n                            repo.writeMergeCommitMsg(null);\n                            repo.writeMergeHeads(null);\n                        } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                            repo.writeMergeCommitMsg(null);\n                            repo.writeCherryPickHead(null);\n                        } else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n                            repo.writeMergeCommitMsg(null);\n                            repo.writeRevertHead(null);\n                        }\n                        Hooks.postCommit(repo, hookOutRedirect.get(PostCommitHook.NAME)).call();\n                        return revCommit;\n                    }\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw new UnmergedPathsException(e);\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 172,
      "functionName": "call",
      "functionAnnotation": "@Override",
      "functionDoc": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link RevCommit} object representing the successful commit.\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathsException\n            when the current index contained unmerged paths (conflicts)\n@throws ConcurrentRefUpdateException\n            when HEAD or branch ref is updated concurrently by someone\n            else\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n@throws AbortedByHookException\n            if there are either pre-commit or commit-msg hooks present in\n            the repository and one of them rejects the commit.\n",
      "diff": "@@ -1,106 +1,107 @@\n+@Override\n public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException, AbortedByHookException {\n     checkCallable();\n     Collections.sort(only);\n     try (RevWalk rw \u003d new RevWalk(repo)) {\n         RepositoryState state \u003d repo.getRepositoryState();\n         if (!state.canCommit())\n             throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n         if (!noVerify) {\n             Hooks.preCommit(repo, hookOutRedirect.get(PreCommitHook.NAME)).call();\n         }\n         processOptions(state, rw);\n         if (all \u0026\u0026 !repo.isBare()) {\n             try (Git git \u003d new Git(repo)) {\n                 git.add().addFilepattern(\".\").setUpdate(true).call();\n             } catch (NoFilepatternException e) {\n                 throw new JGitInternalException(e.getMessage(), e);\n             }\n         }\n         Ref head \u003d repo.exactRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n         if (headId \u003d\u003d null \u0026\u0026 amend)\n             throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n         if (headId !\u003d null)\n             if (amend) {\n                 RevCommit previousCommit \u003d rw.parseCommit(headId);\n                 for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                 if (author \u003d\u003d null)\n                     author \u003d previousCommit.getAuthorIdent();\n             } else {\n                 parents.add(0, headId);\n             }\n         if (!noVerify) {\n             message \u003d Hooks.commitMsg(repo, hookOutRedirect.get(CommitMsgHook.NAME)).setCommitMessage(message).call();\n         }\n         DirCache index \u003d repo.lockDirCache();\n         try (ObjectInserter odi \u003d repo.newObjectInserter()) {\n             if (!only.isEmpty())\n                 index \u003d createTemporaryIndex(headId, index, rw);\n             ObjectId indexTreeId \u003d index.writeTree(odi);\n             if (insertChangeId)\n                 insertChangeId(indexTreeId);\n             if (headId !\u003d null \u0026\u0026 !allowEmpty.booleanValue()) {\n                 RevCommit headCommit \u003d rw.parseCommit(headId);\n                 headCommit.getTree();\n                 if (indexTreeId.equals(headCommit.getTree())) {\n                     throw new EmtpyCommitException(JGitText.get().emptyCommit);\n                 }\n             }\n             CommitBuilder commit \u003d new CommitBuilder();\n             commit.setCommitter(committer);\n             commit.setAuthor(author);\n             commit.setMessage(message);\n             commit.setParentIds(parents);\n             commit.setTreeId(indexTreeId);\n             ObjectId commitId \u003d odi.insert(commit);\n             odi.flush();\n             RevCommit revCommit \u003d rw.parseCommit(commitId);\n             RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n             ru.setNewObjectId(commitId);\n             if (!useDefaultReflogMessage) {\n                 ru.setRefLogMessage(reflogComment, false);\n             } else {\n                 String prefix \u003d amend ? \"commit (amend): \" : parents.size() \u003d\u003d 0 ? \"commit (initial): \" : \"commit: \";\n                 ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n             }\n             if (headId !\u003d null)\n                 ru.setExpectedOldObjectId(headId);\n             else\n                 ru.setExpectedOldObjectId(ObjectId.zeroId());\n             Result rc \u003d ru.forceUpdate();\n             switch(rc) {\n                 case NEW:\n                 case FORCED:\n                 case FAST_FORWARD:\n                     {\n                         setCallable(false);\n                         if (state \u003d\u003d RepositoryState.MERGING_RESOLVED || isMergeDuringRebase(state)) {\n                             repo.writeMergeCommitMsg(null);\n                             repo.writeMergeHeads(null);\n                         } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                             repo.writeMergeCommitMsg(null);\n                             repo.writeCherryPickHead(null);\n                         } else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n                             repo.writeMergeCommitMsg(null);\n                             repo.writeRevertHead(null);\n                         }\n                         Hooks.postCommit(repo, hookOutRedirect.get(PostCommitHook.NAME)).call();\n                         return revCommit;\n                     }\n                 case REJECTED:\n                 case LOCK_FAILURE:\n                     throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                 default:\n                     throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n             }\n         } finally {\n             index.unlock();\n         }\n     } catch (UnmergedPathException e) {\n         throw new UnmergedPathsException(e);\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "",
        "newValue": "@Override"
      }
    },
    "57a263f1823d164142235a72072154f0568cb61c": {
      "type": "Ybodychange",
      "commitMessage": "Add support for post-commit hooks\n\nChange-Id: I6691b454404dd4db3c690ecfc7515de765bc2ef7\nSigned-off-by: Martin Goellnitz \u003cm.goellnitz@outlook.com\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2016/9/13 下午11:13",
      "commitName": "57a263f1823d164142235a72072154f0568cb61c",
      "commitAuthor": "Martin Goellnitz",
      "commitDateOld": "2016/5/31 上午6:11",
      "commitNameOld": "4c236ff4bbf664fd177a33f42517b0eef52510c8",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 105.71,
      "commitsBetweenForRepo": 136,
      "commitsBetweenForFile": 1,
      "actualSource": "public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException, AbortedByHookException {\n    checkCallable();\n    Collections.sort(only);\n    try (RevWalk rw \u003d new RevWalk(repo)) {\n        RepositoryState state \u003d repo.getRepositoryState();\n        if (!state.canCommit())\n            throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n        if (!noVerify) {\n            Hooks.preCommit(repo, hookOutRedirect.get(PreCommitHook.NAME)).call();\n        }\n        processOptions(state, rw);\n        if (all \u0026\u0026 !repo.isBare()) {\n            try (Git git \u003d new Git(repo)) {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head \u003d repo.exactRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId \u003d\u003d null \u0026\u0026 amend)\n            throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n        if (headId !\u003d null)\n            if (amend) {\n                RevCommit previousCommit \u003d rw.parseCommit(headId);\n                for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                if (author \u003d\u003d null)\n                    author \u003d previousCommit.getAuthorIdent();\n            } else {\n                parents.add(0, headId);\n            }\n        if (!noVerify) {\n            message \u003d Hooks.commitMsg(repo, hookOutRedirect.get(CommitMsgHook.NAME)).setCommitMessage(message).call();\n        }\n        DirCache index \u003d repo.lockDirCache();\n        try (ObjectInserter odi \u003d repo.newObjectInserter()) {\n            if (!only.isEmpty())\n                index \u003d createTemporaryIndex(headId, index, rw);\n            ObjectId indexTreeId \u003d index.writeTree(odi);\n            if (insertChangeId)\n                insertChangeId(indexTreeId);\n            if (headId !\u003d null \u0026\u0026 !allowEmpty.booleanValue()) {\n                RevCommit headCommit \u003d rw.parseCommit(headId);\n                headCommit.getTree();\n                if (indexTreeId.equals(headCommit.getTree())) {\n                    throw new EmtpyCommitException(JGitText.get().emptyCommit);\n                }\n            }\n            CommitBuilder commit \u003d new CommitBuilder();\n            commit.setCommitter(committer);\n            commit.setAuthor(author);\n            commit.setMessage(message);\n            commit.setParentIds(parents);\n            commit.setTreeId(indexTreeId);\n            ObjectId commitId \u003d odi.insert(commit);\n            odi.flush();\n            RevCommit revCommit \u003d rw.parseCommit(commitId);\n            RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n            ru.setNewObjectId(commitId);\n            if (!useDefaultReflogMessage) {\n                ru.setRefLogMessage(reflogComment, false);\n            } else {\n                String prefix \u003d amend ? \"commit (amend): \" : parents.size() \u003d\u003d 0 ? \"commit (initial): \" : \"commit: \";\n                ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n            }\n            if (headId !\u003d null)\n                ru.setExpectedOldObjectId(headId);\n            else\n                ru.setExpectedOldObjectId(ObjectId.zeroId());\n            Result rc \u003d ru.forceUpdate();\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    {\n                        setCallable(false);\n                        if (state \u003d\u003d RepositoryState.MERGING_RESOLVED || isMergeDuringRebase(state)) {\n                            repo.writeMergeCommitMsg(null);\n                            repo.writeMergeHeads(null);\n                        } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                            repo.writeMergeCommitMsg(null);\n                            repo.writeCherryPickHead(null);\n                        } else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n                            repo.writeMergeCommitMsg(null);\n                            repo.writeRevertHead(null);\n                        }\n                        Hooks.postCommit(repo, hookOutRedirect.get(PostCommitHook.NAME)).call();\n                        return revCommit;\n                    }\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw new UnmergedPathsException(e);\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 171,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link RevCommit} object representing the successful commit.\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathsException\n            when the current index contained unmerged paths (conflicts)\n@throws ConcurrentRefUpdateException\n            when HEAD or branch ref is updated concurrently by someone\n            else\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n@throws AbortedByHookException\n            if there are either pre-commit or commit-msg hooks present in\n            the repository and one of them rejects the commit.\n",
      "diff": "@@ -1,105 +1,106 @@\n public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException, AbortedByHookException {\n     checkCallable();\n     Collections.sort(only);\n     try (RevWalk rw \u003d new RevWalk(repo)) {\n         RepositoryState state \u003d repo.getRepositoryState();\n         if (!state.canCommit())\n             throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n         if (!noVerify) {\n-            Hooks.preCommit(repo, hookOutRedirect).call();\n+            Hooks.preCommit(repo, hookOutRedirect.get(PreCommitHook.NAME)).call();\n         }\n         processOptions(state, rw);\n         if (all \u0026\u0026 !repo.isBare()) {\n             try (Git git \u003d new Git(repo)) {\n                 git.add().addFilepattern(\".\").setUpdate(true).call();\n             } catch (NoFilepatternException e) {\n                 throw new JGitInternalException(e.getMessage(), e);\n             }\n         }\n         Ref head \u003d repo.exactRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n         if (headId \u003d\u003d null \u0026\u0026 amend)\n             throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n         if (headId !\u003d null)\n             if (amend) {\n                 RevCommit previousCommit \u003d rw.parseCommit(headId);\n                 for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                 if (author \u003d\u003d null)\n                     author \u003d previousCommit.getAuthorIdent();\n             } else {\n                 parents.add(0, headId);\n             }\n         if (!noVerify) {\n-            message \u003d Hooks.commitMsg(repo, hookOutRedirect).setCommitMessage(message).call();\n+            message \u003d Hooks.commitMsg(repo, hookOutRedirect.get(CommitMsgHook.NAME)).setCommitMessage(message).call();\n         }\n         DirCache index \u003d repo.lockDirCache();\n         try (ObjectInserter odi \u003d repo.newObjectInserter()) {\n             if (!only.isEmpty())\n                 index \u003d createTemporaryIndex(headId, index, rw);\n             ObjectId indexTreeId \u003d index.writeTree(odi);\n             if (insertChangeId)\n                 insertChangeId(indexTreeId);\n             if (headId !\u003d null \u0026\u0026 !allowEmpty.booleanValue()) {\n                 RevCommit headCommit \u003d rw.parseCommit(headId);\n                 headCommit.getTree();\n                 if (indexTreeId.equals(headCommit.getTree())) {\n                     throw new EmtpyCommitException(JGitText.get().emptyCommit);\n                 }\n             }\n             CommitBuilder commit \u003d new CommitBuilder();\n             commit.setCommitter(committer);\n             commit.setAuthor(author);\n             commit.setMessage(message);\n             commit.setParentIds(parents);\n             commit.setTreeId(indexTreeId);\n             ObjectId commitId \u003d odi.insert(commit);\n             odi.flush();\n             RevCommit revCommit \u003d rw.parseCommit(commitId);\n             RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n             ru.setNewObjectId(commitId);\n             if (!useDefaultReflogMessage) {\n                 ru.setRefLogMessage(reflogComment, false);\n             } else {\n                 String prefix \u003d amend ? \"commit (amend): \" : parents.size() \u003d\u003d 0 ? \"commit (initial): \" : \"commit: \";\n                 ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n             }\n             if (headId !\u003d null)\n                 ru.setExpectedOldObjectId(headId);\n             else\n                 ru.setExpectedOldObjectId(ObjectId.zeroId());\n             Result rc \u003d ru.forceUpdate();\n             switch(rc) {\n                 case NEW:\n                 case FORCED:\n                 case FAST_FORWARD:\n                     {\n                         setCallable(false);\n                         if (state \u003d\u003d RepositoryState.MERGING_RESOLVED || isMergeDuringRebase(state)) {\n                             repo.writeMergeCommitMsg(null);\n                             repo.writeMergeHeads(null);\n                         } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                             repo.writeMergeCommitMsg(null);\n                             repo.writeCherryPickHead(null);\n                         } else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n                             repo.writeMergeCommitMsg(null);\n                             repo.writeRevertHead(null);\n                         }\n+                        Hooks.postCommit(repo, hookOutRedirect.get(PostCommitHook.NAME)).call();\n                         return revCommit;\n                     }\n                 case REJECTED:\n                 case LOCK_FAILURE:\n                     throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                 default:\n                     throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n             }\n         } finally {\n             index.unlock();\n         }\n     } catch (UnmergedPathException e) {\n         throw new UnmergedPathsException(e);\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4c236ff4bbf664fd177a33f42517b0eef52510c8": {
      "type": "Ybodychange",
      "commitMessage": "Replace use of deprecated method Repository.getRef()\n\nChange-Id: Iecf2b8deafc4991cc3333702fb9fa0638be7b914\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2016/5/31 上午6:11",
      "commitName": "4c236ff4bbf664fd177a33f42517b0eef52510c8",
      "commitAuthor": "Matthias Sohn",
      "commitDateOld": "2016/4/11 下午2:58",
      "commitNameOld": "36a53d1a3cdd66c40b6db241a75a28293f22f5e1",
      "commitAuthorOld": "Christian Halstrick",
      "daysBetweenCommits": 49.63,
      "commitsBetweenForRepo": 42,
      "commitsBetweenForFile": 1,
      "actualSource": "public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException, AbortedByHookException {\n    checkCallable();\n    Collections.sort(only);\n    try (RevWalk rw \u003d new RevWalk(repo)) {\n        RepositoryState state \u003d repo.getRepositoryState();\n        if (!state.canCommit())\n            throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n        if (!noVerify) {\n            Hooks.preCommit(repo, hookOutRedirect).call();\n        }\n        processOptions(state, rw);\n        if (all \u0026\u0026 !repo.isBare()) {\n            try (Git git \u003d new Git(repo)) {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head \u003d repo.exactRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId \u003d\u003d null \u0026\u0026 amend)\n            throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n        if (headId !\u003d null)\n            if (amend) {\n                RevCommit previousCommit \u003d rw.parseCommit(headId);\n                for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                if (author \u003d\u003d null)\n                    author \u003d previousCommit.getAuthorIdent();\n            } else {\n                parents.add(0, headId);\n            }\n        if (!noVerify) {\n            message \u003d Hooks.commitMsg(repo, hookOutRedirect).setCommitMessage(message).call();\n        }\n        DirCache index \u003d repo.lockDirCache();\n        try (ObjectInserter odi \u003d repo.newObjectInserter()) {\n            if (!only.isEmpty())\n                index \u003d createTemporaryIndex(headId, index, rw);\n            ObjectId indexTreeId \u003d index.writeTree(odi);\n            if (insertChangeId)\n                insertChangeId(indexTreeId);\n            if (headId !\u003d null \u0026\u0026 !allowEmpty.booleanValue()) {\n                RevCommit headCommit \u003d rw.parseCommit(headId);\n                headCommit.getTree();\n                if (indexTreeId.equals(headCommit.getTree())) {\n                    throw new EmtpyCommitException(JGitText.get().emptyCommit);\n                }\n            }\n            CommitBuilder commit \u003d new CommitBuilder();\n            commit.setCommitter(committer);\n            commit.setAuthor(author);\n            commit.setMessage(message);\n            commit.setParentIds(parents);\n            commit.setTreeId(indexTreeId);\n            ObjectId commitId \u003d odi.insert(commit);\n            odi.flush();\n            RevCommit revCommit \u003d rw.parseCommit(commitId);\n            RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n            ru.setNewObjectId(commitId);\n            if (!useDefaultReflogMessage) {\n                ru.setRefLogMessage(reflogComment, false);\n            } else {\n                String prefix \u003d amend ? \"commit (amend): \" : parents.size() \u003d\u003d 0 ? \"commit (initial): \" : \"commit: \";\n                ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n            }\n            if (headId !\u003d null)\n                ru.setExpectedOldObjectId(headId);\n            else\n                ru.setExpectedOldObjectId(ObjectId.zeroId());\n            Result rc \u003d ru.forceUpdate();\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    {\n                        setCallable(false);\n                        if (state \u003d\u003d RepositoryState.MERGING_RESOLVED || isMergeDuringRebase(state)) {\n                            repo.writeMergeCommitMsg(null);\n                            repo.writeMergeHeads(null);\n                        } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                            repo.writeMergeCommitMsg(null);\n                            repo.writeCherryPickHead(null);\n                        } else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n                            repo.writeMergeCommitMsg(null);\n                            repo.writeRevertHead(null);\n                        }\n                        return revCommit;\n                    }\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw new UnmergedPathsException(e);\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 167,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link RevCommit} object representing the successful commit.\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathsException\n            when the current index contained unmerged paths (conflicts)\n@throws ConcurrentRefUpdateException\n            when HEAD or branch ref is updated concurrently by someone\n            else\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n@throws AbortedByHookException\n            if there are either pre-commit or commit-msg hooks present in\n            the repository and one of them rejects the commit.\n",
      "diff": "@@ -1,105 +1,105 @@\n public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException, AbortedByHookException {\n     checkCallable();\n     Collections.sort(only);\n     try (RevWalk rw \u003d new RevWalk(repo)) {\n         RepositoryState state \u003d repo.getRepositoryState();\n         if (!state.canCommit())\n             throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n         if (!noVerify) {\n             Hooks.preCommit(repo, hookOutRedirect).call();\n         }\n         processOptions(state, rw);\n         if (all \u0026\u0026 !repo.isBare()) {\n             try (Git git \u003d new Git(repo)) {\n                 git.add().addFilepattern(\".\").setUpdate(true).call();\n             } catch (NoFilepatternException e) {\n                 throw new JGitInternalException(e.getMessage(), e);\n             }\n         }\n-        Ref head \u003d repo.getRef(Constants.HEAD);\n+        Ref head \u003d repo.exactRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n         if (headId \u003d\u003d null \u0026\u0026 amend)\n             throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n         if (headId !\u003d null)\n             if (amend) {\n                 RevCommit previousCommit \u003d rw.parseCommit(headId);\n                 for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                 if (author \u003d\u003d null)\n                     author \u003d previousCommit.getAuthorIdent();\n             } else {\n                 parents.add(0, headId);\n             }\n         if (!noVerify) {\n             message \u003d Hooks.commitMsg(repo, hookOutRedirect).setCommitMessage(message).call();\n         }\n         DirCache index \u003d repo.lockDirCache();\n         try (ObjectInserter odi \u003d repo.newObjectInserter()) {\n             if (!only.isEmpty())\n                 index \u003d createTemporaryIndex(headId, index, rw);\n             ObjectId indexTreeId \u003d index.writeTree(odi);\n             if (insertChangeId)\n                 insertChangeId(indexTreeId);\n             if (headId !\u003d null \u0026\u0026 !allowEmpty.booleanValue()) {\n                 RevCommit headCommit \u003d rw.parseCommit(headId);\n                 headCommit.getTree();\n                 if (indexTreeId.equals(headCommit.getTree())) {\n                     throw new EmtpyCommitException(JGitText.get().emptyCommit);\n                 }\n             }\n             CommitBuilder commit \u003d new CommitBuilder();\n             commit.setCommitter(committer);\n             commit.setAuthor(author);\n             commit.setMessage(message);\n             commit.setParentIds(parents);\n             commit.setTreeId(indexTreeId);\n             ObjectId commitId \u003d odi.insert(commit);\n             odi.flush();\n             RevCommit revCommit \u003d rw.parseCommit(commitId);\n             RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n             ru.setNewObjectId(commitId);\n             if (!useDefaultReflogMessage) {\n                 ru.setRefLogMessage(reflogComment, false);\n             } else {\n                 String prefix \u003d amend ? \"commit (amend): \" : parents.size() \u003d\u003d 0 ? \"commit (initial): \" : \"commit: \";\n                 ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n             }\n             if (headId !\u003d null)\n                 ru.setExpectedOldObjectId(headId);\n             else\n                 ru.setExpectedOldObjectId(ObjectId.zeroId());\n             Result rc \u003d ru.forceUpdate();\n             switch(rc) {\n                 case NEW:\n                 case FORCED:\n                 case FAST_FORWARD:\n                     {\n                         setCallable(false);\n                         if (state \u003d\u003d RepositoryState.MERGING_RESOLVED || isMergeDuringRebase(state)) {\n                             repo.writeMergeCommitMsg(null);\n                             repo.writeMergeHeads(null);\n                         } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                             repo.writeMergeCommitMsg(null);\n                             repo.writeCherryPickHead(null);\n                         } else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n                             repo.writeMergeCommitMsg(null);\n                             repo.writeRevertHead(null);\n                         }\n                         return revCommit;\n                     }\n                 case REJECTED:\n                 case LOCK_FAILURE:\n                     throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                 default:\n                     throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n             }\n         } finally {\n             index.unlock();\n         }\n     } catch (UnmergedPathException e) {\n         throw new UnmergedPathsException(e);\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "36a53d1a3cdd66c40b6db241a75a28293f22f5e1": {
      "type": "Ybodychange",
      "commitMessage": "Fix CommitCommand to be able to skip writing to RefLog\n\nCommitCommand already provided a method to set the comment which should\nbe written into the reflog. The underlying RefUpdate class supported to\nskip writing a reflog entry. But through the CommitCommand API it was\nnot possible to prevent writing a reflog entry. Fix this and allow\ncreating commits which don\u0027t occur in the reflog.\n\nChange-Id: I193c53de71fb5958ea749c4bfa8360a51acc9b58\n",
      "commitDate": "2016/4/11 下午2:58",
      "commitName": "36a53d1a3cdd66c40b6db241a75a28293f22f5e1",
      "commitAuthor": "Christian Halstrick",
      "commitDateOld": "2016/2/2 下午5:27",
      "commitNameOld": "521f513d6d5d43bbf27b976434a4b75c4798d718",
      "commitAuthorOld": "David Pursehouse",
      "daysBetweenCommits": 68.9,
      "commitsBetweenForRepo": 97,
      "commitsBetweenForFile": 1,
      "actualSource": "public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException, AbortedByHookException {\n    checkCallable();\n    Collections.sort(only);\n    try (RevWalk rw \u003d new RevWalk(repo)) {\n        RepositoryState state \u003d repo.getRepositoryState();\n        if (!state.canCommit())\n            throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n        if (!noVerify) {\n            Hooks.preCommit(repo, hookOutRedirect).call();\n        }\n        processOptions(state, rw);\n        if (all \u0026\u0026 !repo.isBare()) {\n            try (Git git \u003d new Git(repo)) {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId \u003d\u003d null \u0026\u0026 amend)\n            throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n        if (headId !\u003d null)\n            if (amend) {\n                RevCommit previousCommit \u003d rw.parseCommit(headId);\n                for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                if (author \u003d\u003d null)\n                    author \u003d previousCommit.getAuthorIdent();\n            } else {\n                parents.add(0, headId);\n            }\n        if (!noVerify) {\n            message \u003d Hooks.commitMsg(repo, hookOutRedirect).setCommitMessage(message).call();\n        }\n        DirCache index \u003d repo.lockDirCache();\n        try (ObjectInserter odi \u003d repo.newObjectInserter()) {\n            if (!only.isEmpty())\n                index \u003d createTemporaryIndex(headId, index, rw);\n            ObjectId indexTreeId \u003d index.writeTree(odi);\n            if (insertChangeId)\n                insertChangeId(indexTreeId);\n            if (headId !\u003d null \u0026\u0026 !allowEmpty.booleanValue()) {\n                RevCommit headCommit \u003d rw.parseCommit(headId);\n                headCommit.getTree();\n                if (indexTreeId.equals(headCommit.getTree())) {\n                    throw new EmtpyCommitException(JGitText.get().emptyCommit);\n                }\n            }\n            CommitBuilder commit \u003d new CommitBuilder();\n            commit.setCommitter(committer);\n            commit.setAuthor(author);\n            commit.setMessage(message);\n            commit.setParentIds(parents);\n            commit.setTreeId(indexTreeId);\n            ObjectId commitId \u003d odi.insert(commit);\n            odi.flush();\n            RevCommit revCommit \u003d rw.parseCommit(commitId);\n            RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n            ru.setNewObjectId(commitId);\n            if (!useDefaultReflogMessage) {\n                ru.setRefLogMessage(reflogComment, false);\n            } else {\n                String prefix \u003d amend ? \"commit (amend): \" : parents.size() \u003d\u003d 0 ? \"commit (initial): \" : \"commit: \";\n                ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n            }\n            if (headId !\u003d null)\n                ru.setExpectedOldObjectId(headId);\n            else\n                ru.setExpectedOldObjectId(ObjectId.zeroId());\n            Result rc \u003d ru.forceUpdate();\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    {\n                        setCallable(false);\n                        if (state \u003d\u003d RepositoryState.MERGING_RESOLVED || isMergeDuringRebase(state)) {\n                            repo.writeMergeCommitMsg(null);\n                            repo.writeMergeHeads(null);\n                        } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                            repo.writeMergeCommitMsg(null);\n                            repo.writeCherryPickHead(null);\n                        } else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n                            repo.writeMergeCommitMsg(null);\n                            repo.writeRevertHead(null);\n                        }\n                        return revCommit;\n                    }\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw new UnmergedPathsException(e);\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 167,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link RevCommit} object representing the successful commit.\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathsException\n            when the current index contained unmerged paths (conflicts)\n@throws ConcurrentRefUpdateException\n            when HEAD or branch ref is updated concurrently by someone\n            else\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n@throws AbortedByHookException\n            if there are either pre-commit or commit-msg hooks present in\n            the repository and one of them rejects the commit.\n",
      "diff": "@@ -1,105 +1,105 @@\n public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException, AbortedByHookException {\n     checkCallable();\n     Collections.sort(only);\n     try (RevWalk rw \u003d new RevWalk(repo)) {\n         RepositoryState state \u003d repo.getRepositoryState();\n         if (!state.canCommit())\n             throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n         if (!noVerify) {\n             Hooks.preCommit(repo, hookOutRedirect).call();\n         }\n         processOptions(state, rw);\n         if (all \u0026\u0026 !repo.isBare()) {\n             try (Git git \u003d new Git(repo)) {\n                 git.add().addFilepattern(\".\").setUpdate(true).call();\n             } catch (NoFilepatternException e) {\n                 throw new JGitInternalException(e.getMessage(), e);\n             }\n         }\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n         if (headId \u003d\u003d null \u0026\u0026 amend)\n             throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n         if (headId !\u003d null)\n             if (amend) {\n                 RevCommit previousCommit \u003d rw.parseCommit(headId);\n                 for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                 if (author \u003d\u003d null)\n                     author \u003d previousCommit.getAuthorIdent();\n             } else {\n                 parents.add(0, headId);\n             }\n         if (!noVerify) {\n             message \u003d Hooks.commitMsg(repo, hookOutRedirect).setCommitMessage(message).call();\n         }\n         DirCache index \u003d repo.lockDirCache();\n         try (ObjectInserter odi \u003d repo.newObjectInserter()) {\n             if (!only.isEmpty())\n                 index \u003d createTemporaryIndex(headId, index, rw);\n             ObjectId indexTreeId \u003d index.writeTree(odi);\n             if (insertChangeId)\n                 insertChangeId(indexTreeId);\n             if (headId !\u003d null \u0026\u0026 !allowEmpty.booleanValue()) {\n                 RevCommit headCommit \u003d rw.parseCommit(headId);\n                 headCommit.getTree();\n                 if (indexTreeId.equals(headCommit.getTree())) {\n                     throw new EmtpyCommitException(JGitText.get().emptyCommit);\n                 }\n             }\n             CommitBuilder commit \u003d new CommitBuilder();\n             commit.setCommitter(committer);\n             commit.setAuthor(author);\n             commit.setMessage(message);\n             commit.setParentIds(parents);\n             commit.setTreeId(indexTreeId);\n             ObjectId commitId \u003d odi.insert(commit);\n             odi.flush();\n             RevCommit revCommit \u003d rw.parseCommit(commitId);\n             RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n             ru.setNewObjectId(commitId);\n-            if (reflogComment !\u003d null) {\n+            if (!useDefaultReflogMessage) {\n                 ru.setRefLogMessage(reflogComment, false);\n             } else {\n                 String prefix \u003d amend ? \"commit (amend): \" : parents.size() \u003d\u003d 0 ? \"commit (initial): \" : \"commit: \";\n                 ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n             }\n             if (headId !\u003d null)\n                 ru.setExpectedOldObjectId(headId);\n             else\n                 ru.setExpectedOldObjectId(ObjectId.zeroId());\n             Result rc \u003d ru.forceUpdate();\n             switch(rc) {\n                 case NEW:\n                 case FORCED:\n                 case FAST_FORWARD:\n                     {\n                         setCallable(false);\n                         if (state \u003d\u003d RepositoryState.MERGING_RESOLVED || isMergeDuringRebase(state)) {\n                             repo.writeMergeCommitMsg(null);\n                             repo.writeMergeHeads(null);\n                         } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                             repo.writeMergeCommitMsg(null);\n                             repo.writeCherryPickHead(null);\n                         } else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n                             repo.writeMergeCommitMsg(null);\n                             repo.writeRevertHead(null);\n                         }\n                         return revCommit;\n                     }\n                 case REJECTED:\n                 case LOCK_FAILURE:\n                     throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                 default:\n                     throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n             }\n         } finally {\n             index.unlock();\n         }\n     } catch (UnmergedPathException e) {\n         throw new UnmergedPathsException(e);\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "da43d8d79890e561a993a4d90e6a2724a04cd60f": {
      "type": "Ybodychange",
      "commitMessage": "Add option to allow empty commits to CommitCommand\n\nCommitCommand should allow to specify whether empty commits (commits\nhaving the same tree as the sole predecessor commit) are allowed or not.\nSimilar to native git\u0027s \"--allow-empty\" flag.\n\nThe defaults differ between JGit and native git even after this change.\nWhen not specifying paths then by default JGit allows to create empty\ncommits while native git does not. It would be API breaking to change\nthis now.\n\nBug: 460301\nChange-Id: I88feb0c3ffb2c686b1d0594e669729b065cda4cb\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2016/1/20 下午6:14",
      "commitName": "da43d8d79890e561a993a4d90e6a2724a04cd60f",
      "commitAuthor": "Christian Halstrick",
      "commitDateOld": "2016/1/20 上午8:45",
      "commitNameOld": "aca07fac464834611bab83b91e828308838f361c",
      "commitAuthorOld": "",
      "daysBetweenCommits": 0.39,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException, AbortedByHookException {\n    checkCallable();\n    Collections.sort(only);\n    try (RevWalk rw \u003d new RevWalk(repo)) {\n        RepositoryState state \u003d repo.getRepositoryState();\n        if (!state.canCommit())\n            throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n        if (!noVerify) {\n            Hooks.preCommit(repo, hookOutRedirect).call();\n        }\n        processOptions(state, rw);\n        if (all \u0026\u0026 !repo.isBare()) {\n            try (Git git \u003d new Git(repo)) {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId \u003d\u003d null \u0026\u0026 amend)\n            throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n        if (headId !\u003d null)\n            if (amend) {\n                RevCommit previousCommit \u003d rw.parseCommit(headId);\n                for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                if (author \u003d\u003d null)\n                    author \u003d previousCommit.getAuthorIdent();\n            } else {\n                parents.add(0, headId);\n            }\n        if (!noVerify) {\n            message \u003d Hooks.commitMsg(repo, hookOutRedirect).setCommitMessage(message).call();\n        }\n        DirCache index \u003d repo.lockDirCache();\n        try (ObjectInserter odi \u003d repo.newObjectInserter()) {\n            if (!only.isEmpty())\n                index \u003d createTemporaryIndex(headId, index, rw);\n            ObjectId indexTreeId \u003d index.writeTree(odi);\n            if (insertChangeId)\n                insertChangeId(indexTreeId);\n            if (headId !\u003d null \u0026\u0026 !allowEmpty.booleanValue()) {\n                RevCommit headCommit \u003d rw.parseCommit(headId);\n                headCommit.getTree();\n                if (indexTreeId.equals(headCommit.getTree())) {\n                    throw new EmtpyCommitException(JGitText.get().emptyCommit);\n                }\n            }\n            CommitBuilder commit \u003d new CommitBuilder();\n            commit.setCommitter(committer);\n            commit.setAuthor(author);\n            commit.setMessage(message);\n            commit.setParentIds(parents);\n            commit.setTreeId(indexTreeId);\n            ObjectId commitId \u003d odi.insert(commit);\n            odi.flush();\n            RevCommit revCommit \u003d rw.parseCommit(commitId);\n            RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n            ru.setNewObjectId(commitId);\n            if (reflogComment !\u003d null) {\n                ru.setRefLogMessage(reflogComment, false);\n            } else {\n                String prefix \u003d amend ? \"commit (amend): \" : parents.size() \u003d\u003d 0 ? \"commit (initial): \" : \"commit: \";\n                ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n            }\n            if (headId !\u003d null)\n                ru.setExpectedOldObjectId(headId);\n            else\n                ru.setExpectedOldObjectId(ObjectId.zeroId());\n            Result rc \u003d ru.forceUpdate();\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    {\n                        setCallable(false);\n                        if (state \u003d\u003d RepositoryState.MERGING_RESOLVED || isMergeDuringRebase(state)) {\n                            repo.writeMergeCommitMsg(null);\n                            repo.writeMergeHeads(null);\n                        } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                            repo.writeMergeCommitMsg(null);\n                            repo.writeCherryPickHead(null);\n                        } else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n                            repo.writeMergeCommitMsg(null);\n                            repo.writeRevertHead(null);\n                        }\n                        return revCommit;\n                    }\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw new UnmergedPathsException(e);\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 165,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link RevCommit} object representing the successful commit.\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathsException\n            when the current index contained unmerged paths (conflicts)\n@throws ConcurrentRefUpdateException\n            when HEAD or branch ref is updated concurrently by someone\n            else\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n@throws AbortedByHookException\n            if there are either pre-commit or commit-msg hooks present in\n            the repository and one of them rejects the commit.\n",
      "diff": "@@ -1,98 +1,105 @@\n public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException, AbortedByHookException {\n     checkCallable();\n     Collections.sort(only);\n     try (RevWalk rw \u003d new RevWalk(repo)) {\n         RepositoryState state \u003d repo.getRepositoryState();\n         if (!state.canCommit())\n             throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n         if (!noVerify) {\n             Hooks.preCommit(repo, hookOutRedirect).call();\n         }\n         processOptions(state, rw);\n         if (all \u0026\u0026 !repo.isBare()) {\n             try (Git git \u003d new Git(repo)) {\n                 git.add().addFilepattern(\".\").setUpdate(true).call();\n             } catch (NoFilepatternException e) {\n                 throw new JGitInternalException(e.getMessage(), e);\n             }\n         }\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n         if (headId \u003d\u003d null \u0026\u0026 amend)\n             throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n         if (headId !\u003d null)\n             if (amend) {\n                 RevCommit previousCommit \u003d rw.parseCommit(headId);\n                 for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                 if (author \u003d\u003d null)\n                     author \u003d previousCommit.getAuthorIdent();\n             } else {\n                 parents.add(0, headId);\n             }\n         if (!noVerify) {\n             message \u003d Hooks.commitMsg(repo, hookOutRedirect).setCommitMessage(message).call();\n         }\n         DirCache index \u003d repo.lockDirCache();\n         try (ObjectInserter odi \u003d repo.newObjectInserter()) {\n             if (!only.isEmpty())\n                 index \u003d createTemporaryIndex(headId, index, rw);\n             ObjectId indexTreeId \u003d index.writeTree(odi);\n             if (insertChangeId)\n                 insertChangeId(indexTreeId);\n+            if (headId !\u003d null \u0026\u0026 !allowEmpty.booleanValue()) {\n+                RevCommit headCommit \u003d rw.parseCommit(headId);\n+                headCommit.getTree();\n+                if (indexTreeId.equals(headCommit.getTree())) {\n+                    throw new EmtpyCommitException(JGitText.get().emptyCommit);\n+                }\n+            }\n             CommitBuilder commit \u003d new CommitBuilder();\n             commit.setCommitter(committer);\n             commit.setAuthor(author);\n             commit.setMessage(message);\n             commit.setParentIds(parents);\n             commit.setTreeId(indexTreeId);\n             ObjectId commitId \u003d odi.insert(commit);\n             odi.flush();\n             RevCommit revCommit \u003d rw.parseCommit(commitId);\n             RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n             ru.setNewObjectId(commitId);\n             if (reflogComment !\u003d null) {\n                 ru.setRefLogMessage(reflogComment, false);\n             } else {\n                 String prefix \u003d amend ? \"commit (amend): \" : parents.size() \u003d\u003d 0 ? \"commit (initial): \" : \"commit: \";\n                 ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n             }\n             if (headId !\u003d null)\n                 ru.setExpectedOldObjectId(headId);\n             else\n                 ru.setExpectedOldObjectId(ObjectId.zeroId());\n             Result rc \u003d ru.forceUpdate();\n             switch(rc) {\n                 case NEW:\n                 case FORCED:\n                 case FAST_FORWARD:\n                     {\n                         setCallable(false);\n                         if (state \u003d\u003d RepositoryState.MERGING_RESOLVED || isMergeDuringRebase(state)) {\n                             repo.writeMergeCommitMsg(null);\n                             repo.writeMergeHeads(null);\n                         } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                             repo.writeMergeCommitMsg(null);\n                             repo.writeCherryPickHead(null);\n                         } else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n                             repo.writeMergeCommitMsg(null);\n                             repo.writeRevertHead(null);\n                         }\n                         return revCommit;\n                     }\n                 case REJECTED:\n                 case LOCK_FAILURE:\n                     throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                 default:\n                     throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n             }\n         } finally {\n             index.unlock();\n         }\n     } catch (UnmergedPathException e) {\n         throw new UnmergedPathsException(e);\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1ed5382b37453309580e11a11cf4c3bb134813fa": {
      "type": "Ybodychange",
      "commitMessage": "CommitCommand: Remove redundant null check\n\nRepository.getWorkTree is annotated as @NonNull, so the check\nfor it returning null is redundant.\n\nChange-Id: I597b0f774ff857b8900519f14a1a17a904cf7c6f\nSigned-off-by: David Pursehouse \u003cdavid.pursehouse@sonymobile.com\u003e\n",
      "commitDate": "2016/1/14 下午2:04",
      "commitName": "1ed5382b37453309580e11a11cf4c3bb134813fa",
      "commitAuthor": "David Pursehouse",
      "commitDateOld": "2015/11/28 上午6:23",
      "commitNameOld": "5d9f595eb87fba31c2253051102116fc7876e6c0",
      "commitAuthorOld": "Christian Halstrick",
      "daysBetweenCommits": 47.32,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "actualSource": "public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException, AbortedByHookException {\n    checkCallable();\n    Collections.sort(only);\n    try (RevWalk rw \u003d new RevWalk(repo)) {\n        RepositoryState state \u003d repo.getRepositoryState();\n        if (!state.canCommit())\n            throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n        if (!noVerify) {\n            Hooks.preCommit(repo, hookOutRedirect).call();\n        }\n        processOptions(state, rw);\n        if (all \u0026\u0026 !repo.isBare()) {\n            try (Git git \u003d new Git(repo)) {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId \u003d\u003d null \u0026\u0026 amend)\n            throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n        if (headId !\u003d null)\n            if (amend) {\n                RevCommit previousCommit \u003d rw.parseCommit(headId);\n                for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                if (author \u003d\u003d null)\n                    author \u003d previousCommit.getAuthorIdent();\n            } else {\n                parents.add(0, headId);\n            }\n        if (!noVerify) {\n            message \u003d Hooks.commitMsg(repo, hookOutRedirect).setCommitMessage(message).call();\n        }\n        DirCache index \u003d repo.lockDirCache();\n        try (ObjectInserter odi \u003d repo.newObjectInserter()) {\n            if (!only.isEmpty())\n                index \u003d createTemporaryIndex(headId, index, rw);\n            ObjectId indexTreeId \u003d index.writeTree(odi);\n            if (insertChangeId)\n                insertChangeId(indexTreeId);\n            CommitBuilder commit \u003d new CommitBuilder();\n            commit.setCommitter(committer);\n            commit.setAuthor(author);\n            commit.setMessage(message);\n            commit.setParentIds(parents);\n            commit.setTreeId(indexTreeId);\n            ObjectId commitId \u003d odi.insert(commit);\n            odi.flush();\n            RevCommit revCommit \u003d rw.parseCommit(commitId);\n            RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n            ru.setNewObjectId(commitId);\n            if (reflogComment !\u003d null) {\n                ru.setRefLogMessage(reflogComment, false);\n            } else {\n                String prefix \u003d amend ? \"commit (amend): \" : parents.size() \u003d\u003d 0 ? \"commit (initial): \" : \"commit: \";\n                ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n            }\n            if (headId !\u003d null)\n                ru.setExpectedOldObjectId(headId);\n            else\n                ru.setExpectedOldObjectId(ObjectId.zeroId());\n            Result rc \u003d ru.forceUpdate();\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    {\n                        setCallable(false);\n                        if (state \u003d\u003d RepositoryState.MERGING_RESOLVED || isMergeDuringRebase(state)) {\n                            repo.writeMergeCommitMsg(null);\n                            repo.writeMergeHeads(null);\n                        } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                            repo.writeMergeCommitMsg(null);\n                            repo.writeCherryPickHead(null);\n                        } else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n                            repo.writeMergeCommitMsg(null);\n                            repo.writeRevertHead(null);\n                        }\n                        return revCommit;\n                    }\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw new UnmergedPathsException(e);\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 162,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link RevCommit} object representing the successful commit.\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathsException\n            when the current index contained unmerged paths (conflicts)\n@throws ConcurrentRefUpdateException\n            when HEAD or branch ref is updated concurrently by someone\n            else\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n@throws AbortedByHookException\n            if there are either pre-commit or commit-msg hooks present in\n            the repository and one of them rejects the commit.\n",
      "diff": "@@ -1,98 +1,98 @@\n public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException, AbortedByHookException {\n     checkCallable();\n     Collections.sort(only);\n     try (RevWalk rw \u003d new RevWalk(repo)) {\n         RepositoryState state \u003d repo.getRepositoryState();\n         if (!state.canCommit())\n             throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n         if (!noVerify) {\n             Hooks.preCommit(repo, hookOutRedirect).call();\n         }\n         processOptions(state, rw);\n-        if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n+        if (all \u0026\u0026 !repo.isBare()) {\n             try (Git git \u003d new Git(repo)) {\n                 git.add().addFilepattern(\".\").setUpdate(true).call();\n             } catch (NoFilepatternException e) {\n                 throw new JGitInternalException(e.getMessage(), e);\n             }\n         }\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n         if (headId \u003d\u003d null \u0026\u0026 amend)\n             throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n         if (headId !\u003d null)\n             if (amend) {\n                 RevCommit previousCommit \u003d rw.parseCommit(headId);\n                 for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                 if (author \u003d\u003d null)\n                     author \u003d previousCommit.getAuthorIdent();\n             } else {\n                 parents.add(0, headId);\n             }\n         if (!noVerify) {\n             message \u003d Hooks.commitMsg(repo, hookOutRedirect).setCommitMessage(message).call();\n         }\n         DirCache index \u003d repo.lockDirCache();\n         try (ObjectInserter odi \u003d repo.newObjectInserter()) {\n             if (!only.isEmpty())\n                 index \u003d createTemporaryIndex(headId, index, rw);\n             ObjectId indexTreeId \u003d index.writeTree(odi);\n             if (insertChangeId)\n                 insertChangeId(indexTreeId);\n             CommitBuilder commit \u003d new CommitBuilder();\n             commit.setCommitter(committer);\n             commit.setAuthor(author);\n             commit.setMessage(message);\n             commit.setParentIds(parents);\n             commit.setTreeId(indexTreeId);\n             ObjectId commitId \u003d odi.insert(commit);\n             odi.flush();\n             RevCommit revCommit \u003d rw.parseCommit(commitId);\n             RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n             ru.setNewObjectId(commitId);\n             if (reflogComment !\u003d null) {\n                 ru.setRefLogMessage(reflogComment, false);\n             } else {\n                 String prefix \u003d amend ? \"commit (amend): \" : parents.size() \u003d\u003d 0 ? \"commit (initial): \" : \"commit: \";\n                 ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n             }\n             if (headId !\u003d null)\n                 ru.setExpectedOldObjectId(headId);\n             else\n                 ru.setExpectedOldObjectId(ObjectId.zeroId());\n             Result rc \u003d ru.forceUpdate();\n             switch(rc) {\n                 case NEW:\n                 case FORCED:\n                 case FAST_FORWARD:\n                     {\n                         setCallable(false);\n                         if (state \u003d\u003d RepositoryState.MERGING_RESOLVED || isMergeDuringRebase(state)) {\n                             repo.writeMergeCommitMsg(null);\n                             repo.writeMergeHeads(null);\n                         } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                             repo.writeMergeCommitMsg(null);\n                             repo.writeCherryPickHead(null);\n                         } else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n                             repo.writeMergeCommitMsg(null);\n                             repo.writeRevertHead(null);\n                         }\n                         return revCommit;\n                     }\n                 case REJECTED:\n                 case LOCK_FAILURE:\n                     throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                 default:\n                     throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n             }\n         } finally {\n             index.unlock();\n         }\n     } catch (UnmergedPathException e) {\n         throw new UnmergedPathsException(e);\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d726f0c1e02c196e2dd87de53b54338be15503f1": {
      "type": "Ybodychange",
      "commitMessage": "Use try-with-resource to close resources in CommitCommand\n\nChange-Id: Ibbbc74acfd050f28e68f318970660b5959caf7e3\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2015/4/9 上午4:53",
      "commitName": "d726f0c1e02c196e2dd87de53b54338be15503f1",
      "commitAuthor": "Matthias Sohn",
      "commitDateOld": "2015/3/3 上午12:45",
      "commitNameOld": "efeb02bf2bed32ef94d5c4891404f551cdc6957f",
      "commitAuthorOld": "Laurent Delaigue",
      "daysBetweenCommits": 37.17,
      "commitsBetweenForRepo": 74,
      "commitsBetweenForFile": 1,
      "actualSource": "public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException, AbortedByHookException {\n    checkCallable();\n    Collections.sort(only);\n    try (RevWalk rw \u003d new RevWalk(repo)) {\n        RepositoryState state \u003d repo.getRepositoryState();\n        if (!state.canCommit())\n            throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n        if (!noVerify) {\n            Hooks.preCommit(repo, hookOutRedirect).call();\n        }\n        processOptions(state, rw);\n        if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n            try (Git git \u003d new Git(repo)) {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId \u003d\u003d null \u0026\u0026 amend)\n            throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n        if (headId !\u003d null)\n            if (amend) {\n                RevCommit previousCommit \u003d rw.parseCommit(headId);\n                for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                if (author \u003d\u003d null)\n                    author \u003d previousCommit.getAuthorIdent();\n            } else {\n                parents.add(0, headId);\n            }\n        if (!noVerify) {\n            message \u003d Hooks.commitMsg(repo, hookOutRedirect).setCommitMessage(message).call();\n        }\n        DirCache index \u003d repo.lockDirCache();\n        try (ObjectInserter odi \u003d repo.newObjectInserter()) {\n            if (!only.isEmpty())\n                index \u003d createTemporaryIndex(headId, index, rw);\n            ObjectId indexTreeId \u003d index.writeTree(odi);\n            if (insertChangeId)\n                insertChangeId(indexTreeId);\n            CommitBuilder commit \u003d new CommitBuilder();\n            commit.setCommitter(committer);\n            commit.setAuthor(author);\n            commit.setMessage(message);\n            commit.setParentIds(parents);\n            commit.setTreeId(indexTreeId);\n            ObjectId commitId \u003d odi.insert(commit);\n            odi.flush();\n            RevCommit revCommit \u003d rw.parseCommit(commitId);\n            RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n            ru.setNewObjectId(commitId);\n            if (reflogComment !\u003d null) {\n                ru.setRefLogMessage(reflogComment, false);\n            } else {\n                String prefix \u003d amend ? \"commit (amend): \" : parents.size() \u003d\u003d 0 ? \"commit (initial): \" : \"commit: \";\n                ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n            }\n            if (headId !\u003d null)\n                ru.setExpectedOldObjectId(headId);\n            else\n                ru.setExpectedOldObjectId(ObjectId.zeroId());\n            Result rc \u003d ru.forceUpdate();\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    {\n                        setCallable(false);\n                        if (state \u003d\u003d RepositoryState.MERGING_RESOLVED || isMergeDuringRebase(state)) {\n                            repo.writeMergeCommitMsg(null);\n                            repo.writeMergeHeads(null);\n                        } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                            repo.writeMergeCommitMsg(null);\n                            repo.writeCherryPickHead(null);\n                        } else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n                            repo.writeMergeCommitMsg(null);\n                            repo.writeRevertHead(null);\n                        }\n                        return revCommit;\n                    }\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw new UnmergedPathsException(e);\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 161,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link RevCommit} object representing the successful commit.\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathsException\n            when the current index contained unmerged paths (conflicts)\n@throws ConcurrentRefUpdateException\n            when HEAD or branch ref is updated concurrently by someone\n            else\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n@throws AbortedByHookException\n            if there are either pre-commit or commit-msg hooks present in\n            the repository and one of them rejects the commit.\n",
      "diff": "@@ -1,107 +1,98 @@\n public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException, AbortedByHookException {\n     checkCallable();\n     Collections.sort(only);\n-    RevWalk rw \u003d new RevWalk(repo);\n-    try {\n+    try (RevWalk rw \u003d new RevWalk(repo)) {\n         RepositoryState state \u003d repo.getRepositoryState();\n         if (!state.canCommit())\n             throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n         if (!noVerify) {\n             Hooks.preCommit(repo, hookOutRedirect).call();\n         }\n         processOptions(state, rw);\n         if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n-            Git git \u003d new Git(repo);\n-            try {\n+            try (Git git \u003d new Git(repo)) {\n                 git.add().addFilepattern(\".\").setUpdate(true).call();\n             } catch (NoFilepatternException e) {\n                 throw new JGitInternalException(e.getMessage(), e);\n             }\n         }\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n         if (headId \u003d\u003d null \u0026\u0026 amend)\n             throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n         if (headId !\u003d null)\n             if (amend) {\n                 RevCommit previousCommit \u003d rw.parseCommit(headId);\n                 for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                 if (author \u003d\u003d null)\n                     author \u003d previousCommit.getAuthorIdent();\n             } else {\n                 parents.add(0, headId);\n             }\n         if (!noVerify) {\n             message \u003d Hooks.commitMsg(repo, hookOutRedirect).setCommitMessage(message).call();\n         }\n         DirCache index \u003d repo.lockDirCache();\n-        try {\n+        try (ObjectInserter odi \u003d repo.newObjectInserter()) {\n             if (!only.isEmpty())\n                 index \u003d createTemporaryIndex(headId, index, rw);\n-            ObjectInserter odi \u003d repo.newObjectInserter();\n-            try {\n-                ObjectId indexTreeId \u003d index.writeTree(odi);\n-                if (insertChangeId)\n-                    insertChangeId(indexTreeId);\n-                CommitBuilder commit \u003d new CommitBuilder();\n-                commit.setCommitter(committer);\n-                commit.setAuthor(author);\n-                commit.setMessage(message);\n-                commit.setParentIds(parents);\n-                commit.setTreeId(indexTreeId);\n-                ObjectId commitId \u003d odi.insert(commit);\n-                odi.flush();\n-                RevCommit revCommit \u003d rw.parseCommit(commitId);\n-                RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n-                ru.setNewObjectId(commitId);\n-                if (reflogComment !\u003d null) {\n-                    ru.setRefLogMessage(reflogComment, false);\n-                } else {\n-                    String prefix \u003d amend ? \"commit (amend): \" : parents.size() \u003d\u003d 0 ? \"commit (initial): \" : \"commit: \";\n-                    ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n-                }\n-                if (headId !\u003d null)\n-                    ru.setExpectedOldObjectId(headId);\n-                else\n-                    ru.setExpectedOldObjectId(ObjectId.zeroId());\n-                Result rc \u003d ru.forceUpdate();\n-                switch(rc) {\n-                    case NEW:\n-                    case FORCED:\n-                    case FAST_FORWARD:\n-                        {\n-                            setCallable(false);\n-                            if (state \u003d\u003d RepositoryState.MERGING_RESOLVED || isMergeDuringRebase(state)) {\n-                                repo.writeMergeCommitMsg(null);\n-                                repo.writeMergeHeads(null);\n-                            } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n-                                repo.writeMergeCommitMsg(null);\n-                                repo.writeCherryPickHead(null);\n-                            } else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n-                                repo.writeMergeCommitMsg(null);\n-                                repo.writeRevertHead(null);\n-                            }\n-                            return revCommit;\n+            ObjectId indexTreeId \u003d index.writeTree(odi);\n+            if (insertChangeId)\n+                insertChangeId(indexTreeId);\n+            CommitBuilder commit \u003d new CommitBuilder();\n+            commit.setCommitter(committer);\n+            commit.setAuthor(author);\n+            commit.setMessage(message);\n+            commit.setParentIds(parents);\n+            commit.setTreeId(indexTreeId);\n+            ObjectId commitId \u003d odi.insert(commit);\n+            odi.flush();\n+            RevCommit revCommit \u003d rw.parseCommit(commitId);\n+            RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n+            ru.setNewObjectId(commitId);\n+            if (reflogComment !\u003d null) {\n+                ru.setRefLogMessage(reflogComment, false);\n+            } else {\n+                String prefix \u003d amend ? \"commit (amend): \" : parents.size() \u003d\u003d 0 ? \"commit (initial): \" : \"commit: \";\n+                ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n+            }\n+            if (headId !\u003d null)\n+                ru.setExpectedOldObjectId(headId);\n+            else\n+                ru.setExpectedOldObjectId(ObjectId.zeroId());\n+            Result rc \u003d ru.forceUpdate();\n+            switch(rc) {\n+                case NEW:\n+                case FORCED:\n+                case FAST_FORWARD:\n+                    {\n+                        setCallable(false);\n+                        if (state \u003d\u003d RepositoryState.MERGING_RESOLVED || isMergeDuringRebase(state)) {\n+                            repo.writeMergeCommitMsg(null);\n+                            repo.writeMergeHeads(null);\n+                        } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n+                            repo.writeMergeCommitMsg(null);\n+                            repo.writeCherryPickHead(null);\n+                        } else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n+                            repo.writeMergeCommitMsg(null);\n+                            repo.writeRevertHead(null);\n                         }\n-                    case REJECTED:\n-                    case LOCK_FAILURE:\n-                        throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n-                    default:\n-                        throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n-                }\n-            } finally {\n-                odi.release();\n+                        return revCommit;\n+                    }\n+                case REJECTED:\n+                case LOCK_FAILURE:\n+                    throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n+                default:\n+                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n             }\n         } finally {\n             index.unlock();\n         }\n     } catch (UnmergedPathException e) {\n         throw new UnmergedPathsException(e);\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n-    } finally {\n-        rw.dispose();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "efeb02bf2bed32ef94d5c4891404f551cdc6957f": {
      "type": "Ybodychange",
      "commitMessage": "Support for the commit-msg hook.\n\nThis hook uses the file .git/COMMIT_EDITMSG to receive and potentially\nmodify the commit message.\n\nChange-Id: Ibe2faadfb5d3932a5a3da2252d8156c4c04856c7\nSigned-off-by: Laurent Delaigue \u003claurent.delaigue@obeo.fr\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2015/3/3 上午12:45",
      "commitName": "efeb02bf2bed32ef94d5c4891404f551cdc6957f",
      "commitAuthor": "Laurent Delaigue",
      "commitDateOld": "2015/3/2 下午10:33",
      "commitNameOld": "26fd56f167e6377777e6d46c14779183e4bcb55a",
      "commitAuthorOld": "Laurent Delaigue",
      "daysBetweenCommits": 0.09,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException, AbortedByHookException {\n    checkCallable();\n    Collections.sort(only);\n    RevWalk rw \u003d new RevWalk(repo);\n    try {\n        RepositoryState state \u003d repo.getRepositoryState();\n        if (!state.canCommit())\n            throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n        if (!noVerify) {\n            Hooks.preCommit(repo, hookOutRedirect).call();\n        }\n        processOptions(state, rw);\n        if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n            Git git \u003d new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId \u003d\u003d null \u0026\u0026 amend)\n            throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n        if (headId !\u003d null)\n            if (amend) {\n                RevCommit previousCommit \u003d rw.parseCommit(headId);\n                for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                if (author \u003d\u003d null)\n                    author \u003d previousCommit.getAuthorIdent();\n            } else {\n                parents.add(0, headId);\n            }\n        if (!noVerify) {\n            message \u003d Hooks.commitMsg(repo, hookOutRedirect).setCommitMessage(message).call();\n        }\n        DirCache index \u003d repo.lockDirCache();\n        try {\n            if (!only.isEmpty())\n                index \u003d createTemporaryIndex(headId, index, rw);\n            ObjectInserter odi \u003d repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId \u003d index.writeTree(odi);\n                if (insertChangeId)\n                    insertChangeId(indexTreeId);\n                CommitBuilder commit \u003d new CommitBuilder();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId \u003d odi.insert(commit);\n                odi.flush();\n                RevCommit revCommit \u003d rw.parseCommit(commitId);\n                RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                ru.setNewObjectId(commitId);\n                if (reflogComment !\u003d null) {\n                    ru.setRefLogMessage(reflogComment, false);\n                } else {\n                    String prefix \u003d amend ? \"commit (amend): \" : parents.size() \u003d\u003d 0 ? \"commit (initial): \" : \"commit: \";\n                    ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                }\n                if (headId !\u003d null)\n                    ru.setExpectedOldObjectId(headId);\n                else\n                    ru.setExpectedOldObjectId(ObjectId.zeroId());\n                Result rc \u003d ru.forceUpdate();\n                switch(rc) {\n                    case NEW:\n                    case FORCED:\n                    case FAST_FORWARD:\n                        {\n                            setCallable(false);\n                            if (state \u003d\u003d RepositoryState.MERGING_RESOLVED || isMergeDuringRebase(state)) {\n                                repo.writeMergeCommitMsg(null);\n                                repo.writeMergeHeads(null);\n                            } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                repo.writeMergeCommitMsg(null);\n                                repo.writeCherryPickHead(null);\n                            } else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n                                repo.writeMergeCommitMsg(null);\n                                repo.writeRevertHead(null);\n                            }\n                            return revCommit;\n                        }\n                    case REJECTED:\n                    case LOCK_FAILURE:\n                        throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                    default:\n                        throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw new UnmergedPathsException(e);\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    } finally {\n        rw.dispose();\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 161,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link RevCommit} object representing the successful commit.\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathsException\n            when the current index contained unmerged paths (conflicts)\n@throws ConcurrentRefUpdateException\n            when HEAD or branch ref is updated concurrently by someone\n            else\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n@throws AbortedByHookException\n            if there are either pre-commit or commit-msg hooks present in\n            the repository and one of them rejects the commit.\n",
      "diff": "@@ -1,104 +1,107 @@\n public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException, AbortedByHookException {\n     checkCallable();\n     Collections.sort(only);\n     RevWalk rw \u003d new RevWalk(repo);\n     try {\n         RepositoryState state \u003d repo.getRepositoryState();\n         if (!state.canCommit())\n             throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n         if (!noVerify) {\n             Hooks.preCommit(repo, hookOutRedirect).call();\n         }\n         processOptions(state, rw);\n         if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n             Git git \u003d new Git(repo);\n             try {\n                 git.add().addFilepattern(\".\").setUpdate(true).call();\n             } catch (NoFilepatternException e) {\n                 throw new JGitInternalException(e.getMessage(), e);\n             }\n         }\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n         if (headId \u003d\u003d null \u0026\u0026 amend)\n             throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n         if (headId !\u003d null)\n             if (amend) {\n                 RevCommit previousCommit \u003d rw.parseCommit(headId);\n                 for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                 if (author \u003d\u003d null)\n                     author \u003d previousCommit.getAuthorIdent();\n             } else {\n                 parents.add(0, headId);\n             }\n+        if (!noVerify) {\n+            message \u003d Hooks.commitMsg(repo, hookOutRedirect).setCommitMessage(message).call();\n+        }\n         DirCache index \u003d repo.lockDirCache();\n         try {\n             if (!only.isEmpty())\n                 index \u003d createTemporaryIndex(headId, index, rw);\n             ObjectInserter odi \u003d repo.newObjectInserter();\n             try {\n                 ObjectId indexTreeId \u003d index.writeTree(odi);\n                 if (insertChangeId)\n                     insertChangeId(indexTreeId);\n                 CommitBuilder commit \u003d new CommitBuilder();\n                 commit.setCommitter(committer);\n                 commit.setAuthor(author);\n                 commit.setMessage(message);\n                 commit.setParentIds(parents);\n                 commit.setTreeId(indexTreeId);\n                 ObjectId commitId \u003d odi.insert(commit);\n                 odi.flush();\n                 RevCommit revCommit \u003d rw.parseCommit(commitId);\n                 RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                 ru.setNewObjectId(commitId);\n                 if (reflogComment !\u003d null) {\n                     ru.setRefLogMessage(reflogComment, false);\n                 } else {\n                     String prefix \u003d amend ? \"commit (amend): \" : parents.size() \u003d\u003d 0 ? \"commit (initial): \" : \"commit: \";\n                     ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                 }\n                 if (headId !\u003d null)\n                     ru.setExpectedOldObjectId(headId);\n                 else\n                     ru.setExpectedOldObjectId(ObjectId.zeroId());\n                 Result rc \u003d ru.forceUpdate();\n                 switch(rc) {\n                     case NEW:\n                     case FORCED:\n                     case FAST_FORWARD:\n                         {\n                             setCallable(false);\n                             if (state \u003d\u003d RepositoryState.MERGING_RESOLVED || isMergeDuringRebase(state)) {\n                                 repo.writeMergeCommitMsg(null);\n                                 repo.writeMergeHeads(null);\n                             } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                 repo.writeMergeCommitMsg(null);\n                                 repo.writeCherryPickHead(null);\n                             } else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n                                 repo.writeMergeCommitMsg(null);\n                                 repo.writeRevertHead(null);\n                             }\n                             return revCommit;\n                         }\n                     case REJECTED:\n                     case LOCK_FAILURE:\n                         throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                     default:\n                         throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                 }\n             } finally {\n                 odi.release();\n             }\n         } finally {\n             index.unlock();\n         }\n     } catch (UnmergedPathException e) {\n         throw new UnmergedPathsException(e);\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n     } finally {\n         rw.dispose();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "26fd56f167e6377777e6d46c14779183e4bcb55a": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange,Ydocchange)",
      "commitMessage": "Refactored pre-commit hook to make it less invasive.\n\nHooks are now obtained via a convenient API like git commands, and\ncallers don\u0027t have to check for their existence.\nThe pre-commit hook has been updated accordingly.\n\nChange-Id: I3383ffb10e2f3b588d7367b9139b606ec7f62758\nSigned-off-by: Laurent Delaigue \u003claurent.delaigue@obeo.fr\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2015/3/2 下午10:33",
      "commitName": "26fd56f167e6377777e6d46c14779183e4bcb55a",
      "commitAuthor": "Laurent Delaigue",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "Refactored pre-commit hook to make it less invasive.\n\nHooks are now obtained via a convenient API like git commands, and\ncallers don\u0027t have to check for their existence.\nThe pre-commit hook has been updated accordingly.\n\nChange-Id: I3383ffb10e2f3b588d7367b9139b606ec7f62758\nSigned-off-by: Laurent Delaigue \u003claurent.delaigue@obeo.fr\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
          "commitDate": "2015/3/2 下午10:33",
          "commitName": "26fd56f167e6377777e6d46c14779183e4bcb55a",
          "commitAuthor": "Laurent Delaigue",
          "commitDateOld": "2015/2/3 上午4:23",
          "commitNameOld": "494e893c541b5cf465b362c69354c08d7a81c249",
          "commitAuthorOld": "Laurent Goubet",
          "daysBetweenCommits": 27.76,
          "commitsBetweenForRepo": 20,
          "commitsBetweenForFile": 1,
          "actualSource": "public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException, AbortedByHookException {\n    checkCallable();\n    Collections.sort(only);\n    RevWalk rw \u003d new RevWalk(repo);\n    try {\n        RepositoryState state \u003d repo.getRepositoryState();\n        if (!state.canCommit())\n            throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n        if (!noVerify) {\n            Hooks.preCommit(repo, hookOutRedirect).call();\n        }\n        processOptions(state, rw);\n        if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n            Git git \u003d new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId \u003d\u003d null \u0026\u0026 amend)\n            throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n        if (headId !\u003d null)\n            if (amend) {\n                RevCommit previousCommit \u003d rw.parseCommit(headId);\n                for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                if (author \u003d\u003d null)\n                    author \u003d previousCommit.getAuthorIdent();\n            } else {\n                parents.add(0, headId);\n            }\n        DirCache index \u003d repo.lockDirCache();\n        try {\n            if (!only.isEmpty())\n                index \u003d createTemporaryIndex(headId, index, rw);\n            ObjectInserter odi \u003d repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId \u003d index.writeTree(odi);\n                if (insertChangeId)\n                    insertChangeId(indexTreeId);\n                CommitBuilder commit \u003d new CommitBuilder();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId \u003d odi.insert(commit);\n                odi.flush();\n                RevCommit revCommit \u003d rw.parseCommit(commitId);\n                RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                ru.setNewObjectId(commitId);\n                if (reflogComment !\u003d null) {\n                    ru.setRefLogMessage(reflogComment, false);\n                } else {\n                    String prefix \u003d amend ? \"commit (amend): \" : parents.size() \u003d\u003d 0 ? \"commit (initial): \" : \"commit: \";\n                    ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                }\n                if (headId !\u003d null)\n                    ru.setExpectedOldObjectId(headId);\n                else\n                    ru.setExpectedOldObjectId(ObjectId.zeroId());\n                Result rc \u003d ru.forceUpdate();\n                switch(rc) {\n                    case NEW:\n                    case FORCED:\n                    case FAST_FORWARD:\n                        {\n                            setCallable(false);\n                            if (state \u003d\u003d RepositoryState.MERGING_RESOLVED || isMergeDuringRebase(state)) {\n                                repo.writeMergeCommitMsg(null);\n                                repo.writeMergeHeads(null);\n                            } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                repo.writeMergeCommitMsg(null);\n                                repo.writeCherryPickHead(null);\n                            } else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n                                repo.writeMergeCommitMsg(null);\n                                repo.writeRevertHead(null);\n                            }\n                            return revCommit;\n                        }\n                    case REJECTED:\n                    case LOCK_FAILURE:\n                        throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                    default:\n                        throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw new UnmergedPathsException(e);\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    } finally {\n        rw.dispose();\n    }\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
          "functionStartLine": 161,
          "functionName": "call",
          "functionAnnotation": "",
          "functionDoc": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link RevCommit} object representing the successful commit.\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathsException\n            when the current index contained unmerged paths (conflicts)\n@throws ConcurrentRefUpdateException\n            when HEAD or branch ref is updated concurrently by someone\n            else\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n@throws AbortedByHookException\n            if there are either pre-commit or commit-msg hooks present in\n            the repository and one of them rejects the commit.\n",
          "diff": "@@ -1,110 +1,104 @@\n-public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException, RejectCommitException {\n+public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException, AbortedByHookException {\n     checkCallable();\n     Collections.sort(only);\n     RevWalk rw \u003d new RevWalk(repo);\n     try {\n         RepositoryState state \u003d repo.getRepositoryState();\n         if (!state.canCommit())\n             throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n         if (!noVerify) {\n-            final ByteArrayOutputStream errorByteArray \u003d new ByteArrayOutputStream();\n-            final PrintStream hookErrRedirect \u003d new PrintStream(errorByteArray);\n-            ProcessResult preCommitHookResult \u003d FS.DETECTED.runIfPresent(repo, Hook.PRE_COMMIT, new String[0], hookOutRedirect, hookErrRedirect, null);\n-            if (preCommitHookResult.getStatus() \u003d\u003d ProcessResult.Status.OK \u0026\u0026 preCommitHookResult.getExitCode() !\u003d 0) {\n-                String errorMessage \u003d MessageFormat.format(JGitText.get().commitRejectedByHook, Hook.PRE_COMMIT.getName(), errorByteArray.toString());\n-                throw new RejectCommitException(errorMessage);\n-            }\n+            Hooks.preCommit(repo, hookOutRedirect).call();\n         }\n         processOptions(state, rw);\n         if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n             Git git \u003d new Git(repo);\n             try {\n                 git.add().addFilepattern(\".\").setUpdate(true).call();\n             } catch (NoFilepatternException e) {\n                 throw new JGitInternalException(e.getMessage(), e);\n             }\n         }\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n         if (headId \u003d\u003d null \u0026\u0026 amend)\n             throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n         if (headId !\u003d null)\n             if (amend) {\n                 RevCommit previousCommit \u003d rw.parseCommit(headId);\n                 for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                 if (author \u003d\u003d null)\n                     author \u003d previousCommit.getAuthorIdent();\n             } else {\n                 parents.add(0, headId);\n             }\n         DirCache index \u003d repo.lockDirCache();\n         try {\n             if (!only.isEmpty())\n                 index \u003d createTemporaryIndex(headId, index, rw);\n             ObjectInserter odi \u003d repo.newObjectInserter();\n             try {\n                 ObjectId indexTreeId \u003d index.writeTree(odi);\n                 if (insertChangeId)\n                     insertChangeId(indexTreeId);\n                 CommitBuilder commit \u003d new CommitBuilder();\n                 commit.setCommitter(committer);\n                 commit.setAuthor(author);\n                 commit.setMessage(message);\n                 commit.setParentIds(parents);\n                 commit.setTreeId(indexTreeId);\n                 ObjectId commitId \u003d odi.insert(commit);\n                 odi.flush();\n                 RevCommit revCommit \u003d rw.parseCommit(commitId);\n                 RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                 ru.setNewObjectId(commitId);\n                 if (reflogComment !\u003d null) {\n                     ru.setRefLogMessage(reflogComment, false);\n                 } else {\n                     String prefix \u003d amend ? \"commit (amend): \" : parents.size() \u003d\u003d 0 ? \"commit (initial): \" : \"commit: \";\n                     ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                 }\n                 if (headId !\u003d null)\n                     ru.setExpectedOldObjectId(headId);\n                 else\n                     ru.setExpectedOldObjectId(ObjectId.zeroId());\n                 Result rc \u003d ru.forceUpdate();\n                 switch(rc) {\n                     case NEW:\n                     case FORCED:\n                     case FAST_FORWARD:\n                         {\n                             setCallable(false);\n                             if (state \u003d\u003d RepositoryState.MERGING_RESOLVED || isMergeDuringRebase(state)) {\n                                 repo.writeMergeCommitMsg(null);\n                                 repo.writeMergeHeads(null);\n                             } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                 repo.writeMergeCommitMsg(null);\n                                 repo.writeCherryPickHead(null);\n                             } else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n                                 repo.writeMergeCommitMsg(null);\n                                 repo.writeRevertHead(null);\n                             }\n                             return revCommit;\n                         }\n                     case REJECTED:\n                     case LOCK_FAILURE:\n                         throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                     default:\n                         throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                 }\n             } finally {\n                 odi.release();\n             }\n         } finally {\n             index.unlock();\n         }\n     } catch (UnmergedPathException e) {\n         throw new UnmergedPathsException(e);\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n     } finally {\n         rw.dispose();\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException, RejectCommitException]",
            "newValue": "[GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException, AbortedByHookException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Refactored pre-commit hook to make it less invasive.\n\nHooks are now obtained via a convenient API like git commands, and\ncallers don\u0027t have to check for their existence.\nThe pre-commit hook has been updated accordingly.\n\nChange-Id: I3383ffb10e2f3b588d7367b9139b606ec7f62758\nSigned-off-by: Laurent Delaigue \u003claurent.delaigue@obeo.fr\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
          "commitDate": "2015/3/2 下午10:33",
          "commitName": "26fd56f167e6377777e6d46c14779183e4bcb55a",
          "commitAuthor": "Laurent Delaigue",
          "commitDateOld": "2015/2/3 上午4:23",
          "commitNameOld": "494e893c541b5cf465b362c69354c08d7a81c249",
          "commitAuthorOld": "Laurent Goubet",
          "daysBetweenCommits": 27.76,
          "commitsBetweenForRepo": 20,
          "commitsBetweenForFile": 1,
          "actualSource": "public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException, AbortedByHookException {\n    checkCallable();\n    Collections.sort(only);\n    RevWalk rw \u003d new RevWalk(repo);\n    try {\n        RepositoryState state \u003d repo.getRepositoryState();\n        if (!state.canCommit())\n            throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n        if (!noVerify) {\n            Hooks.preCommit(repo, hookOutRedirect).call();\n        }\n        processOptions(state, rw);\n        if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n            Git git \u003d new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId \u003d\u003d null \u0026\u0026 amend)\n            throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n        if (headId !\u003d null)\n            if (amend) {\n                RevCommit previousCommit \u003d rw.parseCommit(headId);\n                for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                if (author \u003d\u003d null)\n                    author \u003d previousCommit.getAuthorIdent();\n            } else {\n                parents.add(0, headId);\n            }\n        DirCache index \u003d repo.lockDirCache();\n        try {\n            if (!only.isEmpty())\n                index \u003d createTemporaryIndex(headId, index, rw);\n            ObjectInserter odi \u003d repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId \u003d index.writeTree(odi);\n                if (insertChangeId)\n                    insertChangeId(indexTreeId);\n                CommitBuilder commit \u003d new CommitBuilder();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId \u003d odi.insert(commit);\n                odi.flush();\n                RevCommit revCommit \u003d rw.parseCommit(commitId);\n                RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                ru.setNewObjectId(commitId);\n                if (reflogComment !\u003d null) {\n                    ru.setRefLogMessage(reflogComment, false);\n                } else {\n                    String prefix \u003d amend ? \"commit (amend): \" : parents.size() \u003d\u003d 0 ? \"commit (initial): \" : \"commit: \";\n                    ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                }\n                if (headId !\u003d null)\n                    ru.setExpectedOldObjectId(headId);\n                else\n                    ru.setExpectedOldObjectId(ObjectId.zeroId());\n                Result rc \u003d ru.forceUpdate();\n                switch(rc) {\n                    case NEW:\n                    case FORCED:\n                    case FAST_FORWARD:\n                        {\n                            setCallable(false);\n                            if (state \u003d\u003d RepositoryState.MERGING_RESOLVED || isMergeDuringRebase(state)) {\n                                repo.writeMergeCommitMsg(null);\n                                repo.writeMergeHeads(null);\n                            } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                repo.writeMergeCommitMsg(null);\n                                repo.writeCherryPickHead(null);\n                            } else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n                                repo.writeMergeCommitMsg(null);\n                                repo.writeRevertHead(null);\n                            }\n                            return revCommit;\n                        }\n                    case REJECTED:\n                    case LOCK_FAILURE:\n                        throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                    default:\n                        throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw new UnmergedPathsException(e);\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    } finally {\n        rw.dispose();\n    }\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
          "functionStartLine": 161,
          "functionName": "call",
          "functionAnnotation": "",
          "functionDoc": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link RevCommit} object representing the successful commit.\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathsException\n            when the current index contained unmerged paths (conflicts)\n@throws ConcurrentRefUpdateException\n            when HEAD or branch ref is updated concurrently by someone\n            else\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n@throws AbortedByHookException\n            if there are either pre-commit or commit-msg hooks present in\n            the repository and one of them rejects the commit.\n",
          "diff": "@@ -1,110 +1,104 @@\n-public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException, RejectCommitException {\n+public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException, AbortedByHookException {\n     checkCallable();\n     Collections.sort(only);\n     RevWalk rw \u003d new RevWalk(repo);\n     try {\n         RepositoryState state \u003d repo.getRepositoryState();\n         if (!state.canCommit())\n             throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n         if (!noVerify) {\n-            final ByteArrayOutputStream errorByteArray \u003d new ByteArrayOutputStream();\n-            final PrintStream hookErrRedirect \u003d new PrintStream(errorByteArray);\n-            ProcessResult preCommitHookResult \u003d FS.DETECTED.runIfPresent(repo, Hook.PRE_COMMIT, new String[0], hookOutRedirect, hookErrRedirect, null);\n-            if (preCommitHookResult.getStatus() \u003d\u003d ProcessResult.Status.OK \u0026\u0026 preCommitHookResult.getExitCode() !\u003d 0) {\n-                String errorMessage \u003d MessageFormat.format(JGitText.get().commitRejectedByHook, Hook.PRE_COMMIT.getName(), errorByteArray.toString());\n-                throw new RejectCommitException(errorMessage);\n-            }\n+            Hooks.preCommit(repo, hookOutRedirect).call();\n         }\n         processOptions(state, rw);\n         if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n             Git git \u003d new Git(repo);\n             try {\n                 git.add().addFilepattern(\".\").setUpdate(true).call();\n             } catch (NoFilepatternException e) {\n                 throw new JGitInternalException(e.getMessage(), e);\n             }\n         }\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n         if (headId \u003d\u003d null \u0026\u0026 amend)\n             throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n         if (headId !\u003d null)\n             if (amend) {\n                 RevCommit previousCommit \u003d rw.parseCommit(headId);\n                 for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                 if (author \u003d\u003d null)\n                     author \u003d previousCommit.getAuthorIdent();\n             } else {\n                 parents.add(0, headId);\n             }\n         DirCache index \u003d repo.lockDirCache();\n         try {\n             if (!only.isEmpty())\n                 index \u003d createTemporaryIndex(headId, index, rw);\n             ObjectInserter odi \u003d repo.newObjectInserter();\n             try {\n                 ObjectId indexTreeId \u003d index.writeTree(odi);\n                 if (insertChangeId)\n                     insertChangeId(indexTreeId);\n                 CommitBuilder commit \u003d new CommitBuilder();\n                 commit.setCommitter(committer);\n                 commit.setAuthor(author);\n                 commit.setMessage(message);\n                 commit.setParentIds(parents);\n                 commit.setTreeId(indexTreeId);\n                 ObjectId commitId \u003d odi.insert(commit);\n                 odi.flush();\n                 RevCommit revCommit \u003d rw.parseCommit(commitId);\n                 RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                 ru.setNewObjectId(commitId);\n                 if (reflogComment !\u003d null) {\n                     ru.setRefLogMessage(reflogComment, false);\n                 } else {\n                     String prefix \u003d amend ? \"commit (amend): \" : parents.size() \u003d\u003d 0 ? \"commit (initial): \" : \"commit: \";\n                     ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                 }\n                 if (headId !\u003d null)\n                     ru.setExpectedOldObjectId(headId);\n                 else\n                     ru.setExpectedOldObjectId(ObjectId.zeroId());\n                 Result rc \u003d ru.forceUpdate();\n                 switch(rc) {\n                     case NEW:\n                     case FORCED:\n                     case FAST_FORWARD:\n                         {\n                             setCallable(false);\n                             if (state \u003d\u003d RepositoryState.MERGING_RESOLVED || isMergeDuringRebase(state)) {\n                                 repo.writeMergeCommitMsg(null);\n                                 repo.writeMergeHeads(null);\n                             } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                 repo.writeMergeCommitMsg(null);\n                                 repo.writeCherryPickHead(null);\n                             } else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n                                 repo.writeMergeCommitMsg(null);\n                                 repo.writeRevertHead(null);\n                             }\n                             return revCommit;\n                         }\n                     case REJECTED:\n                     case LOCK_FAILURE:\n                         throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                     default:\n                         throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                 }\n             } finally {\n                 odi.release();\n             }\n         } finally {\n             index.unlock();\n         }\n     } catch (UnmergedPathException e) {\n         throw new UnmergedPathsException(e);\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n     } finally {\n         rw.dispose();\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Refactored pre-commit hook to make it less invasive.\n\nHooks are now obtained via a convenient API like git commands, and\ncallers don\u0027t have to check for their existence.\nThe pre-commit hook has been updated accordingly.\n\nChange-Id: I3383ffb10e2f3b588d7367b9139b606ec7f62758\nSigned-off-by: Laurent Delaigue \u003claurent.delaigue@obeo.fr\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
          "commitDate": "2015/3/2 下午10:33",
          "commitName": "26fd56f167e6377777e6d46c14779183e4bcb55a",
          "commitAuthor": "Laurent Delaigue",
          "commitDateOld": "2015/2/3 上午4:23",
          "commitNameOld": "494e893c541b5cf465b362c69354c08d7a81c249",
          "commitAuthorOld": "Laurent Goubet",
          "daysBetweenCommits": 27.76,
          "commitsBetweenForRepo": 20,
          "commitsBetweenForFile": 1,
          "actualSource": "public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException, AbortedByHookException {\n    checkCallable();\n    Collections.sort(only);\n    RevWalk rw \u003d new RevWalk(repo);\n    try {\n        RepositoryState state \u003d repo.getRepositoryState();\n        if (!state.canCommit())\n            throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n        if (!noVerify) {\n            Hooks.preCommit(repo, hookOutRedirect).call();\n        }\n        processOptions(state, rw);\n        if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n            Git git \u003d new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId \u003d\u003d null \u0026\u0026 amend)\n            throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n        if (headId !\u003d null)\n            if (amend) {\n                RevCommit previousCommit \u003d rw.parseCommit(headId);\n                for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                if (author \u003d\u003d null)\n                    author \u003d previousCommit.getAuthorIdent();\n            } else {\n                parents.add(0, headId);\n            }\n        DirCache index \u003d repo.lockDirCache();\n        try {\n            if (!only.isEmpty())\n                index \u003d createTemporaryIndex(headId, index, rw);\n            ObjectInserter odi \u003d repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId \u003d index.writeTree(odi);\n                if (insertChangeId)\n                    insertChangeId(indexTreeId);\n                CommitBuilder commit \u003d new CommitBuilder();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId \u003d odi.insert(commit);\n                odi.flush();\n                RevCommit revCommit \u003d rw.parseCommit(commitId);\n                RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                ru.setNewObjectId(commitId);\n                if (reflogComment !\u003d null) {\n                    ru.setRefLogMessage(reflogComment, false);\n                } else {\n                    String prefix \u003d amend ? \"commit (amend): \" : parents.size() \u003d\u003d 0 ? \"commit (initial): \" : \"commit: \";\n                    ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                }\n                if (headId !\u003d null)\n                    ru.setExpectedOldObjectId(headId);\n                else\n                    ru.setExpectedOldObjectId(ObjectId.zeroId());\n                Result rc \u003d ru.forceUpdate();\n                switch(rc) {\n                    case NEW:\n                    case FORCED:\n                    case FAST_FORWARD:\n                        {\n                            setCallable(false);\n                            if (state \u003d\u003d RepositoryState.MERGING_RESOLVED || isMergeDuringRebase(state)) {\n                                repo.writeMergeCommitMsg(null);\n                                repo.writeMergeHeads(null);\n                            } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                repo.writeMergeCommitMsg(null);\n                                repo.writeCherryPickHead(null);\n                            } else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n                                repo.writeMergeCommitMsg(null);\n                                repo.writeRevertHead(null);\n                            }\n                            return revCommit;\n                        }\n                    case REJECTED:\n                    case LOCK_FAILURE:\n                        throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                    default:\n                        throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw new UnmergedPathsException(e);\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    } finally {\n        rw.dispose();\n    }\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
          "functionStartLine": 161,
          "functionName": "call",
          "functionAnnotation": "",
          "functionDoc": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link RevCommit} object representing the successful commit.\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathsException\n            when the current index contained unmerged paths (conflicts)\n@throws ConcurrentRefUpdateException\n            when HEAD or branch ref is updated concurrently by someone\n            else\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n@throws AbortedByHookException\n            if there are either pre-commit or commit-msg hooks present in\n            the repository and one of them rejects the commit.\n",
          "diff": "@@ -1,110 +1,104 @@\n-public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException, RejectCommitException {\n+public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException, AbortedByHookException {\n     checkCallable();\n     Collections.sort(only);\n     RevWalk rw \u003d new RevWalk(repo);\n     try {\n         RepositoryState state \u003d repo.getRepositoryState();\n         if (!state.canCommit())\n             throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n         if (!noVerify) {\n-            final ByteArrayOutputStream errorByteArray \u003d new ByteArrayOutputStream();\n-            final PrintStream hookErrRedirect \u003d new PrintStream(errorByteArray);\n-            ProcessResult preCommitHookResult \u003d FS.DETECTED.runIfPresent(repo, Hook.PRE_COMMIT, new String[0], hookOutRedirect, hookErrRedirect, null);\n-            if (preCommitHookResult.getStatus() \u003d\u003d ProcessResult.Status.OK \u0026\u0026 preCommitHookResult.getExitCode() !\u003d 0) {\n-                String errorMessage \u003d MessageFormat.format(JGitText.get().commitRejectedByHook, Hook.PRE_COMMIT.getName(), errorByteArray.toString());\n-                throw new RejectCommitException(errorMessage);\n-            }\n+            Hooks.preCommit(repo, hookOutRedirect).call();\n         }\n         processOptions(state, rw);\n         if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n             Git git \u003d new Git(repo);\n             try {\n                 git.add().addFilepattern(\".\").setUpdate(true).call();\n             } catch (NoFilepatternException e) {\n                 throw new JGitInternalException(e.getMessage(), e);\n             }\n         }\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n         if (headId \u003d\u003d null \u0026\u0026 amend)\n             throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n         if (headId !\u003d null)\n             if (amend) {\n                 RevCommit previousCommit \u003d rw.parseCommit(headId);\n                 for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                 if (author \u003d\u003d null)\n                     author \u003d previousCommit.getAuthorIdent();\n             } else {\n                 parents.add(0, headId);\n             }\n         DirCache index \u003d repo.lockDirCache();\n         try {\n             if (!only.isEmpty())\n                 index \u003d createTemporaryIndex(headId, index, rw);\n             ObjectInserter odi \u003d repo.newObjectInserter();\n             try {\n                 ObjectId indexTreeId \u003d index.writeTree(odi);\n                 if (insertChangeId)\n                     insertChangeId(indexTreeId);\n                 CommitBuilder commit \u003d new CommitBuilder();\n                 commit.setCommitter(committer);\n                 commit.setAuthor(author);\n                 commit.setMessage(message);\n                 commit.setParentIds(parents);\n                 commit.setTreeId(indexTreeId);\n                 ObjectId commitId \u003d odi.insert(commit);\n                 odi.flush();\n                 RevCommit revCommit \u003d rw.parseCommit(commitId);\n                 RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                 ru.setNewObjectId(commitId);\n                 if (reflogComment !\u003d null) {\n                     ru.setRefLogMessage(reflogComment, false);\n                 } else {\n                     String prefix \u003d amend ? \"commit (amend): \" : parents.size() \u003d\u003d 0 ? \"commit (initial): \" : \"commit: \";\n                     ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                 }\n                 if (headId !\u003d null)\n                     ru.setExpectedOldObjectId(headId);\n                 else\n                     ru.setExpectedOldObjectId(ObjectId.zeroId());\n                 Result rc \u003d ru.forceUpdate();\n                 switch(rc) {\n                     case NEW:\n                     case FORCED:\n                     case FAST_FORWARD:\n                         {\n                             setCallable(false);\n                             if (state \u003d\u003d RepositoryState.MERGING_RESOLVED || isMergeDuringRebase(state)) {\n                                 repo.writeMergeCommitMsg(null);\n                                 repo.writeMergeHeads(null);\n                             } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                 repo.writeMergeCommitMsg(null);\n                                 repo.writeCherryPickHead(null);\n                             } else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n                                 repo.writeMergeCommitMsg(null);\n                                 repo.writeRevertHead(null);\n                             }\n                             return revCommit;\n                         }\n                     case REJECTED:\n                     case LOCK_FAILURE:\n                         throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                     default:\n                         throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                 }\n             } finally {\n                 odi.release();\n             }\n         } finally {\n             index.unlock();\n         }\n     } catch (UnmergedPathException e) {\n         throw new UnmergedPathsException(e);\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n     } finally {\n         rw.dispose();\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link RevCommit} object representing the successful commit.\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathsException\n            when the current index contained unmerged paths (conflicts)\n@throws ConcurrentRefUpdateException\n            when HEAD or branch ref is updated concurrently by someone\n            else\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n@throws RejectCommitException\n            if there are either pre-commit or commit-msg hooks present in\n            the repository and at least one of them rejects the commit.\n",
            "newValue": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link RevCommit} object representing the successful commit.\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathsException\n            when the current index contained unmerged paths (conflicts)\n@throws ConcurrentRefUpdateException\n            when HEAD or branch ref is updated concurrently by someone\n            else\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n@throws AbortedByHookException\n            if there are either pre-commit or commit-msg hooks present in\n            the repository and one of them rejects the commit.\n"
          }
        }
      ]
    },
    "494e893c541b5cf465b362c69354c08d7a81c249": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange,Ydocchange)",
      "commitMessage": "Support for the pre-commit hook\n\nIntroduce support for the pre-commit hook into JGit, along with the\n--no-verify commit command option to bypass it when rebasing /\ncherry-picking.\n\nChange-Id: If86df98577fa56c5c03d783579c895a38bee9d18\nSigned-off-by: Laurent Goubet \u003claurent.goubet@obeo.fr\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2015/2/3 上午4:23",
      "commitName": "494e893c541b5cf465b362c69354c08d7a81c249",
      "commitAuthor": "Laurent Goubet",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "Support for the pre-commit hook\n\nIntroduce support for the pre-commit hook into JGit, along with the\n--no-verify commit command option to bypass it when rebasing /\ncherry-picking.\n\nChange-Id: If86df98577fa56c5c03d783579c895a38bee9d18\nSigned-off-by: Laurent Goubet \u003claurent.goubet@obeo.fr\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
          "commitDate": "2015/2/3 上午4:23",
          "commitName": "494e893c541b5cf465b362c69354c08d7a81c249",
          "commitAuthor": "Laurent Goubet",
          "commitDateOld": "2014/7/16 上午7:00",
          "commitNameOld": "e0fbae5dc3fc2345383ec373b384fcca10e64f24",
          "commitAuthorOld": "Konrad Kügler",
          "daysBetweenCommits": 201.89,
          "commitsBetweenForRepo": 227,
          "commitsBetweenForFile": 1,
          "actualSource": "public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException, RejectCommitException {\n    checkCallable();\n    Collections.sort(only);\n    RevWalk rw \u003d new RevWalk(repo);\n    try {\n        RepositoryState state \u003d repo.getRepositoryState();\n        if (!state.canCommit())\n            throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n        if (!noVerify) {\n            final ByteArrayOutputStream errorByteArray \u003d new ByteArrayOutputStream();\n            final PrintStream hookErrRedirect \u003d new PrintStream(errorByteArray);\n            ProcessResult preCommitHookResult \u003d FS.DETECTED.runIfPresent(repo, Hook.PRE_COMMIT, new String[0], hookOutRedirect, hookErrRedirect, null);\n            if (preCommitHookResult.getStatus() \u003d\u003d ProcessResult.Status.OK \u0026\u0026 preCommitHookResult.getExitCode() !\u003d 0) {\n                String errorMessage \u003d MessageFormat.format(JGitText.get().commitRejectedByHook, Hook.PRE_COMMIT.getName(), errorByteArray.toString());\n                throw new RejectCommitException(errorMessage);\n            }\n        }\n        processOptions(state, rw);\n        if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n            Git git \u003d new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId \u003d\u003d null \u0026\u0026 amend)\n            throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n        if (headId !\u003d null)\n            if (amend) {\n                RevCommit previousCommit \u003d rw.parseCommit(headId);\n                for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                if (author \u003d\u003d null)\n                    author \u003d previousCommit.getAuthorIdent();\n            } else {\n                parents.add(0, headId);\n            }\n        DirCache index \u003d repo.lockDirCache();\n        try {\n            if (!only.isEmpty())\n                index \u003d createTemporaryIndex(headId, index, rw);\n            ObjectInserter odi \u003d repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId \u003d index.writeTree(odi);\n                if (insertChangeId)\n                    insertChangeId(indexTreeId);\n                CommitBuilder commit \u003d new CommitBuilder();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId \u003d odi.insert(commit);\n                odi.flush();\n                RevCommit revCommit \u003d rw.parseCommit(commitId);\n                RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                ru.setNewObjectId(commitId);\n                if (reflogComment !\u003d null) {\n                    ru.setRefLogMessage(reflogComment, false);\n                } else {\n                    String prefix \u003d amend ? \"commit (amend): \" : parents.size() \u003d\u003d 0 ? \"commit (initial): \" : \"commit: \";\n                    ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                }\n                if (headId !\u003d null)\n                    ru.setExpectedOldObjectId(headId);\n                else\n                    ru.setExpectedOldObjectId(ObjectId.zeroId());\n                Result rc \u003d ru.forceUpdate();\n                switch(rc) {\n                    case NEW:\n                    case FORCED:\n                    case FAST_FORWARD:\n                        {\n                            setCallable(false);\n                            if (state \u003d\u003d RepositoryState.MERGING_RESOLVED || isMergeDuringRebase(state)) {\n                                repo.writeMergeCommitMsg(null);\n                                repo.writeMergeHeads(null);\n                            } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                repo.writeMergeCommitMsg(null);\n                                repo.writeCherryPickHead(null);\n                            } else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n                                repo.writeMergeCommitMsg(null);\n                                repo.writeRevertHead(null);\n                            }\n                            return revCommit;\n                        }\n                    case REJECTED:\n                    case LOCK_FAILURE:\n                        throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                    default:\n                        throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw new UnmergedPathsException(e);\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    } finally {\n        rw.dispose();\n    }\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
          "functionStartLine": 166,
          "functionName": "call",
          "functionAnnotation": "",
          "functionDoc": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link RevCommit} object representing the successful commit.\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathsException\n            when the current index contained unmerged paths (conflicts)\n@throws ConcurrentRefUpdateException\n            when HEAD or branch ref is updated concurrently by someone\n            else\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n@throws RejectCommitException\n            if there are either pre-commit or commit-msg hooks present in\n            the repository and at least one of them rejects the commit.\n",
          "diff": "@@ -1,101 +1,110 @@\n-public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException {\n+public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException, RejectCommitException {\n     checkCallable();\n     Collections.sort(only);\n     RevWalk rw \u003d new RevWalk(repo);\n     try {\n         RepositoryState state \u003d repo.getRepositoryState();\n         if (!state.canCommit())\n             throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n+        if (!noVerify) {\n+            final ByteArrayOutputStream errorByteArray \u003d new ByteArrayOutputStream();\n+            final PrintStream hookErrRedirect \u003d new PrintStream(errorByteArray);\n+            ProcessResult preCommitHookResult \u003d FS.DETECTED.runIfPresent(repo, Hook.PRE_COMMIT, new String[0], hookOutRedirect, hookErrRedirect, null);\n+            if (preCommitHookResult.getStatus() \u003d\u003d ProcessResult.Status.OK \u0026\u0026 preCommitHookResult.getExitCode() !\u003d 0) {\n+                String errorMessage \u003d MessageFormat.format(JGitText.get().commitRejectedByHook, Hook.PRE_COMMIT.getName(), errorByteArray.toString());\n+                throw new RejectCommitException(errorMessage);\n+            }\n+        }\n         processOptions(state, rw);\n         if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n             Git git \u003d new Git(repo);\n             try {\n                 git.add().addFilepattern(\".\").setUpdate(true).call();\n             } catch (NoFilepatternException e) {\n                 throw new JGitInternalException(e.getMessage(), e);\n             }\n         }\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n         if (headId \u003d\u003d null \u0026\u0026 amend)\n             throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n         if (headId !\u003d null)\n             if (amend) {\n                 RevCommit previousCommit \u003d rw.parseCommit(headId);\n                 for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                 if (author \u003d\u003d null)\n                     author \u003d previousCommit.getAuthorIdent();\n             } else {\n                 parents.add(0, headId);\n             }\n         DirCache index \u003d repo.lockDirCache();\n         try {\n             if (!only.isEmpty())\n                 index \u003d createTemporaryIndex(headId, index, rw);\n             ObjectInserter odi \u003d repo.newObjectInserter();\n             try {\n                 ObjectId indexTreeId \u003d index.writeTree(odi);\n                 if (insertChangeId)\n                     insertChangeId(indexTreeId);\n                 CommitBuilder commit \u003d new CommitBuilder();\n                 commit.setCommitter(committer);\n                 commit.setAuthor(author);\n                 commit.setMessage(message);\n                 commit.setParentIds(parents);\n                 commit.setTreeId(indexTreeId);\n                 ObjectId commitId \u003d odi.insert(commit);\n                 odi.flush();\n                 RevCommit revCommit \u003d rw.parseCommit(commitId);\n                 RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                 ru.setNewObjectId(commitId);\n                 if (reflogComment !\u003d null) {\n                     ru.setRefLogMessage(reflogComment, false);\n                 } else {\n                     String prefix \u003d amend ? \"commit (amend): \" : parents.size() \u003d\u003d 0 ? \"commit (initial): \" : \"commit: \";\n                     ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                 }\n                 if (headId !\u003d null)\n                     ru.setExpectedOldObjectId(headId);\n                 else\n                     ru.setExpectedOldObjectId(ObjectId.zeroId());\n                 Result rc \u003d ru.forceUpdate();\n                 switch(rc) {\n                     case NEW:\n                     case FORCED:\n                     case FAST_FORWARD:\n                         {\n                             setCallable(false);\n                             if (state \u003d\u003d RepositoryState.MERGING_RESOLVED || isMergeDuringRebase(state)) {\n                                 repo.writeMergeCommitMsg(null);\n                                 repo.writeMergeHeads(null);\n                             } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                 repo.writeMergeCommitMsg(null);\n                                 repo.writeCherryPickHead(null);\n                             } else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n                                 repo.writeMergeCommitMsg(null);\n                                 repo.writeRevertHead(null);\n                             }\n                             return revCommit;\n                         }\n                     case REJECTED:\n                     case LOCK_FAILURE:\n                         throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                     default:\n                         throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                 }\n             } finally {\n                 odi.release();\n             }\n         } finally {\n             index.unlock();\n         }\n     } catch (UnmergedPathException e) {\n         throw new UnmergedPathsException(e);\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n     } finally {\n         rw.dispose();\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException]",
            "newValue": "[GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException, RejectCommitException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Support for the pre-commit hook\n\nIntroduce support for the pre-commit hook into JGit, along with the\n--no-verify commit command option to bypass it when rebasing /\ncherry-picking.\n\nChange-Id: If86df98577fa56c5c03d783579c895a38bee9d18\nSigned-off-by: Laurent Goubet \u003claurent.goubet@obeo.fr\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
          "commitDate": "2015/2/3 上午4:23",
          "commitName": "494e893c541b5cf465b362c69354c08d7a81c249",
          "commitAuthor": "Laurent Goubet",
          "commitDateOld": "2014/7/16 上午7:00",
          "commitNameOld": "e0fbae5dc3fc2345383ec373b384fcca10e64f24",
          "commitAuthorOld": "Konrad Kügler",
          "daysBetweenCommits": 201.89,
          "commitsBetweenForRepo": 227,
          "commitsBetweenForFile": 1,
          "actualSource": "public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException, RejectCommitException {\n    checkCallable();\n    Collections.sort(only);\n    RevWalk rw \u003d new RevWalk(repo);\n    try {\n        RepositoryState state \u003d repo.getRepositoryState();\n        if (!state.canCommit())\n            throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n        if (!noVerify) {\n            final ByteArrayOutputStream errorByteArray \u003d new ByteArrayOutputStream();\n            final PrintStream hookErrRedirect \u003d new PrintStream(errorByteArray);\n            ProcessResult preCommitHookResult \u003d FS.DETECTED.runIfPresent(repo, Hook.PRE_COMMIT, new String[0], hookOutRedirect, hookErrRedirect, null);\n            if (preCommitHookResult.getStatus() \u003d\u003d ProcessResult.Status.OK \u0026\u0026 preCommitHookResult.getExitCode() !\u003d 0) {\n                String errorMessage \u003d MessageFormat.format(JGitText.get().commitRejectedByHook, Hook.PRE_COMMIT.getName(), errorByteArray.toString());\n                throw new RejectCommitException(errorMessage);\n            }\n        }\n        processOptions(state, rw);\n        if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n            Git git \u003d new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId \u003d\u003d null \u0026\u0026 amend)\n            throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n        if (headId !\u003d null)\n            if (amend) {\n                RevCommit previousCommit \u003d rw.parseCommit(headId);\n                for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                if (author \u003d\u003d null)\n                    author \u003d previousCommit.getAuthorIdent();\n            } else {\n                parents.add(0, headId);\n            }\n        DirCache index \u003d repo.lockDirCache();\n        try {\n            if (!only.isEmpty())\n                index \u003d createTemporaryIndex(headId, index, rw);\n            ObjectInserter odi \u003d repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId \u003d index.writeTree(odi);\n                if (insertChangeId)\n                    insertChangeId(indexTreeId);\n                CommitBuilder commit \u003d new CommitBuilder();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId \u003d odi.insert(commit);\n                odi.flush();\n                RevCommit revCommit \u003d rw.parseCommit(commitId);\n                RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                ru.setNewObjectId(commitId);\n                if (reflogComment !\u003d null) {\n                    ru.setRefLogMessage(reflogComment, false);\n                } else {\n                    String prefix \u003d amend ? \"commit (amend): \" : parents.size() \u003d\u003d 0 ? \"commit (initial): \" : \"commit: \";\n                    ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                }\n                if (headId !\u003d null)\n                    ru.setExpectedOldObjectId(headId);\n                else\n                    ru.setExpectedOldObjectId(ObjectId.zeroId());\n                Result rc \u003d ru.forceUpdate();\n                switch(rc) {\n                    case NEW:\n                    case FORCED:\n                    case FAST_FORWARD:\n                        {\n                            setCallable(false);\n                            if (state \u003d\u003d RepositoryState.MERGING_RESOLVED || isMergeDuringRebase(state)) {\n                                repo.writeMergeCommitMsg(null);\n                                repo.writeMergeHeads(null);\n                            } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                repo.writeMergeCommitMsg(null);\n                                repo.writeCherryPickHead(null);\n                            } else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n                                repo.writeMergeCommitMsg(null);\n                                repo.writeRevertHead(null);\n                            }\n                            return revCommit;\n                        }\n                    case REJECTED:\n                    case LOCK_FAILURE:\n                        throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                    default:\n                        throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw new UnmergedPathsException(e);\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    } finally {\n        rw.dispose();\n    }\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
          "functionStartLine": 166,
          "functionName": "call",
          "functionAnnotation": "",
          "functionDoc": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link RevCommit} object representing the successful commit.\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathsException\n            when the current index contained unmerged paths (conflicts)\n@throws ConcurrentRefUpdateException\n            when HEAD or branch ref is updated concurrently by someone\n            else\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n@throws RejectCommitException\n            if there are either pre-commit or commit-msg hooks present in\n            the repository and at least one of them rejects the commit.\n",
          "diff": "@@ -1,101 +1,110 @@\n-public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException {\n+public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException, RejectCommitException {\n     checkCallable();\n     Collections.sort(only);\n     RevWalk rw \u003d new RevWalk(repo);\n     try {\n         RepositoryState state \u003d repo.getRepositoryState();\n         if (!state.canCommit())\n             throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n+        if (!noVerify) {\n+            final ByteArrayOutputStream errorByteArray \u003d new ByteArrayOutputStream();\n+            final PrintStream hookErrRedirect \u003d new PrintStream(errorByteArray);\n+            ProcessResult preCommitHookResult \u003d FS.DETECTED.runIfPresent(repo, Hook.PRE_COMMIT, new String[0], hookOutRedirect, hookErrRedirect, null);\n+            if (preCommitHookResult.getStatus() \u003d\u003d ProcessResult.Status.OK \u0026\u0026 preCommitHookResult.getExitCode() !\u003d 0) {\n+                String errorMessage \u003d MessageFormat.format(JGitText.get().commitRejectedByHook, Hook.PRE_COMMIT.getName(), errorByteArray.toString());\n+                throw new RejectCommitException(errorMessage);\n+            }\n+        }\n         processOptions(state, rw);\n         if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n             Git git \u003d new Git(repo);\n             try {\n                 git.add().addFilepattern(\".\").setUpdate(true).call();\n             } catch (NoFilepatternException e) {\n                 throw new JGitInternalException(e.getMessage(), e);\n             }\n         }\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n         if (headId \u003d\u003d null \u0026\u0026 amend)\n             throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n         if (headId !\u003d null)\n             if (amend) {\n                 RevCommit previousCommit \u003d rw.parseCommit(headId);\n                 for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                 if (author \u003d\u003d null)\n                     author \u003d previousCommit.getAuthorIdent();\n             } else {\n                 parents.add(0, headId);\n             }\n         DirCache index \u003d repo.lockDirCache();\n         try {\n             if (!only.isEmpty())\n                 index \u003d createTemporaryIndex(headId, index, rw);\n             ObjectInserter odi \u003d repo.newObjectInserter();\n             try {\n                 ObjectId indexTreeId \u003d index.writeTree(odi);\n                 if (insertChangeId)\n                     insertChangeId(indexTreeId);\n                 CommitBuilder commit \u003d new CommitBuilder();\n                 commit.setCommitter(committer);\n                 commit.setAuthor(author);\n                 commit.setMessage(message);\n                 commit.setParentIds(parents);\n                 commit.setTreeId(indexTreeId);\n                 ObjectId commitId \u003d odi.insert(commit);\n                 odi.flush();\n                 RevCommit revCommit \u003d rw.parseCommit(commitId);\n                 RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                 ru.setNewObjectId(commitId);\n                 if (reflogComment !\u003d null) {\n                     ru.setRefLogMessage(reflogComment, false);\n                 } else {\n                     String prefix \u003d amend ? \"commit (amend): \" : parents.size() \u003d\u003d 0 ? \"commit (initial): \" : \"commit: \";\n                     ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                 }\n                 if (headId !\u003d null)\n                     ru.setExpectedOldObjectId(headId);\n                 else\n                     ru.setExpectedOldObjectId(ObjectId.zeroId());\n                 Result rc \u003d ru.forceUpdate();\n                 switch(rc) {\n                     case NEW:\n                     case FORCED:\n                     case FAST_FORWARD:\n                         {\n                             setCallable(false);\n                             if (state \u003d\u003d RepositoryState.MERGING_RESOLVED || isMergeDuringRebase(state)) {\n                                 repo.writeMergeCommitMsg(null);\n                                 repo.writeMergeHeads(null);\n                             } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                 repo.writeMergeCommitMsg(null);\n                                 repo.writeCherryPickHead(null);\n                             } else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n                                 repo.writeMergeCommitMsg(null);\n                                 repo.writeRevertHead(null);\n                             }\n                             return revCommit;\n                         }\n                     case REJECTED:\n                     case LOCK_FAILURE:\n                         throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                     default:\n                         throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                 }\n             } finally {\n                 odi.release();\n             }\n         } finally {\n             index.unlock();\n         }\n     } catch (UnmergedPathException e) {\n         throw new UnmergedPathsException(e);\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n     } finally {\n         rw.dispose();\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Support for the pre-commit hook\n\nIntroduce support for the pre-commit hook into JGit, along with the\n--no-verify commit command option to bypass it when rebasing /\ncherry-picking.\n\nChange-Id: If86df98577fa56c5c03d783579c895a38bee9d18\nSigned-off-by: Laurent Goubet \u003claurent.goubet@obeo.fr\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
          "commitDate": "2015/2/3 上午4:23",
          "commitName": "494e893c541b5cf465b362c69354c08d7a81c249",
          "commitAuthor": "Laurent Goubet",
          "commitDateOld": "2014/7/16 上午7:00",
          "commitNameOld": "e0fbae5dc3fc2345383ec373b384fcca10e64f24",
          "commitAuthorOld": "Konrad Kügler",
          "daysBetweenCommits": 201.89,
          "commitsBetweenForRepo": 227,
          "commitsBetweenForFile": 1,
          "actualSource": "public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException, RejectCommitException {\n    checkCallable();\n    Collections.sort(only);\n    RevWalk rw \u003d new RevWalk(repo);\n    try {\n        RepositoryState state \u003d repo.getRepositoryState();\n        if (!state.canCommit())\n            throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n        if (!noVerify) {\n            final ByteArrayOutputStream errorByteArray \u003d new ByteArrayOutputStream();\n            final PrintStream hookErrRedirect \u003d new PrintStream(errorByteArray);\n            ProcessResult preCommitHookResult \u003d FS.DETECTED.runIfPresent(repo, Hook.PRE_COMMIT, new String[0], hookOutRedirect, hookErrRedirect, null);\n            if (preCommitHookResult.getStatus() \u003d\u003d ProcessResult.Status.OK \u0026\u0026 preCommitHookResult.getExitCode() !\u003d 0) {\n                String errorMessage \u003d MessageFormat.format(JGitText.get().commitRejectedByHook, Hook.PRE_COMMIT.getName(), errorByteArray.toString());\n                throw new RejectCommitException(errorMessage);\n            }\n        }\n        processOptions(state, rw);\n        if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n            Git git \u003d new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId \u003d\u003d null \u0026\u0026 amend)\n            throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n        if (headId !\u003d null)\n            if (amend) {\n                RevCommit previousCommit \u003d rw.parseCommit(headId);\n                for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                if (author \u003d\u003d null)\n                    author \u003d previousCommit.getAuthorIdent();\n            } else {\n                parents.add(0, headId);\n            }\n        DirCache index \u003d repo.lockDirCache();\n        try {\n            if (!only.isEmpty())\n                index \u003d createTemporaryIndex(headId, index, rw);\n            ObjectInserter odi \u003d repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId \u003d index.writeTree(odi);\n                if (insertChangeId)\n                    insertChangeId(indexTreeId);\n                CommitBuilder commit \u003d new CommitBuilder();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId \u003d odi.insert(commit);\n                odi.flush();\n                RevCommit revCommit \u003d rw.parseCommit(commitId);\n                RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                ru.setNewObjectId(commitId);\n                if (reflogComment !\u003d null) {\n                    ru.setRefLogMessage(reflogComment, false);\n                } else {\n                    String prefix \u003d amend ? \"commit (amend): \" : parents.size() \u003d\u003d 0 ? \"commit (initial): \" : \"commit: \";\n                    ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                }\n                if (headId !\u003d null)\n                    ru.setExpectedOldObjectId(headId);\n                else\n                    ru.setExpectedOldObjectId(ObjectId.zeroId());\n                Result rc \u003d ru.forceUpdate();\n                switch(rc) {\n                    case NEW:\n                    case FORCED:\n                    case FAST_FORWARD:\n                        {\n                            setCallable(false);\n                            if (state \u003d\u003d RepositoryState.MERGING_RESOLVED || isMergeDuringRebase(state)) {\n                                repo.writeMergeCommitMsg(null);\n                                repo.writeMergeHeads(null);\n                            } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                repo.writeMergeCommitMsg(null);\n                                repo.writeCherryPickHead(null);\n                            } else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n                                repo.writeMergeCommitMsg(null);\n                                repo.writeRevertHead(null);\n                            }\n                            return revCommit;\n                        }\n                    case REJECTED:\n                    case LOCK_FAILURE:\n                        throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                    default:\n                        throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw new UnmergedPathsException(e);\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    } finally {\n        rw.dispose();\n    }\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
          "functionStartLine": 166,
          "functionName": "call",
          "functionAnnotation": "",
          "functionDoc": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link RevCommit} object representing the successful commit.\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathsException\n            when the current index contained unmerged paths (conflicts)\n@throws ConcurrentRefUpdateException\n            when HEAD or branch ref is updated concurrently by someone\n            else\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n@throws RejectCommitException\n            if there are either pre-commit or commit-msg hooks present in\n            the repository and at least one of them rejects the commit.\n",
          "diff": "@@ -1,101 +1,110 @@\n-public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException {\n+public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException, RejectCommitException {\n     checkCallable();\n     Collections.sort(only);\n     RevWalk rw \u003d new RevWalk(repo);\n     try {\n         RepositoryState state \u003d repo.getRepositoryState();\n         if (!state.canCommit())\n             throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n+        if (!noVerify) {\n+            final ByteArrayOutputStream errorByteArray \u003d new ByteArrayOutputStream();\n+            final PrintStream hookErrRedirect \u003d new PrintStream(errorByteArray);\n+            ProcessResult preCommitHookResult \u003d FS.DETECTED.runIfPresent(repo, Hook.PRE_COMMIT, new String[0], hookOutRedirect, hookErrRedirect, null);\n+            if (preCommitHookResult.getStatus() \u003d\u003d ProcessResult.Status.OK \u0026\u0026 preCommitHookResult.getExitCode() !\u003d 0) {\n+                String errorMessage \u003d MessageFormat.format(JGitText.get().commitRejectedByHook, Hook.PRE_COMMIT.getName(), errorByteArray.toString());\n+                throw new RejectCommitException(errorMessage);\n+            }\n+        }\n         processOptions(state, rw);\n         if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n             Git git \u003d new Git(repo);\n             try {\n                 git.add().addFilepattern(\".\").setUpdate(true).call();\n             } catch (NoFilepatternException e) {\n                 throw new JGitInternalException(e.getMessage(), e);\n             }\n         }\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n         if (headId \u003d\u003d null \u0026\u0026 amend)\n             throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n         if (headId !\u003d null)\n             if (amend) {\n                 RevCommit previousCommit \u003d rw.parseCommit(headId);\n                 for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                 if (author \u003d\u003d null)\n                     author \u003d previousCommit.getAuthorIdent();\n             } else {\n                 parents.add(0, headId);\n             }\n         DirCache index \u003d repo.lockDirCache();\n         try {\n             if (!only.isEmpty())\n                 index \u003d createTemporaryIndex(headId, index, rw);\n             ObjectInserter odi \u003d repo.newObjectInserter();\n             try {\n                 ObjectId indexTreeId \u003d index.writeTree(odi);\n                 if (insertChangeId)\n                     insertChangeId(indexTreeId);\n                 CommitBuilder commit \u003d new CommitBuilder();\n                 commit.setCommitter(committer);\n                 commit.setAuthor(author);\n                 commit.setMessage(message);\n                 commit.setParentIds(parents);\n                 commit.setTreeId(indexTreeId);\n                 ObjectId commitId \u003d odi.insert(commit);\n                 odi.flush();\n                 RevCommit revCommit \u003d rw.parseCommit(commitId);\n                 RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                 ru.setNewObjectId(commitId);\n                 if (reflogComment !\u003d null) {\n                     ru.setRefLogMessage(reflogComment, false);\n                 } else {\n                     String prefix \u003d amend ? \"commit (amend): \" : parents.size() \u003d\u003d 0 ? \"commit (initial): \" : \"commit: \";\n                     ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                 }\n                 if (headId !\u003d null)\n                     ru.setExpectedOldObjectId(headId);\n                 else\n                     ru.setExpectedOldObjectId(ObjectId.zeroId());\n                 Result rc \u003d ru.forceUpdate();\n                 switch(rc) {\n                     case NEW:\n                     case FORCED:\n                     case FAST_FORWARD:\n                         {\n                             setCallable(false);\n                             if (state \u003d\u003d RepositoryState.MERGING_RESOLVED || isMergeDuringRebase(state)) {\n                                 repo.writeMergeCommitMsg(null);\n                                 repo.writeMergeHeads(null);\n                             } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                 repo.writeMergeCommitMsg(null);\n                                 repo.writeCherryPickHead(null);\n                             } else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n                                 repo.writeMergeCommitMsg(null);\n                                 repo.writeRevertHead(null);\n                             }\n                             return revCommit;\n                         }\n                     case REJECTED:\n                     case LOCK_FAILURE:\n                         throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                     default:\n                         throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                 }\n             } finally {\n                 odi.release();\n             }\n         } finally {\n             index.unlock();\n         }\n     } catch (UnmergedPathException e) {\n         throw new UnmergedPathsException(e);\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n     } finally {\n         rw.dispose();\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link RevCommit} object representing the successful commit.\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathsException\n            when the current index contained unmerged paths (conflicts)\n@throws ConcurrentRefUpdateException\n            when HEAD or branch ref is updated concurrently by someone\n            else\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n",
            "newValue": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link RevCommit} object representing the successful commit.\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathsException\n            when the current index contained unmerged paths (conflicts)\n@throws ConcurrentRefUpdateException\n            when HEAD or branch ref is updated concurrently by someone\n            else\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n@throws RejectCommitException\n            if there are either pre-commit or commit-msg hooks present in\n            the repository and at least one of them rejects the commit.\n"
          }
        }
      ]
    },
    "e0fbae5dc3fc2345383ec373b384fcca10e64f24": {
      "type": "Ybodychange",
      "commitMessage": "Rebase: Add --preserve-merges support\n\nWith --preserve-merges C Git re-does merges using the rewritten merge\nparents, discarding the old merge commit. For the common use-case of\npull with rebase this is unfortunate, as it loses the merge conflict\nresolution (and other fixes in the merge), which may have taken quite\nsome time to get right in the first place.\n\nTo overcome this we use a two-fold approach:\nIf any of the (non-first) merge parents of a merge were rewritten, we\nalso redo the merge, to include the (potential) new changes in those\ncommits.\nIf only the first parent was rewritten, i.e. we are merging a branch\nthat is otherwise unaffected by the rebase, we instead cherry-pick the\nmerge commit at hand. This is done with the --mainline 1 and --no-commit\noptions to apply the changes introduced by the merge. Then we set up an\nappropriate MERGE_HEAD and commit the result, thus effectively forging a\nmerge.\n\nApart from the approach taken to rebase merge commits, this\nimplementation closely follows C Git. As a result, both Git\nimplementations can continue rebases of each other.\n\nPreserving merges works for both interactive and non-interactive rebase,\nbut as in C Git it is easy do get undesired outcomes with interactive\nrebase.\n\nCommitCommand supports committing merges during rebase now.\n\nBug: 439421\nChange-Id: I4cf69b9d4ec6109d130ab8e3f42fcbdac25a13b2\nSigned-off-by: Konrad Kügler \u003cswamblumat-eclipsebugs@yahoo.de\u003e\n",
      "commitDate": "2014/7/16 上午7:00",
      "commitName": "e0fbae5dc3fc2345383ec373b384fcca10e64f24",
      "commitAuthor": "Konrad Kügler",
      "commitDateOld": "2013/11/16 上午2:20",
      "commitNameOld": "97b8115be4fd5c8901ce39e53e11b3b425697574",
      "commitAuthorOld": "Robin Stocker",
      "daysBetweenCommits": 242.2,
      "commitsBetweenForRepo": 290,
      "commitsBetweenForFile": 1,
      "actualSource": "public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException {\n    checkCallable();\n    Collections.sort(only);\n    RevWalk rw \u003d new RevWalk(repo);\n    try {\n        RepositoryState state \u003d repo.getRepositoryState();\n        if (!state.canCommit())\n            throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n        processOptions(state, rw);\n        if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n            Git git \u003d new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId \u003d\u003d null \u0026\u0026 amend)\n            throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n        if (headId !\u003d null)\n            if (amend) {\n                RevCommit previousCommit \u003d rw.parseCommit(headId);\n                for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                if (author \u003d\u003d null)\n                    author \u003d previousCommit.getAuthorIdent();\n            } else {\n                parents.add(0, headId);\n            }\n        DirCache index \u003d repo.lockDirCache();\n        try {\n            if (!only.isEmpty())\n                index \u003d createTemporaryIndex(headId, index, rw);\n            ObjectInserter odi \u003d repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId \u003d index.writeTree(odi);\n                if (insertChangeId)\n                    insertChangeId(indexTreeId);\n                CommitBuilder commit \u003d new CommitBuilder();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId \u003d odi.insert(commit);\n                odi.flush();\n                RevCommit revCommit \u003d rw.parseCommit(commitId);\n                RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                ru.setNewObjectId(commitId);\n                if (reflogComment !\u003d null) {\n                    ru.setRefLogMessage(reflogComment, false);\n                } else {\n                    String prefix \u003d amend ? \"commit (amend): \" : parents.size() \u003d\u003d 0 ? \"commit (initial): \" : \"commit: \";\n                    ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                }\n                if (headId !\u003d null)\n                    ru.setExpectedOldObjectId(headId);\n                else\n                    ru.setExpectedOldObjectId(ObjectId.zeroId());\n                Result rc \u003d ru.forceUpdate();\n                switch(rc) {\n                    case NEW:\n                    case FORCED:\n                    case FAST_FORWARD:\n                        {\n                            setCallable(false);\n                            if (state \u003d\u003d RepositoryState.MERGING_RESOLVED || isMergeDuringRebase(state)) {\n                                repo.writeMergeCommitMsg(null);\n                                repo.writeMergeHeads(null);\n                            } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                repo.writeMergeCommitMsg(null);\n                                repo.writeCherryPickHead(null);\n                            } else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n                                repo.writeMergeCommitMsg(null);\n                                repo.writeRevertHead(null);\n                            }\n                            return revCommit;\n                        }\n                    case REJECTED:\n                    case LOCK_FAILURE:\n                        throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                    default:\n                        throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw new UnmergedPathsException(e);\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    } finally {\n        rw.dispose();\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 148,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link RevCommit} object representing the successful commit.\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathsException\n            when the current index contained unmerged paths (conflicts)\n@throws ConcurrentRefUpdateException\n            when HEAD or branch ref is updated concurrently by someone\n            else\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n",
      "diff": "@@ -1,101 +1,101 @@\n public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException {\n     checkCallable();\n     Collections.sort(only);\n     RevWalk rw \u003d new RevWalk(repo);\n     try {\n         RepositoryState state \u003d repo.getRepositoryState();\n         if (!state.canCommit())\n             throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n         processOptions(state, rw);\n         if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n             Git git \u003d new Git(repo);\n             try {\n                 git.add().addFilepattern(\".\").setUpdate(true).call();\n             } catch (NoFilepatternException e) {\n                 throw new JGitInternalException(e.getMessage(), e);\n             }\n         }\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n         if (headId \u003d\u003d null \u0026\u0026 amend)\n             throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n         if (headId !\u003d null)\n             if (amend) {\n                 RevCommit previousCommit \u003d rw.parseCommit(headId);\n                 for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                 if (author \u003d\u003d null)\n                     author \u003d previousCommit.getAuthorIdent();\n             } else {\n                 parents.add(0, headId);\n             }\n         DirCache index \u003d repo.lockDirCache();\n         try {\n             if (!only.isEmpty())\n                 index \u003d createTemporaryIndex(headId, index, rw);\n             ObjectInserter odi \u003d repo.newObjectInserter();\n             try {\n                 ObjectId indexTreeId \u003d index.writeTree(odi);\n                 if (insertChangeId)\n                     insertChangeId(indexTreeId);\n                 CommitBuilder commit \u003d new CommitBuilder();\n                 commit.setCommitter(committer);\n                 commit.setAuthor(author);\n                 commit.setMessage(message);\n                 commit.setParentIds(parents);\n                 commit.setTreeId(indexTreeId);\n                 ObjectId commitId \u003d odi.insert(commit);\n                 odi.flush();\n                 RevCommit revCommit \u003d rw.parseCommit(commitId);\n                 RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                 ru.setNewObjectId(commitId);\n                 if (reflogComment !\u003d null) {\n                     ru.setRefLogMessage(reflogComment, false);\n                 } else {\n                     String prefix \u003d amend ? \"commit (amend): \" : parents.size() \u003d\u003d 0 ? \"commit (initial): \" : \"commit: \";\n                     ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                 }\n                 if (headId !\u003d null)\n                     ru.setExpectedOldObjectId(headId);\n                 else\n                     ru.setExpectedOldObjectId(ObjectId.zeroId());\n                 Result rc \u003d ru.forceUpdate();\n                 switch(rc) {\n                     case NEW:\n                     case FORCED:\n                     case FAST_FORWARD:\n                         {\n                             setCallable(false);\n-                            if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n+                            if (state \u003d\u003d RepositoryState.MERGING_RESOLVED || isMergeDuringRebase(state)) {\n                                 repo.writeMergeCommitMsg(null);\n                                 repo.writeMergeHeads(null);\n                             } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                 repo.writeMergeCommitMsg(null);\n                                 repo.writeCherryPickHead(null);\n                             } else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n                                 repo.writeMergeCommitMsg(null);\n                                 repo.writeRevertHead(null);\n                             }\n                             return revCommit;\n                         }\n                     case REJECTED:\n                     case LOCK_FAILURE:\n                         throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                     default:\n                         throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                 }\n             } finally {\n                 odi.release();\n             }\n         } finally {\n             index.unlock();\n         }\n     } catch (UnmergedPathException e) {\n         throw new UnmergedPathsException(e);\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n     } finally {\n         rw.dispose();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a2b33a8ac33c63eea82f300b802a26af54a3d61d": {
      "type": "Ybodychange",
      "commitMessage": "Add NON-NLS comments for some obviously untranslatable strings\n\nChange-Id: I2d1076b46695dac84961b8ae663bfc5cb123b3a3\nSigned-off-by: Chris Aniszczyk \u003ccaniszczyk@gmail.com\u003e\n",
      "commitDate": "2013/7/22 上午11:06",
      "commitName": "a2b33a8ac33c63eea82f300b802a26af54a3d61d",
      "commitAuthor": "Robin Rosenberg",
      "commitDateOld": "2013/5/12 上午4:45",
      "commitNameOld": "c93a59330249677cd990820b59558a39f747009f",
      "commitAuthorOld": "Christian Halstrick",
      "daysBetweenCommits": 71.26,
      "commitsBetweenForRepo": 80,
      "commitsBetweenForFile": 1,
      "actualSource": "public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException {\n    checkCallable();\n    Collections.sort(only);\n    RevWalk rw \u003d new RevWalk(repo);\n    try {\n        RepositoryState state \u003d repo.getRepositoryState();\n        if (!state.canCommit())\n            throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n        processOptions(state, rw);\n        if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n            Git git \u003d new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId \u003d\u003d null \u0026\u0026 amend)\n            throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n        if (headId !\u003d null)\n            if (amend) {\n                RevCommit previousCommit \u003d rw.parseCommit(headId);\n                for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                if (author \u003d\u003d null)\n                    author \u003d previousCommit.getAuthorIdent();\n            } else {\n                parents.add(0, headId);\n            }\n        DirCache index \u003d repo.lockDirCache();\n        try {\n            if (!only.isEmpty())\n                index \u003d createTemporaryIndex(headId, index, rw);\n            ObjectInserter odi \u003d repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId \u003d index.writeTree(odi);\n                if (insertChangeId)\n                    insertChangeId(indexTreeId);\n                CommitBuilder commit \u003d new CommitBuilder();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId \u003d odi.insert(commit);\n                odi.flush();\n                RevCommit revCommit \u003d rw.parseCommit(commitId);\n                RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                ru.setNewObjectId(commitId);\n                if (reflogComment !\u003d null) {\n                    ru.setRefLogMessage(reflogComment, false);\n                } else {\n                    String prefix \u003d amend ? \"commit (amend): \" : parents.size() \u003d\u003d 0 ? \"commit (initial): \" : \"commit: \";\n                    ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                }\n                if (headId !\u003d null)\n                    ru.setExpectedOldObjectId(headId);\n                else\n                    ru.setExpectedOldObjectId(ObjectId.zeroId());\n                Result rc \u003d ru.forceUpdate();\n                switch(rc) {\n                    case NEW:\n                    case FORCED:\n                    case FAST_FORWARD:\n                        {\n                            setCallable(false);\n                            if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n                                repo.writeMergeCommitMsg(null);\n                                repo.writeMergeHeads(null);\n                            } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                repo.writeMergeCommitMsg(null);\n                                repo.writeCherryPickHead(null);\n                            } else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n                                repo.writeMergeCommitMsg(null);\n                                repo.writeRevertHead(null);\n                            }\n                            return revCommit;\n                        }\n                    case REJECTED:\n                    case LOCK_FAILURE:\n                        throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                    default:\n                        throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw new UnmergedPathsException(e);\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    } finally {\n        rw.dispose();\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 148,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link RevCommit} object representing the successful commit.\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathsException\n            when the current index contained unmerged paths (conflicts)\n@throws ConcurrentRefUpdateException\n            when HEAD or branch ref is updated concurrently by someone\n            else\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n",
      "diff": "",
      "extendedDetails": {}
    },
    "c93a59330249677cd990820b59558a39f747009f": {
      "type": "Ybodychange",
      "commitMessage": "Fix CommitCommand not to destroy repo\n\nThere was a severe bug in CommitCommand which could corrupt\nrepos. When merging an annotated tag the JGit MergeCommand writes\ncorrectly the ID of the tag (and not the id of the commit the tag was\npointing to) into MERGE_HEAD. Native git does the same. But\nCommitCommand was reading this file and trusting blindly that it will\ncontain only IDs of commits. Then the CommitCommand created a\ncommit which has as parent a non-commit object (the tag object). That\u0027s\nso corrupt that even native git gives up when you call \"git log\" in\nsuch a repo.\n\nTo reproduce that with EGit simply right-click on a tag in the\nRepository View and select Merge. The result was a corrupt repo!\n\nBug: 336291\nChange-Id: I24cd5de19ce6ca7b68b4052c9e73dcc6d207b57c\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2013/5/12 上午4:45",
      "commitName": "c93a59330249677cd990820b59558a39f747009f",
      "commitAuthor": "Christian Halstrick",
      "commitDateOld": "2013/4/3 上午3:57",
      "commitNameOld": "65027d8bb429581635f51d0c588493e5c458cc25",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 39.03,
      "commitsBetweenForRepo": 88,
      "commitsBetweenForFile": 1,
      "actualSource": "public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException {\n    checkCallable();\n    Collections.sort(only);\n    RevWalk rw \u003d new RevWalk(repo);\n    try {\n        RepositoryState state \u003d repo.getRepositoryState();\n        if (!state.canCommit())\n            throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n        processOptions(state, rw);\n        if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n            Git git \u003d new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId \u003d\u003d null \u0026\u0026 amend)\n            throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n        if (headId !\u003d null)\n            if (amend) {\n                RevCommit previousCommit \u003d rw.parseCommit(headId);\n                for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                if (author \u003d\u003d null)\n                    author \u003d previousCommit.getAuthorIdent();\n            } else {\n                parents.add(0, headId);\n            }\n        DirCache index \u003d repo.lockDirCache();\n        try {\n            if (!only.isEmpty())\n                index \u003d createTemporaryIndex(headId, index, rw);\n            ObjectInserter odi \u003d repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId \u003d index.writeTree(odi);\n                if (insertChangeId)\n                    insertChangeId(indexTreeId);\n                CommitBuilder commit \u003d new CommitBuilder();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId \u003d odi.insert(commit);\n                odi.flush();\n                RevCommit revCommit \u003d rw.parseCommit(commitId);\n                RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                ru.setNewObjectId(commitId);\n                if (reflogComment !\u003d null) {\n                    ru.setRefLogMessage(reflogComment, false);\n                } else {\n                    String prefix \u003d amend ? \"commit (amend): \" : parents.size() \u003d\u003d 0 ? \"commit (initial): \" : \"commit: \";\n                    ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                }\n                if (headId !\u003d null)\n                    ru.setExpectedOldObjectId(headId);\n                else\n                    ru.setExpectedOldObjectId(ObjectId.zeroId());\n                Result rc \u003d ru.forceUpdate();\n                switch(rc) {\n                    case NEW:\n                    case FORCED:\n                    case FAST_FORWARD:\n                        {\n                            setCallable(false);\n                            if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n                                repo.writeMergeCommitMsg(null);\n                                repo.writeMergeHeads(null);\n                            } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                repo.writeMergeCommitMsg(null);\n                                repo.writeCherryPickHead(null);\n                            } else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n                                repo.writeMergeCommitMsg(null);\n                                repo.writeRevertHead(null);\n                            }\n                            return revCommit;\n                        }\n                    case REJECTED:\n                    case LOCK_FAILURE:\n                        throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                    default:\n                        throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw new UnmergedPathsException(e);\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    } finally {\n        rw.dispose();\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 148,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link RevCommit} object representing the successful commit.\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathsException\n            when the current index contained unmerged paths (conflicts)\n@throws ConcurrentRefUpdateException\n            when HEAD or branch ref is updated concurrently by someone\n            else\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n",
      "diff": "@@ -1,103 +1,101 @@\n public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException {\n     checkCallable();\n     Collections.sort(only);\n-    RepositoryState state \u003d repo.getRepositoryState();\n-    if (!state.canCommit())\n-        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n-    processOptions(state);\n+    RevWalk rw \u003d new RevWalk(repo);\n     try {\n+        RepositoryState state \u003d repo.getRepositoryState();\n+        if (!state.canCommit())\n+            throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n+        processOptions(state, rw);\n         if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n             Git git \u003d new Git(repo);\n             try {\n                 git.add().addFilepattern(\".\").setUpdate(true).call();\n             } catch (NoFilepatternException e) {\n                 throw new JGitInternalException(e.getMessage(), e);\n             }\n         }\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n         if (headId \u003d\u003d null \u0026\u0026 amend)\n             throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n         if (headId !\u003d null)\n             if (amend) {\n-                RevCommit previousCommit \u003d new RevWalk(repo).parseCommit(headId);\n+                RevCommit previousCommit \u003d rw.parseCommit(headId);\n                 for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                 if (author \u003d\u003d null)\n                     author \u003d previousCommit.getAuthorIdent();\n             } else {\n                 parents.add(0, headId);\n             }\n         DirCache index \u003d repo.lockDirCache();\n         try {\n             if (!only.isEmpty())\n-                index \u003d createTemporaryIndex(headId, index);\n+                index \u003d createTemporaryIndex(headId, index, rw);\n             ObjectInserter odi \u003d repo.newObjectInserter();\n             try {\n                 ObjectId indexTreeId \u003d index.writeTree(odi);\n                 if (insertChangeId)\n                     insertChangeId(indexTreeId);\n                 CommitBuilder commit \u003d new CommitBuilder();\n                 commit.setCommitter(committer);\n                 commit.setAuthor(author);\n                 commit.setMessage(message);\n                 commit.setParentIds(parents);\n                 commit.setTreeId(indexTreeId);\n                 ObjectId commitId \u003d odi.insert(commit);\n                 odi.flush();\n-                RevWalk revWalk \u003d new RevWalk(repo);\n-                try {\n-                    RevCommit revCommit \u003d revWalk.parseCommit(commitId);\n-                    RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n-                    ru.setNewObjectId(commitId);\n-                    if (reflogComment !\u003d null) {\n-                        ru.setRefLogMessage(reflogComment, false);\n-                    } else {\n-                        String prefix \u003d amend ? \"commit (amend): \" : parents.size() \u003d\u003d 0 ? \"commit (initial): \" : \"commit: \";\n-                        ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n-                    }\n-                    if (headId !\u003d null)\n-                        ru.setExpectedOldObjectId(headId);\n-                    else\n-                        ru.setExpectedOldObjectId(ObjectId.zeroId());\n-                    Result rc \u003d ru.forceUpdate();\n-                    switch(rc) {\n-                        case NEW:\n-                        case FORCED:\n-                        case FAST_FORWARD:\n-                            {\n-                                setCallable(false);\n-                                if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n-                                    repo.writeMergeCommitMsg(null);\n-                                    repo.writeMergeHeads(null);\n-                                } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n-                                    repo.writeMergeCommitMsg(null);\n-                                    repo.writeCherryPickHead(null);\n-                                } else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n-                                    repo.writeMergeCommitMsg(null);\n-                                    repo.writeRevertHead(null);\n-                                }\n-                                return revCommit;\n+                RevCommit revCommit \u003d rw.parseCommit(commitId);\n+                RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n+                ru.setNewObjectId(commitId);\n+                if (reflogComment !\u003d null) {\n+                    ru.setRefLogMessage(reflogComment, false);\n+                } else {\n+                    String prefix \u003d amend ? \"commit (amend): \" : parents.size() \u003d\u003d 0 ? \"commit (initial): \" : \"commit: \";\n+                    ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n+                }\n+                if (headId !\u003d null)\n+                    ru.setExpectedOldObjectId(headId);\n+                else\n+                    ru.setExpectedOldObjectId(ObjectId.zeroId());\n+                Result rc \u003d ru.forceUpdate();\n+                switch(rc) {\n+                    case NEW:\n+                    case FORCED:\n+                    case FAST_FORWARD:\n+                        {\n+                            setCallable(false);\n+                            if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n+                                repo.writeMergeCommitMsg(null);\n+                                repo.writeMergeHeads(null);\n+                            } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n+                                repo.writeMergeCommitMsg(null);\n+                                repo.writeCherryPickHead(null);\n+                            } else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n+                                repo.writeMergeCommitMsg(null);\n+                                repo.writeRevertHead(null);\n                             }\n-                        case REJECTED:\n-                        case LOCK_FAILURE:\n-                            throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n-                        default:\n-                            throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n-                    }\n-                } finally {\n-                    revWalk.release();\n+                            return revCommit;\n+                        }\n+                    case REJECTED:\n+                    case LOCK_FAILURE:\n+                        throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n+                    default:\n+                        throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                 }\n             } finally {\n                 odi.release();\n             }\n         } finally {\n             index.unlock();\n         }\n     } catch (UnmergedPathException e) {\n         throw new UnmergedPathsException(e);\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n+    } finally {\n+        rw.dispose();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "65027d8bb429581635f51d0c588493e5c458cc25": {
      "type": "Ybodychange",
      "commitMessage": "Indicate initial commit on a branch in the reflog\n\nBug: 393463\nChange-Id: I4733d6f719bc0dc694e7a6a6ad2092de6364898c\n",
      "commitDate": "2013/4/3 上午3:57",
      "commitName": "65027d8bb429581635f51d0c588493e5c458cc25",
      "commitAuthor": "Robin Rosenberg",
      "commitDateOld": "2013/3/29 上午1:58",
      "commitNameOld": "1f51aecf95d61e48618d478a693f73dcf1ec1146",
      "commitAuthorOld": "Shawn Pearce",
      "daysBetweenCommits": 5.08,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException {\n    checkCallable();\n    Collections.sort(only);\n    RepositoryState state \u003d repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n            Git git \u003d new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId \u003d\u003d null \u0026\u0026 amend)\n            throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n        if (headId !\u003d null)\n            if (amend) {\n                RevCommit previousCommit \u003d new RevWalk(repo).parseCommit(headId);\n                for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                if (author \u003d\u003d null)\n                    author \u003d previousCommit.getAuthorIdent();\n            } else {\n                parents.add(0, headId);\n            }\n        DirCache index \u003d repo.lockDirCache();\n        try {\n            if (!only.isEmpty())\n                index \u003d createTemporaryIndex(headId, index);\n            ObjectInserter odi \u003d repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId \u003d index.writeTree(odi);\n                if (insertChangeId)\n                    insertChangeId(indexTreeId);\n                CommitBuilder commit \u003d new CommitBuilder();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId \u003d odi.insert(commit);\n                odi.flush();\n                RevWalk revWalk \u003d new RevWalk(repo);\n                try {\n                    RevCommit revCommit \u003d revWalk.parseCommit(commitId);\n                    RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                    ru.setNewObjectId(commitId);\n                    if (reflogComment !\u003d null) {\n                        ru.setRefLogMessage(reflogComment, false);\n                    } else {\n                        String prefix \u003d amend ? \"commit (amend): \" : parents.size() \u003d\u003d 0 ? \"commit (initial): \" : \"commit: \";\n                        ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                    }\n                    if (headId !\u003d null)\n                        ru.setExpectedOldObjectId(headId);\n                    else\n                        ru.setExpectedOldObjectId(ObjectId.zeroId());\n                    Result rc \u003d ru.forceUpdate();\n                    switch(rc) {\n                        case NEW:\n                        case FORCED:\n                        case FAST_FORWARD:\n                            {\n                                setCallable(false);\n                                if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeMergeHeads(null);\n                                } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeCherryPickHead(null);\n                                } else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeRevertHead(null);\n                                }\n                                return revCommit;\n                            }\n                        case REJECTED:\n                        case LOCK_FAILURE:\n                            throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                        default:\n                            throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                    }\n                } finally {\n                    revWalk.release();\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw new UnmergedPathsException(e);\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 146,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link RevCommit} object representing the successful commit.\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathsException\n            when the current index contained unmerged paths (conflicts)\n@throws ConcurrentRefUpdateException\n            when HEAD or branch ref is updated concurrently by someone\n            else\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n",
      "diff": "@@ -1,103 +1,103 @@\n public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException {\n     checkCallable();\n     Collections.sort(only);\n     RepositoryState state \u003d repo.getRepositoryState();\n     if (!state.canCommit())\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n     processOptions(state);\n     try {\n         if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n             Git git \u003d new Git(repo);\n             try {\n                 git.add().addFilepattern(\".\").setUpdate(true).call();\n             } catch (NoFilepatternException e) {\n                 throw new JGitInternalException(e.getMessage(), e);\n             }\n         }\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n         if (headId \u003d\u003d null \u0026\u0026 amend)\n             throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n         if (headId !\u003d null)\n             if (amend) {\n                 RevCommit previousCommit \u003d new RevWalk(repo).parseCommit(headId);\n                 for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                 if (author \u003d\u003d null)\n                     author \u003d previousCommit.getAuthorIdent();\n             } else {\n                 parents.add(0, headId);\n             }\n         DirCache index \u003d repo.lockDirCache();\n         try {\n             if (!only.isEmpty())\n                 index \u003d createTemporaryIndex(headId, index);\n             ObjectInserter odi \u003d repo.newObjectInserter();\n             try {\n                 ObjectId indexTreeId \u003d index.writeTree(odi);\n                 if (insertChangeId)\n                     insertChangeId(indexTreeId);\n                 CommitBuilder commit \u003d new CommitBuilder();\n                 commit.setCommitter(committer);\n                 commit.setAuthor(author);\n                 commit.setMessage(message);\n                 commit.setParentIds(parents);\n                 commit.setTreeId(indexTreeId);\n                 ObjectId commitId \u003d odi.insert(commit);\n                 odi.flush();\n                 RevWalk revWalk \u003d new RevWalk(repo);\n                 try {\n                     RevCommit revCommit \u003d revWalk.parseCommit(commitId);\n                     RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                     ru.setNewObjectId(commitId);\n                     if (reflogComment !\u003d null) {\n                         ru.setRefLogMessage(reflogComment, false);\n                     } else {\n-                        String prefix \u003d amend ? \"commit (amend): \" : \"commit: \";\n+                        String prefix \u003d amend ? \"commit (amend): \" : parents.size() \u003d\u003d 0 ? \"commit (initial): \" : \"commit: \";\n                         ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                     }\n                     if (headId !\u003d null)\n                         ru.setExpectedOldObjectId(headId);\n                     else\n                         ru.setExpectedOldObjectId(ObjectId.zeroId());\n                     Result rc \u003d ru.forceUpdate();\n                     switch(rc) {\n                         case NEW:\n                         case FORCED:\n                         case FAST_FORWARD:\n                             {\n                                 setCallable(false);\n                                 if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n                                     repo.writeMergeCommitMsg(null);\n                                     repo.writeMergeHeads(null);\n                                 } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                     repo.writeMergeCommitMsg(null);\n                                     repo.writeCherryPickHead(null);\n                                 } else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n                                     repo.writeMergeCommitMsg(null);\n                                     repo.writeRevertHead(null);\n                                 }\n                                 return revCommit;\n                             }\n                         case REJECTED:\n                         case LOCK_FAILURE:\n                             throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                         default:\n                             throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                     }\n                 } finally {\n                     revWalk.release();\n                 }\n             } finally {\n                 odi.release();\n             }\n         } finally {\n             index.unlock();\n         }\n     } catch (UnmergedPathException e) {\n         throw new UnmergedPathsException(e);\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1f51aecf95d61e48618d478a693f73dcf1ec1146": {
      "type": "Ybodychange",
      "commitMessage": "Fix CommitCommand amend mode to preserve parent order\n\nChange-Id: I476921ff8dfa6a357932d42ee59340873502b582\n",
      "commitDate": "2013/3/29 上午1:58",
      "commitName": "1f51aecf95d61e48618d478a693f73dcf1ec1146",
      "commitAuthor": "Shawn Pearce",
      "commitDateOld": "2013/1/7 上午8:08",
      "commitNameOld": "549034500a55ffc8f401fd73a74d8dc55f096d2f",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 80.74,
      "commitsBetweenForRepo": 127,
      "commitsBetweenForFile": 1,
      "actualSource": "public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException {\n    checkCallable();\n    Collections.sort(only);\n    RepositoryState state \u003d repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n            Git git \u003d new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId \u003d\u003d null \u0026\u0026 amend)\n            throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n        if (headId !\u003d null)\n            if (amend) {\n                RevCommit previousCommit \u003d new RevWalk(repo).parseCommit(headId);\n                for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                if (author \u003d\u003d null)\n                    author \u003d previousCommit.getAuthorIdent();\n            } else {\n                parents.add(0, headId);\n            }\n        DirCache index \u003d repo.lockDirCache();\n        try {\n            if (!only.isEmpty())\n                index \u003d createTemporaryIndex(headId, index);\n            ObjectInserter odi \u003d repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId \u003d index.writeTree(odi);\n                if (insertChangeId)\n                    insertChangeId(indexTreeId);\n                CommitBuilder commit \u003d new CommitBuilder();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId \u003d odi.insert(commit);\n                odi.flush();\n                RevWalk revWalk \u003d new RevWalk(repo);\n                try {\n                    RevCommit revCommit \u003d revWalk.parseCommit(commitId);\n                    RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                    ru.setNewObjectId(commitId);\n                    if (reflogComment !\u003d null) {\n                        ru.setRefLogMessage(reflogComment, false);\n                    } else {\n                        String prefix \u003d amend ? \"commit (amend): \" : \"commit: \";\n                        ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                    }\n                    if (headId !\u003d null)\n                        ru.setExpectedOldObjectId(headId);\n                    else\n                        ru.setExpectedOldObjectId(ObjectId.zeroId());\n                    Result rc \u003d ru.forceUpdate();\n                    switch(rc) {\n                        case NEW:\n                        case FORCED:\n                        case FAST_FORWARD:\n                            {\n                                setCallable(false);\n                                if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeMergeHeads(null);\n                                } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeCherryPickHead(null);\n                                } else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeRevertHead(null);\n                                }\n                                return revCommit;\n                            }\n                        case REJECTED:\n                        case LOCK_FAILURE:\n                            throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                        default:\n                            throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                    }\n                } finally {\n                    revWalk.release();\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw new UnmergedPathsException(e);\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 146,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link RevCommit} object representing the successful commit.\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathsException\n            when the current index contained unmerged paths (conflicts)\n@throws ConcurrentRefUpdateException\n            when HEAD or branch ref is updated concurrently by someone\n            else\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n",
      "diff": "@@ -1,104 +1,103 @@\n public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException {\n     checkCallable();\n     Collections.sort(only);\n     RepositoryState state \u003d repo.getRepositoryState();\n     if (!state.canCommit())\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n     processOptions(state);\n     try {\n         if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n             Git git \u003d new Git(repo);\n             try {\n                 git.add().addFilepattern(\".\").setUpdate(true).call();\n             } catch (NoFilepatternException e) {\n                 throw new JGitInternalException(e.getMessage(), e);\n             }\n         }\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n         if (headId \u003d\u003d null \u0026\u0026 amend)\n             throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n         if (headId !\u003d null)\n             if (amend) {\n                 RevCommit previousCommit \u003d new RevWalk(repo).parseCommit(headId);\n-                RevCommit[] p \u003d previousCommit.getParents();\n-                for (int i \u003d 0; i \u003c p.length; i++) parents.add(0, p[i].getId());\n+                for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                 if (author \u003d\u003d null)\n                     author \u003d previousCommit.getAuthorIdent();\n             } else {\n                 parents.add(0, headId);\n             }\n         DirCache index \u003d repo.lockDirCache();\n         try {\n             if (!only.isEmpty())\n                 index \u003d createTemporaryIndex(headId, index);\n             ObjectInserter odi \u003d repo.newObjectInserter();\n             try {\n                 ObjectId indexTreeId \u003d index.writeTree(odi);\n                 if (insertChangeId)\n                     insertChangeId(indexTreeId);\n                 CommitBuilder commit \u003d new CommitBuilder();\n                 commit.setCommitter(committer);\n                 commit.setAuthor(author);\n                 commit.setMessage(message);\n                 commit.setParentIds(parents);\n                 commit.setTreeId(indexTreeId);\n                 ObjectId commitId \u003d odi.insert(commit);\n                 odi.flush();\n                 RevWalk revWalk \u003d new RevWalk(repo);\n                 try {\n                     RevCommit revCommit \u003d revWalk.parseCommit(commitId);\n                     RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                     ru.setNewObjectId(commitId);\n                     if (reflogComment !\u003d null) {\n                         ru.setRefLogMessage(reflogComment, false);\n                     } else {\n                         String prefix \u003d amend ? \"commit (amend): \" : \"commit: \";\n                         ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                     }\n                     if (headId !\u003d null)\n                         ru.setExpectedOldObjectId(headId);\n                     else\n                         ru.setExpectedOldObjectId(ObjectId.zeroId());\n                     Result rc \u003d ru.forceUpdate();\n                     switch(rc) {\n                         case NEW:\n                         case FORCED:\n                         case FAST_FORWARD:\n                             {\n                                 setCallable(false);\n                                 if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n                                     repo.writeMergeCommitMsg(null);\n                                     repo.writeMergeHeads(null);\n                                 } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                     repo.writeMergeCommitMsg(null);\n                                     repo.writeCherryPickHead(null);\n                                 } else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n                                     repo.writeMergeCommitMsg(null);\n                                     repo.writeRevertHead(null);\n                                 }\n                                 return revCommit;\n                             }\n                         case REJECTED:\n                         case LOCK_FAILURE:\n                             throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                         default:\n                             throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                     }\n                 } finally {\n                     revWalk.release();\n                 }\n             } finally {\n                 odi.release();\n             }\n         } finally {\n             index.unlock();\n         }\n     } catch (UnmergedPathException e) {\n         throw new UnmergedPathsException(e);\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "549034500a55ffc8f401fd73a74d8dc55f096d2f": {
      "type": "Ybodychange",
      "commitMessage": "Speed up handling of \"only\" paths in the CommitCommand\n\nUse binary search to reduce the number of lookups for very large number\nof paths.\n\nChange-Id: I76a16594b756bffd95298897414485a9cd637819\n",
      "commitDate": "2013/1/7 上午8:08",
      "commitName": "549034500a55ffc8f401fd73a74d8dc55f096d2f",
      "commitAuthor": "Robin Rosenberg",
      "commitDateOld": "2012/12/29 上午6:44",
      "commitNameOld": "315f1cfa5c63f4d3355704c80d00ac1323a36171",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 9.06,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException {\n    checkCallable();\n    Collections.sort(only);\n    RepositoryState state \u003d repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n            Git git \u003d new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId \u003d\u003d null \u0026\u0026 amend)\n            throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n        if (headId !\u003d null)\n            if (amend) {\n                RevCommit previousCommit \u003d new RevWalk(repo).parseCommit(headId);\n                RevCommit[] p \u003d previousCommit.getParents();\n                for (int i \u003d 0; i \u003c p.length; i++) parents.add(0, p[i].getId());\n                if (author \u003d\u003d null)\n                    author \u003d previousCommit.getAuthorIdent();\n            } else {\n                parents.add(0, headId);\n            }\n        DirCache index \u003d repo.lockDirCache();\n        try {\n            if (!only.isEmpty())\n                index \u003d createTemporaryIndex(headId, index);\n            ObjectInserter odi \u003d repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId \u003d index.writeTree(odi);\n                if (insertChangeId)\n                    insertChangeId(indexTreeId);\n                CommitBuilder commit \u003d new CommitBuilder();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId \u003d odi.insert(commit);\n                odi.flush();\n                RevWalk revWalk \u003d new RevWalk(repo);\n                try {\n                    RevCommit revCommit \u003d revWalk.parseCommit(commitId);\n                    RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                    ru.setNewObjectId(commitId);\n                    if (reflogComment !\u003d null) {\n                        ru.setRefLogMessage(reflogComment, false);\n                    } else {\n                        String prefix \u003d amend ? \"commit (amend): \" : \"commit: \";\n                        ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                    }\n                    if (headId !\u003d null)\n                        ru.setExpectedOldObjectId(headId);\n                    else\n                        ru.setExpectedOldObjectId(ObjectId.zeroId());\n                    Result rc \u003d ru.forceUpdate();\n                    switch(rc) {\n                        case NEW:\n                        case FORCED:\n                        case FAST_FORWARD:\n                            {\n                                setCallable(false);\n                                if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeMergeHeads(null);\n                                } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeCherryPickHead(null);\n                                } else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeRevertHead(null);\n                                }\n                                return revCommit;\n                            }\n                        case REJECTED:\n                        case LOCK_FAILURE:\n                            throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                        default:\n                            throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                    }\n                } finally {\n                    revWalk.release();\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw new UnmergedPathsException(e);\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 146,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link RevCommit} object representing the successful commit.\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathsException\n            when the current index contained unmerged paths (conflicts)\n@throws ConcurrentRefUpdateException\n            when HEAD or branch ref is updated concurrently by someone\n            else\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n",
      "diff": "@@ -1,103 +1,104 @@\n public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException {\n     checkCallable();\n+    Collections.sort(only);\n     RepositoryState state \u003d repo.getRepositoryState();\n     if (!state.canCommit())\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n     processOptions(state);\n     try {\n         if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n             Git git \u003d new Git(repo);\n             try {\n                 git.add().addFilepattern(\".\").setUpdate(true).call();\n             } catch (NoFilepatternException e) {\n                 throw new JGitInternalException(e.getMessage(), e);\n             }\n         }\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n         if (headId \u003d\u003d null \u0026\u0026 amend)\n             throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n         if (headId !\u003d null)\n             if (amend) {\n                 RevCommit previousCommit \u003d new RevWalk(repo).parseCommit(headId);\n                 RevCommit[] p \u003d previousCommit.getParents();\n                 for (int i \u003d 0; i \u003c p.length; i++) parents.add(0, p[i].getId());\n                 if (author \u003d\u003d null)\n                     author \u003d previousCommit.getAuthorIdent();\n             } else {\n                 parents.add(0, headId);\n             }\n         DirCache index \u003d repo.lockDirCache();\n         try {\n             if (!only.isEmpty())\n                 index \u003d createTemporaryIndex(headId, index);\n             ObjectInserter odi \u003d repo.newObjectInserter();\n             try {\n                 ObjectId indexTreeId \u003d index.writeTree(odi);\n                 if (insertChangeId)\n                     insertChangeId(indexTreeId);\n                 CommitBuilder commit \u003d new CommitBuilder();\n                 commit.setCommitter(committer);\n                 commit.setAuthor(author);\n                 commit.setMessage(message);\n                 commit.setParentIds(parents);\n                 commit.setTreeId(indexTreeId);\n                 ObjectId commitId \u003d odi.insert(commit);\n                 odi.flush();\n                 RevWalk revWalk \u003d new RevWalk(repo);\n                 try {\n                     RevCommit revCommit \u003d revWalk.parseCommit(commitId);\n                     RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                     ru.setNewObjectId(commitId);\n                     if (reflogComment !\u003d null) {\n                         ru.setRefLogMessage(reflogComment, false);\n                     } else {\n                         String prefix \u003d amend ? \"commit (amend): \" : \"commit: \";\n                         ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                     }\n                     if (headId !\u003d null)\n                         ru.setExpectedOldObjectId(headId);\n                     else\n                         ru.setExpectedOldObjectId(ObjectId.zeroId());\n                     Result rc \u003d ru.forceUpdate();\n                     switch(rc) {\n                         case NEW:\n                         case FORCED:\n                         case FAST_FORWARD:\n                             {\n                                 setCallable(false);\n                                 if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n                                     repo.writeMergeCommitMsg(null);\n                                     repo.writeMergeHeads(null);\n                                 } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                     repo.writeMergeCommitMsg(null);\n                                     repo.writeCherryPickHead(null);\n                                 } else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n                                     repo.writeMergeCommitMsg(null);\n                                     repo.writeRevertHead(null);\n                                 }\n                                 return revCommit;\n                             }\n                         case REJECTED:\n                         case LOCK_FAILURE:\n                             throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                         default:\n                             throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                     }\n                 } finally {\n                     revWalk.release();\n                 }\n             } finally {\n                 odi.release();\n             }\n         } finally {\n             index.unlock();\n         }\n     } catch (UnmergedPathException e) {\n         throw new UnmergedPathsException(e);\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "315f1cfa5c63f4d3355704c80d00ac1323a36171": {
      "type": "Ybodychange",
      "commitMessage": "Update the revert command and things relating to revert\n\nCherry-pick has been fixed, but even though revert does\nbasically the same thing, the fixes were not carried over here.\n\n- Recognize the revert-states, analogous to the cherry picking states\n- Make reset handle a revert-in-progress\n- Update REVERT_HEAD and MERGE_MSG when revert fails due to conflicts\n- Clear revert state on commit and reset\n- Format the message similarily to how cherry-pick does. This is\n  not exactly how C Git does it.\n\nThe interface is still not the same as for cherry-picking.\n\nChange-Id: I8ea956fcbc9526d62a2365360feea23a9280eba3\nSigned-off-by: Chris Aniszczyk \u003czx@twitter.com\u003e\n",
      "commitDate": "2012/12/29 上午6:44",
      "commitName": "315f1cfa5c63f4d3355704c80d00ac1323a36171",
      "commitAuthor": "Robin Rosenberg",
      "commitDateOld": "2012/12/27 下午11:57",
      "commitNameOld": "c310fa0c802f40a774edb58641de3ac5bfad0e2c",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 1.28,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "actualSource": "public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException {\n    checkCallable();\n    RepositoryState state \u003d repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n            Git git \u003d new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId \u003d\u003d null \u0026\u0026 amend)\n            throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n        if (headId !\u003d null)\n            if (amend) {\n                RevCommit previousCommit \u003d new RevWalk(repo).parseCommit(headId);\n                RevCommit[] p \u003d previousCommit.getParents();\n                for (int i \u003d 0; i \u003c p.length; i++) parents.add(0, p[i].getId());\n                if (author \u003d\u003d null)\n                    author \u003d previousCommit.getAuthorIdent();\n            } else {\n                parents.add(0, headId);\n            }\n        DirCache index \u003d repo.lockDirCache();\n        try {\n            if (!only.isEmpty())\n                index \u003d createTemporaryIndex(headId, index);\n            ObjectInserter odi \u003d repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId \u003d index.writeTree(odi);\n                if (insertChangeId)\n                    insertChangeId(indexTreeId);\n                CommitBuilder commit \u003d new CommitBuilder();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId \u003d odi.insert(commit);\n                odi.flush();\n                RevWalk revWalk \u003d new RevWalk(repo);\n                try {\n                    RevCommit revCommit \u003d revWalk.parseCommit(commitId);\n                    RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                    ru.setNewObjectId(commitId);\n                    if (reflogComment !\u003d null) {\n                        ru.setRefLogMessage(reflogComment, false);\n                    } else {\n                        String prefix \u003d amend ? \"commit (amend): \" : \"commit: \";\n                        ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                    }\n                    if (headId !\u003d null)\n                        ru.setExpectedOldObjectId(headId);\n                    else\n                        ru.setExpectedOldObjectId(ObjectId.zeroId());\n                    Result rc \u003d ru.forceUpdate();\n                    switch(rc) {\n                        case NEW:\n                        case FORCED:\n                        case FAST_FORWARD:\n                            {\n                                setCallable(false);\n                                if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeMergeHeads(null);\n                                } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeCherryPickHead(null);\n                                } else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeRevertHead(null);\n                                }\n                                return revCommit;\n                            }\n                        case REJECTED:\n                        case LOCK_FAILURE:\n                            throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                        default:\n                            throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                    }\n                } finally {\n                    revWalk.release();\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw new UnmergedPathsException(e);\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 145,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link RevCommit} object representing the successful commit.\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathsException\n            when the current index contained unmerged paths (conflicts)\n@throws ConcurrentRefUpdateException\n            when HEAD or branch ref is updated concurrently by someone\n            else\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n",
      "diff": "@@ -1,100 +1,103 @@\n public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException {\n     checkCallable();\n     RepositoryState state \u003d repo.getRepositoryState();\n     if (!state.canCommit())\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n     processOptions(state);\n     try {\n         if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n             Git git \u003d new Git(repo);\n             try {\n                 git.add().addFilepattern(\".\").setUpdate(true).call();\n             } catch (NoFilepatternException e) {\n                 throw new JGitInternalException(e.getMessage(), e);\n             }\n         }\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n         if (headId \u003d\u003d null \u0026\u0026 amend)\n             throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n         if (headId !\u003d null)\n             if (amend) {\n                 RevCommit previousCommit \u003d new RevWalk(repo).parseCommit(headId);\n                 RevCommit[] p \u003d previousCommit.getParents();\n                 for (int i \u003d 0; i \u003c p.length; i++) parents.add(0, p[i].getId());\n                 if (author \u003d\u003d null)\n                     author \u003d previousCommit.getAuthorIdent();\n             } else {\n                 parents.add(0, headId);\n             }\n         DirCache index \u003d repo.lockDirCache();\n         try {\n             if (!only.isEmpty())\n                 index \u003d createTemporaryIndex(headId, index);\n             ObjectInserter odi \u003d repo.newObjectInserter();\n             try {\n                 ObjectId indexTreeId \u003d index.writeTree(odi);\n                 if (insertChangeId)\n                     insertChangeId(indexTreeId);\n                 CommitBuilder commit \u003d new CommitBuilder();\n                 commit.setCommitter(committer);\n                 commit.setAuthor(author);\n                 commit.setMessage(message);\n                 commit.setParentIds(parents);\n                 commit.setTreeId(indexTreeId);\n                 ObjectId commitId \u003d odi.insert(commit);\n                 odi.flush();\n                 RevWalk revWalk \u003d new RevWalk(repo);\n                 try {\n                     RevCommit revCommit \u003d revWalk.parseCommit(commitId);\n                     RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                     ru.setNewObjectId(commitId);\n                     if (reflogComment !\u003d null) {\n                         ru.setRefLogMessage(reflogComment, false);\n                     } else {\n                         String prefix \u003d amend ? \"commit (amend): \" : \"commit: \";\n                         ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                     }\n                     if (headId !\u003d null)\n                         ru.setExpectedOldObjectId(headId);\n                     else\n                         ru.setExpectedOldObjectId(ObjectId.zeroId());\n                     Result rc \u003d ru.forceUpdate();\n                     switch(rc) {\n                         case NEW:\n                         case FORCED:\n                         case FAST_FORWARD:\n                             {\n                                 setCallable(false);\n                                 if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n                                     repo.writeMergeCommitMsg(null);\n                                     repo.writeMergeHeads(null);\n                                 } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                     repo.writeMergeCommitMsg(null);\n                                     repo.writeCherryPickHead(null);\n+                                } else if (state \u003d\u003d RepositoryState.REVERTING_RESOLVED) {\n+                                    repo.writeMergeCommitMsg(null);\n+                                    repo.writeRevertHead(null);\n                                 }\n                                 return revCommit;\n                             }\n                         case REJECTED:\n                         case LOCK_FAILURE:\n                             throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                         default:\n                             throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                     }\n                 } finally {\n                     revWalk.release();\n                 }\n             } finally {\n                 odi.release();\n             }\n         } finally {\n             index.unlock();\n         }\n     } catch (UnmergedPathException e) {\n         throw new UnmergedPathsException(e);\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c310fa0c802f40a774edb58641de3ac5bfad0e2c": {
      "type": "Ybodychange",
      "commitMessage": "Mark non-externalizable strings as such\n\nA few classes such as Constanrs are marked with @SuppressWarnings, as are\ntoString() methods with many liternal, but otherwise $NLS-n$ is used for\nstring containing text that should not be translated. A few literals may\nfall into the gray zone, but mostly I\u0027ve tried to only tag the obvious\nones.\n\nChange-Id: I22e50a77e2bf9e0b842a66bdf674e8fa1692f590\n",
      "commitDate": "2012/12/27 下午11:57",
      "commitName": "c310fa0c802f40a774edb58641de3ac5bfad0e2c",
      "commitAuthor": "Robin Rosenberg",
      "commitDateOld": "2012/11/13 上午5:51",
      "commitNameOld": "0f88d7b72ff09297954930cbe2a23cf8feff9382",
      "commitAuthorOld": "Robin Stocker",
      "daysBetweenCommits": 44.75,
      "commitsBetweenForRepo": 49,
      "commitsBetweenForFile": 1,
      "actualSource": "public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException {\n    checkCallable();\n    RepositoryState state \u003d repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n            Git git \u003d new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId \u003d\u003d null \u0026\u0026 amend)\n            throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n        if (headId !\u003d null)\n            if (amend) {\n                RevCommit previousCommit \u003d new RevWalk(repo).parseCommit(headId);\n                RevCommit[] p \u003d previousCommit.getParents();\n                for (int i \u003d 0; i \u003c p.length; i++) parents.add(0, p[i].getId());\n                if (author \u003d\u003d null)\n                    author \u003d previousCommit.getAuthorIdent();\n            } else {\n                parents.add(0, headId);\n            }\n        DirCache index \u003d repo.lockDirCache();\n        try {\n            if (!only.isEmpty())\n                index \u003d createTemporaryIndex(headId, index);\n            ObjectInserter odi \u003d repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId \u003d index.writeTree(odi);\n                if (insertChangeId)\n                    insertChangeId(indexTreeId);\n                CommitBuilder commit \u003d new CommitBuilder();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId \u003d odi.insert(commit);\n                odi.flush();\n                RevWalk revWalk \u003d new RevWalk(repo);\n                try {\n                    RevCommit revCommit \u003d revWalk.parseCommit(commitId);\n                    RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                    ru.setNewObjectId(commitId);\n                    if (reflogComment !\u003d null) {\n                        ru.setRefLogMessage(reflogComment, false);\n                    } else {\n                        String prefix \u003d amend ? \"commit (amend): \" : \"commit: \";\n                        ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                    }\n                    if (headId !\u003d null)\n                        ru.setExpectedOldObjectId(headId);\n                    else\n                        ru.setExpectedOldObjectId(ObjectId.zeroId());\n                    Result rc \u003d ru.forceUpdate();\n                    switch(rc) {\n                        case NEW:\n                        case FORCED:\n                        case FAST_FORWARD:\n                            {\n                                setCallable(false);\n                                if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeMergeHeads(null);\n                                } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeCherryPickHead(null);\n                                }\n                                return revCommit;\n                            }\n                        case REJECTED:\n                        case LOCK_FAILURE:\n                            throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                        default:\n                            throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                    }\n                } finally {\n                    revWalk.release();\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw new UnmergedPathsException(e);\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 145,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link RevCommit} object representing the successful commit.\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathsException\n            when the current index contained unmerged paths (conflicts)\n@throws ConcurrentRefUpdateException\n            when HEAD or branch ref is updated concurrently by someone\n            else\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n",
      "diff": "",
      "extendedDetails": {}
    },
    "79f33419ec073edf31a1db16ae9b11e69ee997a1": {
      "type": "Ybodychange",
      "commitMessage": "CommitCommand: Use original author on amend if author is not set\n\nThis way, callers don\u0027t have to parse author ident of HEAD themselves.\n\nBug: 362391\nChange-Id: I383a817e6ed4707d637c52c007bc7b57728e6c85\n",
      "commitDate": "2012/10/8 上午6:31",
      "commitName": "79f33419ec073edf31a1db16ae9b11e69ee997a1",
      "commitAuthor": "Robin Stocker",
      "commitDateOld": "2012/10/8 上午6:31",
      "commitNameOld": "c96b40d5921d68edb96afad38b9c171388af4e05",
      "commitAuthorOld": "Robin Stocker",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException {\n    checkCallable();\n    RepositoryState state \u003d repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n            Git git \u003d new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId \u003d\u003d null \u0026\u0026 amend)\n            throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n        if (headId !\u003d null)\n            if (amend) {\n                RevCommit previousCommit \u003d new RevWalk(repo).parseCommit(headId);\n                RevCommit[] p \u003d previousCommit.getParents();\n                for (int i \u003d 0; i \u003c p.length; i++) parents.add(0, p[i].getId());\n                if (author \u003d\u003d null)\n                    author \u003d previousCommit.getAuthorIdent();\n            } else {\n                parents.add(0, headId);\n            }\n        DirCache index \u003d repo.lockDirCache();\n        try {\n            if (!only.isEmpty())\n                index \u003d createTemporaryIndex(headId, index);\n            ObjectInserter odi \u003d repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId \u003d index.writeTree(odi);\n                if (insertChangeId)\n                    insertChangeId(indexTreeId);\n                CommitBuilder commit \u003d new CommitBuilder();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId \u003d odi.insert(commit);\n                odi.flush();\n                RevWalk revWalk \u003d new RevWalk(repo);\n                try {\n                    RevCommit revCommit \u003d revWalk.parseCommit(commitId);\n                    RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                    ru.setNewObjectId(commitId);\n                    if (reflogComment !\u003d null) {\n                        ru.setRefLogMessage(reflogComment, false);\n                    } else {\n                        String prefix \u003d amend ? \"commit (amend): \" : \"commit: \";\n                        ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                    }\n                    if (headId !\u003d null)\n                        ru.setExpectedOldObjectId(headId);\n                    else\n                        ru.setExpectedOldObjectId(ObjectId.zeroId());\n                    Result rc \u003d ru.forceUpdate();\n                    switch(rc) {\n                        case NEW:\n                        case FORCED:\n                        case FAST_FORWARD:\n                            {\n                                setCallable(false);\n                                if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeMergeHeads(null);\n                                } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeCherryPickHead(null);\n                                }\n                                return revCommit;\n                            }\n                        case REJECTED:\n                        case LOCK_FAILURE:\n                            throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                        default:\n                            throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                    }\n                } finally {\n                    revWalk.release();\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw new UnmergedPathsException(e);\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 147,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link RevCommit} object representing the successful commit.\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathsException\n            when the current index contained unmerged paths (conflicts)\n@throws ConcurrentRefUpdateException\n            when HEAD or branch ref is updated concurrently by someone\n            else\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n",
      "diff": "@@ -1,98 +1,100 @@\n public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException {\n     checkCallable();\n     RepositoryState state \u003d repo.getRepositoryState();\n     if (!state.canCommit())\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n     processOptions(state);\n     try {\n         if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n             Git git \u003d new Git(repo);\n             try {\n                 git.add().addFilepattern(\".\").setUpdate(true).call();\n             } catch (NoFilepatternException e) {\n                 throw new JGitInternalException(e.getMessage(), e);\n             }\n         }\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n         if (headId \u003d\u003d null \u0026\u0026 amend)\n             throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n         if (headId !\u003d null)\n             if (amend) {\n                 RevCommit previousCommit \u003d new RevWalk(repo).parseCommit(headId);\n                 RevCommit[] p \u003d previousCommit.getParents();\n                 for (int i \u003d 0; i \u003c p.length; i++) parents.add(0, p[i].getId());\n+                if (author \u003d\u003d null)\n+                    author \u003d previousCommit.getAuthorIdent();\n             } else {\n                 parents.add(0, headId);\n             }\n         DirCache index \u003d repo.lockDirCache();\n         try {\n             if (!only.isEmpty())\n                 index \u003d createTemporaryIndex(headId, index);\n             ObjectInserter odi \u003d repo.newObjectInserter();\n             try {\n                 ObjectId indexTreeId \u003d index.writeTree(odi);\n                 if (insertChangeId)\n                     insertChangeId(indexTreeId);\n                 CommitBuilder commit \u003d new CommitBuilder();\n                 commit.setCommitter(committer);\n                 commit.setAuthor(author);\n                 commit.setMessage(message);\n                 commit.setParentIds(parents);\n                 commit.setTreeId(indexTreeId);\n                 ObjectId commitId \u003d odi.insert(commit);\n                 odi.flush();\n                 RevWalk revWalk \u003d new RevWalk(repo);\n                 try {\n                     RevCommit revCommit \u003d revWalk.parseCommit(commitId);\n                     RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                     ru.setNewObjectId(commitId);\n                     if (reflogComment !\u003d null) {\n                         ru.setRefLogMessage(reflogComment, false);\n                     } else {\n                         String prefix \u003d amend ? \"commit (amend): \" : \"commit: \";\n                         ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                     }\n                     if (headId !\u003d null)\n                         ru.setExpectedOldObjectId(headId);\n                     else\n                         ru.setExpectedOldObjectId(ObjectId.zeroId());\n                     Result rc \u003d ru.forceUpdate();\n                     switch(rc) {\n                         case NEW:\n                         case FORCED:\n                         case FAST_FORWARD:\n                             {\n                                 setCallable(false);\n                                 if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n                                     repo.writeMergeCommitMsg(null);\n                                     repo.writeMergeHeads(null);\n                                 } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                     repo.writeMergeCommitMsg(null);\n                                     repo.writeCherryPickHead(null);\n                                 }\n                                 return revCommit;\n                             }\n                         case REJECTED:\n                         case LOCK_FAILURE:\n                             throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                         default:\n                             throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                     }\n                 } finally {\n                     revWalk.release();\n                 }\n             } finally {\n                 odi.release();\n             }\n         } finally {\n             index.unlock();\n         }\n     } catch (UnmergedPathException e) {\n         throw new UnmergedPathsException(e);\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c96b40d5921d68edb96afad38b9c171388af4e05": {
      "type": "Ybodychange",
      "commitMessage": "CommitCommand: Don\u0027t allow amending on initial commit\n\nChange-Id: I27b13510eb6756da21d0d359d76031da4a875e28\n",
      "commitDate": "2012/10/8 上午6:31",
      "commitName": "c96b40d5921d68edb96afad38b9c171388af4e05",
      "commitAuthor": "Robin Stocker",
      "commitDateOld": "2012/6/15 下午2:59",
      "commitNameOld": "2656ac1b5acb9b73c6b47e2cf8830a0a0b2cc214",
      "commitAuthorOld": "Tomasz Zarna",
      "daysBetweenCommits": 114.65,
      "commitsBetweenForRepo": 116,
      "commitsBetweenForFile": 1,
      "actualSource": "public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException {\n    checkCallable();\n    RepositoryState state \u003d repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n            Git git \u003d new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId \u003d\u003d null \u0026\u0026 amend)\n            throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n        if (headId !\u003d null)\n            if (amend) {\n                RevCommit previousCommit \u003d new RevWalk(repo).parseCommit(headId);\n                RevCommit[] p \u003d previousCommit.getParents();\n                for (int i \u003d 0; i \u003c p.length; i++) parents.add(0, p[i].getId());\n            } else {\n                parents.add(0, headId);\n            }\n        DirCache index \u003d repo.lockDirCache();\n        try {\n            if (!only.isEmpty())\n                index \u003d createTemporaryIndex(headId, index);\n            ObjectInserter odi \u003d repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId \u003d index.writeTree(odi);\n                if (insertChangeId)\n                    insertChangeId(indexTreeId);\n                CommitBuilder commit \u003d new CommitBuilder();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId \u003d odi.insert(commit);\n                odi.flush();\n                RevWalk revWalk \u003d new RevWalk(repo);\n                try {\n                    RevCommit revCommit \u003d revWalk.parseCommit(commitId);\n                    RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                    ru.setNewObjectId(commitId);\n                    if (reflogComment !\u003d null) {\n                        ru.setRefLogMessage(reflogComment, false);\n                    } else {\n                        String prefix \u003d amend ? \"commit (amend): \" : \"commit: \";\n                        ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                    }\n                    if (headId !\u003d null)\n                        ru.setExpectedOldObjectId(headId);\n                    else\n                        ru.setExpectedOldObjectId(ObjectId.zeroId());\n                    Result rc \u003d ru.forceUpdate();\n                    switch(rc) {\n                        case NEW:\n                        case FORCED:\n                        case FAST_FORWARD:\n                            {\n                                setCallable(false);\n                                if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeMergeHeads(null);\n                                } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeCherryPickHead(null);\n                                }\n                                return revCommit;\n                            }\n                        case REJECTED:\n                        case LOCK_FAILURE:\n                            throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                        default:\n                            throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                    }\n                } finally {\n                    revWalk.release();\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw new UnmergedPathsException(e);\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 147,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link RevCommit} object representing the successful commit.\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathsException\n            when the current index contained unmerged paths (conflicts)\n@throws ConcurrentRefUpdateException\n            when HEAD or branch ref is updated concurrently by someone\n            else\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n",
      "diff": "@@ -1,96 +1,98 @@\n public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException {\n     checkCallable();\n     RepositoryState state \u003d repo.getRepositoryState();\n     if (!state.canCommit())\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n     processOptions(state);\n     try {\n         if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n             Git git \u003d new Git(repo);\n             try {\n                 git.add().addFilepattern(\".\").setUpdate(true).call();\n             } catch (NoFilepatternException e) {\n                 throw new JGitInternalException(e.getMessage(), e);\n             }\n         }\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n+        if (headId \u003d\u003d null \u0026\u0026 amend)\n+            throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n         if (headId !\u003d null)\n             if (amend) {\n                 RevCommit previousCommit \u003d new RevWalk(repo).parseCommit(headId);\n                 RevCommit[] p \u003d previousCommit.getParents();\n                 for (int i \u003d 0; i \u003c p.length; i++) parents.add(0, p[i].getId());\n             } else {\n                 parents.add(0, headId);\n             }\n         DirCache index \u003d repo.lockDirCache();\n         try {\n             if (!only.isEmpty())\n                 index \u003d createTemporaryIndex(headId, index);\n             ObjectInserter odi \u003d repo.newObjectInserter();\n             try {\n                 ObjectId indexTreeId \u003d index.writeTree(odi);\n                 if (insertChangeId)\n                     insertChangeId(indexTreeId);\n                 CommitBuilder commit \u003d new CommitBuilder();\n                 commit.setCommitter(committer);\n                 commit.setAuthor(author);\n                 commit.setMessage(message);\n                 commit.setParentIds(parents);\n                 commit.setTreeId(indexTreeId);\n                 ObjectId commitId \u003d odi.insert(commit);\n                 odi.flush();\n                 RevWalk revWalk \u003d new RevWalk(repo);\n                 try {\n                     RevCommit revCommit \u003d revWalk.parseCommit(commitId);\n                     RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                     ru.setNewObjectId(commitId);\n                     if (reflogComment !\u003d null) {\n                         ru.setRefLogMessage(reflogComment, false);\n                     } else {\n                         String prefix \u003d amend ? \"commit (amend): \" : \"commit: \";\n                         ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                     }\n                     if (headId !\u003d null)\n                         ru.setExpectedOldObjectId(headId);\n                     else\n                         ru.setExpectedOldObjectId(ObjectId.zeroId());\n                     Result rc \u003d ru.forceUpdate();\n                     switch(rc) {\n                         case NEW:\n                         case FORCED:\n                         case FAST_FORWARD:\n                             {\n                                 setCallable(false);\n                                 if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n                                     repo.writeMergeCommitMsg(null);\n                                     repo.writeMergeHeads(null);\n                                 } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                     repo.writeMergeCommitMsg(null);\n                                     repo.writeCherryPickHead(null);\n                                 }\n                                 return revCommit;\n                             }\n                         case REJECTED:\n                         case LOCK_FAILURE:\n                             throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                         default:\n                             throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                     }\n                 } finally {\n                     revWalk.release();\n                 }\n             } finally {\n                 odi.release();\n             }\n         } finally {\n             index.unlock();\n         }\n     } catch (UnmergedPathException e) {\n         throw new UnmergedPathsException(e);\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4e1454ded6e2fcf6cb789c004756883c3ea5f77e": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange,Ydocchange)",
      "commitMessage": "Git API does not declare GitAPIException call() and related cleanups\n\nAll commands should throw a GitAPIException so new exceptions can be\nadded without breaking the builds of old code, i.e. anyone that calls\na Git API should catch GitAPIException and not just the currently known\nexceptions.\n\nNow the only checked exceptions on Git API calls are GitException and\nsubclasses of it. New checked exceptions that are subclasses of\nGitException may be added without breaking the API.\n\nJavadoc for GitAPIException is declared on GitCommand and\ninherited to subclasses. JGitInternalException is not explicitly\ndocumented anymore.\n\nUnfortunately this change itself breaks the API. The intention is\nthat it shall be possible to add new checked subclasses of\nGitAPIException without breaking the API.\n\nBug: 366914\nEGit-Change-Id: I50380f13fc82c22d0036f47c7859cc3a77e767c5\nChange-Id: I50380f13fc82c22d0036f47c7859cc3a77e767c5\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e\n",
      "commitDate": "2012/5/31 上午4:08",
      "commitName": "4e1454ded6e2fcf6cb789c004756883c3ea5f77e",
      "commitAuthor": "Robin Rosenberg",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "Git API does not declare GitAPIException call() and related cleanups\n\nAll commands should throw a GitAPIException so new exceptions can be\nadded without breaking the builds of old code, i.e. anyone that calls\na Git API should catch GitAPIException and not just the currently known\nexceptions.\n\nNow the only checked exceptions on Git API calls are GitException and\nsubclasses of it. New checked exceptions that are subclasses of\nGitException may be added without breaking the API.\n\nJavadoc for GitAPIException is declared on GitCommand and\ninherited to subclasses. JGitInternalException is not explicitly\ndocumented anymore.\n\nUnfortunately this change itself breaks the API. The intention is\nthat it shall be possible to add new checked subclasses of\nGitAPIException without breaking the API.\n\nBug: 366914\nEGit-Change-Id: I50380f13fc82c22d0036f47c7859cc3a77e767c5\nChange-Id: I50380f13fc82c22d0036f47c7859cc3a77e767c5\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e\n",
          "commitDate": "2012/5/31 上午4:08",
          "commitName": "4e1454ded6e2fcf6cb789c004756883c3ea5f77e",
          "commitAuthor": "Robin Rosenberg",
          "commitDateOld": "2012/3/27 上午6:47",
          "commitNameOld": "3f4725c179c176560937d756682fcd6cfbf685fe",
          "commitAuthorOld": "Robin Rosenberg",
          "daysBetweenCommits": 64.89,
          "commitsBetweenForRepo": 48,
          "commitsBetweenForFile": 1,
          "actualSource": "public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException {\n    checkCallable();\n    RepositoryState state \u003d repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n            Git git \u003d new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId !\u003d null)\n            if (amend) {\n                RevCommit previousCommit \u003d new RevWalk(repo).parseCommit(headId);\n                RevCommit[] p \u003d previousCommit.getParents();\n                for (int i \u003d 0; i \u003c p.length; i++) parents.add(0, p[i].getId());\n            } else {\n                parents.add(0, headId);\n            }\n        DirCache index \u003d repo.lockDirCache();\n        try {\n            if (!only.isEmpty())\n                index \u003d createTemporaryIndex(headId, index);\n            ObjectInserter odi \u003d repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId \u003d index.writeTree(odi);\n                if (insertChangeId)\n                    insertChangeId(indexTreeId);\n                CommitBuilder commit \u003d new CommitBuilder();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId \u003d odi.insert(commit);\n                odi.flush();\n                RevWalk revWalk \u003d new RevWalk(repo);\n                try {\n                    RevCommit revCommit \u003d revWalk.parseCommit(commitId);\n                    RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                    ru.setNewObjectId(commitId);\n                    if (reflogComment !\u003d null) {\n                        ru.setRefLogMessage(reflogComment, false);\n                    } else {\n                        String prefix \u003d amend ? \"commit (amend): \" : \"commit: \";\n                        ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                    }\n                    if (headId !\u003d null)\n                        ru.setExpectedOldObjectId(headId);\n                    else\n                        ru.setExpectedOldObjectId(ObjectId.zeroId());\n                    Result rc \u003d ru.forceUpdate();\n                    switch(rc) {\n                        case NEW:\n                        case FORCED:\n                        case FAST_FORWARD:\n                            {\n                                setCallable(false);\n                                if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeMergeHeads(null);\n                                } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeCherryPickHead(null);\n                                }\n                                return revCommit;\n                            }\n                        case REJECTED:\n                        case LOCK_FAILURE:\n                            throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                        default:\n                            throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                    }\n                } finally {\n                    revWalk.release();\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw new UnmergedPathsException(e);\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
          "functionStartLine": 147,
          "functionName": "call",
          "functionAnnotation": "",
          "functionDoc": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link RevCommit} object representing the successful commit.\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathsException\n            when the current index contained unmerged paths (conflicts)\n@throws ConcurrentRefUpdateException\n            when HEAD or branch ref is updated concurrently by someone\n            else\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n",
          "diff": "@@ -1,96 +1,96 @@\n-public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n+public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException {\n     checkCallable();\n     RepositoryState state \u003d repo.getRepositoryState();\n     if (!state.canCommit())\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n     processOptions(state);\n     try {\n         if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n             Git git \u003d new Git(repo);\n             try {\n                 git.add().addFilepattern(\".\").setUpdate(true).call();\n             } catch (NoFilepatternException e) {\n                 throw new JGitInternalException(e.getMessage(), e);\n             }\n         }\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n         if (headId !\u003d null)\n             if (amend) {\n                 RevCommit previousCommit \u003d new RevWalk(repo).parseCommit(headId);\n                 RevCommit[] p \u003d previousCommit.getParents();\n                 for (int i \u003d 0; i \u003c p.length; i++) parents.add(0, p[i].getId());\n             } else {\n                 parents.add(0, headId);\n             }\n         DirCache index \u003d repo.lockDirCache();\n         try {\n             if (!only.isEmpty())\n                 index \u003d createTemporaryIndex(headId, index);\n             ObjectInserter odi \u003d repo.newObjectInserter();\n             try {\n                 ObjectId indexTreeId \u003d index.writeTree(odi);\n                 if (insertChangeId)\n                     insertChangeId(indexTreeId);\n                 CommitBuilder commit \u003d new CommitBuilder();\n                 commit.setCommitter(committer);\n                 commit.setAuthor(author);\n                 commit.setMessage(message);\n                 commit.setParentIds(parents);\n                 commit.setTreeId(indexTreeId);\n                 ObjectId commitId \u003d odi.insert(commit);\n                 odi.flush();\n                 RevWalk revWalk \u003d new RevWalk(repo);\n                 try {\n                     RevCommit revCommit \u003d revWalk.parseCommit(commitId);\n                     RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                     ru.setNewObjectId(commitId);\n                     if (reflogComment !\u003d null) {\n                         ru.setRefLogMessage(reflogComment, false);\n                     } else {\n                         String prefix \u003d amend ? \"commit (amend): \" : \"commit: \";\n                         ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                     }\n                     if (headId !\u003d null)\n                         ru.setExpectedOldObjectId(headId);\n                     else\n                         ru.setExpectedOldObjectId(ObjectId.zeroId());\n                     Result rc \u003d ru.forceUpdate();\n                     switch(rc) {\n                         case NEW:\n                         case FORCED:\n                         case FAST_FORWARD:\n                             {\n                                 setCallable(false);\n                                 if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n                                     repo.writeMergeCommitMsg(null);\n                                     repo.writeMergeHeads(null);\n                                 } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                     repo.writeMergeCommitMsg(null);\n                                     repo.writeCherryPickHead(null);\n                                 }\n                                 return revCommit;\n                             }\n                         case REJECTED:\n                         case LOCK_FAILURE:\n                             throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                         default:\n                             throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                     }\n                 } finally {\n                     revWalk.release();\n                 }\n             } finally {\n                 odi.release();\n             }\n         } finally {\n             index.unlock();\n         }\n     } catch (UnmergedPathException e) {\n-        throw e;\n+        throw new UnmergedPathsException(e);\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException]",
            "newValue": "[GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Git API does not declare GitAPIException call() and related cleanups\n\nAll commands should throw a GitAPIException so new exceptions can be\nadded without breaking the builds of old code, i.e. anyone that calls\na Git API should catch GitAPIException and not just the currently known\nexceptions.\n\nNow the only checked exceptions on Git API calls are GitException and\nsubclasses of it. New checked exceptions that are subclasses of\nGitException may be added without breaking the API.\n\nJavadoc for GitAPIException is declared on GitCommand and\ninherited to subclasses. JGitInternalException is not explicitly\ndocumented anymore.\n\nUnfortunately this change itself breaks the API. The intention is\nthat it shall be possible to add new checked subclasses of\nGitAPIException without breaking the API.\n\nBug: 366914\nEGit-Change-Id: I50380f13fc82c22d0036f47c7859cc3a77e767c5\nChange-Id: I50380f13fc82c22d0036f47c7859cc3a77e767c5\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e\n",
          "commitDate": "2012/5/31 上午4:08",
          "commitName": "4e1454ded6e2fcf6cb789c004756883c3ea5f77e",
          "commitAuthor": "Robin Rosenberg",
          "commitDateOld": "2012/3/27 上午6:47",
          "commitNameOld": "3f4725c179c176560937d756682fcd6cfbf685fe",
          "commitAuthorOld": "Robin Rosenberg",
          "daysBetweenCommits": 64.89,
          "commitsBetweenForRepo": 48,
          "commitsBetweenForFile": 1,
          "actualSource": "public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException {\n    checkCallable();\n    RepositoryState state \u003d repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n            Git git \u003d new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId !\u003d null)\n            if (amend) {\n                RevCommit previousCommit \u003d new RevWalk(repo).parseCommit(headId);\n                RevCommit[] p \u003d previousCommit.getParents();\n                for (int i \u003d 0; i \u003c p.length; i++) parents.add(0, p[i].getId());\n            } else {\n                parents.add(0, headId);\n            }\n        DirCache index \u003d repo.lockDirCache();\n        try {\n            if (!only.isEmpty())\n                index \u003d createTemporaryIndex(headId, index);\n            ObjectInserter odi \u003d repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId \u003d index.writeTree(odi);\n                if (insertChangeId)\n                    insertChangeId(indexTreeId);\n                CommitBuilder commit \u003d new CommitBuilder();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId \u003d odi.insert(commit);\n                odi.flush();\n                RevWalk revWalk \u003d new RevWalk(repo);\n                try {\n                    RevCommit revCommit \u003d revWalk.parseCommit(commitId);\n                    RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                    ru.setNewObjectId(commitId);\n                    if (reflogComment !\u003d null) {\n                        ru.setRefLogMessage(reflogComment, false);\n                    } else {\n                        String prefix \u003d amend ? \"commit (amend): \" : \"commit: \";\n                        ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                    }\n                    if (headId !\u003d null)\n                        ru.setExpectedOldObjectId(headId);\n                    else\n                        ru.setExpectedOldObjectId(ObjectId.zeroId());\n                    Result rc \u003d ru.forceUpdate();\n                    switch(rc) {\n                        case NEW:\n                        case FORCED:\n                        case FAST_FORWARD:\n                            {\n                                setCallable(false);\n                                if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeMergeHeads(null);\n                                } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeCherryPickHead(null);\n                                }\n                                return revCommit;\n                            }\n                        case REJECTED:\n                        case LOCK_FAILURE:\n                            throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                        default:\n                            throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                    }\n                } finally {\n                    revWalk.release();\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw new UnmergedPathsException(e);\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
          "functionStartLine": 147,
          "functionName": "call",
          "functionAnnotation": "",
          "functionDoc": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link RevCommit} object representing the successful commit.\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathsException\n            when the current index contained unmerged paths (conflicts)\n@throws ConcurrentRefUpdateException\n            when HEAD or branch ref is updated concurrently by someone\n            else\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n",
          "diff": "@@ -1,96 +1,96 @@\n-public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n+public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException {\n     checkCallable();\n     RepositoryState state \u003d repo.getRepositoryState();\n     if (!state.canCommit())\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n     processOptions(state);\n     try {\n         if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n             Git git \u003d new Git(repo);\n             try {\n                 git.add().addFilepattern(\".\").setUpdate(true).call();\n             } catch (NoFilepatternException e) {\n                 throw new JGitInternalException(e.getMessage(), e);\n             }\n         }\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n         if (headId !\u003d null)\n             if (amend) {\n                 RevCommit previousCommit \u003d new RevWalk(repo).parseCommit(headId);\n                 RevCommit[] p \u003d previousCommit.getParents();\n                 for (int i \u003d 0; i \u003c p.length; i++) parents.add(0, p[i].getId());\n             } else {\n                 parents.add(0, headId);\n             }\n         DirCache index \u003d repo.lockDirCache();\n         try {\n             if (!only.isEmpty())\n                 index \u003d createTemporaryIndex(headId, index);\n             ObjectInserter odi \u003d repo.newObjectInserter();\n             try {\n                 ObjectId indexTreeId \u003d index.writeTree(odi);\n                 if (insertChangeId)\n                     insertChangeId(indexTreeId);\n                 CommitBuilder commit \u003d new CommitBuilder();\n                 commit.setCommitter(committer);\n                 commit.setAuthor(author);\n                 commit.setMessage(message);\n                 commit.setParentIds(parents);\n                 commit.setTreeId(indexTreeId);\n                 ObjectId commitId \u003d odi.insert(commit);\n                 odi.flush();\n                 RevWalk revWalk \u003d new RevWalk(repo);\n                 try {\n                     RevCommit revCommit \u003d revWalk.parseCommit(commitId);\n                     RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                     ru.setNewObjectId(commitId);\n                     if (reflogComment !\u003d null) {\n                         ru.setRefLogMessage(reflogComment, false);\n                     } else {\n                         String prefix \u003d amend ? \"commit (amend): \" : \"commit: \";\n                         ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                     }\n                     if (headId !\u003d null)\n                         ru.setExpectedOldObjectId(headId);\n                     else\n                         ru.setExpectedOldObjectId(ObjectId.zeroId());\n                     Result rc \u003d ru.forceUpdate();\n                     switch(rc) {\n                         case NEW:\n                         case FORCED:\n                         case FAST_FORWARD:\n                             {\n                                 setCallable(false);\n                                 if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n                                     repo.writeMergeCommitMsg(null);\n                                     repo.writeMergeHeads(null);\n                                 } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                     repo.writeMergeCommitMsg(null);\n                                     repo.writeCherryPickHead(null);\n                                 }\n                                 return revCommit;\n                             }\n                         case REJECTED:\n                         case LOCK_FAILURE:\n                             throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                         default:\n                             throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                     }\n                 } finally {\n                     revWalk.release();\n                 }\n             } finally {\n                 odi.release();\n             }\n         } finally {\n             index.unlock();\n         }\n     } catch (UnmergedPathException e) {\n-        throw e;\n+        throw new UnmergedPathsException(e);\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Git API does not declare GitAPIException call() and related cleanups\n\nAll commands should throw a GitAPIException so new exceptions can be\nadded without breaking the builds of old code, i.e. anyone that calls\na Git API should catch GitAPIException and not just the currently known\nexceptions.\n\nNow the only checked exceptions on Git API calls are GitException and\nsubclasses of it. New checked exceptions that are subclasses of\nGitException may be added without breaking the API.\n\nJavadoc for GitAPIException is declared on GitCommand and\ninherited to subclasses. JGitInternalException is not explicitly\ndocumented anymore.\n\nUnfortunately this change itself breaks the API. The intention is\nthat it shall be possible to add new checked subclasses of\nGitAPIException without breaking the API.\n\nBug: 366914\nEGit-Change-Id: I50380f13fc82c22d0036f47c7859cc3a77e767c5\nChange-Id: I50380f13fc82c22d0036f47c7859cc3a77e767c5\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e\n",
          "commitDate": "2012/5/31 上午4:08",
          "commitName": "4e1454ded6e2fcf6cb789c004756883c3ea5f77e",
          "commitAuthor": "Robin Rosenberg",
          "commitDateOld": "2012/3/27 上午6:47",
          "commitNameOld": "3f4725c179c176560937d756682fcd6cfbf685fe",
          "commitAuthorOld": "Robin Rosenberg",
          "daysBetweenCommits": 64.89,
          "commitsBetweenForRepo": 48,
          "commitsBetweenForFile": 1,
          "actualSource": "public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException {\n    checkCallable();\n    RepositoryState state \u003d repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n            Git git \u003d new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId !\u003d null)\n            if (amend) {\n                RevCommit previousCommit \u003d new RevWalk(repo).parseCommit(headId);\n                RevCommit[] p \u003d previousCommit.getParents();\n                for (int i \u003d 0; i \u003c p.length; i++) parents.add(0, p[i].getId());\n            } else {\n                parents.add(0, headId);\n            }\n        DirCache index \u003d repo.lockDirCache();\n        try {\n            if (!only.isEmpty())\n                index \u003d createTemporaryIndex(headId, index);\n            ObjectInserter odi \u003d repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId \u003d index.writeTree(odi);\n                if (insertChangeId)\n                    insertChangeId(indexTreeId);\n                CommitBuilder commit \u003d new CommitBuilder();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId \u003d odi.insert(commit);\n                odi.flush();\n                RevWalk revWalk \u003d new RevWalk(repo);\n                try {\n                    RevCommit revCommit \u003d revWalk.parseCommit(commitId);\n                    RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                    ru.setNewObjectId(commitId);\n                    if (reflogComment !\u003d null) {\n                        ru.setRefLogMessage(reflogComment, false);\n                    } else {\n                        String prefix \u003d amend ? \"commit (amend): \" : \"commit: \";\n                        ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                    }\n                    if (headId !\u003d null)\n                        ru.setExpectedOldObjectId(headId);\n                    else\n                        ru.setExpectedOldObjectId(ObjectId.zeroId());\n                    Result rc \u003d ru.forceUpdate();\n                    switch(rc) {\n                        case NEW:\n                        case FORCED:\n                        case FAST_FORWARD:\n                            {\n                                setCallable(false);\n                                if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeMergeHeads(null);\n                                } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeCherryPickHead(null);\n                                }\n                                return revCommit;\n                            }\n                        case REJECTED:\n                        case LOCK_FAILURE:\n                            throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                        default:\n                            throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                    }\n                } finally {\n                    revWalk.release();\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw new UnmergedPathsException(e);\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
          "functionStartLine": 147,
          "functionName": "call",
          "functionAnnotation": "",
          "functionDoc": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link RevCommit} object representing the successful commit.\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathsException\n            when the current index contained unmerged paths (conflicts)\n@throws ConcurrentRefUpdateException\n            when HEAD or branch ref is updated concurrently by someone\n            else\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n",
          "diff": "@@ -1,96 +1,96 @@\n-public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n+public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException {\n     checkCallable();\n     RepositoryState state \u003d repo.getRepositoryState();\n     if (!state.canCommit())\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n     processOptions(state);\n     try {\n         if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n             Git git \u003d new Git(repo);\n             try {\n                 git.add().addFilepattern(\".\").setUpdate(true).call();\n             } catch (NoFilepatternException e) {\n                 throw new JGitInternalException(e.getMessage(), e);\n             }\n         }\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n         if (headId !\u003d null)\n             if (amend) {\n                 RevCommit previousCommit \u003d new RevWalk(repo).parseCommit(headId);\n                 RevCommit[] p \u003d previousCommit.getParents();\n                 for (int i \u003d 0; i \u003c p.length; i++) parents.add(0, p[i].getId());\n             } else {\n                 parents.add(0, headId);\n             }\n         DirCache index \u003d repo.lockDirCache();\n         try {\n             if (!only.isEmpty())\n                 index \u003d createTemporaryIndex(headId, index);\n             ObjectInserter odi \u003d repo.newObjectInserter();\n             try {\n                 ObjectId indexTreeId \u003d index.writeTree(odi);\n                 if (insertChangeId)\n                     insertChangeId(indexTreeId);\n                 CommitBuilder commit \u003d new CommitBuilder();\n                 commit.setCommitter(committer);\n                 commit.setAuthor(author);\n                 commit.setMessage(message);\n                 commit.setParentIds(parents);\n                 commit.setTreeId(indexTreeId);\n                 ObjectId commitId \u003d odi.insert(commit);\n                 odi.flush();\n                 RevWalk revWalk \u003d new RevWalk(repo);\n                 try {\n                     RevCommit revCommit \u003d revWalk.parseCommit(commitId);\n                     RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                     ru.setNewObjectId(commitId);\n                     if (reflogComment !\u003d null) {\n                         ru.setRefLogMessage(reflogComment, false);\n                     } else {\n                         String prefix \u003d amend ? \"commit (amend): \" : \"commit: \";\n                         ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                     }\n                     if (headId !\u003d null)\n                         ru.setExpectedOldObjectId(headId);\n                     else\n                         ru.setExpectedOldObjectId(ObjectId.zeroId());\n                     Result rc \u003d ru.forceUpdate();\n                     switch(rc) {\n                         case NEW:\n                         case FORCED:\n                         case FAST_FORWARD:\n                             {\n                                 setCallable(false);\n                                 if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n                                     repo.writeMergeCommitMsg(null);\n                                     repo.writeMergeHeads(null);\n                                 } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                     repo.writeMergeCommitMsg(null);\n                                     repo.writeCherryPickHead(null);\n                                 }\n                                 return revCommit;\n                             }\n                         case REJECTED:\n                         case LOCK_FAILURE:\n                             throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                         default:\n                             throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                     }\n                 } finally {\n                     revWalk.release();\n                 }\n             } finally {\n                 odi.release();\n             }\n         } finally {\n             index.unlock();\n         }\n     } catch (UnmergedPathException e) {\n-        throw e;\n+        throw new UnmergedPathsException(e);\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link RevCommit} object representing the successful commit.\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathException\n            when the current index contained unmerged paths (conflicts)\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n@throws JGitInternalException\n            a low-level exception of JGit has occurred. The original\n            exception can be retrieved by calling\n            {@link Exception#getCause()}. Expect only\n            {@code IOException\u0027s} to be wrapped. Subclasses of\n            {@link IOException} (e.g. {@link UnmergedPathException}) are\n            typically not wrapped here but thrown as original exception\n",
            "newValue": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link RevCommit} object representing the successful commit.\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathsException\n            when the current index contained unmerged paths (conflicts)\n@throws ConcurrentRefUpdateException\n            when HEAD or branch ref is updated concurrently by someone\n            else\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n"
          }
        }
      ]
    },
    "2539b1ee096266b7fcca64545f93d7c08ab30f53": {
      "type": "Ybodychange",
      "commitMessage": "Set expected old object id to all zeros when head id is null\n\nThis will be the case on the initial commit to a repository\nand the ref update should expect a non-existent ref\n\nChange-Id: Iaa06e47e6e8cc4a0281c7683b367d4806dd980ea\n",
      "commitDate": "2011/12/7 上午10:02",
      "commitName": "2539b1ee096266b7fcca64545f93d7c08ab30f53",
      "commitAuthor": "Kevin Sawicki",
      "commitDateOld": "2011/9/22 上午5:36",
      "commitNameOld": "4f4e468f6f344ed7c106b86b850d2c9171dd1a0f",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 76.18,
      "commitsBetweenForRepo": 86,
      "commitsBetweenForFile": 1,
      "actualSource": "public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n    checkCallable();\n    RepositoryState state \u003d repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n            Git git \u003d new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId !\u003d null)\n            if (amend) {\n                RevCommit previousCommit \u003d new RevWalk(repo).parseCommit(headId);\n                RevCommit[] p \u003d previousCommit.getParents();\n                for (int i \u003d 0; i \u003c p.length; i++) parents.add(0, p[i].getId());\n            } else {\n                parents.add(0, headId);\n            }\n        DirCache index \u003d repo.lockDirCache();\n        try {\n            if (!only.isEmpty())\n                index \u003d createTemporaryIndex(headId, index);\n            ObjectInserter odi \u003d repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId \u003d index.writeTree(odi);\n                if (insertChangeId)\n                    insertChangeId(indexTreeId);\n                CommitBuilder commit \u003d new CommitBuilder();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId \u003d odi.insert(commit);\n                odi.flush();\n                RevWalk revWalk \u003d new RevWalk(repo);\n                try {\n                    RevCommit revCommit \u003d revWalk.parseCommit(commitId);\n                    RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                    ru.setNewObjectId(commitId);\n                    if (reflogComment !\u003d null) {\n                        ru.setRefLogMessage(reflogComment, false);\n                    } else {\n                        String prefix \u003d amend ? \"commit (amend): \" : \"commit: \";\n                        ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                    }\n                    if (headId !\u003d null)\n                        ru.setExpectedOldObjectId(headId);\n                    else\n                        ru.setExpectedOldObjectId(ObjectId.zeroId());\n                    Result rc \u003d ru.forceUpdate();\n                    switch(rc) {\n                        case NEW:\n                        case FORCED:\n                        case FAST_FORWARD:\n                            {\n                                setCallable(false);\n                                if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeMergeHeads(null);\n                                } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeCherryPickHead(null);\n                                }\n                                return revCommit;\n                            }\n                        case REJECTED:\n                        case LOCK_FAILURE:\n                            throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                        default:\n                            throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                    }\n                } finally {\n                    revWalk.release();\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw e;\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 149,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link RevCommit} object representing the successful commit.\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathException\n            when the current index contained unmerged paths (conflicts)\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n@throws JGitInternalException\n            a low-level exception of JGit has occurred. The original\n            exception can be retrieved by calling\n            {@link Exception#getCause()}. Expect only\n            {@code IOException\u0027s} to be wrapped. Subclasses of\n            {@link IOException} (e.g. {@link UnmergedPathException}) are\n            typically not wrapped here but thrown as original exception\n",
      "diff": "@@ -1,93 +1,96 @@\n public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n     checkCallable();\n     RepositoryState state \u003d repo.getRepositoryState();\n     if (!state.canCommit())\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n     processOptions(state);\n     try {\n         if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n             Git git \u003d new Git(repo);\n             try {\n                 git.add().addFilepattern(\".\").setUpdate(true).call();\n             } catch (NoFilepatternException e) {\n                 throw new JGitInternalException(e.getMessage(), e);\n             }\n         }\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n         if (headId !\u003d null)\n             if (amend) {\n                 RevCommit previousCommit \u003d new RevWalk(repo).parseCommit(headId);\n                 RevCommit[] p \u003d previousCommit.getParents();\n                 for (int i \u003d 0; i \u003c p.length; i++) parents.add(0, p[i].getId());\n             } else {\n                 parents.add(0, headId);\n             }\n         DirCache index \u003d repo.lockDirCache();\n         try {\n             if (!only.isEmpty())\n                 index \u003d createTemporaryIndex(headId, index);\n             ObjectInserter odi \u003d repo.newObjectInserter();\n             try {\n                 ObjectId indexTreeId \u003d index.writeTree(odi);\n                 if (insertChangeId)\n                     insertChangeId(indexTreeId);\n                 CommitBuilder commit \u003d new CommitBuilder();\n                 commit.setCommitter(committer);\n                 commit.setAuthor(author);\n                 commit.setMessage(message);\n                 commit.setParentIds(parents);\n                 commit.setTreeId(indexTreeId);\n                 ObjectId commitId \u003d odi.insert(commit);\n                 odi.flush();\n                 RevWalk revWalk \u003d new RevWalk(repo);\n                 try {\n                     RevCommit revCommit \u003d revWalk.parseCommit(commitId);\n                     RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                     ru.setNewObjectId(commitId);\n                     if (reflogComment !\u003d null) {\n                         ru.setRefLogMessage(reflogComment, false);\n                     } else {\n                         String prefix \u003d amend ? \"commit (amend): \" : \"commit: \";\n                         ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                     }\n-                    ru.setExpectedOldObjectId(headId);\n+                    if (headId !\u003d null)\n+                        ru.setExpectedOldObjectId(headId);\n+                    else\n+                        ru.setExpectedOldObjectId(ObjectId.zeroId());\n                     Result rc \u003d ru.forceUpdate();\n                     switch(rc) {\n                         case NEW:\n                         case FORCED:\n                         case FAST_FORWARD:\n                             {\n                                 setCallable(false);\n                                 if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n                                     repo.writeMergeCommitMsg(null);\n                                     repo.writeMergeHeads(null);\n                                 } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                     repo.writeMergeCommitMsg(null);\n                                     repo.writeCherryPickHead(null);\n                                 }\n                                 return revCommit;\n                             }\n                         case REJECTED:\n                         case LOCK_FAILURE:\n                             throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                         default:\n                             throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                     }\n                 } finally {\n                     revWalk.release();\n                 }\n             } finally {\n                 odi.release();\n             }\n         } finally {\n             index.unlock();\n         }\n     } catch (UnmergedPathException e) {\n         throw e;\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4f4e468f6f344ed7c106b86b850d2c9171dd1a0f": {
      "type": "Ybodychange",
      "commitMessage": "Fix the reflog prefix for cherry-pick, revert and merge commands\n\nWe should see whether the commit was a regular commit or something\nelse.\n\nChange-Id: I82d8300cf3c53cb2bdcb6495386aadb803e0c6f7\nSigned-off-by: Robin Rosenberg \u003crobin.rosenberg@dewire.com\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e\n",
      "commitDate": "2011/9/22 上午5:36",
      "commitName": "4f4e468f6f344ed7c106b86b850d2c9171dd1a0f",
      "commitAuthor": "Robin Rosenberg",
      "commitDateOld": "2011/9/8 下午10:46",
      "commitNameOld": "a7d3c680151aa27608c6381db0983b51828c2358",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 13.28,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n    checkCallable();\n    RepositoryState state \u003d repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n            Git git \u003d new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId !\u003d null)\n            if (amend) {\n                RevCommit previousCommit \u003d new RevWalk(repo).parseCommit(headId);\n                RevCommit[] p \u003d previousCommit.getParents();\n                for (int i \u003d 0; i \u003c p.length; i++) parents.add(0, p[i].getId());\n            } else {\n                parents.add(0, headId);\n            }\n        DirCache index \u003d repo.lockDirCache();\n        try {\n            if (!only.isEmpty())\n                index \u003d createTemporaryIndex(headId, index);\n            ObjectInserter odi \u003d repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId \u003d index.writeTree(odi);\n                if (insertChangeId)\n                    insertChangeId(indexTreeId);\n                CommitBuilder commit \u003d new CommitBuilder();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId \u003d odi.insert(commit);\n                odi.flush();\n                RevWalk revWalk \u003d new RevWalk(repo);\n                try {\n                    RevCommit revCommit \u003d revWalk.parseCommit(commitId);\n                    RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                    ru.setNewObjectId(commitId);\n                    if (reflogComment !\u003d null) {\n                        ru.setRefLogMessage(reflogComment, false);\n                    } else {\n                        String prefix \u003d amend ? \"commit (amend): \" : \"commit: \";\n                        ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                    }\n                    ru.setExpectedOldObjectId(headId);\n                    Result rc \u003d ru.forceUpdate();\n                    switch(rc) {\n                        case NEW:\n                        case FORCED:\n                        case FAST_FORWARD:\n                            {\n                                setCallable(false);\n                                if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeMergeHeads(null);\n                                } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeCherryPickHead(null);\n                                }\n                                return revCommit;\n                            }\n                        case REJECTED:\n                        case LOCK_FAILURE:\n                            throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                        default:\n                            throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                    }\n                } finally {\n                    revWalk.release();\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw e;\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 149,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link RevCommit} object representing the successful commit.\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathException\n            when the current index contained unmerged paths (conflicts)\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n@throws JGitInternalException\n            a low-level exception of JGit has occurred. The original\n            exception can be retrieved by calling\n            {@link Exception#getCause()}. Expect only\n            {@code IOException\u0027s} to be wrapped. Subclasses of\n            {@link IOException} (e.g. {@link UnmergedPathException}) are\n            typically not wrapped here but thrown as original exception\n",
      "diff": "@@ -1,89 +1,93 @@\n public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n     checkCallable();\n     RepositoryState state \u003d repo.getRepositoryState();\n     if (!state.canCommit())\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n     processOptions(state);\n     try {\n         if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n             Git git \u003d new Git(repo);\n             try {\n                 git.add().addFilepattern(\".\").setUpdate(true).call();\n             } catch (NoFilepatternException e) {\n                 throw new JGitInternalException(e.getMessage(), e);\n             }\n         }\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n         if (headId !\u003d null)\n             if (amend) {\n                 RevCommit previousCommit \u003d new RevWalk(repo).parseCommit(headId);\n                 RevCommit[] p \u003d previousCommit.getParents();\n                 for (int i \u003d 0; i \u003c p.length; i++) parents.add(0, p[i].getId());\n             } else {\n                 parents.add(0, headId);\n             }\n         DirCache index \u003d repo.lockDirCache();\n         try {\n             if (!only.isEmpty())\n                 index \u003d createTemporaryIndex(headId, index);\n             ObjectInserter odi \u003d repo.newObjectInserter();\n             try {\n                 ObjectId indexTreeId \u003d index.writeTree(odi);\n                 if (insertChangeId)\n                     insertChangeId(indexTreeId);\n                 CommitBuilder commit \u003d new CommitBuilder();\n                 commit.setCommitter(committer);\n                 commit.setAuthor(author);\n                 commit.setMessage(message);\n                 commit.setParentIds(parents);\n                 commit.setTreeId(indexTreeId);\n                 ObjectId commitId \u003d odi.insert(commit);\n                 odi.flush();\n                 RevWalk revWalk \u003d new RevWalk(repo);\n                 try {\n                     RevCommit revCommit \u003d revWalk.parseCommit(commitId);\n                     RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                     ru.setNewObjectId(commitId);\n-                    String prefix \u003d amend ? \"commit (amend): \" : \"commit: \";\n-                    ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n+                    if (reflogComment !\u003d null) {\n+                        ru.setRefLogMessage(reflogComment, false);\n+                    } else {\n+                        String prefix \u003d amend ? \"commit (amend): \" : \"commit: \";\n+                        ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n+                    }\n                     ru.setExpectedOldObjectId(headId);\n                     Result rc \u003d ru.forceUpdate();\n                     switch(rc) {\n                         case NEW:\n                         case FORCED:\n                         case FAST_FORWARD:\n                             {\n                                 setCallable(false);\n                                 if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n                                     repo.writeMergeCommitMsg(null);\n                                     repo.writeMergeHeads(null);\n                                 } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                     repo.writeMergeCommitMsg(null);\n                                     repo.writeCherryPickHead(null);\n                                 }\n                                 return revCommit;\n                             }\n                         case REJECTED:\n                         case LOCK_FAILURE:\n                             throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                         default:\n                             throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                     }\n                 } finally {\n                     revWalk.release();\n                 }\n             } finally {\n                 odi.release();\n             }\n         } finally {\n             index.unlock();\n         }\n     } catch (UnmergedPathException e) {\n         throw e;\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6e10aa42e90a25b82f00f0c27574f57ffa9e4a25": {
      "type": "Ybodychange",
      "commitMessage": "Add CHERRY_PICK_HEAD for cherry-pick conflicts\n\nAdd handling of CHERRY_PICK_HEAD file in .git (similar to MERGE_HEAD),\nwhich is written in case of a conflicting cherry-pick merge.\n\nIt is used so that Repository.getRepositoryState can return the new\nstates CHERRY_PICKING and CHERRY_PICKING_RESOLVED. These states, as well\nas CHERRY_PICK_HEAD can be used in EGit to properly show the merge tool.\n\nAlso, in case of a conflict, MERGE_MSG is written with the original\ncommit message and a \"Conflicts\" section appended. This way, the\ncherry-picked message is not lost and can later be re-used in the commit\ndialog.\n\nBug: 339092\nChange-Id: I947967fdc2f1d55016c95106b104c2afcc9797a1\nSigned-off-by: Robin Stocker \u003crobin@nibor.org\u003e\nSigned-off-by: Chris Aniszczyk \u003ccaniszczyk@gmail.com\u003e\n",
      "commitDate": "2011/4/7 上午2:28",
      "commitName": "6e10aa42e90a25b82f00f0c27574f57ffa9e4a25",
      "commitAuthor": "Robin Stocker",
      "commitDateOld": "2011/3/18 上午1:15",
      "commitNameOld": "fd963a9180af73b6a05a5c1a2af6dd7168899170",
      "commitAuthorOld": "Jens Baumgart",
      "daysBetweenCommits": 20.05,
      "commitsBetweenForRepo": 52,
      "commitsBetweenForFile": 1,
      "actualSource": "public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n    checkCallable();\n    RepositoryState state \u003d repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n            Git git \u003d new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId !\u003d null)\n            if (amend) {\n                RevCommit previousCommit \u003d new RevWalk(repo).parseCommit(headId);\n                RevCommit[] p \u003d previousCommit.getParents();\n                for (int i \u003d 0; i \u003c p.length; i++) parents.add(0, p[i].getId());\n            } else {\n                parents.add(0, headId);\n            }\n        DirCache index \u003d repo.lockDirCache();\n        try {\n            if (!only.isEmpty())\n                index \u003d createTemporaryIndex(headId, index);\n            ObjectInserter odi \u003d repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId \u003d index.writeTree(odi);\n                if (insertChangeId)\n                    insertChangeId(indexTreeId);\n                CommitBuilder commit \u003d new CommitBuilder();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId \u003d odi.insert(commit);\n                odi.flush();\n                RevWalk revWalk \u003d new RevWalk(repo);\n                try {\n                    RevCommit revCommit \u003d revWalk.parseCommit(commitId);\n                    RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                    ru.setNewObjectId(commitId);\n                    String prefix \u003d amend ? \"commit (amend): \" : \"commit: \";\n                    ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                    ru.setExpectedOldObjectId(headId);\n                    Result rc \u003d ru.forceUpdate();\n                    switch(rc) {\n                        case NEW:\n                        case FORCED:\n                        case FAST_FORWARD:\n                            {\n                                setCallable(false);\n                                if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeMergeHeads(null);\n                                } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeCherryPickHead(null);\n                                }\n                                return revCommit;\n                            }\n                        case REJECTED:\n                        case LOCK_FAILURE:\n                            throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                        default:\n                            throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                    }\n                } finally {\n                    revWalk.release();\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw e;\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 146,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link RevCommit} object representing the successful commit.\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathException\n            when the current index contained unmerged paths (conflicts)\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n@throws JGitInternalException\n            a low-level exception of JGit has occurred. The original\n            exception can be retrieved by calling\n            {@link Exception#getCause()}. Expect only\n            {@code IOException\u0027s} to be wrapped. Subclasses of\n            {@link IOException} (e.g. {@link UnmergedPathException}) are\n            typically not wrapped here but thrown as original exception\n",
      "diff": "@@ -1,86 +1,89 @@\n public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n     checkCallable();\n     RepositoryState state \u003d repo.getRepositoryState();\n     if (!state.canCommit())\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n     processOptions(state);\n     try {\n         if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n             Git git \u003d new Git(repo);\n             try {\n                 git.add().addFilepattern(\".\").setUpdate(true).call();\n             } catch (NoFilepatternException e) {\n                 throw new JGitInternalException(e.getMessage(), e);\n             }\n         }\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n         if (headId !\u003d null)\n             if (amend) {\n                 RevCommit previousCommit \u003d new RevWalk(repo).parseCommit(headId);\n                 RevCommit[] p \u003d previousCommit.getParents();\n                 for (int i \u003d 0; i \u003c p.length; i++) parents.add(0, p[i].getId());\n             } else {\n                 parents.add(0, headId);\n             }\n         DirCache index \u003d repo.lockDirCache();\n         try {\n             if (!only.isEmpty())\n                 index \u003d createTemporaryIndex(headId, index);\n             ObjectInserter odi \u003d repo.newObjectInserter();\n             try {\n                 ObjectId indexTreeId \u003d index.writeTree(odi);\n                 if (insertChangeId)\n                     insertChangeId(indexTreeId);\n                 CommitBuilder commit \u003d new CommitBuilder();\n                 commit.setCommitter(committer);\n                 commit.setAuthor(author);\n                 commit.setMessage(message);\n                 commit.setParentIds(parents);\n                 commit.setTreeId(indexTreeId);\n                 ObjectId commitId \u003d odi.insert(commit);\n                 odi.flush();\n                 RevWalk revWalk \u003d new RevWalk(repo);\n                 try {\n                     RevCommit revCommit \u003d revWalk.parseCommit(commitId);\n                     RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                     ru.setNewObjectId(commitId);\n                     String prefix \u003d amend ? \"commit (amend): \" : \"commit: \";\n                     ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                     ru.setExpectedOldObjectId(headId);\n                     Result rc \u003d ru.forceUpdate();\n                     switch(rc) {\n                         case NEW:\n                         case FORCED:\n                         case FAST_FORWARD:\n                             {\n                                 setCallable(false);\n                                 if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n                                     repo.writeMergeCommitMsg(null);\n                                     repo.writeMergeHeads(null);\n+                                } else if (state \u003d\u003d RepositoryState.CHERRY_PICKING_RESOLVED) {\n+                                    repo.writeMergeCommitMsg(null);\n+                                    repo.writeCherryPickHead(null);\n                                 }\n                                 return revCommit;\n                             }\n                         case REJECTED:\n                         case LOCK_FAILURE:\n                             throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                         default:\n                             throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                     }\n                 } finally {\n                     revWalk.release();\n                 }\n             } finally {\n                 odi.release();\n             }\n         } finally {\n             index.unlock();\n         }\n     } catch (UnmergedPathException e) {\n         throw e;\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fd963a9180af73b6a05a5c1a2af6dd7168899170": {
      "type": "Ybodychange",
      "commitMessage": "CommitCommand: add option to insert a change id\n\nAn option to insert a change id into the commit message was added\nto CommitCommand.\nThis change is a prerequisite for removing GitIndex from EGit.\n\nChange-Id: Iff9e26a8aaf21d8224bfd6ce3c98821c077bcd82\nSigned-off-by: Jens Baumgart \u003cjens.baumgart@sap.com\u003e\nSigned-off-by: Philipp Thun \u003cphilipp.thun@sap.com\u003e\nSigned-off-by: Mathias Kinzler \u003cmathias.kinzler@sap.com\u003e",
      "commitDate": "2011/3/18 上午1:15",
      "commitName": "fd963a9180af73b6a05a5c1a2af6dd7168899170",
      "commitAuthor": "Jens Baumgart",
      "commitDateOld": "2011/3/15 下午8:55",
      "commitNameOld": "79ad15924acc2ba2412d5114c85db27f0f4aca22",
      "commitAuthorOld": "Philipp Thun",
      "daysBetweenCommits": 2.18,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n    checkCallable();\n    RepositoryState state \u003d repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n            Git git \u003d new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId !\u003d null)\n            if (amend) {\n                RevCommit previousCommit \u003d new RevWalk(repo).parseCommit(headId);\n                RevCommit[] p \u003d previousCommit.getParents();\n                for (int i \u003d 0; i \u003c p.length; i++) parents.add(0, p[i].getId());\n            } else {\n                parents.add(0, headId);\n            }\n        DirCache index \u003d repo.lockDirCache();\n        try {\n            if (!only.isEmpty())\n                index \u003d createTemporaryIndex(headId, index);\n            ObjectInserter odi \u003d repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId \u003d index.writeTree(odi);\n                if (insertChangeId)\n                    insertChangeId(indexTreeId);\n                CommitBuilder commit \u003d new CommitBuilder();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId \u003d odi.insert(commit);\n                odi.flush();\n                RevWalk revWalk \u003d new RevWalk(repo);\n                try {\n                    RevCommit revCommit \u003d revWalk.parseCommit(commitId);\n                    RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                    ru.setNewObjectId(commitId);\n                    String prefix \u003d amend ? \"commit (amend): \" : \"commit: \";\n                    ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                    ru.setExpectedOldObjectId(headId);\n                    Result rc \u003d ru.forceUpdate();\n                    switch(rc) {\n                        case NEW:\n                        case FORCED:\n                        case FAST_FORWARD:\n                            {\n                                setCallable(false);\n                                if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeMergeHeads(null);\n                                }\n                                return revCommit;\n                            }\n                        case REJECTED:\n                        case LOCK_FAILURE:\n                            throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                        default:\n                            throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                    }\n                } finally {\n                    revWalk.release();\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw e;\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 146,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link RevCommit} object representing the successful commit.\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathException\n            when the current index contained unmerged paths (conflicts)\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n@throws JGitInternalException\n            a low-level exception of JGit has occurred. The original\n            exception can be retrieved by calling\n            {@link Exception#getCause()}. Expect only\n            {@code IOException\u0027s} to be wrapped. Subclasses of\n            {@link IOException} (e.g. {@link UnmergedPathException}) are\n            typically not wrapped here but thrown as original exception\n",
      "diff": "@@ -1,84 +1,86 @@\n public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n     checkCallable();\n     RepositoryState state \u003d repo.getRepositoryState();\n     if (!state.canCommit())\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n     processOptions(state);\n     try {\n         if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n             Git git \u003d new Git(repo);\n             try {\n                 git.add().addFilepattern(\".\").setUpdate(true).call();\n             } catch (NoFilepatternException e) {\n                 throw new JGitInternalException(e.getMessage(), e);\n             }\n         }\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n         if (headId !\u003d null)\n             if (amend) {\n                 RevCommit previousCommit \u003d new RevWalk(repo).parseCommit(headId);\n                 RevCommit[] p \u003d previousCommit.getParents();\n                 for (int i \u003d 0; i \u003c p.length; i++) parents.add(0, p[i].getId());\n             } else {\n                 parents.add(0, headId);\n             }\n         DirCache index \u003d repo.lockDirCache();\n         try {\n             if (!only.isEmpty())\n                 index \u003d createTemporaryIndex(headId, index);\n             ObjectInserter odi \u003d repo.newObjectInserter();\n             try {\n                 ObjectId indexTreeId \u003d index.writeTree(odi);\n+                if (insertChangeId)\n+                    insertChangeId(indexTreeId);\n                 CommitBuilder commit \u003d new CommitBuilder();\n                 commit.setCommitter(committer);\n                 commit.setAuthor(author);\n                 commit.setMessage(message);\n                 commit.setParentIds(parents);\n                 commit.setTreeId(indexTreeId);\n                 ObjectId commitId \u003d odi.insert(commit);\n                 odi.flush();\n                 RevWalk revWalk \u003d new RevWalk(repo);\n                 try {\n                     RevCommit revCommit \u003d revWalk.parseCommit(commitId);\n                     RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                     ru.setNewObjectId(commitId);\n                     String prefix \u003d amend ? \"commit (amend): \" : \"commit: \";\n                     ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                     ru.setExpectedOldObjectId(headId);\n                     Result rc \u003d ru.forceUpdate();\n                     switch(rc) {\n                         case NEW:\n                         case FORCED:\n                         case FAST_FORWARD:\n                             {\n                                 setCallable(false);\n                                 if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n                                     repo.writeMergeCommitMsg(null);\n                                     repo.writeMergeHeads(null);\n                                 }\n                                 return revCommit;\n                             }\n                         case REJECTED:\n                         case LOCK_FAILURE:\n                             throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                         default:\n                             throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                     }\n                 } finally {\n                     revWalk.release();\n                 }\n             } finally {\n                 odi.release();\n             }\n         } finally {\n             index.unlock();\n         }\n     } catch (UnmergedPathException e) {\n         throw e;\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9830baf48dd5b3feb9780a3cc1d83b79e1d4c46b": {
      "type": "Ybodychange",
      "commitMessage": "CommitCommand: set correct Reflog message when amending\n\nChange-Id: I2322d31b09ca63bdcee50e90340e326467dc5021\nSigned-off-by: Jens Baumgart \u003cjens.baumgart@sap.com\u003e\nSigned-off-by: Chris Aniszczyk \u003ccaniszczyk@gmail.com\u003e\n",
      "commitDate": "2011/3/15 上午4:51",
      "commitName": "9830baf48dd5b3feb9780a3cc1d83b79e1d4c46b",
      "commitAuthor": "Jens Baumgart",
      "commitDateOld": "2011/3/11 下午9:25",
      "commitNameOld": "a490afedba12676a53338bc52b729b9bb779f3a1",
      "commitAuthorOld": "Philipp Thun",
      "daysBetweenCommits": 3.31,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n    checkCallable();\n    RepositoryState state \u003d repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n            Git git \u003d new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId !\u003d null)\n            if (amend) {\n                RevCommit previousCommit \u003d new RevWalk(repo).parseCommit(headId);\n                RevCommit[] p \u003d previousCommit.getParents();\n                for (int i \u003d 0; i \u003c p.length; i++) parents.add(0, p[i].getId());\n            } else {\n                parents.add(0, headId);\n            }\n        DirCache index \u003d repo.lockDirCache();\n        try {\n            if (!only.isEmpty())\n                index \u003d createTemporaryIndex(headId, index);\n            ObjectInserter odi \u003d repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId \u003d index.writeTree(odi);\n                CommitBuilder commit \u003d new CommitBuilder();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId \u003d odi.insert(commit);\n                odi.flush();\n                RevWalk revWalk \u003d new RevWalk(repo);\n                try {\n                    RevCommit revCommit \u003d revWalk.parseCommit(commitId);\n                    RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                    ru.setNewObjectId(commitId);\n                    String prefix \u003d amend ? \"commit (amend): \" : \"commit: \";\n                    ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                    ru.setExpectedOldObjectId(headId);\n                    Result rc \u003d ru.forceUpdate();\n                    switch(rc) {\n                        case NEW:\n                        case FORCED:\n                        case FAST_FORWARD:\n                            {\n                                setCallable(false);\n                                if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeMergeHeads(null);\n                                }\n                                return revCommit;\n                            }\n                        case REJECTED:\n                        case LOCK_FAILURE:\n                            throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                        default:\n                            throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                    }\n                } finally {\n                    revWalk.release();\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw e;\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 143,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link RevCommit} object representing the successful commit.\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathException\n            when the current index contained unmerged paths (conflicts)\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n@throws JGitInternalException\n            a low-level exception of JGit has occurred. The original\n            exception can be retrieved by calling\n            {@link Exception#getCause()}. Expect only\n            {@code IOException\u0027s} to be wrapped. Subclasses of\n            {@link IOException} (e.g. {@link UnmergedPathException}) are\n            typically not wrapped here but thrown as original exception\n",
      "diff": "@@ -1,83 +1,84 @@\n public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n     checkCallable();\n     RepositoryState state \u003d repo.getRepositoryState();\n     if (!state.canCommit())\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n     processOptions(state);\n     try {\n         if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n             Git git \u003d new Git(repo);\n             try {\n                 git.add().addFilepattern(\".\").setUpdate(true).call();\n             } catch (NoFilepatternException e) {\n                 throw new JGitInternalException(e.getMessage(), e);\n             }\n         }\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n         if (headId !\u003d null)\n             if (amend) {\n                 RevCommit previousCommit \u003d new RevWalk(repo).parseCommit(headId);\n                 RevCommit[] p \u003d previousCommit.getParents();\n                 for (int i \u003d 0; i \u003c p.length; i++) parents.add(0, p[i].getId());\n             } else {\n                 parents.add(0, headId);\n             }\n         DirCache index \u003d repo.lockDirCache();\n         try {\n             if (!only.isEmpty())\n                 index \u003d createTemporaryIndex(headId, index);\n             ObjectInserter odi \u003d repo.newObjectInserter();\n             try {\n                 ObjectId indexTreeId \u003d index.writeTree(odi);\n                 CommitBuilder commit \u003d new CommitBuilder();\n                 commit.setCommitter(committer);\n                 commit.setAuthor(author);\n                 commit.setMessage(message);\n                 commit.setParentIds(parents);\n                 commit.setTreeId(indexTreeId);\n                 ObjectId commitId \u003d odi.insert(commit);\n                 odi.flush();\n                 RevWalk revWalk \u003d new RevWalk(repo);\n                 try {\n                     RevCommit revCommit \u003d revWalk.parseCommit(commitId);\n                     RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                     ru.setNewObjectId(commitId);\n-                    ru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(), false);\n+                    String prefix \u003d amend ? \"commit (amend): \" : \"commit: \";\n+                    ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                     ru.setExpectedOldObjectId(headId);\n                     Result rc \u003d ru.forceUpdate();\n                     switch(rc) {\n                         case NEW:\n                         case FORCED:\n                         case FAST_FORWARD:\n                             {\n                                 setCallable(false);\n                                 if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n                                     repo.writeMergeCommitMsg(null);\n                                     repo.writeMergeHeads(null);\n                                 }\n                                 return revCommit;\n                             }\n                         case REJECTED:\n                         case LOCK_FAILURE:\n                             throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                         default:\n                             throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                     }\n                 } finally {\n                     revWalk.release();\n                 }\n             } finally {\n                 odi.release();\n             }\n         } finally {\n             index.unlock();\n         }\n     } catch (UnmergedPathException e) {\n         throw e;\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a490afedba12676a53338bc52b729b9bb779f3a1": {
      "type": "Ybodychange",
      "commitMessage": "Add -o option to commit command\n\nThis change adds the --only/ -o option to the commit command.\n\nChange-Id: I44352d56877f8204d985cb7a35a2e0faffb7d341\nSigned-off-by: Philipp Thun \u003cphilipp.thun@sap.com\u003e\n",
      "commitDate": "2011/3/11 下午9:25",
      "commitName": "a490afedba12676a53338bc52b729b9bb779f3a1",
      "commitAuthor": "Philipp Thun",
      "commitDateOld": "2011/3/8 上午12:19",
      "commitNameOld": "cda64073fd45d3056486b96877e4ff6dd12dbaa5",
      "commitAuthorOld": "Tomasz Zarna",
      "daysBetweenCommits": 3.88,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "actualSource": "public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n    checkCallable();\n    RepositoryState state \u003d repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n            Git git \u003d new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId !\u003d null)\n            if (amend) {\n                RevCommit previousCommit \u003d new RevWalk(repo).parseCommit(headId);\n                RevCommit[] p \u003d previousCommit.getParents();\n                for (int i \u003d 0; i \u003c p.length; i++) parents.add(0, p[i].getId());\n            } else {\n                parents.add(0, headId);\n            }\n        DirCache index \u003d repo.lockDirCache();\n        try {\n            if (!only.isEmpty())\n                index \u003d createTemporaryIndex(headId, index);\n            ObjectInserter odi \u003d repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId \u003d index.writeTree(odi);\n                CommitBuilder commit \u003d new CommitBuilder();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId \u003d odi.insert(commit);\n                odi.flush();\n                RevWalk revWalk \u003d new RevWalk(repo);\n                try {\n                    RevCommit revCommit \u003d revWalk.parseCommit(commitId);\n                    RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                    ru.setNewObjectId(commitId);\n                    ru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(), false);\n                    ru.setExpectedOldObjectId(headId);\n                    Result rc \u003d ru.forceUpdate();\n                    switch(rc) {\n                        case NEW:\n                        case FORCED:\n                        case FAST_FORWARD:\n                            {\n                                setCallable(false);\n                                if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeMergeHeads(null);\n                                }\n                                return revCommit;\n                            }\n                        case REJECTED:\n                        case LOCK_FAILURE:\n                            throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                        default:\n                            throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                    }\n                } finally {\n                    revWalk.release();\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw e;\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 143,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link RevCommit} object representing the successful commit.\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathException\n            when the current index contained unmerged paths (conflicts)\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n@throws JGitInternalException\n            a low-level exception of JGit has occurred. The original\n            exception can be retrieved by calling\n            {@link Exception#getCause()}. Expect only\n            {@code IOException\u0027s} to be wrapped. Subclasses of\n            {@link IOException} (e.g. {@link UnmergedPathException}) are\n            typically not wrapped here but thrown as original exception\n",
      "diff": "@@ -1,81 +1,83 @@\n public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n     checkCallable();\n     RepositoryState state \u003d repo.getRepositoryState();\n     if (!state.canCommit())\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n     processOptions(state);\n     try {\n         if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n             Git git \u003d new Git(repo);\n             try {\n                 git.add().addFilepattern(\".\").setUpdate(true).call();\n             } catch (NoFilepatternException e) {\n                 throw new JGitInternalException(e.getMessage(), e);\n             }\n         }\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n         if (headId !\u003d null)\n             if (amend) {\n                 RevCommit previousCommit \u003d new RevWalk(repo).parseCommit(headId);\n                 RevCommit[] p \u003d previousCommit.getParents();\n                 for (int i \u003d 0; i \u003c p.length; i++) parents.add(0, p[i].getId());\n             } else {\n                 parents.add(0, headId);\n             }\n         DirCache index \u003d repo.lockDirCache();\n         try {\n+            if (!only.isEmpty())\n+                index \u003d createTemporaryIndex(headId, index);\n             ObjectInserter odi \u003d repo.newObjectInserter();\n             try {\n                 ObjectId indexTreeId \u003d index.writeTree(odi);\n                 CommitBuilder commit \u003d new CommitBuilder();\n                 commit.setCommitter(committer);\n                 commit.setAuthor(author);\n                 commit.setMessage(message);\n                 commit.setParentIds(parents);\n                 commit.setTreeId(indexTreeId);\n                 ObjectId commitId \u003d odi.insert(commit);\n                 odi.flush();\n                 RevWalk revWalk \u003d new RevWalk(repo);\n                 try {\n                     RevCommit revCommit \u003d revWalk.parseCommit(commitId);\n                     RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                     ru.setNewObjectId(commitId);\n                     ru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(), false);\n                     ru.setExpectedOldObjectId(headId);\n                     Result rc \u003d ru.forceUpdate();\n                     switch(rc) {\n                         case NEW:\n                         case FORCED:\n                         case FAST_FORWARD:\n                             {\n                                 setCallable(false);\n                                 if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n                                     repo.writeMergeCommitMsg(null);\n                                     repo.writeMergeHeads(null);\n                                 }\n                                 return revCommit;\n                             }\n                         case REJECTED:\n                         case LOCK_FAILURE:\n                             throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                         default:\n                             throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                     }\n                 } finally {\n                     revWalk.release();\n                 }\n             } finally {\n                 odi.release();\n             }\n         } finally {\n             index.unlock();\n         }\n     } catch (UnmergedPathException e) {\n         throw e;\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cda64073fd45d3056486b96877e4ff6dd12dbaa5": {
      "type": "Ybodychange",
      "commitMessage": "Allow to amend a commit with CommitCommand\n\nBug: 339088\nChange-Id: I57dc727688c4bb6968ac076b176661c857c05afa\nSigned-off-by: Chris Aniszczyk \u003ccaniszczyk@gmail.com\u003e\n",
      "commitDate": "2011/3/8 上午12:19",
      "commitName": "cda64073fd45d3056486b96877e4ff6dd12dbaa5",
      "commitAuthor": "Tomasz Zarna",
      "commitDateOld": "2011/1/18 上午5:04",
      "commitNameOld": "e43887b69e27672b80e55391e0ee255efe715ab9",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 48.8,
      "commitsBetweenForRepo": 134,
      "commitsBetweenForFile": 1,
      "actualSource": "public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n    checkCallable();\n    RepositoryState state \u003d repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n            Git git \u003d new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId !\u003d null)\n            if (amend) {\n                RevCommit previousCommit \u003d new RevWalk(repo).parseCommit(headId);\n                RevCommit[] p \u003d previousCommit.getParents();\n                for (int i \u003d 0; i \u003c p.length; i++) parents.add(0, p[i].getId());\n            } else {\n                parents.add(0, headId);\n            }\n        DirCache index \u003d repo.lockDirCache();\n        try {\n            ObjectInserter odi \u003d repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId \u003d index.writeTree(odi);\n                CommitBuilder commit \u003d new CommitBuilder();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId \u003d odi.insert(commit);\n                odi.flush();\n                RevWalk revWalk \u003d new RevWalk(repo);\n                try {\n                    RevCommit revCommit \u003d revWalk.parseCommit(commitId);\n                    RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                    ru.setNewObjectId(commitId);\n                    ru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(), false);\n                    ru.setExpectedOldObjectId(headId);\n                    Result rc \u003d ru.forceUpdate();\n                    switch(rc) {\n                        case NEW:\n                        case FORCED:\n                        case FAST_FORWARD:\n                            {\n                                setCallable(false);\n                                if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeMergeHeads(null);\n                                }\n                                return revCommit;\n                            }\n                        case REJECTED:\n                        case LOCK_FAILURE:\n                            throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                        default:\n                            throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                    }\n                } finally {\n                    revWalk.release();\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw e;\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 128,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link RevCommit} object representing the successful commit.\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathException\n            when the current index contained unmerged paths (conflicts)\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n@throws JGitInternalException\n            a low-level exception of JGit has occurred. The original\n            exception can be retrieved by calling\n            {@link Exception#getCause()}. Expect only\n            {@code IOException\u0027s} to be wrapped. Subclasses of\n            {@link IOException} (e.g. {@link UnmergedPathException}) are\n            typically not wrapped here but thrown as original exception\n",
      "diff": "@@ -1,74 +1,81 @@\n public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n     checkCallable();\n     RepositoryState state \u003d repo.getRepositoryState();\n     if (!state.canCommit())\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n     processOptions(state);\n     try {\n         if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n             Git git \u003d new Git(repo);\n             try {\n                 git.add().addFilepattern(\".\").setUpdate(true).call();\n             } catch (NoFilepatternException e) {\n                 throw new JGitInternalException(e.getMessage(), e);\n             }\n         }\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n         if (headId !\u003d null)\n-            parents.add(0, headId);\n+            if (amend) {\n+                RevCommit previousCommit \u003d new RevWalk(repo).parseCommit(headId);\n+                RevCommit[] p \u003d previousCommit.getParents();\n+                for (int i \u003d 0; i \u003c p.length; i++) parents.add(0, p[i].getId());\n+            } else {\n+                parents.add(0, headId);\n+            }\n         DirCache index \u003d repo.lockDirCache();\n         try {\n             ObjectInserter odi \u003d repo.newObjectInserter();\n             try {\n                 ObjectId indexTreeId \u003d index.writeTree(odi);\n                 CommitBuilder commit \u003d new CommitBuilder();\n                 commit.setCommitter(committer);\n                 commit.setAuthor(author);\n                 commit.setMessage(message);\n                 commit.setParentIds(parents);\n                 commit.setTreeId(indexTreeId);\n                 ObjectId commitId \u003d odi.insert(commit);\n                 odi.flush();\n                 RevWalk revWalk \u003d new RevWalk(repo);\n                 try {\n                     RevCommit revCommit \u003d revWalk.parseCommit(commitId);\n                     RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                     ru.setNewObjectId(commitId);\n                     ru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(), false);\n                     ru.setExpectedOldObjectId(headId);\n-                    Result rc \u003d ru.update();\n+                    Result rc \u003d ru.forceUpdate();\n                     switch(rc) {\n                         case NEW:\n+                        case FORCED:\n                         case FAST_FORWARD:\n                             {\n                                 setCallable(false);\n                                 if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n                                     repo.writeMergeCommitMsg(null);\n                                     repo.writeMergeHeads(null);\n                                 }\n                                 return revCommit;\n                             }\n                         case REJECTED:\n                         case LOCK_FAILURE:\n                             throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                         default:\n                             throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                     }\n                 } finally {\n                     revWalk.release();\n                 }\n             } finally {\n                 odi.release();\n             }\n         } finally {\n             index.unlock();\n         }\n     } catch (UnmergedPathException e) {\n         throw e;\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e43887b69e27672b80e55391e0ee255efe715ab9": {
      "type": "Ydocchange",
      "commitMessage": "Fix misc spelling errors in comments and method names\n\nChange-Id: I24552443710075856540696717ac4068dfe6a7f2\nSigned-off-by: Robin Rosenberg \u003crobin.rosenberg@dewire.com\u003e\n",
      "commitDate": "2011/1/18 上午5:04",
      "commitName": "e43887b69e27672b80e55391e0ee255efe715ab9",
      "commitAuthor": "Robin Rosenberg",
      "commitDateOld": "2010/9/2 上午6:27",
      "commitNameOld": "38327a54a86697458a1b326278e04833c105c00e",
      "commitAuthorOld": "Chris Aniszczyk",
      "daysBetweenCommits": 137.94,
      "commitsBetweenForRepo": 313,
      "commitsBetweenForFile": 1,
      "actualSource": "public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n    checkCallable();\n    RepositoryState state \u003d repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n            Git git \u003d new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId !\u003d null)\n            parents.add(0, headId);\n        DirCache index \u003d repo.lockDirCache();\n        try {\n            ObjectInserter odi \u003d repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId \u003d index.writeTree(odi);\n                CommitBuilder commit \u003d new CommitBuilder();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId \u003d odi.insert(commit);\n                odi.flush();\n                RevWalk revWalk \u003d new RevWalk(repo);\n                try {\n                    RevCommit revCommit \u003d revWalk.parseCommit(commitId);\n                    RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                    ru.setNewObjectId(commitId);\n                    ru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(), false);\n                    ru.setExpectedOldObjectId(headId);\n                    Result rc \u003d ru.update();\n                    switch(rc) {\n                        case NEW:\n                        case FAST_FORWARD:\n                            {\n                                setCallable(false);\n                                if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeMergeHeads(null);\n                                }\n                                return revCommit;\n                            }\n                        case REJECTED:\n                        case LOCK_FAILURE:\n                            throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                        default:\n                            throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                    }\n                } finally {\n                    revWalk.release();\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw e;\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 126,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link RevCommit} object representing the successful commit.\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathException\n            when the current index contained unmerged paths (conflicts)\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n@throws JGitInternalException\n            a low-level exception of JGit has occurred. The original\n            exception can be retrieved by calling\n            {@link Exception#getCause()}. Expect only\n            {@code IOException\u0027s} to be wrapped. Subclasses of\n            {@link IOException} (e.g. {@link UnmergedPathException}) are\n            typically not wrapped here but thrown as original exception\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link RevCommit} object representing the successful commit.\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathException\n            when the current index contained unmerged pathes (conflicts)\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n@throws JGitInternalException\n            a low-level exception of JGit has occurred. The original\n            exception can be retrieved by calling\n            {@link Exception#getCause()}. Expect only\n            {@code IOException\u0027s} to be wrapped. Subclasses of\n            {@link IOException} (e.g. {@link UnmergedPathException}) are\n            typically not wrapped here but thrown as original exception\n",
        "newValue": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link RevCommit} object representing the successful commit.\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathException\n            when the current index contained unmerged paths (conflicts)\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n@throws JGitInternalException\n            a low-level exception of JGit has occurred. The original\n            exception can be retrieved by calling\n            {@link Exception#getCause()}. Expect only\n            {@code IOException\u0027s} to be wrapped. Subclasses of\n            {@link IOException} (e.g. {@link UnmergedPathException}) are\n            typically not wrapped here but thrown as original exception\n"
      }
    },
    "6df5d3397c5c9354409d21a8e207a061f2e6efc2": {
      "type": "Ybodychange",
      "commitMessage": "Move commit and tag formatting to CommitBuilder, TagBuilder\n\nThese objects should be responsible for their own formatting,\nrather than delegating it to some obtuse type called ObjectInserter.\n\nWhile we are at it, simplify the way we insert these into a database.\nPassing in the type and calling format in application code turned\nout to be a huge mistake in terms of ease-of-use of the insert API.\n\nChange-Id: Id5bb95ee56aa2a002243e9b7853b84ec8df1d7bf\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010/8/24 上午1:13",
      "commitName": "6df5d3397c5c9354409d21a8e207a061f2e6efc2",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2010/8/24 上午12:46",
      "commitNameOld": "22b285695a2980824c15363ef5fec709ebc3d434",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n    checkCallable();\n    RepositoryState state \u003d repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n            Git git \u003d new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId !\u003d null)\n            parents.add(0, headId);\n        DirCache index \u003d repo.lockDirCache();\n        try {\n            ObjectInserter odi \u003d repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId \u003d index.writeTree(odi);\n                CommitBuilder commit \u003d new CommitBuilder();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId \u003d odi.insert(commit);\n                odi.flush();\n                RevWalk revWalk \u003d new RevWalk(repo);\n                try {\n                    RevCommit revCommit \u003d revWalk.parseCommit(commitId);\n                    RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                    ru.setNewObjectId(commitId);\n                    ru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(), false);\n                    ru.setExpectedOldObjectId(headId);\n                    Result rc \u003d ru.update();\n                    switch(rc) {\n                        case NEW:\n                        case FAST_FORWARD:\n                            {\n                                setCallable(false);\n                                if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeMergeHeads(null);\n                                }\n                                return revCommit;\n                            }\n                        case REJECTED:\n                        case LOCK_FAILURE:\n                            throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                        default:\n                            throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                    }\n                } finally {\n                    revWalk.release();\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw e;\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 120,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link RevCommit} object representing the successful commit.\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathException\n            when the current index contained unmerged pathes (conflicts)\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n@throws JGitInternalException\n            a low-level exception of JGit has occurred. The original\n            exception can be retrieved by calling\n            {@link Exception#getCause()}. Expect only\n            {@code IOException\u0027s} to be wrapped. Subclasses of\n            {@link IOException} (e.g. {@link UnmergedPathException}) are\n            typically not wrapped here but thrown as original exception\n",
      "diff": "@@ -1,74 +1,74 @@\n public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n     checkCallable();\n     RepositoryState state \u003d repo.getRepositoryState();\n     if (!state.canCommit())\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n     processOptions(state);\n     try {\n         if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n             Git git \u003d new Git(repo);\n             try {\n                 git.add().addFilepattern(\".\").setUpdate(true).call();\n             } catch (NoFilepatternException e) {\n                 throw new JGitInternalException(e.getMessage(), e);\n             }\n         }\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n         if (headId !\u003d null)\n             parents.add(0, headId);\n         DirCache index \u003d repo.lockDirCache();\n         try {\n             ObjectInserter odi \u003d repo.newObjectInserter();\n             try {\n                 ObjectId indexTreeId \u003d index.writeTree(odi);\n                 CommitBuilder commit \u003d new CommitBuilder();\n                 commit.setCommitter(committer);\n                 commit.setAuthor(author);\n                 commit.setMessage(message);\n                 commit.setParentIds(parents);\n                 commit.setTreeId(indexTreeId);\n-                ObjectId commitId \u003d odi.insert(Constants.OBJ_COMMIT, odi.format(commit));\n+                ObjectId commitId \u003d odi.insert(commit);\n                 odi.flush();\n                 RevWalk revWalk \u003d new RevWalk(repo);\n                 try {\n                     RevCommit revCommit \u003d revWalk.parseCommit(commitId);\n                     RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                     ru.setNewObjectId(commitId);\n                     ru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(), false);\n                     ru.setExpectedOldObjectId(headId);\n                     Result rc \u003d ru.update();\n                     switch(rc) {\n                         case NEW:\n                         case FAST_FORWARD:\n                             {\n                                 setCallable(false);\n                                 if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n                                     repo.writeMergeCommitMsg(null);\n                                     repo.writeMergeHeads(null);\n                                 }\n                                 return revCommit;\n                             }\n                         case REJECTED:\n                         case LOCK_FAILURE:\n                             throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                         default:\n                             throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                     }\n                 } finally {\n                     revWalk.release();\n                 }\n             } finally {\n                 odi.release();\n             }\n         } finally {\n             index.unlock();\n         }\n     } catch (UnmergedPathException e) {\n         throw e;\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "22b285695a2980824c15363ef5fec709ebc3d434": {
      "type": "Ymultichange(Ybodychange,Ydocchange)",
      "commitMessage": "Rename Commit, Tag to CommitBuilder, TagBuilder\n\nSince these types no longer support reading, calling them a Builder\nis a better description of what they do.  They help the caller to\nbuild a commit or a tag object.\n\nChange-Id: I53cae5a800a66ea1721b0fe5e702599df31da05d\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010/8/24 上午12:46",
      "commitName": "22b285695a2980824c15363ef5fec709ebc3d434",
      "commitAuthor": "Shawn O. Pearce",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "Rename Commit, Tag to CommitBuilder, TagBuilder\n\nSince these types no longer support reading, calling them a Builder\nis a better description of what they do.  They help the caller to\nbuild a commit or a tag object.\n\nChange-Id: I53cae5a800a66ea1721b0fe5e702599df31da05d\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
          "commitDate": "2010/8/24 上午12:46",
          "commitName": "22b285695a2980824c15363ef5fec709ebc3d434",
          "commitAuthor": "Shawn O. Pearce",
          "commitDateOld": "2010/8/23 下午4:20",
          "commitNameOld": "5fc990130bbd3cf3a0d505c0e12132ec0ecd6b75",
          "commitAuthorOld": "Christian Halstrick",
          "daysBetweenCommits": 0.35,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n    checkCallable();\n    RepositoryState state \u003d repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n            Git git \u003d new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId !\u003d null)\n            parents.add(0, headId);\n        DirCache index \u003d repo.lockDirCache();\n        try {\n            ObjectInserter odi \u003d repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId \u003d index.writeTree(odi);\n                CommitBuilder commit \u003d new CommitBuilder();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId \u003d odi.insert(Constants.OBJ_COMMIT, odi.format(commit));\n                odi.flush();\n                RevWalk revWalk \u003d new RevWalk(repo);\n                try {\n                    RevCommit revCommit \u003d revWalk.parseCommit(commitId);\n                    RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                    ru.setNewObjectId(commitId);\n                    ru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(), false);\n                    ru.setExpectedOldObjectId(headId);\n                    Result rc \u003d ru.update();\n                    switch(rc) {\n                        case NEW:\n                        case FAST_FORWARD:\n                            {\n                                setCallable(false);\n                                if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeMergeHeads(null);\n                                }\n                                return revCommit;\n                            }\n                        case REJECTED:\n                        case LOCK_FAILURE:\n                            throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                        default:\n                            throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                    }\n                } finally {\n                    revWalk.release();\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw e;\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
          "functionStartLine": 120,
          "functionName": "call",
          "functionAnnotation": "",
          "functionDoc": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link RevCommit} object representing the successful commit.\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathException\n            when the current index contained unmerged pathes (conflicts)\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n@throws JGitInternalException\n            a low-level exception of JGit has occurred. The original\n            exception can be retrieved by calling\n            {@link Exception#getCause()}. Expect only\n            {@code IOException\u0027s} to be wrapped. Subclasses of\n            {@link IOException} (e.g. {@link UnmergedPathException}) are\n            typically not wrapped here but thrown as original exception\n",
          "diff": "@@ -1,74 +1,74 @@\n public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n     checkCallable();\n     RepositoryState state \u003d repo.getRepositoryState();\n     if (!state.canCommit())\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n     processOptions(state);\n     try {\n         if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n             Git git \u003d new Git(repo);\n             try {\n                 git.add().addFilepattern(\".\").setUpdate(true).call();\n             } catch (NoFilepatternException e) {\n                 throw new JGitInternalException(e.getMessage(), e);\n             }\n         }\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n         if (headId !\u003d null)\n             parents.add(0, headId);\n         DirCache index \u003d repo.lockDirCache();\n         try {\n             ObjectInserter odi \u003d repo.newObjectInserter();\n             try {\n                 ObjectId indexTreeId \u003d index.writeTree(odi);\n-                Commit commit \u003d new Commit();\n+                CommitBuilder commit \u003d new CommitBuilder();\n                 commit.setCommitter(committer);\n                 commit.setAuthor(author);\n                 commit.setMessage(message);\n                 commit.setParentIds(parents);\n                 commit.setTreeId(indexTreeId);\n                 ObjectId commitId \u003d odi.insert(Constants.OBJ_COMMIT, odi.format(commit));\n                 odi.flush();\n                 RevWalk revWalk \u003d new RevWalk(repo);\n                 try {\n                     RevCommit revCommit \u003d revWalk.parseCommit(commitId);\n                     RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                     ru.setNewObjectId(commitId);\n                     ru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(), false);\n                     ru.setExpectedOldObjectId(headId);\n                     Result rc \u003d ru.update();\n                     switch(rc) {\n                         case NEW:\n                         case FAST_FORWARD:\n                             {\n                                 setCallable(false);\n                                 if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n                                     repo.writeMergeCommitMsg(null);\n                                     repo.writeMergeHeads(null);\n                                 }\n                                 return revCommit;\n                             }\n                         case REJECTED:\n                         case LOCK_FAILURE:\n                             throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                         default:\n                             throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                     }\n                 } finally {\n                     revWalk.release();\n                 }\n             } finally {\n                 odi.release();\n             }\n         } finally {\n             index.unlock();\n         }\n     } catch (UnmergedPathException e) {\n         throw e;\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Rename Commit, Tag to CommitBuilder, TagBuilder\n\nSince these types no longer support reading, calling them a Builder\nis a better description of what they do.  They help the caller to\nbuild a commit or a tag object.\n\nChange-Id: I53cae5a800a66ea1721b0fe5e702599df31da05d\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
          "commitDate": "2010/8/24 上午12:46",
          "commitName": "22b285695a2980824c15363ef5fec709ebc3d434",
          "commitAuthor": "Shawn O. Pearce",
          "commitDateOld": "2010/8/23 下午4:20",
          "commitNameOld": "5fc990130bbd3cf3a0d505c0e12132ec0ecd6b75",
          "commitAuthorOld": "Christian Halstrick",
          "daysBetweenCommits": 0.35,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n    checkCallable();\n    RepositoryState state \u003d repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n            Git git \u003d new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId !\u003d null)\n            parents.add(0, headId);\n        DirCache index \u003d repo.lockDirCache();\n        try {\n            ObjectInserter odi \u003d repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId \u003d index.writeTree(odi);\n                CommitBuilder commit \u003d new CommitBuilder();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId \u003d odi.insert(Constants.OBJ_COMMIT, odi.format(commit));\n                odi.flush();\n                RevWalk revWalk \u003d new RevWalk(repo);\n                try {\n                    RevCommit revCommit \u003d revWalk.parseCommit(commitId);\n                    RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                    ru.setNewObjectId(commitId);\n                    ru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(), false);\n                    ru.setExpectedOldObjectId(headId);\n                    Result rc \u003d ru.update();\n                    switch(rc) {\n                        case NEW:\n                        case FAST_FORWARD:\n                            {\n                                setCallable(false);\n                                if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeMergeHeads(null);\n                                }\n                                return revCommit;\n                            }\n                        case REJECTED:\n                        case LOCK_FAILURE:\n                            throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                        default:\n                            throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                    }\n                } finally {\n                    revWalk.release();\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw e;\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
          "functionStartLine": 120,
          "functionName": "call",
          "functionAnnotation": "",
          "functionDoc": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link RevCommit} object representing the successful commit.\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathException\n            when the current index contained unmerged pathes (conflicts)\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n@throws JGitInternalException\n            a low-level exception of JGit has occurred. The original\n            exception can be retrieved by calling\n            {@link Exception#getCause()}. Expect only\n            {@code IOException\u0027s} to be wrapped. Subclasses of\n            {@link IOException} (e.g. {@link UnmergedPathException}) are\n            typically not wrapped here but thrown as original exception\n",
          "diff": "@@ -1,74 +1,74 @@\n public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n     checkCallable();\n     RepositoryState state \u003d repo.getRepositoryState();\n     if (!state.canCommit())\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n     processOptions(state);\n     try {\n         if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n             Git git \u003d new Git(repo);\n             try {\n                 git.add().addFilepattern(\".\").setUpdate(true).call();\n             } catch (NoFilepatternException e) {\n                 throw new JGitInternalException(e.getMessage(), e);\n             }\n         }\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n         if (headId !\u003d null)\n             parents.add(0, headId);\n         DirCache index \u003d repo.lockDirCache();\n         try {\n             ObjectInserter odi \u003d repo.newObjectInserter();\n             try {\n                 ObjectId indexTreeId \u003d index.writeTree(odi);\n-                Commit commit \u003d new Commit();\n+                CommitBuilder commit \u003d new CommitBuilder();\n                 commit.setCommitter(committer);\n                 commit.setAuthor(author);\n                 commit.setMessage(message);\n                 commit.setParentIds(parents);\n                 commit.setTreeId(indexTreeId);\n                 ObjectId commitId \u003d odi.insert(Constants.OBJ_COMMIT, odi.format(commit));\n                 odi.flush();\n                 RevWalk revWalk \u003d new RevWalk(repo);\n                 try {\n                     RevCommit revCommit \u003d revWalk.parseCommit(commitId);\n                     RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                     ru.setNewObjectId(commitId);\n                     ru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(), false);\n                     ru.setExpectedOldObjectId(headId);\n                     Result rc \u003d ru.update();\n                     switch(rc) {\n                         case NEW:\n                         case FAST_FORWARD:\n                             {\n                                 setCallable(false);\n                                 if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n                                     repo.writeMergeCommitMsg(null);\n                                     repo.writeMergeHeads(null);\n                                 }\n                                 return revCommit;\n                             }\n                         case REJECTED:\n                         case LOCK_FAILURE:\n                             throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                         default:\n                             throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                     }\n                 } finally {\n                     revWalk.release();\n                 }\n             } finally {\n                 odi.release();\n             }\n         } finally {\n             index.unlock();\n         }\n     } catch (UnmergedPathException e) {\n         throw e;\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link Commit} object representing the successful commit\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathException\n            when the current index contained unmerged pathes (conflicts)\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n@throws JGitInternalException\n            a low-level exception of JGit has occurred. The original\n            exception can be retrieved by calling\n            {@link Exception#getCause()}. Expect only\n            {@code IOException\u0027s} to be wrapped. Subclasses of\n            {@link IOException} (e.g. {@link UnmergedPathException}) are\n            typically not wrapped here but thrown as original exception\n",
            "newValue": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link RevCommit} object representing the successful commit.\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathException\n            when the current index contained unmerged pathes (conflicts)\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n@throws JGitInternalException\n            a low-level exception of JGit has occurred. The original\n            exception can be retrieved by calling\n            {@link Exception#getCause()}. Expect only\n            {@code IOException\u0027s} to be wrapped. Subclasses of\n            {@link IOException} (e.g. {@link UnmergedPathException}) are\n            typically not wrapped here but thrown as original exception\n"
          }
        }
      ]
    },
    "b46b635c0389e01a55b2f9c490e5b6c54a8ce640": {
      "type": "Ybodychange",
      "commitMessage": "Make Commit class only for writing\n\nThe Commit class now only supports the creation of a commit object.\nTo read a commit, applictions should use RevCommit.  This permits\nus to have exactly one implementation, and RevCommit\u0027s is faster\nand more bug-free.\n\nChange-Id: Ib573f7e15f36855112815269385c21dea532e2cf\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010/8/21 上午8:38",
      "commitName": "b46b635c0389e01a55b2f9c490e5b6c54a8ce640",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2010/8/4 下午7:53",
      "commitNameOld": "ab57af08e83d5d042bb954ad280389b34ca36d0e",
      "commitAuthorOld": "Stefan Lay",
      "daysBetweenCommits": 16.53,
      "commitsBetweenForRepo": 28,
      "commitsBetweenForFile": 1,
      "actualSource": "public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n    checkCallable();\n    RepositoryState state \u003d repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n            Git git \u003d new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId !\u003d null)\n            parents.add(0, headId);\n        DirCache index \u003d repo.lockDirCache();\n        try {\n            ObjectInserter odi \u003d repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId \u003d index.writeTree(odi);\n                Commit commit \u003d new Commit();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId \u003d odi.insert(Constants.OBJ_COMMIT, odi.format(commit));\n                odi.flush();\n                RevWalk revWalk \u003d new RevWalk(repo);\n                try {\n                    RevCommit revCommit \u003d revWalk.parseCommit(commitId);\n                    RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                    ru.setNewObjectId(commitId);\n                    ru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(), false);\n                    ru.setExpectedOldObjectId(headId);\n                    Result rc \u003d ru.update();\n                    switch(rc) {\n                        case NEW:\n                        case FAST_FORWARD:\n                            {\n                                setCallable(false);\n                                if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeMergeHeads(null);\n                                }\n                                return revCommit;\n                            }\n                        case REJECTED:\n                        case LOCK_FAILURE:\n                            throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                        default:\n                            throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                    }\n                } finally {\n                    revWalk.release();\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw e;\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 120,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link Commit} object representing the successful commit\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathException\n            when the current index contained unmerged pathes (conflicts)\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n@throws JGitInternalException\n            a low-level exception of JGit has occurred. The original\n            exception can be retrieved by calling\n            {@link Exception#getCause()}. Expect only\n            {@code IOException\u0027s} to be wrapped. Subclasses of\n            {@link IOException} (e.g. {@link UnmergedPathException}) are\n            typically not wrapped here but thrown as original exception\n",
      "diff": "@@ -1,74 +1,74 @@\n public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n     checkCallable();\n     RepositoryState state \u003d repo.getRepositoryState();\n     if (!state.canCommit())\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n     processOptions(state);\n     try {\n         if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n             Git git \u003d new Git(repo);\n             try {\n                 git.add().addFilepattern(\".\").setUpdate(true).call();\n             } catch (NoFilepatternException e) {\n                 throw new JGitInternalException(e.getMessage(), e);\n             }\n         }\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n         if (headId !\u003d null)\n             parents.add(0, headId);\n         DirCache index \u003d repo.lockDirCache();\n         try {\n             ObjectInserter odi \u003d repo.newObjectInserter();\n             try {\n                 ObjectId indexTreeId \u003d index.writeTree(odi);\n-                Commit commit \u003d new Commit(repo);\n+                Commit commit \u003d new Commit();\n                 commit.setCommitter(committer);\n                 commit.setAuthor(author);\n                 commit.setMessage(message);\n-                commit.setParentIds(parents.toArray(new ObjectId[] {}));\n+                commit.setParentIds(parents);\n                 commit.setTreeId(indexTreeId);\n                 ObjectId commitId \u003d odi.insert(Constants.OBJ_COMMIT, odi.format(commit));\n                 odi.flush();\n                 RevWalk revWalk \u003d new RevWalk(repo);\n                 try {\n                     RevCommit revCommit \u003d revWalk.parseCommit(commitId);\n                     RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                     ru.setNewObjectId(commitId);\n                     ru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(), false);\n                     ru.setExpectedOldObjectId(headId);\n                     Result rc \u003d ru.update();\n                     switch(rc) {\n                         case NEW:\n                         case FAST_FORWARD:\n                             {\n                                 setCallable(false);\n                                 if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n                                     repo.writeMergeCommitMsg(null);\n                                     repo.writeMergeHeads(null);\n                                 }\n                                 return revCommit;\n                             }\n                         case REJECTED:\n                         case LOCK_FAILURE:\n                             throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                         default:\n                             throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                     }\n                 } finally {\n                     revWalk.release();\n                 }\n             } finally {\n                 odi.release();\n             }\n         } finally {\n             index.unlock();\n         }\n     } catch (UnmergedPathException e) {\n         throw e;\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ab57af08e83d5d042bb954ad280389b34ca36d0e": {
      "type": "Ybodychange",
      "commitMessage": "Add \"all\" parameter to the commit Command\n\nWhen the add parameter is set all modified and deleted files\nare staged prior to commit.\n\nChange-Id: Id23bc25730fcdd151386cd495a7cdc0935cbc00b\nSigned-off-by: Stefan Lay \u003cstefan.lay@sap.com\u003e\n",
      "commitDate": "2010/8/4 下午7:53",
      "commitName": "ab57af08e83d5d042bb954ad280389b34ca36d0e",
      "commitAuthor": "Stefan Lay",
      "commitDateOld": "2010/7/29 下午9:12",
      "commitNameOld": "94207f0a43a44261b8170d3cdba3028059775d9d",
      "commitAuthorOld": "Christian Halstrick",
      "daysBetweenCommits": 5.95,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n    checkCallable();\n    RepositoryState state \u003d repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n            Git git \u003d new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId !\u003d null)\n            parents.add(0, headId);\n        DirCache index \u003d repo.lockDirCache();\n        try {\n            ObjectInserter odi \u003d repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId \u003d index.writeTree(odi);\n                Commit commit \u003d new Commit(repo);\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents.toArray(new ObjectId[] {}));\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId \u003d odi.insert(Constants.OBJ_COMMIT, odi.format(commit));\n                odi.flush();\n                RevWalk revWalk \u003d new RevWalk(repo);\n                try {\n                    RevCommit revCommit \u003d revWalk.parseCommit(commitId);\n                    RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                    ru.setNewObjectId(commitId);\n                    ru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(), false);\n                    ru.setExpectedOldObjectId(headId);\n                    Result rc \u003d ru.update();\n                    switch(rc) {\n                        case NEW:\n                        case FAST_FORWARD:\n                            {\n                                setCallable(false);\n                                if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeMergeHeads(null);\n                                }\n                                return revCommit;\n                            }\n                        case REJECTED:\n                        case LOCK_FAILURE:\n                            throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                        default:\n                            throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                    }\n                } finally {\n                    revWalk.release();\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw e;\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 120,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link Commit} object representing the successful commit\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathException\n            when the current index contained unmerged pathes (conflicts)\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n@throws JGitInternalException\n            a low-level exception of JGit has occurred. The original\n            exception can be retrieved by calling\n            {@link Exception#getCause()}. Expect only\n            {@code IOException\u0027s} to be wrapped. Subclasses of\n            {@link IOException} (e.g. {@link UnmergedPathException}) are\n            typically not wrapped here but thrown as original exception\n",
      "diff": "@@ -1,66 +1,74 @@\n public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n     checkCallable();\n     RepositoryState state \u003d repo.getRepositoryState();\n     if (!state.canCommit())\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n     processOptions(state);\n     try {\n+        if (all \u0026\u0026 !repo.isBare() \u0026\u0026 repo.getWorkTree() !\u003d null) {\n+            Git git \u003d new Git(repo);\n+            try {\n+                git.add().addFilepattern(\".\").setUpdate(true).call();\n+            } catch (NoFilepatternException e) {\n+                throw new JGitInternalException(e.getMessage(), e);\n+            }\n+        }\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n         if (headId !\u003d null)\n             parents.add(0, headId);\n         DirCache index \u003d repo.lockDirCache();\n         try {\n             ObjectInserter odi \u003d repo.newObjectInserter();\n             try {\n                 ObjectId indexTreeId \u003d index.writeTree(odi);\n                 Commit commit \u003d new Commit(repo);\n                 commit.setCommitter(committer);\n                 commit.setAuthor(author);\n                 commit.setMessage(message);\n                 commit.setParentIds(parents.toArray(new ObjectId[] {}));\n                 commit.setTreeId(indexTreeId);\n                 ObjectId commitId \u003d odi.insert(Constants.OBJ_COMMIT, odi.format(commit));\n                 odi.flush();\n                 RevWalk revWalk \u003d new RevWalk(repo);\n                 try {\n                     RevCommit revCommit \u003d revWalk.parseCommit(commitId);\n                     RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                     ru.setNewObjectId(commitId);\n                     ru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(), false);\n                     ru.setExpectedOldObjectId(headId);\n                     Result rc \u003d ru.update();\n                     switch(rc) {\n                         case NEW:\n                         case FAST_FORWARD:\n                             {\n                                 setCallable(false);\n                                 if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n                                     repo.writeMergeCommitMsg(null);\n                                     repo.writeMergeHeads(null);\n                                 }\n                                 return revCommit;\n                             }\n                         case REJECTED:\n                         case LOCK_FAILURE:\n                             throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                         default:\n                             throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                     }\n                 } finally {\n                     revWalk.release();\n                 }\n             } finally {\n                 odi.release();\n             }\n         } finally {\n             index.unlock();\n         }\n     } catch (UnmergedPathException e) {\n         throw e;\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "94207f0a43a44261b8170d3cdba3028059775d9d": {
      "type": "Ybodychange",
      "commitMessage": "Make use of Repository.writeMerge...()\n\nThe CommitCommand should not use java.io to delete MERGE_HEAD and MERGE_MSG\nfiles since Repository already has utility methods for that.\n\nChange-Id: If66a419349b95510e5b5c2237a91f06c1d5ba0d4\nSigned-off-by: Christian Halstrick \u003cchristian.halstrick@sap.com\u003e\n",
      "commitDate": "2010/7/29 下午9:12",
      "commitName": "94207f0a43a44261b8170d3cdba3028059775d9d",
      "commitAuthor": "Christian Halstrick",
      "commitDateOld": "2010/7/1 上午1:39",
      "commitNameOld": "a1d5f5b6b526d086a0963c634a38edb6789a4594",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 28.81,
      "commitsBetweenForRepo": 97,
      "commitsBetweenForFile": 1,
      "actualSource": "public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n    checkCallable();\n    RepositoryState state \u003d repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId !\u003d null)\n            parents.add(0, headId);\n        DirCache index \u003d repo.lockDirCache();\n        try {\n            ObjectInserter odi \u003d repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId \u003d index.writeTree(odi);\n                Commit commit \u003d new Commit(repo);\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents.toArray(new ObjectId[] {}));\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId \u003d odi.insert(Constants.OBJ_COMMIT, odi.format(commit));\n                odi.flush();\n                RevWalk revWalk \u003d new RevWalk(repo);\n                try {\n                    RevCommit revCommit \u003d revWalk.parseCommit(commitId);\n                    RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                    ru.setNewObjectId(commitId);\n                    ru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(), false);\n                    ru.setExpectedOldObjectId(headId);\n                    Result rc \u003d ru.update();\n                    switch(rc) {\n                        case NEW:\n                        case FAST_FORWARD:\n                            {\n                                setCallable(false);\n                                if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeMergeHeads(null);\n                                }\n                                return revCommit;\n                            }\n                        case REJECTED:\n                        case LOCK_FAILURE:\n                            throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                        default:\n                            throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                    }\n                } finally {\n                    revWalk.release();\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw e;\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 118,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link Commit} object representing the successful commit\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathException\n            when the current index contained unmerged pathes (conflicts)\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n@throws JGitInternalException\n            a low-level exception of JGit has occurred. The original\n            exception can be retrieved by calling\n            {@link Exception#getCause()}. Expect only\n            {@code IOException\u0027s} to be wrapped. Subclasses of\n            {@link IOException} (e.g. {@link UnmergedPathException}) are\n            typically not wrapped here but thrown as original exception\n",
      "diff": "@@ -1,67 +1,66 @@\n public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n     checkCallable();\n     RepositoryState state \u003d repo.getRepositoryState();\n     if (!state.canCommit())\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n     processOptions(state);\n     try {\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n         if (headId !\u003d null)\n             parents.add(0, headId);\n         DirCache index \u003d repo.lockDirCache();\n         try {\n             ObjectInserter odi \u003d repo.newObjectInserter();\n             try {\n                 ObjectId indexTreeId \u003d index.writeTree(odi);\n                 Commit commit \u003d new Commit(repo);\n                 commit.setCommitter(committer);\n                 commit.setAuthor(author);\n                 commit.setMessage(message);\n                 commit.setParentIds(parents.toArray(new ObjectId[] {}));\n                 commit.setTreeId(indexTreeId);\n                 ObjectId commitId \u003d odi.insert(Constants.OBJ_COMMIT, odi.format(commit));\n                 odi.flush();\n                 RevWalk revWalk \u003d new RevWalk(repo);\n                 try {\n                     RevCommit revCommit \u003d revWalk.parseCommit(commitId);\n                     RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                     ru.setNewObjectId(commitId);\n                     ru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(), false);\n                     ru.setExpectedOldObjectId(headId);\n                     Result rc \u003d ru.update();\n                     switch(rc) {\n                         case NEW:\n                         case FAST_FORWARD:\n                             {\n                                 setCallable(false);\n-                                File meta \u003d repo.getDirectory();\n-                                if (state \u003d\u003d RepositoryState.MERGING_RESOLVED \u0026\u0026 meta !\u003d null) {\n-                                    new File(meta, Constants.MERGE_HEAD).delete();\n-                                    new File(meta, Constants.MERGE_MSG).delete();\n+                                if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n+                                    repo.writeMergeCommitMsg(null);\n+                                    repo.writeMergeHeads(null);\n                                 }\n                                 return revCommit;\n                             }\n                         case REJECTED:\n                         case LOCK_FAILURE:\n                             throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                         default:\n                             throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                     }\n                 } finally {\n                     revWalk.release();\n                 }\n             } finally {\n                 odi.release();\n             }\n         } finally {\n             index.unlock();\n         }\n     } catch (UnmergedPathException e) {\n         throw e;\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a1d5f5b6b526d086a0963c634a38edb6789a4594": {
      "type": "Ybodychange",
      "commitMessage": "Move DirCache factory methods to Repository\n\nInstead of creating the DirCache from a static factory method, use\nan instance method on Repository, permitting the implementation to\noverride the method with a completely different type of DirCache\nreading and writing.  This would better support a repository in the\ncloud strategy, or even just an in-memory unit test environment.\n\nChange-Id: I6399894b12d6480c4b3ac84d10775dfd1b8d13e7\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010/7/1 上午1:39",
      "commitName": "a1d5f5b6b526d086a0963c634a38edb6789a4594",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2010/6/30 上午6:12",
      "commitNameOld": "515deaf7e503738b4c53c3c2dfd6d7acab3bef18",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 0.81,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n    checkCallable();\n    RepositoryState state \u003d repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId !\u003d null)\n            parents.add(0, headId);\n        DirCache index \u003d repo.lockDirCache();\n        try {\n            ObjectInserter odi \u003d repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId \u003d index.writeTree(odi);\n                Commit commit \u003d new Commit(repo);\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents.toArray(new ObjectId[] {}));\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId \u003d odi.insert(Constants.OBJ_COMMIT, odi.format(commit));\n                odi.flush();\n                RevWalk revWalk \u003d new RevWalk(repo);\n                try {\n                    RevCommit revCommit \u003d revWalk.parseCommit(commitId);\n                    RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                    ru.setNewObjectId(commitId);\n                    ru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(), false);\n                    ru.setExpectedOldObjectId(headId);\n                    Result rc \u003d ru.update();\n                    switch(rc) {\n                        case NEW:\n                        case FAST_FORWARD:\n                            {\n                                setCallable(false);\n                                File meta \u003d repo.getDirectory();\n                                if (state \u003d\u003d RepositoryState.MERGING_RESOLVED \u0026\u0026 meta !\u003d null) {\n                                    new File(meta, Constants.MERGE_HEAD).delete();\n                                    new File(meta, Constants.MERGE_MSG).delete();\n                                }\n                                return revCommit;\n                            }\n                        case REJECTED:\n                        case LOCK_FAILURE:\n                            throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                        default:\n                            throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                    }\n                } finally {\n                    revWalk.release();\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw e;\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 119,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link Commit} object representing the successful commit\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathException\n            when the current index contained unmerged pathes (conflicts)\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n@throws JGitInternalException\n            a low-level exception of JGit has occurred. The original\n            exception can be retrieved by calling\n            {@link Exception#getCause()}. Expect only\n            {@code IOException\u0027s} to be wrapped. Subclasses of\n            {@link IOException} (e.g. {@link UnmergedPathException}) are\n            typically not wrapped here but thrown as original exception\n",
      "diff": "@@ -1,67 +1,67 @@\n public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n     checkCallable();\n     RepositoryState state \u003d repo.getRepositoryState();\n     if (!state.canCommit())\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n     processOptions(state);\n     try {\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n         if (headId !\u003d null)\n             parents.add(0, headId);\n-        DirCache index \u003d DirCache.lock(repo);\n+        DirCache index \u003d repo.lockDirCache();\n         try {\n             ObjectInserter odi \u003d repo.newObjectInserter();\n             try {\n                 ObjectId indexTreeId \u003d index.writeTree(odi);\n                 Commit commit \u003d new Commit(repo);\n                 commit.setCommitter(committer);\n                 commit.setAuthor(author);\n                 commit.setMessage(message);\n                 commit.setParentIds(parents.toArray(new ObjectId[] {}));\n                 commit.setTreeId(indexTreeId);\n                 ObjectId commitId \u003d odi.insert(Constants.OBJ_COMMIT, odi.format(commit));\n                 odi.flush();\n                 RevWalk revWalk \u003d new RevWalk(repo);\n                 try {\n                     RevCommit revCommit \u003d revWalk.parseCommit(commitId);\n                     RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                     ru.setNewObjectId(commitId);\n                     ru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(), false);\n                     ru.setExpectedOldObjectId(headId);\n                     Result rc \u003d ru.update();\n                     switch(rc) {\n                         case NEW:\n                         case FAST_FORWARD:\n                             {\n                                 setCallable(false);\n                                 File meta \u003d repo.getDirectory();\n                                 if (state \u003d\u003d RepositoryState.MERGING_RESOLVED \u0026\u0026 meta !\u003d null) {\n                                     new File(meta, Constants.MERGE_HEAD).delete();\n                                     new File(meta, Constants.MERGE_MSG).delete();\n                                 }\n                                 return revCommit;\n                             }\n                         case REJECTED:\n                         case LOCK_FAILURE:\n                             throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                         default:\n                             throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                     }\n                 } finally {\n                     revWalk.release();\n                 }\n             } finally {\n                 odi.release();\n             }\n         } finally {\n             index.unlock();\n         }\n     } catch (UnmergedPathException e) {\n         throw e;\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "515deaf7e503738b4c53c3c2dfd6d7acab3bef18": {
      "type": "Ybodychange",
      "commitMessage": "Ensure RevWalk is released when done\n\nUpdate a number of calling sites of RevWalk to ensure the walker\u0027s\ninternal ObjectReader is released after the walk is no longer used.\nBecause the ObjectReader is likely to hold onto a native resource\nlike an Inflater, we don\u0027t want to leak them outside of their\nuseful scope.\n\nWhere possible we also try to share ObjectReaders across several\nwalk pools, or between a walker and a PackWriter.  This permits\nthe ObjectReader to actually do some caching if it felt inclined\nto do so.\n\nNot everything was updated, we\u0027ll probably need to come back and\nupdate even more call sites, but these are some of the biggest\noffenders.  Test cases in particular aren\u0027t updated.  My plan is to\nmove most storage-agnostic tests onto some purely in-memory storage\nsolution that doesn\u0027t do compression.\n\nChange-Id: I04087ec79faeea208b19848939898ad7172b6672\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010/6/30 上午6:12",
      "commitName": "515deaf7e503738b4c53c3c2dfd6d7acab3bef18",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2010/6/26 上午9:03",
      "commitNameOld": "ffe0614d4db653cbcd48c19e9f599fd87cdcfaba",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 3.88,
      "commitsBetweenForRepo": 30,
      "commitsBetweenForFile": 1,
      "actualSource": "public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n    checkCallable();\n    RepositoryState state \u003d repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId !\u003d null)\n            parents.add(0, headId);\n        DirCache index \u003d DirCache.lock(repo);\n        try {\n            ObjectInserter odi \u003d repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId \u003d index.writeTree(odi);\n                Commit commit \u003d new Commit(repo);\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents.toArray(new ObjectId[] {}));\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId \u003d odi.insert(Constants.OBJ_COMMIT, odi.format(commit));\n                odi.flush();\n                RevWalk revWalk \u003d new RevWalk(repo);\n                try {\n                    RevCommit revCommit \u003d revWalk.parseCommit(commitId);\n                    RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                    ru.setNewObjectId(commitId);\n                    ru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(), false);\n                    ru.setExpectedOldObjectId(headId);\n                    Result rc \u003d ru.update();\n                    switch(rc) {\n                        case NEW:\n                        case FAST_FORWARD:\n                            {\n                                setCallable(false);\n                                File meta \u003d repo.getDirectory();\n                                if (state \u003d\u003d RepositoryState.MERGING_RESOLVED \u0026\u0026 meta !\u003d null) {\n                                    new File(meta, Constants.MERGE_HEAD).delete();\n                                    new File(meta, Constants.MERGE_MSG).delete();\n                                }\n                                return revCommit;\n                            }\n                        case REJECTED:\n                        case LOCK_FAILURE:\n                            throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                        default:\n                            throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                    }\n                } finally {\n                    revWalk.release();\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw e;\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 119,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link Commit} object representing the successful commit\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathException\n            when the current index contained unmerged pathes (conflicts)\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n@throws JGitInternalException\n            a low-level exception of JGit has occurred. The original\n            exception can be retrieved by calling\n            {@link Exception#getCause()}. Expect only\n            {@code IOException\u0027s} to be wrapped. Subclasses of\n            {@link IOException} (e.g. {@link UnmergedPathException}) are\n            typically not wrapped here but thrown as original exception\n",
      "diff": "@@ -1,62 +1,67 @@\n public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n     checkCallable();\n     RepositoryState state \u003d repo.getRepositoryState();\n     if (!state.canCommit())\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n     processOptions(state);\n     try {\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n         if (headId !\u003d null)\n             parents.add(0, headId);\n         DirCache index \u003d DirCache.lock(repo);\n         try {\n             ObjectInserter odi \u003d repo.newObjectInserter();\n             try {\n                 ObjectId indexTreeId \u003d index.writeTree(odi);\n                 Commit commit \u003d new Commit(repo);\n                 commit.setCommitter(committer);\n                 commit.setAuthor(author);\n                 commit.setMessage(message);\n                 commit.setParentIds(parents.toArray(new ObjectId[] {}));\n                 commit.setTreeId(indexTreeId);\n                 ObjectId commitId \u003d odi.insert(Constants.OBJ_COMMIT, odi.format(commit));\n                 odi.flush();\n-                RevCommit revCommit \u003d new RevWalk(repo).parseCommit(commitId);\n-                RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n-                ru.setNewObjectId(commitId);\n-                ru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(), false);\n-                ru.setExpectedOldObjectId(headId);\n-                Result rc \u003d ru.update();\n-                switch(rc) {\n-                    case NEW:\n-                    case FAST_FORWARD:\n-                        {\n-                            setCallable(false);\n-                            File meta \u003d repo.getDirectory();\n-                            if (state \u003d\u003d RepositoryState.MERGING_RESOLVED \u0026\u0026 meta !\u003d null) {\n-                                new File(meta, Constants.MERGE_HEAD).delete();\n-                                new File(meta, Constants.MERGE_MSG).delete();\n+                RevWalk revWalk \u003d new RevWalk(repo);\n+                try {\n+                    RevCommit revCommit \u003d revWalk.parseCommit(commitId);\n+                    RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n+                    ru.setNewObjectId(commitId);\n+                    ru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(), false);\n+                    ru.setExpectedOldObjectId(headId);\n+                    Result rc \u003d ru.update();\n+                    switch(rc) {\n+                        case NEW:\n+                        case FAST_FORWARD:\n+                            {\n+                                setCallable(false);\n+                                File meta \u003d repo.getDirectory();\n+                                if (state \u003d\u003d RepositoryState.MERGING_RESOLVED \u0026\u0026 meta !\u003d null) {\n+                                    new File(meta, Constants.MERGE_HEAD).delete();\n+                                    new File(meta, Constants.MERGE_MSG).delete();\n+                                }\n+                                return revCommit;\n                             }\n-                            return revCommit;\n-                        }\n-                    case REJECTED:\n-                    case LOCK_FAILURE:\n-                        throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n-                    default:\n-                        throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n+                        case REJECTED:\n+                        case LOCK_FAILURE:\n+                            throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n+                        default:\n+                            throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n+                    }\n+                } finally {\n+                    revWalk.release();\n                 }\n             } finally {\n                 odi.release();\n             }\n         } finally {\n             index.unlock();\n         }\n     } catch (UnmergedPathException e) {\n         throw e;\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ffe0614d4db653cbcd48c19e9f599fd87cdcfaba": {
      "type": "Ybodychange",
      "commitMessage": "Allow Repository.getDirectory() to be null\n\nSome types of repositories might not be stored on local disk.  For\nthese, they will most likely return null for getDirectory() as the\njava.io.File type cannot describe where their storage is, its not\nin the host\u0027s filesystem.\n\nDocument that getDirectory() can return null now, and update all\ncurrent non-test callers in JGit that might run into problems on\nsuch repositories.  For the most part, just act like its bare.\n\nChange-Id: I061236a691372a267fd7d41f0550650e165d2066\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010/6/26 上午9:03",
      "commitName": "ffe0614d4db653cbcd48c19e9f599fd87cdcfaba",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2010/6/26 上午8:46",
      "commitNameOld": "88530a179e2ddfa81de5cc441a27d66521334608",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n    checkCallable();\n    RepositoryState state \u003d repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId !\u003d null)\n            parents.add(0, headId);\n        DirCache index \u003d DirCache.lock(repo);\n        try {\n            ObjectInserter odi \u003d repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId \u003d index.writeTree(odi);\n                Commit commit \u003d new Commit(repo);\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents.toArray(new ObjectId[] {}));\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId \u003d odi.insert(Constants.OBJ_COMMIT, odi.format(commit));\n                odi.flush();\n                RevCommit revCommit \u003d new RevWalk(repo).parseCommit(commitId);\n                RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                ru.setNewObjectId(commitId);\n                ru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(), false);\n                ru.setExpectedOldObjectId(headId);\n                Result rc \u003d ru.update();\n                switch(rc) {\n                    case NEW:\n                    case FAST_FORWARD:\n                        {\n                            setCallable(false);\n                            File meta \u003d repo.getDirectory();\n                            if (state \u003d\u003d RepositoryState.MERGING_RESOLVED \u0026\u0026 meta !\u003d null) {\n                                new File(meta, Constants.MERGE_HEAD).delete();\n                                new File(meta, Constants.MERGE_MSG).delete();\n                            }\n                            return revCommit;\n                        }\n                    case REJECTED:\n                    case LOCK_FAILURE:\n                        throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                    default:\n                        throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw e;\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 119,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link Commit} object representing the successful commit\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathException\n            when the current index contained unmerged pathes (conflicts)\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n@throws JGitInternalException\n            a low-level exception of JGit has occurred. The original\n            exception can be retrieved by calling\n            {@link Exception#getCause()}. Expect only\n            {@code IOException\u0027s} to be wrapped. Subclasses of\n            {@link IOException} (e.g. {@link UnmergedPathException}) are\n            typically not wrapped here but thrown as original exception\n",
      "diff": "@@ -1,59 +1,62 @@\n public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n     checkCallable();\n     RepositoryState state \u003d repo.getRepositoryState();\n     if (!state.canCommit())\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n     processOptions(state);\n     try {\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n         if (headId !\u003d null)\n             parents.add(0, headId);\n         DirCache index \u003d DirCache.lock(repo);\n         try {\n             ObjectInserter odi \u003d repo.newObjectInserter();\n             try {\n                 ObjectId indexTreeId \u003d index.writeTree(odi);\n                 Commit commit \u003d new Commit(repo);\n                 commit.setCommitter(committer);\n                 commit.setAuthor(author);\n                 commit.setMessage(message);\n                 commit.setParentIds(parents.toArray(new ObjectId[] {}));\n                 commit.setTreeId(indexTreeId);\n                 ObjectId commitId \u003d odi.insert(Constants.OBJ_COMMIT, odi.format(commit));\n                 odi.flush();\n                 RevCommit revCommit \u003d new RevWalk(repo).parseCommit(commitId);\n                 RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                 ru.setNewObjectId(commitId);\n                 ru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(), false);\n                 ru.setExpectedOldObjectId(headId);\n                 Result rc \u003d ru.update();\n                 switch(rc) {\n                     case NEW:\n                     case FAST_FORWARD:\n-                        setCallable(false);\n-                        if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n-                            new File(repo.getDirectory(), Constants.MERGE_HEAD).delete();\n-                            new File(repo.getDirectory(), Constants.MERGE_MSG).delete();\n+                        {\n+                            setCallable(false);\n+                            File meta \u003d repo.getDirectory();\n+                            if (state \u003d\u003d RepositoryState.MERGING_RESOLVED \u0026\u0026 meta !\u003d null) {\n+                                new File(meta, Constants.MERGE_HEAD).delete();\n+                                new File(meta, Constants.MERGE_MSG).delete();\n+                            }\n+                            return revCommit;\n                         }\n-                        return revCommit;\n                     case REJECTED:\n                     case LOCK_FAILURE:\n                         throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                     default:\n                         throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                 }\n             } finally {\n                 odi.release();\n             }\n         } finally {\n             index.unlock();\n         }\n     } catch (UnmergedPathException e) {\n         throw e;\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "88530a179e2ddfa81de5cc441a27d66521334608": {
      "type": "Ybodychange",
      "commitMessage": "Start using ObjectInserter instead of ObjectWriter\n\nSome newer style APIs are updated to use the newer ObjectInserter\ninterface instead of the now deprecated ObjectWriter.  In many of\nthe unit tests we don\u0027t bother to release the inserter, these are\ntypically using the file backend which doesn\u0027t need a release,\nbut in the future should use an in-memory HashMap based store,\nwhich really wouldn\u0027t need it either.\n\nChange-Id: I91a15e1dc42da68e6715397814e30fbd87fa2e73\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010/6/26 上午8:46",
      "commitName": "88530a179e2ddfa81de5cc441a27d66521334608",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2010/5/21 上午7:49",
      "commitNameOld": "6ca9843f3ebbea152969a8b795efce1d4ff15dbf",
      "commitAuthorOld": "Christian Halstrick",
      "daysBetweenCommits": 36.04,
      "commitsBetweenForRepo": 75,
      "commitsBetweenForFile": 1,
      "actualSource": "public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n    checkCallable();\n    RepositoryState state \u003d repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId !\u003d null)\n            parents.add(0, headId);\n        DirCache index \u003d DirCache.lock(repo);\n        try {\n            ObjectInserter odi \u003d repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId \u003d index.writeTree(odi);\n                Commit commit \u003d new Commit(repo);\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents.toArray(new ObjectId[] {}));\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId \u003d odi.insert(Constants.OBJ_COMMIT, odi.format(commit));\n                odi.flush();\n                RevCommit revCommit \u003d new RevWalk(repo).parseCommit(commitId);\n                RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n                ru.setNewObjectId(commitId);\n                ru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(), false);\n                ru.setExpectedOldObjectId(headId);\n                Result rc \u003d ru.update();\n                switch(rc) {\n                    case NEW:\n                    case FAST_FORWARD:\n                        setCallable(false);\n                        if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n                            new File(repo.getDirectory(), Constants.MERGE_HEAD).delete();\n                            new File(repo.getDirectory(), Constants.MERGE_MSG).delete();\n                        }\n                        return revCommit;\n                    case REJECTED:\n                    case LOCK_FAILURE:\n                        throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                    default:\n                        throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw e;\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 119,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link Commit} object representing the successful commit\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathException\n            when the current index contained unmerged pathes (conflicts)\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n@throws JGitInternalException\n            a low-level exception of JGit has occurred. The original\n            exception can be retrieved by calling\n            {@link Exception#getCause()}. Expect only\n            {@code IOException\u0027s} to be wrapped. Subclasses of\n            {@link IOException} (e.g. {@link UnmergedPathException}) are\n            typically not wrapped here but thrown as original exception\n",
      "diff": "@@ -1,54 +1,59 @@\n public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n     checkCallable();\n     RepositoryState state \u003d repo.getRepositoryState();\n     if (!state.canCommit())\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n     processOptions(state);\n     try {\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n         if (headId !\u003d null)\n             parents.add(0, headId);\n         DirCache index \u003d DirCache.lock(repo);\n         try {\n-            ObjectWriter repoWriter \u003d new ObjectWriter(repo);\n-            ObjectId indexTreeId \u003d index.writeTree(repoWriter);\n-            Commit commit \u003d new Commit(repo);\n-            commit.setCommitter(committer);\n-            commit.setAuthor(author);\n-            commit.setMessage(message);\n-            commit.setParentIds(parents.toArray(new ObjectId[] {}));\n-            commit.setTreeId(indexTreeId);\n-            ObjectId commitId \u003d repoWriter.writeCommit(commit);\n-            RevCommit revCommit \u003d new RevWalk(repo).parseCommit(commitId);\n-            RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n-            ru.setNewObjectId(commitId);\n-            ru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(), false);\n-            ru.setExpectedOldObjectId(headId);\n-            Result rc \u003d ru.update();\n-            switch(rc) {\n-                case NEW:\n-                case FAST_FORWARD:\n-                    setCallable(false);\n-                    if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n-                        new File(repo.getDirectory(), Constants.MERGE_HEAD).delete();\n-                        new File(repo.getDirectory(), Constants.MERGE_MSG).delete();\n-                    }\n-                    return revCommit;\n-                case REJECTED:\n-                case LOCK_FAILURE:\n-                    throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n-                default:\n-                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n+            ObjectInserter odi \u003d repo.newObjectInserter();\n+            try {\n+                ObjectId indexTreeId \u003d index.writeTree(odi);\n+                Commit commit \u003d new Commit(repo);\n+                commit.setCommitter(committer);\n+                commit.setAuthor(author);\n+                commit.setMessage(message);\n+                commit.setParentIds(parents.toArray(new ObjectId[] {}));\n+                commit.setTreeId(indexTreeId);\n+                ObjectId commitId \u003d odi.insert(Constants.OBJ_COMMIT, odi.format(commit));\n+                odi.flush();\n+                RevCommit revCommit \u003d new RevWalk(repo).parseCommit(commitId);\n+                RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n+                ru.setNewObjectId(commitId);\n+                ru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(), false);\n+                ru.setExpectedOldObjectId(headId);\n+                Result rc \u003d ru.update();\n+                switch(rc) {\n+                    case NEW:\n+                    case FAST_FORWARD:\n+                        setCallable(false);\n+                        if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n+                            new File(repo.getDirectory(), Constants.MERGE_HEAD).delete();\n+                            new File(repo.getDirectory(), Constants.MERGE_MSG).delete();\n+                        }\n+                        return revCommit;\n+                    case REJECTED:\n+                    case LOCK_FAILURE:\n+                        throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n+                    default:\n+                        throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n+                }\n+            } finally {\n+                odi.release();\n             }\n         } finally {\n             index.unlock();\n         }\n     } catch (UnmergedPathException e) {\n         throw e;\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6ca9843f3ebbea152969a8b795efce1d4ff15dbf": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange,Ydocchange)",
      "commitMessage": "Added merge support to CommitCommand\n\nThe CommitCommand should take care to create a merge commit if the file\n$GIT_DIR/MERGE_HEAD exists. It should then read the parents for the merge\ncommit out of this file. It should also take care that when commiting\na merge and no commit message was specified to read the message from\n$GIT_DIR/MERGE_MSG.\nFinally the CommitCommand should remove these files if the commit\nsucceeded.\n\nChange-Id: \tI4e292115085099d5b86546d2021680cb1454266c\nSigned-off-by: Christian Halstrick \u003cchristian.halstrick@sap.com\u003e\n",
      "commitDate": "2010/5/21 上午7:49",
      "commitName": "6ca9843f3ebbea152969a8b795efce1d4ff15dbf",
      "commitAuthor": "Christian Halstrick",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "Added merge support to CommitCommand\n\nThe CommitCommand should take care to create a merge commit if the file\n$GIT_DIR/MERGE_HEAD exists. It should then read the parents for the merge\ncommit out of this file. It should also take care that when commiting\na merge and no commit message was specified to read the message from\n$GIT_DIR/MERGE_MSG.\nFinally the CommitCommand should remove these files if the commit\nsucceeded.\n\nChange-Id: \tI4e292115085099d5b86546d2021680cb1454266c\nSigned-off-by: Christian Halstrick \u003cchristian.halstrick@sap.com\u003e\n",
          "commitDate": "2010/5/21 上午7:49",
          "commitName": "6ca9843f3ebbea152969a8b795efce1d4ff15dbf",
          "commitAuthor": "Christian Halstrick",
          "commitDateOld": "2010/5/20 上午5:37",
          "commitNameOld": "f3d8a8ecad614906a2c4ec0077cdb24129da6c6d",
          "commitAuthorOld": "Sasa Zivkov",
          "daysBetweenCommits": 1.09,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n    checkCallable();\n    RepositoryState state \u003d repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId !\u003d null)\n            parents.add(0, headId);\n        DirCache index \u003d DirCache.lock(repo);\n        try {\n            ObjectWriter repoWriter \u003d new ObjectWriter(repo);\n            ObjectId indexTreeId \u003d index.writeTree(repoWriter);\n            Commit commit \u003d new Commit(repo);\n            commit.setCommitter(committer);\n            commit.setAuthor(author);\n            commit.setMessage(message);\n            commit.setParentIds(parents.toArray(new ObjectId[] {}));\n            commit.setTreeId(indexTreeId);\n            ObjectId commitId \u003d repoWriter.writeCommit(commit);\n            RevCommit revCommit \u003d new RevWalk(repo).parseCommit(commitId);\n            RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n            ru.setNewObjectId(commitId);\n            ru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(), false);\n            ru.setExpectedOldObjectId(headId);\n            Result rc \u003d ru.update();\n            switch(rc) {\n                case NEW:\n                case FAST_FORWARD:\n                    setCallable(false);\n                    if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n                        new File(repo.getDirectory(), Constants.MERGE_HEAD).delete();\n                        new File(repo.getDirectory(), Constants.MERGE_MSG).delete();\n                    }\n                    return revCommit;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw e;\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
          "functionStartLine": 119,
          "functionName": "call",
          "functionAnnotation": "",
          "functionDoc": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link Commit} object representing the successful commit\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathException\n            when the current index contained unmerged pathes (conflicts)\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n@throws JGitInternalException\n            a low-level exception of JGit has occurred. The original\n            exception can be retrieved by calling\n            {@link Exception#getCause()}. Expect only\n            {@code IOException\u0027s} to be wrapped. Subclasses of\n            {@link IOException} (e.g. {@link UnmergedPathException}) are\n            typically not wrapped here but thrown as original exception\n",
          "diff": "@@ -1,46 +1,54 @@\n-public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException {\n+public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n     checkCallable();\n-    processOptions();\n+    RepositoryState state \u003d repo.getRepositoryState();\n+    if (!state.canCommit())\n+        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n+    processOptions(state);\n     try {\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n-        ObjectId parentID \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n+        ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n+        if (headId !\u003d null)\n+            parents.add(0, headId);\n         DirCache index \u003d DirCache.lock(repo);\n         try {\n             ObjectWriter repoWriter \u003d new ObjectWriter(repo);\n             ObjectId indexTreeId \u003d index.writeTree(repoWriter);\n             Commit commit \u003d new Commit(repo);\n             commit.setCommitter(committer);\n             commit.setAuthor(author);\n             commit.setMessage(message);\n-            if (parentID !\u003d null)\n-                commit.setParentIds(new ObjectId[] { parentID });\n+            commit.setParentIds(parents.toArray(new ObjectId[] {}));\n             commit.setTreeId(indexTreeId);\n             ObjectId commitId \u003d repoWriter.writeCommit(commit);\n             RevCommit revCommit \u003d new RevWalk(repo).parseCommit(commitId);\n             RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n             ru.setNewObjectId(commitId);\n             ru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(), false);\n-            ru.setExpectedOldObjectId(parentID);\n+            ru.setExpectedOldObjectId(headId);\n             Result rc \u003d ru.update();\n             switch(rc) {\n                 case NEW:\n                 case FAST_FORWARD:\n                     setCallable(false);\n+                    if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n+                        new File(repo.getDirectory(), Constants.MERGE_HEAD).delete();\n+                        new File(repo.getDirectory(), Constants.MERGE_MSG).delete();\n+                    }\n                     return revCommit;\n                 case REJECTED:\n                 case LOCK_FAILURE:\n                     throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                 default:\n                     throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n             }\n         } finally {\n             index.unlock();\n         }\n     } catch (UnmergedPathException e) {\n         throw e;\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException]",
            "newValue": "[NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Added merge support to CommitCommand\n\nThe CommitCommand should take care to create a merge commit if the file\n$GIT_DIR/MERGE_HEAD exists. It should then read the parents for the merge\ncommit out of this file. It should also take care that when commiting\na merge and no commit message was specified to read the message from\n$GIT_DIR/MERGE_MSG.\nFinally the CommitCommand should remove these files if the commit\nsucceeded.\n\nChange-Id: \tI4e292115085099d5b86546d2021680cb1454266c\nSigned-off-by: Christian Halstrick \u003cchristian.halstrick@sap.com\u003e\n",
          "commitDate": "2010/5/21 上午7:49",
          "commitName": "6ca9843f3ebbea152969a8b795efce1d4ff15dbf",
          "commitAuthor": "Christian Halstrick",
          "commitDateOld": "2010/5/20 上午5:37",
          "commitNameOld": "f3d8a8ecad614906a2c4ec0077cdb24129da6c6d",
          "commitAuthorOld": "Sasa Zivkov",
          "daysBetweenCommits": 1.09,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n    checkCallable();\n    RepositoryState state \u003d repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId !\u003d null)\n            parents.add(0, headId);\n        DirCache index \u003d DirCache.lock(repo);\n        try {\n            ObjectWriter repoWriter \u003d new ObjectWriter(repo);\n            ObjectId indexTreeId \u003d index.writeTree(repoWriter);\n            Commit commit \u003d new Commit(repo);\n            commit.setCommitter(committer);\n            commit.setAuthor(author);\n            commit.setMessage(message);\n            commit.setParentIds(parents.toArray(new ObjectId[] {}));\n            commit.setTreeId(indexTreeId);\n            ObjectId commitId \u003d repoWriter.writeCommit(commit);\n            RevCommit revCommit \u003d new RevWalk(repo).parseCommit(commitId);\n            RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n            ru.setNewObjectId(commitId);\n            ru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(), false);\n            ru.setExpectedOldObjectId(headId);\n            Result rc \u003d ru.update();\n            switch(rc) {\n                case NEW:\n                case FAST_FORWARD:\n                    setCallable(false);\n                    if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n                        new File(repo.getDirectory(), Constants.MERGE_HEAD).delete();\n                        new File(repo.getDirectory(), Constants.MERGE_MSG).delete();\n                    }\n                    return revCommit;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw e;\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
          "functionStartLine": 119,
          "functionName": "call",
          "functionAnnotation": "",
          "functionDoc": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link Commit} object representing the successful commit\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathException\n            when the current index contained unmerged pathes (conflicts)\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n@throws JGitInternalException\n            a low-level exception of JGit has occurred. The original\n            exception can be retrieved by calling\n            {@link Exception#getCause()}. Expect only\n            {@code IOException\u0027s} to be wrapped. Subclasses of\n            {@link IOException} (e.g. {@link UnmergedPathException}) are\n            typically not wrapped here but thrown as original exception\n",
          "diff": "@@ -1,46 +1,54 @@\n-public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException {\n+public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n     checkCallable();\n-    processOptions();\n+    RepositoryState state \u003d repo.getRepositoryState();\n+    if (!state.canCommit())\n+        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n+    processOptions(state);\n     try {\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n-        ObjectId parentID \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n+        ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n+        if (headId !\u003d null)\n+            parents.add(0, headId);\n         DirCache index \u003d DirCache.lock(repo);\n         try {\n             ObjectWriter repoWriter \u003d new ObjectWriter(repo);\n             ObjectId indexTreeId \u003d index.writeTree(repoWriter);\n             Commit commit \u003d new Commit(repo);\n             commit.setCommitter(committer);\n             commit.setAuthor(author);\n             commit.setMessage(message);\n-            if (parentID !\u003d null)\n-                commit.setParentIds(new ObjectId[] { parentID });\n+            commit.setParentIds(parents.toArray(new ObjectId[] {}));\n             commit.setTreeId(indexTreeId);\n             ObjectId commitId \u003d repoWriter.writeCommit(commit);\n             RevCommit revCommit \u003d new RevWalk(repo).parseCommit(commitId);\n             RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n             ru.setNewObjectId(commitId);\n             ru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(), false);\n-            ru.setExpectedOldObjectId(parentID);\n+            ru.setExpectedOldObjectId(headId);\n             Result rc \u003d ru.update();\n             switch(rc) {\n                 case NEW:\n                 case FAST_FORWARD:\n                     setCallable(false);\n+                    if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n+                        new File(repo.getDirectory(), Constants.MERGE_HEAD).delete();\n+                        new File(repo.getDirectory(), Constants.MERGE_MSG).delete();\n+                    }\n                     return revCommit;\n                 case REJECTED:\n                 case LOCK_FAILURE:\n                     throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                 default:\n                     throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n             }\n         } finally {\n             index.unlock();\n         }\n     } catch (UnmergedPathException e) {\n         throw e;\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Added merge support to CommitCommand\n\nThe CommitCommand should take care to create a merge commit if the file\n$GIT_DIR/MERGE_HEAD exists. It should then read the parents for the merge\ncommit out of this file. It should also take care that when commiting\na merge and no commit message was specified to read the message from\n$GIT_DIR/MERGE_MSG.\nFinally the CommitCommand should remove these files if the commit\nsucceeded.\n\nChange-Id: \tI4e292115085099d5b86546d2021680cb1454266c\nSigned-off-by: Christian Halstrick \u003cchristian.halstrick@sap.com\u003e\n",
          "commitDate": "2010/5/21 上午7:49",
          "commitName": "6ca9843f3ebbea152969a8b795efce1d4ff15dbf",
          "commitAuthor": "Christian Halstrick",
          "commitDateOld": "2010/5/20 上午5:37",
          "commitNameOld": "f3d8a8ecad614906a2c4ec0077cdb24129da6c6d",
          "commitAuthorOld": "Sasa Zivkov",
          "daysBetweenCommits": 1.09,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n    checkCallable();\n    RepositoryState state \u003d repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId !\u003d null)\n            parents.add(0, headId);\n        DirCache index \u003d DirCache.lock(repo);\n        try {\n            ObjectWriter repoWriter \u003d new ObjectWriter(repo);\n            ObjectId indexTreeId \u003d index.writeTree(repoWriter);\n            Commit commit \u003d new Commit(repo);\n            commit.setCommitter(committer);\n            commit.setAuthor(author);\n            commit.setMessage(message);\n            commit.setParentIds(parents.toArray(new ObjectId[] {}));\n            commit.setTreeId(indexTreeId);\n            ObjectId commitId \u003d repoWriter.writeCommit(commit);\n            RevCommit revCommit \u003d new RevWalk(repo).parseCommit(commitId);\n            RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n            ru.setNewObjectId(commitId);\n            ru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(), false);\n            ru.setExpectedOldObjectId(headId);\n            Result rc \u003d ru.update();\n            switch(rc) {\n                case NEW:\n                case FAST_FORWARD:\n                    setCallable(false);\n                    if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n                        new File(repo.getDirectory(), Constants.MERGE_HEAD).delete();\n                        new File(repo.getDirectory(), Constants.MERGE_MSG).delete();\n                    }\n                    return revCommit;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw e;\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
          "functionStartLine": 119,
          "functionName": "call",
          "functionAnnotation": "",
          "functionDoc": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link Commit} object representing the successful commit\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathException\n            when the current index contained unmerged pathes (conflicts)\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n@throws JGitInternalException\n            a low-level exception of JGit has occurred. The original\n            exception can be retrieved by calling\n            {@link Exception#getCause()}. Expect only\n            {@code IOException\u0027s} to be wrapped. Subclasses of\n            {@link IOException} (e.g. {@link UnmergedPathException}) are\n            typically not wrapped here but thrown as original exception\n",
          "diff": "@@ -1,46 +1,54 @@\n-public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException {\n+public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n     checkCallable();\n-    processOptions();\n+    RepositoryState state \u003d repo.getRepositoryState();\n+    if (!state.canCommit())\n+        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n+    processOptions(state);\n     try {\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n-        ObjectId parentID \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n+        ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n+        if (headId !\u003d null)\n+            parents.add(0, headId);\n         DirCache index \u003d DirCache.lock(repo);\n         try {\n             ObjectWriter repoWriter \u003d new ObjectWriter(repo);\n             ObjectId indexTreeId \u003d index.writeTree(repoWriter);\n             Commit commit \u003d new Commit(repo);\n             commit.setCommitter(committer);\n             commit.setAuthor(author);\n             commit.setMessage(message);\n-            if (parentID !\u003d null)\n-                commit.setParentIds(new ObjectId[] { parentID });\n+            commit.setParentIds(parents.toArray(new ObjectId[] {}));\n             commit.setTreeId(indexTreeId);\n             ObjectId commitId \u003d repoWriter.writeCommit(commit);\n             RevCommit revCommit \u003d new RevWalk(repo).parseCommit(commitId);\n             RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n             ru.setNewObjectId(commitId);\n             ru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(), false);\n-            ru.setExpectedOldObjectId(parentID);\n+            ru.setExpectedOldObjectId(headId);\n             Result rc \u003d ru.update();\n             switch(rc) {\n                 case NEW:\n                 case FAST_FORWARD:\n                     setCallable(false);\n+                    if (state \u003d\u003d RepositoryState.MERGING_RESOLVED) {\n+                        new File(repo.getDirectory(), Constants.MERGE_HEAD).delete();\n+                        new File(repo.getDirectory(), Constants.MERGE_MSG).delete();\n+                    }\n                     return revCommit;\n                 case REJECTED:\n                 case LOCK_FAILURE:\n                     throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                 default:\n                     throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n             }\n         } finally {\n             index.unlock();\n         }\n     } catch (UnmergedPathException e) {\n         throw e;\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link Commit} object representing the successful commit\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathException\n            when the current index contained unmerged pathes (conflicts)\n@throws JGitInternalException\n            a low-level exception of JGit has occurred. The original\n            exception can be retrieved by calling\n            {@link Exception#getCause()}. Expect only\n            {@code IOException\u0027s} to be wrapped. Subclasses of\n            {@link IOException} (e.g. {@link UnmergedPathException}) are\n            typically not wrapped here but thrown as original exception\n",
            "newValue": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link Commit} object representing the successful commit\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathException\n            when the current index contained unmerged pathes (conflicts)\n@throws WrongRepositoryStateException\n            when repository is not in the right state for committing\n@throws JGitInternalException\n            a low-level exception of JGit has occurred. The original\n            exception can be retrieved by calling\n            {@link Exception#getCause()}. Expect only\n            {@code IOException\u0027s} to be wrapped. Subclasses of\n            {@link IOException} (e.g. {@link UnmergedPathException}) are\n            typically not wrapped here but thrown as original exception\n"
          }
        }
      ]
    },
    "f3d8a8ecad614906a2c4ec0077cdb24129da6c6d": {
      "type": "Ybodychange",
      "commitMessage": "Externalize strings from JGit\n\nThe strings are externalized into the root resource bundles.\nThe resource bundles are stored under the new \"resources\" source\nfolder to get proper maven build.\n\nStrings from tests are, in general, not externalized. Only in\ncases where it was necessary to make the test pass the strings\nwere externalized. This was typically necessary in cases where\ne.getMessage() was used in assert and the exception message was\nslightly changed due to reuse of the externalized strings.\n\nChange-Id: Ic0f29c80b9a54fcec8320d8539a3e112852a1f7b\nSigned-off-by: Sasa Zivkov \u003csasa.zivkov@sap.com\u003e\n",
      "commitDate": "2010/5/20 上午5:37",
      "commitName": "f3d8a8ecad614906a2c4ec0077cdb24129da6c6d",
      "commitAuthor": "Sasa Zivkov",
      "commitDateOld": "2010/5/10 下午9:17",
      "commitNameOld": "f3fb5824ba45197787bc4ffb81fafcd576c60291",
      "commitAuthorOld": "Christian Halstrick",
      "daysBetweenCommits": 9.35,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "actualSource": "public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException {\n    checkCallable();\n    processOptions();\n    try {\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId parentID \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n        DirCache index \u003d DirCache.lock(repo);\n        try {\n            ObjectWriter repoWriter \u003d new ObjectWriter(repo);\n            ObjectId indexTreeId \u003d index.writeTree(repoWriter);\n            Commit commit \u003d new Commit(repo);\n            commit.setCommitter(committer);\n            commit.setAuthor(author);\n            commit.setMessage(message);\n            if (parentID !\u003d null)\n                commit.setParentIds(new ObjectId[] { parentID });\n            commit.setTreeId(indexTreeId);\n            ObjectId commitId \u003d repoWriter.writeCommit(commit);\n            RevCommit revCommit \u003d new RevWalk(repo).parseCommit(commitId);\n            RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n            ru.setNewObjectId(commitId);\n            ru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(), false);\n            ru.setExpectedOldObjectId(parentID);\n            Result rc \u003d ru.update();\n            switch(rc) {\n                case NEW:\n                case FAST_FORWARD:\n                    setCallable(false);\n                    return revCommit;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw e;\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 107,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link Commit} object representing the successful commit\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathException\n            when the current index contained unmerged pathes (conflicts)\n@throws JGitInternalException\n            a low-level exception of JGit has occurred. The original\n            exception can be retrieved by calling\n            {@link Exception#getCause()}. Expect only\n            {@code IOException\u0027s} to be wrapped. Subclasses of\n            {@link IOException} (e.g. {@link UnmergedPathException}) are\n            typically not wrapped here but thrown as original exception\n",
      "diff": "@@ -1,46 +1,46 @@\n public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException {\n     checkCallable();\n     processOptions();\n     try {\n         Ref head \u003d repo.getRef(Constants.HEAD);\n         if (head \u003d\u003d null)\n-            throw new NoHeadException(\"Commit on repo without HEAD currently not supported\");\n+            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n         ObjectId parentID \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n         DirCache index \u003d DirCache.lock(repo);\n         try {\n             ObjectWriter repoWriter \u003d new ObjectWriter(repo);\n             ObjectId indexTreeId \u003d index.writeTree(repoWriter);\n             Commit commit \u003d new Commit(repo);\n             commit.setCommitter(committer);\n             commit.setAuthor(author);\n             commit.setMessage(message);\n             if (parentID !\u003d null)\n                 commit.setParentIds(new ObjectId[] { parentID });\n             commit.setTreeId(indexTreeId);\n             ObjectId commitId \u003d repoWriter.writeCommit(commit);\n             RevCommit revCommit \u003d new RevWalk(repo).parseCommit(commitId);\n             RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n             ru.setNewObjectId(commitId);\n             ru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(), false);\n             ru.setExpectedOldObjectId(parentID);\n             Result rc \u003d ru.update();\n             switch(rc) {\n                 case NEW:\n                 case FAST_FORWARD:\n                     setCallable(false);\n                     return revCommit;\n                 case REJECTED:\n                 case LOCK_FAILURE:\n-                    throw new ConcurrentRefUpdateException(\"Could lock HEAD during commit\", ru.getRef(), rc);\n+                    throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                 default:\n-                    throw new JGitInternalException(\"Updating the ref \" + Constants.HEAD + \" to \" + commitId.toString() + \" failed. ReturnCode from RefUpdate.update() was \" + rc);\n+                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n             }\n         } finally {\n             index.unlock();\n         }\n     } catch (UnmergedPathException e) {\n         throw e;\n     } catch (IOException e) {\n-        throw new JGitInternalException(\"Exception caught during execution of commit command\", e);\n+        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f3fb5824ba45197787bc4ffb81fafcd576c60291": {
      "type": "Yintroduced",
      "commitMessage": "Add builder-style API to jgit and Commit \u0026 Log cmd\n\nAdded a new package org.eclipse.jgit.api and a builder-style API for\njgit. Added also the first implementation for two git commands: Commit\nand Log.\n\nThis API is intended to be used by external components when\nfunctionalities of the standard git commands are required. It will also\nhelp to ease writing JGit tests.\n\nFor internal usages this API may often not be optimal because the git\ncommands are doing much more than required or they expect parameters of\nan unappropriate type.\n\nChange-Id: I71ac4839ab9d2f848307eba9252090c586b4146b\nSigned-off-by: Christian Halstrick \u003cchristian.halstrick@sap.com\u003e\n",
      "commitDate": "2010/5/10 下午9:17",
      "commitName": "f3fb5824ba45197787bc4ffb81fafcd576c60291",
      "commitAuthor": "Christian Halstrick",
      "diff": "@@ -0,0 +1,46 @@\n+public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException {\n+    checkCallable();\n+    processOptions();\n+    try {\n+        Ref head \u003d repo.getRef(Constants.HEAD);\n+        if (head \u003d\u003d null)\n+            throw new NoHeadException(\"Commit on repo without HEAD currently not supported\");\n+        ObjectId parentID \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n+        DirCache index \u003d DirCache.lock(repo);\n+        try {\n+            ObjectWriter repoWriter \u003d new ObjectWriter(repo);\n+            ObjectId indexTreeId \u003d index.writeTree(repoWriter);\n+            Commit commit \u003d new Commit(repo);\n+            commit.setCommitter(committer);\n+            commit.setAuthor(author);\n+            commit.setMessage(message);\n+            if (parentID !\u003d null)\n+                commit.setParentIds(new ObjectId[] { parentID });\n+            commit.setTreeId(indexTreeId);\n+            ObjectId commitId \u003d repoWriter.writeCommit(commit);\n+            RevCommit revCommit \u003d new RevWalk(repo).parseCommit(commitId);\n+            RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n+            ru.setNewObjectId(commitId);\n+            ru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(), false);\n+            ru.setExpectedOldObjectId(parentID);\n+            Result rc \u003d ru.update();\n+            switch(rc) {\n+                case NEW:\n+                case FAST_FORWARD:\n+                    setCallable(false);\n+                    return revCommit;\n+                case REJECTED:\n+                case LOCK_FAILURE:\n+                    throw new ConcurrentRefUpdateException(\"Could lock HEAD during commit\", ru.getRef(), rc);\n+                default:\n+                    throw new JGitInternalException(\"Updating the ref \" + Constants.HEAD + \" to \" + commitId.toString() + \" failed. ReturnCode from RefUpdate.update() was \" + rc);\n+            }\n+        } finally {\n+            index.unlock();\n+        }\n+    } catch (UnmergedPathException e) {\n+        throw e;\n+    } catch (IOException e) {\n+        throw new JGitInternalException(\"Exception caught during execution of commit command\", e);\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException {\n    checkCallable();\n    processOptions();\n    try {\n        Ref head \u003d repo.getRef(Constants.HEAD);\n        if (head \u003d\u003d null)\n            throw new NoHeadException(\"Commit on repo without HEAD currently not supported\");\n        ObjectId parentID \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n        DirCache index \u003d DirCache.lock(repo);\n        try {\n            ObjectWriter repoWriter \u003d new ObjectWriter(repo);\n            ObjectId indexTreeId \u003d index.writeTree(repoWriter);\n            Commit commit \u003d new Commit(repo);\n            commit.setCommitter(committer);\n            commit.setAuthor(author);\n            commit.setMessage(message);\n            if (parentID !\u003d null)\n                commit.setParentIds(new ObjectId[] { parentID });\n            commit.setTreeId(indexTreeId);\n            ObjectId commitId \u003d repoWriter.writeCommit(commit);\n            RevCommit revCommit \u003d new RevWalk(repo).parseCommit(commitId);\n            RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n            ru.setNewObjectId(commitId);\n            ru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(), false);\n            ru.setExpectedOldObjectId(parentID);\n            Result rc \u003d ru.update();\n            switch(rc) {\n                case NEW:\n                case FAST_FORWARD:\n                    setCallable(false);\n                    return revCommit;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(\"Could lock HEAD during commit\", ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(\"Updating the ref \" + Constants.HEAD + \" to \" + commitId.toString() + \" failed. ReturnCode from RefUpdate.update() was \" + rc);\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw e;\n    } catch (IOException e) {\n        throw new JGitInternalException(\"Exception caught during execution of commit command\", e);\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
      "functionStartLine": 105,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code commit} command with all the options and parameters\ncollected by the setter methods of this class. Each instance of this\nclass should only be used for one invocation of the command (means: one\ncall to {@link #call()})\n\n@return a {@link Commit} object representing the successful commit\n@throws NoHeadException\n            when called on a git repo without a HEAD reference\n@throws NoMessageException\n            when called without specifying a commit message\n@throws UnmergedPathException\n            when the current index contained unmerged pathes (conflicts)\n@throws JGitInternalException\n            a low-level exception of JGit has occurred. The original\n            exception can be retrieved by calling\n            {@link Exception#getCause()}. Expect only\n            {@code IOException\u0027s} to be wrapped. Subclasses of\n            {@link IOException} (e.g. {@link UnmergedPathException}) are\n            typically not wrapped here but thrown as original exception\n"
    }
  }
}