{
  "origin": "codeshovel",
  "repositoryName": "jetty.project",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/jetty.project/.git",
  "startCommitName": "fc5dd874f3deda71e6cd42af994a5af5cb6be4af",
  "sourceFileName": "JsrSession.java",
  "functionName": "addMessageHandler",
  "functionId": "addMessageHandler___handler-MessageHandler",
  "sourceFilePath": "jetty-websocket/javax-websocket-client-impl/src/main/java/org/eclipse/jetty/websocket/jsr356/JsrSession.java",
  "functionAnnotation": "@Override",
  "functionDoc": "",
  "functionStartLine": 95,
  "functionEndLine": 142,
  "numCommitsSeen": 47,
  "timeTaken": 1549,
  "changeHistory": [
    "05c534275253ba65a23863b5ef976636fcd8da4c",
    "33c11dffaa86d09b33fd350f07cd9c548b7d3b7c",
    "46e9493c850d0ff2e6f30f455ad358251e1a2d48",
    "d1692733f56b7c67a885b8c9fdd14fa204c8cab6",
    "3a66b3ec3f8d608140be000dbec507ffd55a503b",
    "43231d84510fde66c4a19a5aac4782eaef15de16"
  ],
  "changeHistoryShort": {
    "05c534275253ba65a23863b5ef976636fcd8da4c": "Ybodychange",
    "33c11dffaa86d09b33fd350f07cd9c548b7d3b7c": "Ybodychange",
    "46e9493c850d0ff2e6f30f455ad358251e1a2d48": "Ymultichange(Yparameterchange,Ybodychange)",
    "d1692733f56b7c67a885b8c9fdd14fa204c8cab6": "Ybodychange",
    "3a66b3ec3f8d608140be000dbec507ffd55a503b": "Ybodychange",
    "43231d84510fde66c4a19a5aac4782eaef15de16": "Yintroduced"
  },
  "changeHistoryDetails": {
    "05c534275253ba65a23863b5ef976636fcd8da4c": {
      "type": "Ybodychange",
      "commitMessage": "JSR-356 Improving MessageHandler manipulation\n",
      "commitDate": "2013/7/16 上午7:00",
      "commitName": "05c534275253ba65a23863b5ef976636fcd8da4c",
      "commitAuthor": "Joakim Erdfelt",
      "commitDateOld": "2013/7/16 上午2:49",
      "commitNameOld": "179a78e5028b77880d96e512a7b04b39e1ef694e",
      "commitAuthorOld": "Joakim Erdfelt",
      "daysBetweenCommits": 0.17,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void addMessageHandler(MessageHandler handler) throws IllegalStateException {\n    Objects.requireNonNull(handler, \"MessageHandler cannot be null\");\n    synchronized (wrappers) {\n        for (MessageHandlerMetadata metadata : messageHandlerFactory.getMetadata(handler.getClass())) {\n            DecoderFactory.Wrapper wrapper \u003d decoderFactory.getWrapperFor(metadata.getMessageClass());\n            if (wrapper \u003d\u003d null) {\n                StringBuilder err \u003d new StringBuilder();\n                err.append(\"Unable to find decoder for type \u003c\");\n                err.append(metadata.getMessageClass().getName());\n                err.append(\"\u003e used in \u003c\");\n                err.append(metadata.getHandlerClass().getName());\n                err.append(\"\u003e\");\n                throw new IllegalStateException(err.toString());\n            }\n            MessageType key \u003d wrapper.getMetadata().getMessageType();\n            MessageHandlerWrapper other \u003d wrappers[key.ordinal()];\n            if (other !\u003d null) {\n                StringBuilder err \u003d new StringBuilder();\n                err.append(\"Encountered duplicate MessageHandler handling message type \u003c\");\n                err.append(wrapper.getMetadata().getObjectType().getName());\n                err.append(\"\u003e, \").append(metadata.getHandlerClass().getName());\n                err.append(\"\u003c\");\n                err.append(metadata.getMessageClass().getName());\n                err.append(\"\u003e and \");\n                err.append(other.getMetadata().getHandlerClass().getName());\n                err.append(\"\u003c\");\n                err.append(other.getMetadata().getMessageClass().getName());\n                err.append(\"\u003e both implement this message type\");\n                throw new IllegalStateException(err.toString());\n            } else {\n                MessageHandlerWrapper handlerWrapper \u003d new MessageHandlerWrapper(handler, metadata, wrapper);\n                wrappers[key.ordinal()] \u003d handlerWrapper;\n            }\n        }\n        updateMessageHandlerSet();\n    }\n}",
      "path": "jetty-websocket/javax-websocket-client-impl/src/main/java/org/eclipse/jetty/websocket/jsr356/JsrSession.java",
      "functionStartLine": 96,
      "functionName": "addMessageHandler",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,44 +1,38 @@\n @Override\n public void addMessageHandler(MessageHandler handler) throws IllegalStateException {\n     Objects.requireNonNull(handler, \"MessageHandler cannot be null\");\n     synchronized (wrappers) {\n         for (MessageHandlerMetadata metadata : messageHandlerFactory.getMetadata(handler.getClass())) {\n             DecoderFactory.Wrapper wrapper \u003d decoderFactory.getWrapperFor(metadata.getMessageClass());\n             if (wrapper \u003d\u003d null) {\n                 StringBuilder err \u003d new StringBuilder();\n                 err.append(\"Unable to find decoder for type \u003c\");\n                 err.append(metadata.getMessageClass().getName());\n                 err.append(\"\u003e used in \u003c\");\n                 err.append(metadata.getHandlerClass().getName());\n                 err.append(\"\u003e\");\n                 throw new IllegalStateException(err.toString());\n             }\n             MessageType key \u003d wrapper.getMetadata().getMessageType();\n             MessageHandlerWrapper other \u003d wrappers[key.ordinal()];\n             if (other !\u003d null) {\n                 StringBuilder err \u003d new StringBuilder();\n                 err.append(\"Encountered duplicate MessageHandler handling message type \u003c\");\n-                err.append(key.name());\n+                err.append(wrapper.getMetadata().getObjectType().getName());\n                 err.append(\"\u003e, \").append(metadata.getHandlerClass().getName());\n                 err.append(\"\u003c\");\n                 err.append(metadata.getMessageClass().getName());\n                 err.append(\"\u003e and \");\n                 err.append(other.getMetadata().getHandlerClass().getName());\n                 err.append(\"\u003c\");\n                 err.append(other.getMetadata().getMessageClass().getName());\n                 err.append(\"\u003e both implement this message type\");\n                 throw new IllegalStateException(err.toString());\n             } else {\n                 MessageHandlerWrapper handlerWrapper \u003d new MessageHandlerWrapper(handler, metadata, wrapper);\n                 wrappers[key.ordinal()] \u003d handlerWrapper;\n             }\n         }\n-        messageHandlerSet.clear();\n-        for (MessageHandlerWrapper wrapper : wrappers) {\n-            if (wrapper \u003d\u003d null) {\n-                continue;\n-            }\n-            messageHandlerSet.add(wrapper.getHandler());\n-        }\n+        updateMessageHandlerSet();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "33c11dffaa86d09b33fd350f07cd9c548b7d3b7c": {
      "type": "Ybodychange",
      "commitMessage": "JSR-356 - cleaning up Decoder and Encoder lifecycle.\n",
      "commitDate": "2013/7/10 上午5:16",
      "commitName": "33c11dffaa86d09b33fd350f07cd9c548b7d3b7c",
      "commitAuthor": "Joakim Erdfelt",
      "commitDateOld": "2013/7/10 上午5:16",
      "commitNameOld": "46e9493c850d0ff2e6f30f455ad358251e1a2d48",
      "commitAuthorOld": "Joakim Erdfelt",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void addMessageHandler(MessageHandler handler) throws IllegalStateException {\n    Objects.requireNonNull(handler, \"MessageHandler cannot be null\");\n    synchronized (wrappers) {\n        for (MessageHandlerMetadata metadata : messageHandlerFactory.getMetadata(handler.getClass())) {\n            DecoderFactory.Wrapper wrapper \u003d decoderFactory.getWrapperFor(metadata.getMessageClass());\n            if (wrapper \u003d\u003d null) {\n                StringBuilder err \u003d new StringBuilder();\n                err.append(\"Unable to find decoder for type \u003c\");\n                err.append(metadata.getMessageClass().getName());\n                err.append(\"\u003e used in \u003c\");\n                err.append(metadata.getHandlerClass().getName());\n                err.append(\"\u003e\");\n                throw new IllegalStateException(err.toString());\n            }\n            MessageType key \u003d wrapper.getMetadata().getMessageType();\n            MessageHandlerWrapper other \u003d wrappers[key.ordinal()];\n            if (other !\u003d null) {\n                StringBuilder err \u003d new StringBuilder();\n                err.append(\"Encountered duplicate MessageHandler handling message type \u003c\");\n                err.append(key.name());\n                err.append(\"\u003e, \").append(metadata.getHandlerClass().getName());\n                err.append(\"\u003c\");\n                err.append(metadata.getMessageClass().getName());\n                err.append(\"\u003e and \");\n                err.append(other.getMetadata().getHandlerClass().getName());\n                err.append(\"\u003c\");\n                err.append(other.getMetadata().getMessageClass().getName());\n                err.append(\"\u003e both implement this message type\");\n                throw new IllegalStateException(err.toString());\n            } else {\n                MessageHandlerWrapper handlerWrapper \u003d new MessageHandlerWrapper(handler, metadata, wrapper);\n                wrappers[key.ordinal()] \u003d handlerWrapper;\n            }\n        }\n        messageHandlerSet.clear();\n        for (MessageHandlerWrapper wrapper : wrappers) {\n            if (wrapper \u003d\u003d null) {\n                continue;\n            }\n            messageHandlerSet.add(wrapper.getHandler());\n        }\n    }\n}",
      "path": "jetty-websocket/javax-websocket-client-impl/src/main/java/org/eclipse/jetty/websocket/jsr356/JsrSession.java",
      "functionStartLine": 96,
      "functionName": "addMessageHandler",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,35 +1,44 @@\n @Override\n public void addMessageHandler(MessageHandler handler) throws IllegalStateException {\n     Objects.requireNonNull(handler, \"MessageHandler cannot be null\");\n     synchronized (wrappers) {\n         for (MessageHandlerMetadata metadata : messageHandlerFactory.getMetadata(handler.getClass())) {\n-            DecoderWrapper decoder \u003d decoderFactory.getWrapperFor(metadata.getMessageClass());\n-            MessageType key \u003d decoder.getMetadata().getMessageType();\n+            DecoderFactory.Wrapper wrapper \u003d decoderFactory.getWrapperFor(metadata.getMessageClass());\n+            if (wrapper \u003d\u003d null) {\n+                StringBuilder err \u003d new StringBuilder();\n+                err.append(\"Unable to find decoder for type \u003c\");\n+                err.append(metadata.getMessageClass().getName());\n+                err.append(\"\u003e used in \u003c\");\n+                err.append(metadata.getHandlerClass().getName());\n+                err.append(\"\u003e\");\n+                throw new IllegalStateException(err.toString());\n+            }\n+            MessageType key \u003d wrapper.getMetadata().getMessageType();\n             MessageHandlerWrapper other \u003d wrappers[key.ordinal()];\n             if (other !\u003d null) {\n                 StringBuilder err \u003d new StringBuilder();\n                 err.append(\"Encountered duplicate MessageHandler handling message type \u003c\");\n                 err.append(key.name());\n                 err.append(\"\u003e, \").append(metadata.getHandlerClass().getName());\n                 err.append(\"\u003c\");\n                 err.append(metadata.getMessageClass().getName());\n                 err.append(\"\u003e and \");\n                 err.append(other.getMetadata().getHandlerClass().getName());\n                 err.append(\"\u003c\");\n                 err.append(other.getMetadata().getMessageClass().getName());\n                 err.append(\"\u003e both implement this message type\");\n                 throw new IllegalStateException(err.toString());\n             } else {\n-                MessageHandlerWrapper wrapper \u003d new MessageHandlerWrapper(handler, metadata, decoder);\n-                wrappers[key.ordinal()] \u003d wrapper;\n+                MessageHandlerWrapper handlerWrapper \u003d new MessageHandlerWrapper(handler, metadata, wrapper);\n+                wrappers[key.ordinal()] \u003d handlerWrapper;\n             }\n         }\n         messageHandlerSet.clear();\n         for (MessageHandlerWrapper wrapper : wrappers) {\n             if (wrapper \u003d\u003d null) {\n                 continue;\n             }\n             messageHandlerSet.add(wrapper.getHandler());\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "46e9493c850d0ff2e6f30f455ad358251e1a2d48": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "JSR-356 - reworked Config to maintain user provided config\n\n+ If a user provided config is supplied, then that config should\n  be used for init(EndpointConfig) and other various accesses to\n  the configuration object.  This refactor stops using an internal\n  EndpointConfig object always and moves the internal config\n  fields into the JsrSession object instead.\n",
      "commitDate": "2013/7/10 上午5:16",
      "commitName": "46e9493c850d0ff2e6f30f455ad358251e1a2d48",
      "commitAuthor": "Joakim Erdfelt",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "JSR-356 - reworked Config to maintain user provided config\n\n+ If a user provided config is supplied, then that config should\n  be used for init(EndpointConfig) and other various accesses to\n  the configuration object.  This refactor stops using an internal\n  EndpointConfig object always and moves the internal config\n  fields into the JsrSession object instead.\n",
          "commitDate": "2013/7/10 上午5:16",
          "commitName": "46e9493c850d0ff2e6f30f455ad358251e1a2d48",
          "commitAuthor": "Joakim Erdfelt",
          "commitDateOld": "2013/4/16 上午3:11",
          "commitNameOld": "fe25ef0454e2be89a6aec8c87a1845ff8ecda1a2",
          "commitAuthorOld": "Joakim Erdfelt",
          "daysBetweenCommits": 85.09,
          "commitsBetweenForRepo": 417,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\npublic void addMessageHandler(MessageHandler handler) throws IllegalStateException {\n    Objects.requireNonNull(handler, \"MessageHandler cannot be null\");\n    synchronized (wrappers) {\n        for (MessageHandlerMetadata metadata : messageHandlerFactory.getMetadata(handler.getClass())) {\n            DecoderWrapper decoder \u003d decoderFactory.getWrapperFor(metadata.getMessageClass());\n            MessageType key \u003d decoder.getMetadata().getMessageType();\n            MessageHandlerWrapper other \u003d wrappers[key.ordinal()];\n            if (other !\u003d null) {\n                StringBuilder err \u003d new StringBuilder();\n                err.append(\"Encountered duplicate MessageHandler handling message type \u003c\");\n                err.append(key.name());\n                err.append(\"\u003e, \").append(metadata.getHandlerClass().getName());\n                err.append(\"\u003c\");\n                err.append(metadata.getMessageClass().getName());\n                err.append(\"\u003e and \");\n                err.append(other.getMetadata().getHandlerClass().getName());\n                err.append(\"\u003c\");\n                err.append(other.getMetadata().getMessageClass().getName());\n                err.append(\"\u003e both implement this message type\");\n                throw new IllegalStateException(err.toString());\n            } else {\n                MessageHandlerWrapper wrapper \u003d new MessageHandlerWrapper(handler, metadata, decoder);\n                wrappers[key.ordinal()] \u003d wrapper;\n            }\n        }\n        messageHandlerSet.clear();\n        for (MessageHandlerWrapper wrapper : wrappers) {\n            if (wrapper \u003d\u003d null) {\n                continue;\n            }\n            messageHandlerSet.add(wrapper.getHandler());\n        }\n    }\n}",
          "path": "jetty-websocket/javax-websocket-client-impl/src/main/java/org/eclipse/jetty/websocket/jsr356/JsrSession.java",
          "functionStartLine": 99,
          "functionName": "addMessageHandler",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,4 +1,35 @@\n @Override\n-public void addMessageHandler(MessageHandler listener) throws IllegalStateException {\n-    this.messageHandlers.add(listener);\n+public void addMessageHandler(MessageHandler handler) throws IllegalStateException {\n+    Objects.requireNonNull(handler, \"MessageHandler cannot be null\");\n+    synchronized (wrappers) {\n+        for (MessageHandlerMetadata metadata : messageHandlerFactory.getMetadata(handler.getClass())) {\n+            DecoderWrapper decoder \u003d decoderFactory.getWrapperFor(metadata.getMessageClass());\n+            MessageType key \u003d decoder.getMetadata().getMessageType();\n+            MessageHandlerWrapper other \u003d wrappers[key.ordinal()];\n+            if (other !\u003d null) {\n+                StringBuilder err \u003d new StringBuilder();\n+                err.append(\"Encountered duplicate MessageHandler handling message type \u003c\");\n+                err.append(key.name());\n+                err.append(\"\u003e, \").append(metadata.getHandlerClass().getName());\n+                err.append(\"\u003c\");\n+                err.append(metadata.getMessageClass().getName());\n+                err.append(\"\u003e and \");\n+                err.append(other.getMetadata().getHandlerClass().getName());\n+                err.append(\"\u003c\");\n+                err.append(other.getMetadata().getMessageClass().getName());\n+                err.append(\"\u003e both implement this message type\");\n+                throw new IllegalStateException(err.toString());\n+            } else {\n+                MessageHandlerWrapper wrapper \u003d new MessageHandlerWrapper(handler, metadata, decoder);\n+                wrappers[key.ordinal()] \u003d wrapper;\n+            }\n+        }\n+        messageHandlerSet.clear();\n+        for (MessageHandlerWrapper wrapper : wrappers) {\n+            if (wrapper \u003d\u003d null) {\n+                continue;\n+            }\n+            messageHandlerSet.add(wrapper.getHandler());\n+        }\n+    }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[listener-MessageHandler]",
            "newValue": "[handler-MessageHandler]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "JSR-356 - reworked Config to maintain user provided config\n\n+ If a user provided config is supplied, then that config should\n  be used for init(EndpointConfig) and other various accesses to\n  the configuration object.  This refactor stops using an internal\n  EndpointConfig object always and moves the internal config\n  fields into the JsrSession object instead.\n",
          "commitDate": "2013/7/10 上午5:16",
          "commitName": "46e9493c850d0ff2e6f30f455ad358251e1a2d48",
          "commitAuthor": "Joakim Erdfelt",
          "commitDateOld": "2013/4/16 上午3:11",
          "commitNameOld": "fe25ef0454e2be89a6aec8c87a1845ff8ecda1a2",
          "commitAuthorOld": "Joakim Erdfelt",
          "daysBetweenCommits": 85.09,
          "commitsBetweenForRepo": 417,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\npublic void addMessageHandler(MessageHandler handler) throws IllegalStateException {\n    Objects.requireNonNull(handler, \"MessageHandler cannot be null\");\n    synchronized (wrappers) {\n        for (MessageHandlerMetadata metadata : messageHandlerFactory.getMetadata(handler.getClass())) {\n            DecoderWrapper decoder \u003d decoderFactory.getWrapperFor(metadata.getMessageClass());\n            MessageType key \u003d decoder.getMetadata().getMessageType();\n            MessageHandlerWrapper other \u003d wrappers[key.ordinal()];\n            if (other !\u003d null) {\n                StringBuilder err \u003d new StringBuilder();\n                err.append(\"Encountered duplicate MessageHandler handling message type \u003c\");\n                err.append(key.name());\n                err.append(\"\u003e, \").append(metadata.getHandlerClass().getName());\n                err.append(\"\u003c\");\n                err.append(metadata.getMessageClass().getName());\n                err.append(\"\u003e and \");\n                err.append(other.getMetadata().getHandlerClass().getName());\n                err.append(\"\u003c\");\n                err.append(other.getMetadata().getMessageClass().getName());\n                err.append(\"\u003e both implement this message type\");\n                throw new IllegalStateException(err.toString());\n            } else {\n                MessageHandlerWrapper wrapper \u003d new MessageHandlerWrapper(handler, metadata, decoder);\n                wrappers[key.ordinal()] \u003d wrapper;\n            }\n        }\n        messageHandlerSet.clear();\n        for (MessageHandlerWrapper wrapper : wrappers) {\n            if (wrapper \u003d\u003d null) {\n                continue;\n            }\n            messageHandlerSet.add(wrapper.getHandler());\n        }\n    }\n}",
          "path": "jetty-websocket/javax-websocket-client-impl/src/main/java/org/eclipse/jetty/websocket/jsr356/JsrSession.java",
          "functionStartLine": 99,
          "functionName": "addMessageHandler",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,4 +1,35 @@\n @Override\n-public void addMessageHandler(MessageHandler listener) throws IllegalStateException {\n-    this.messageHandlers.add(listener);\n+public void addMessageHandler(MessageHandler handler) throws IllegalStateException {\n+    Objects.requireNonNull(handler, \"MessageHandler cannot be null\");\n+    synchronized (wrappers) {\n+        for (MessageHandlerMetadata metadata : messageHandlerFactory.getMetadata(handler.getClass())) {\n+            DecoderWrapper decoder \u003d decoderFactory.getWrapperFor(metadata.getMessageClass());\n+            MessageType key \u003d decoder.getMetadata().getMessageType();\n+            MessageHandlerWrapper other \u003d wrappers[key.ordinal()];\n+            if (other !\u003d null) {\n+                StringBuilder err \u003d new StringBuilder();\n+                err.append(\"Encountered duplicate MessageHandler handling message type \u003c\");\n+                err.append(key.name());\n+                err.append(\"\u003e, \").append(metadata.getHandlerClass().getName());\n+                err.append(\"\u003c\");\n+                err.append(metadata.getMessageClass().getName());\n+                err.append(\"\u003e and \");\n+                err.append(other.getMetadata().getHandlerClass().getName());\n+                err.append(\"\u003c\");\n+                err.append(other.getMetadata().getMessageClass().getName());\n+                err.append(\"\u003e both implement this message type\");\n+                throw new IllegalStateException(err.toString());\n+            } else {\n+                MessageHandlerWrapper wrapper \u003d new MessageHandlerWrapper(handler, metadata, decoder);\n+                wrappers[key.ordinal()] \u003d wrapper;\n+            }\n+        }\n+        messageHandlerSet.clear();\n+        for (MessageHandlerWrapper wrapper : wrappers) {\n+            if (wrapper \u003d\u003d null) {\n+                continue;\n+            }\n+            messageHandlerSet.add(wrapper.getHandler());\n+        }\n+    }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "d1692733f56b7c67a885b8c9fdd14fa204c8cab6": {
      "type": "Ybodychange",
      "commitMessage": "JSR-356: MessageHandler(s) layer\n",
      "commitDate": "2013/4/5 上午3:03",
      "commitName": "d1692733f56b7c67a885b8c9fdd14fa204c8cab6",
      "commitAuthor": "Joakim Erdfelt",
      "commitDateOld": "2013/3/29 上午1:51",
      "commitNameOld": "3a66b3ec3f8d608140be000dbec507ffd55a503b",
      "commitAuthorOld": "Joakim Erdfelt",
      "daysBetweenCommits": 7.05,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void addMessageHandler(MessageHandler listener) throws IllegalStateException {\n    this.messageHandlers.add(listener);\n}",
      "path": "jetty-websocket/javax-websocket-client-impl/src/main/java/org/eclipse/jetty/websocket/jsr356/JsrSession.java",
      "functionStartLine": 66,
      "functionName": "addMessageHandler",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,4 +1,4 @@\n @Override\n public void addMessageHandler(MessageHandler listener) throws IllegalStateException {\n-    messageHandlers.add(listener);\n+    this.messageHandlers.add(listener);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3a66b3ec3f8d608140be000dbec507ffd55a503b": {
      "type": "Ybodychange",
      "commitMessage": "JSR-356 first working annotated @ClientEndpoint echo test\n",
      "commitDate": "2013/3/29 上午1:51",
      "commitName": "3a66b3ec3f8d608140be000dbec507ffd55a503b",
      "commitAuthor": "Joakim Erdfelt",
      "commitDateOld": "2013/3/27 上午8:30",
      "commitNameOld": "fc7526b7392e132f63110258964b45d818947215",
      "commitAuthorOld": "Joakim Erdfelt",
      "daysBetweenCommits": 1.72,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void addMessageHandler(MessageHandler listener) throws IllegalStateException {\n    messageHandlers.add(listener);\n}",
      "path": "jetty-websocket/javax-websocket-client-impl/src/main/java/org/eclipse/jetty/websocket/jsr356/JsrSession.java",
      "functionStartLine": 64,
      "functionName": "addMessageHandler",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,3 +1,4 @@\n @Override\n public void addMessageHandler(MessageHandler listener) throws IllegalStateException {\n+    messageHandlers.add(listener);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "43231d84510fde66c4a19a5aac4782eaef15de16": {
      "type": "Yintroduced",
      "commitMessage": "393473 - Add support for JSR-356 (javax.websocket) draft\n\n + Restarting branch, copying over work from November with new JSR-356\n   Draft 012 api in mind.\n",
      "commitDate": "2013/2/13 上午7:19",
      "commitName": "43231d84510fde66c4a19a5aac4782eaef15de16",
      "commitAuthor": "Joakim Erdfelt",
      "diff": "@@ -0,0 +1,3 @@\n+@Override\n+public void addMessageHandler(MessageHandler listener) throws IllegalStateException {\n+}\n\\ No newline at end of file\n",
      "actualSource": "@Override\npublic void addMessageHandler(MessageHandler listener) throws IllegalStateException {\n}",
      "path": "jetty-websocket/javax-websocket-client-impl/src/main/java/org/eclipse/jetty/websocket/jsr356/JsrSession.java",
      "functionStartLine": 58,
      "functionName": "addMessageHandler",
      "functionAnnotation": "@Override",
      "functionDoc": ""
    }
  }
}