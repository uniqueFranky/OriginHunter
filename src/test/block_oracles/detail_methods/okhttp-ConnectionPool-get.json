{
  "origin": "codeshovel",
  "repositoryName": "okhttp",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/okhttp/.git",
  "startCommitName": "5224f3045ba9b171fce521777edf389f9206173c",
  "sourceFileName": "ConnectionPool.java",
  "functionName": "get",
  "functionId": "get___address-Address__streamAllocation-StreamAllocation__route-Route",
  "sourceFilePath": "okhttp/src/main/java/okhttp3/ConnectionPool.java",
  "functionAnnotation": "@Nullable",
  "functionDoc": "Returns a recycled connection to {@code address}, or null if no such connection exists. The\nroute is null if the address has not yet been routed.\n",
  "functionStartLine": 122,
  "functionEndLine": 131,
  "numCommitsSeen": 103,
  "timeTaken": 2057,
  "changeHistory": [
    "77471444ec81ad9452ebde7ca2b58db58a1f77d1",
    "011b2ee76d41fc689be75e1aa4d2efd9fe33c285",
    "81c7461c98f2228c3bb1a0c80fb803b5ea2e47f0",
    "98443a9ca8ca9ad82d5fb9b05b32f180bb510601",
    "75ebcd5cd13995c3b70e0b621d3204b9a5996806",
    "02d6b4e78c4f1bda5f20e3089af024c58fe6baf6",
    "c9a89876de476983f273edbf108c365127c18c5e",
    "c099f69d0b7198a40e4a6373ae564b65d04363ef",
    "4ae314a1f21d07ee5dbad024bc098182219e9e07",
    "c5f58e45454d1ffc621c65e377cb91345018e087",
    "c358656c8799d30fd422448153e99a5dd37e298a",
    "49a331385343f3ca49d26c4ddd947546867bcd3b",
    "c753d2e41ba667f9b5a31451a16ecbaecdc65d80",
    "98c74ace40b089f2769afb3e56c59a64eef327cb",
    "a8327d121b9eeb3b61ae63f06095d423936a5da2",
    "c26f9af0489869a9e1873ed5010c65f8464cff26",
    "fdee6f13a4c5bf5bd24f2c237c2996aea01cc5ff",
    "1ece746c815a26782042b1fca6069eb527d1029b",
    "7ccbf48838b7cfe42759c67790636d442ea5daa3",
    "f373e2d6e5bfaa86afc147b877a72d600c224c5d",
    "6f6d959fdae64065521990413f86bc7ab038d7c1",
    "06579c5bfb6a051a9fbca5be2d15a52fcf77f38c",
    "689f66222bd8984dd69229a4ee9caf8da528ae12",
    "67604f618d96ae00318ce696ec29a66bec6aafa8",
    "78c6624b11d5f33504dae8211b4592383468343e",
    "70e64037ff295874602133a1d254e5a0440ae4e3",
    "3d2547f18886e771aaa9baa996a21136c93460c4",
    "50999cceb5f5bcdaf79baa5ac7eeef90c72bda8d",
    "40ff76547064c3fb5acb9047a6f679dd4379a4d0",
    "ea63463c2ff8a67f63e541036f0d5998b5bb1f3e"
  ],
  "changeHistoryShort": {
    "77471444ec81ad9452ebde7ca2b58db58a1f77d1": "Ybodychange",
    "011b2ee76d41fc689be75e1aa4d2efd9fe33c285": "Yannotationchange",
    "81c7461c98f2228c3bb1a0c80fb803b5ea2e47f0": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
    "98443a9ca8ca9ad82d5fb9b05b32f180bb510601": "Ybodychange",
    "75ebcd5cd13995c3b70e0b621d3204b9a5996806": "Ybodychange",
    "02d6b4e78c4f1bda5f20e3089af024c58fe6baf6": "Ybodychange",
    "c9a89876de476983f273edbf108c365127c18c5e": "Ymovefromfile",
    "c099f69d0b7198a40e4a6373ae564b65d04363ef": "Ymultichange(Yreturntypechange,Ymodifierchange,Ybodychange)",
    "4ae314a1f21d07ee5dbad024bc098182219e9e07": "Ymultichange(Yparameterchange,Ybodychange)",
    "c5f58e45454d1ffc621c65e377cb91345018e087": "Ybodychange",
    "c358656c8799d30fd422448153e99a5dd37e298a": "Ybodychange",
    "49a331385343f3ca49d26c4ddd947546867bcd3b": "Ybodychange",
    "c753d2e41ba667f9b5a31451a16ecbaecdc65d80": "Ybodychange",
    "98c74ace40b089f2769afb3e56c59a64eef327cb": "Ybodychange",
    "a8327d121b9eeb3b61ae63f06095d423936a5da2": "Ybodychange",
    "c26f9af0489869a9e1873ed5010c65f8464cff26": "Ybodychange",
    "fdee6f13a4c5bf5bd24f2c237c2996aea01cc5ff": "Ybodychange",
    "1ece746c815a26782042b1fca6069eb527d1029b": "Ybodychange",
    "7ccbf48838b7cfe42759c67790636d442ea5daa3": "Yfilerename",
    "f373e2d6e5bfaa86afc147b877a72d600c224c5d": "Ybodychange",
    "6f6d959fdae64065521990413f86bc7ab038d7c1": "Ymultichange(Ymodifierchange,Ybodychange,Ydocchange)",
    "06579c5bfb6a051a9fbca5be2d15a52fcf77f38c": "Ybodychange",
    "689f66222bd8984dd69229a4ee9caf8da528ae12": "Ybodychange",
    "67604f618d96ae00318ce696ec29a66bec6aafa8": "Ybodychange",
    "78c6624b11d5f33504dae8211b4592383468343e": "Ymultichange(Yfilerename,Yreturntypechange,Ybodychange,Ydocchange,Yparameterchange)",
    "70e64037ff295874602133a1d254e5a0440ae4e3": "Ybodychange",
    "3d2547f18886e771aaa9baa996a21136c93460c4": "Ybodychange",
    "50999cceb5f5bcdaf79baa5ac7eeef90c72bda8d": "Yfilerename",
    "40ff76547064c3fb5acb9047a6f679dd4379a4d0": "Ymultichange(Yparameterchange,Yexceptionschange,Ybodychange)",
    "ea63463c2ff8a67f63e541036f0d5998b5bb1f3e": "Yintroduced"
  },
  "changeHistoryDetails": {
    "77471444ec81ad9452ebde7ca2b58db58a1f77d1": {
      "type": "Ybodychange",
      "commitMessage": "Don\u0027t report connectionAcquired until actually connected. (#3566)\n\nCurrently our implementation acquires the connection early so that we have\r\nsomething to close if the call is canceled. Event listeners are simpler if\r\nthey only get a connectionAcquired event once the connection has been\r\nactually established.",
      "commitDate": "2017/9/1 下午1:40",
      "commitName": "77471444ec81ad9452ebde7ca2b58db58a1f77d1",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "2017/5/7 上午3:25",
      "commitNameOld": "011b2ee76d41fc689be75e1aa4d2efd9fe33c285",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 117.43,
      "commitsBetweenForRepo": 75,
      "commitsBetweenForFile": 1,
      "actualSource": "@Nullable\nRealConnection get(Address address, StreamAllocation streamAllocation, Route route) {\n    assert (Thread.holdsLock(this));\n    for (RealConnection connection : connections) {\n        if (connection.isEligible(address, route)) {\n            streamAllocation.acquire(connection, true);\n            return connection;\n        }\n    }\n    return null;\n}",
      "path": "okhttp/src/main/java/okhttp3/ConnectionPool.java",
      "functionStartLine": 122,
      "functionName": "get",
      "functionAnnotation": "@Nullable",
      "functionDoc": "Returns a recycled connection to {@code address}, or null if no such connection exists. The\nroute is null if the address has not yet been routed.\n",
      "diff": "@@ -1,11 +1,11 @@\n @Nullable\n RealConnection get(Address address, StreamAllocation streamAllocation, Route route) {\n     assert (Thread.holdsLock(this));\n     for (RealConnection connection : connections) {\n         if (connection.isEligible(address, route)) {\n-            streamAllocation.acquire(connection);\n+            streamAllocation.acquire(connection, true);\n             return connection;\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "011b2ee76d41fc689be75e1aa4d2efd9fe33c285": {
      "type": "Yannotationchange",
      "commitMessage": "Import jsr305 and use it to mark @Nullable stuff.\n\nThis library is a provided dependency and is not necessary to be included\nby OkHttp users.\n\nThis currently covers the okhttp and okhttp-logging-interceptor modules\nonly. It does not cover the \u0027internal\u0027 package in OkHttp, or its test cases.\nWe can add those as needed.\n",
      "commitDate": "2017/5/7 上午3:25",
      "commitName": "011b2ee76d41fc689be75e1aa4d2efd9fe33c285",
      "commitAuthor": "jwilson",
      "commitDateOld": "2017/3/6 上午9:06",
      "commitNameOld": "81c7461c98f2228c3bb1a0c80fb803b5ea2e47f0",
      "commitAuthorOld": "Yuri Schimke",
      "daysBetweenCommits": 61.76,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "actualSource": "@Nullable\nRealConnection get(Address address, StreamAllocation streamAllocation, Route route) {\n    assert (Thread.holdsLock(this));\n    for (RealConnection connection : connections) {\n        if (connection.isEligible(address, route)) {\n            streamAllocation.acquire(connection);\n            return connection;\n        }\n    }\n    return null;\n}",
      "path": "okhttp/src/main/java/okhttp3/ConnectionPool.java",
      "functionStartLine": 122,
      "functionName": "get",
      "functionAnnotation": "@Nullable",
      "functionDoc": "Returns a recycled connection to {@code address}, or null if no such connection exists. The\nroute is null if the address has not yet been routed.\n",
      "diff": "@@ -1,10 +1,11 @@\n+@Nullable\n RealConnection get(Address address, StreamAllocation streamAllocation, Route route) {\n     assert (Thread.holdsLock(this));\n     for (RealConnection connection : connections) {\n         if (connection.isEligible(address, route)) {\n             streamAllocation.acquire(connection);\n             return connection;\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "",
        "newValue": "@Nullable"
      }
    },
    "81c7461c98f2228c3bb1a0c80fb803b5ea2e47f0": {
      "type": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
      "commitMessage": "Connection coalescing\n\nAs described here:\n\nhttps://daniel.haxx.se/blog/2016/08/18/http2-connection-coalescing/\nhttps://hpbn.co/optimizing-application-delivery/#eliminate-domain-sharding\nhttps://tools.ietf.org/html/rfc7540#section-9.1.1\n\nWhen the following is true\n- HTTP/2 so we don\u0027t overload non multiplexed connections.\n- HTTPS since we need subjectAltNames (n.b. RFC 7540 defines as safe to use over plaintext, based purely on DNS).\n- Desired url host is part of the subjectAltNames for an existing connection.\n- One of the DNS results for desired host match the established connection.\n- HostnameVerifier is *not* overridden.\n- ConnectionPinner accepts the existing certificate chain.\n\nFrom https://tools.ietf.org/html/rfc7540#section-9.1.1\n\n\u003e A server that does not wish clients to reuse connections can indicate\n\u003e that it is not authoritative for a request by sending a 421\n\u003e (Misdirected Request) status code in response to the request (see\n\u003e Section 9.1.2).\n",
      "commitDate": "2017/3/6 上午9:06",
      "commitName": "81c7461c98f2228c3bb1a0c80fb803b5ea2e47f0",
      "commitAuthor": "Yuri Schimke",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Connection coalescing\n\nAs described here:\n\nhttps://daniel.haxx.se/blog/2016/08/18/http2-connection-coalescing/\nhttps://hpbn.co/optimizing-application-delivery/#eliminate-domain-sharding\nhttps://tools.ietf.org/html/rfc7540#section-9.1.1\n\nWhen the following is true\n- HTTP/2 so we don\u0027t overload non multiplexed connections.\n- HTTPS since we need subjectAltNames (n.b. RFC 7540 defines as safe to use over plaintext, based purely on DNS).\n- Desired url host is part of the subjectAltNames for an existing connection.\n- One of the DNS results for desired host match the established connection.\n- HostnameVerifier is *not* overridden.\n- ConnectionPinner accepts the existing certificate chain.\n\nFrom https://tools.ietf.org/html/rfc7540#section-9.1.1\n\n\u003e A server that does not wish clients to reuse connections can indicate\n\u003e that it is not authoritative for a request by sending a 421\n\u003e (Misdirected Request) status code in response to the request (see\n\u003e Section 9.1.2).\n",
          "commitDate": "2017/3/6 上午9:06",
          "commitName": "81c7461c98f2228c3bb1a0c80fb803b5ea2e47f0",
          "commitAuthor": "Yuri Schimke",
          "commitDateOld": "2017/1/21 上午3:54",
          "commitNameOld": "5af089a71997fb454b0ef063664db267d8038a73",
          "commitAuthorOld": "Jake Wharton",
          "daysBetweenCommits": 44.22,
          "commitsBetweenForRepo": 22,
          "commitsBetweenForFile": 1,
          "actualSource": "RealConnection get(Address address, StreamAllocation streamAllocation, Route route) {\n    assert (Thread.holdsLock(this));\n    for (RealConnection connection : connections) {\n        if (connection.isEligible(address, route)) {\n            streamAllocation.acquire(connection);\n            return connection;\n        }\n    }\n    return null;\n}",
          "path": "okhttp/src/main/java/okhttp3/ConnectionPool.java",
          "functionStartLine": 121,
          "functionName": "get",
          "functionAnnotation": "",
          "functionDoc": "Returns a recycled connection to {@code address}, or null if no such connection exists. The\nroute is null if the address has not yet been routed.\n",
          "diff": "@@ -1,10 +1,10 @@\n-RealConnection get(Address address, StreamAllocation streamAllocation) {\n+RealConnection get(Address address, StreamAllocation streamAllocation, Route route) {\n     assert (Thread.holdsLock(this));\n     for (RealConnection connection : connections) {\n-        if (connection.isEligible(address)) {\n+        if (connection.isEligible(address, route)) {\n             streamAllocation.acquire(connection);\n             return connection;\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[address-Address, streamAllocation-StreamAllocation]",
            "newValue": "[address-Address, streamAllocation-StreamAllocation, route-Route]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Connection coalescing\n\nAs described here:\n\nhttps://daniel.haxx.se/blog/2016/08/18/http2-connection-coalescing/\nhttps://hpbn.co/optimizing-application-delivery/#eliminate-domain-sharding\nhttps://tools.ietf.org/html/rfc7540#section-9.1.1\n\nWhen the following is true\n- HTTP/2 so we don\u0027t overload non multiplexed connections.\n- HTTPS since we need subjectAltNames (n.b. RFC 7540 defines as safe to use over plaintext, based purely on DNS).\n- Desired url host is part of the subjectAltNames for an existing connection.\n- One of the DNS results for desired host match the established connection.\n- HostnameVerifier is *not* overridden.\n- ConnectionPinner accepts the existing certificate chain.\n\nFrom https://tools.ietf.org/html/rfc7540#section-9.1.1\n\n\u003e A server that does not wish clients to reuse connections can indicate\n\u003e that it is not authoritative for a request by sending a 421\n\u003e (Misdirected Request) status code in response to the request (see\n\u003e Section 9.1.2).\n",
          "commitDate": "2017/3/6 上午9:06",
          "commitName": "81c7461c98f2228c3bb1a0c80fb803b5ea2e47f0",
          "commitAuthor": "Yuri Schimke",
          "commitDateOld": "2017/1/21 上午3:54",
          "commitNameOld": "5af089a71997fb454b0ef063664db267d8038a73",
          "commitAuthorOld": "Jake Wharton",
          "daysBetweenCommits": 44.22,
          "commitsBetweenForRepo": 22,
          "commitsBetweenForFile": 1,
          "actualSource": "RealConnection get(Address address, StreamAllocation streamAllocation, Route route) {\n    assert (Thread.holdsLock(this));\n    for (RealConnection connection : connections) {\n        if (connection.isEligible(address, route)) {\n            streamAllocation.acquire(connection);\n            return connection;\n        }\n    }\n    return null;\n}",
          "path": "okhttp/src/main/java/okhttp3/ConnectionPool.java",
          "functionStartLine": 121,
          "functionName": "get",
          "functionAnnotation": "",
          "functionDoc": "Returns a recycled connection to {@code address}, or null if no such connection exists. The\nroute is null if the address has not yet been routed.\n",
          "diff": "@@ -1,10 +1,10 @@\n-RealConnection get(Address address, StreamAllocation streamAllocation) {\n+RealConnection get(Address address, StreamAllocation streamAllocation, Route route) {\n     assert (Thread.holdsLock(this));\n     for (RealConnection connection : connections) {\n-        if (connection.isEligible(address)) {\n+        if (connection.isEligible(address, route)) {\n             streamAllocation.acquire(connection);\n             return connection;\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Connection coalescing\n\nAs described here:\n\nhttps://daniel.haxx.se/blog/2016/08/18/http2-connection-coalescing/\nhttps://hpbn.co/optimizing-application-delivery/#eliminate-domain-sharding\nhttps://tools.ietf.org/html/rfc7540#section-9.1.1\n\nWhen the following is true\n- HTTP/2 so we don\u0027t overload non multiplexed connections.\n- HTTPS since we need subjectAltNames (n.b. RFC 7540 defines as safe to use over plaintext, based purely on DNS).\n- Desired url host is part of the subjectAltNames for an existing connection.\n- One of the DNS results for desired host match the established connection.\n- HostnameVerifier is *not* overridden.\n- ConnectionPinner accepts the existing certificate chain.\n\nFrom https://tools.ietf.org/html/rfc7540#section-9.1.1\n\n\u003e A server that does not wish clients to reuse connections can indicate\n\u003e that it is not authoritative for a request by sending a 421\n\u003e (Misdirected Request) status code in response to the request (see\n\u003e Section 9.1.2).\n",
          "commitDate": "2017/3/6 上午9:06",
          "commitName": "81c7461c98f2228c3bb1a0c80fb803b5ea2e47f0",
          "commitAuthor": "Yuri Schimke",
          "commitDateOld": "2017/1/21 上午3:54",
          "commitNameOld": "5af089a71997fb454b0ef063664db267d8038a73",
          "commitAuthorOld": "Jake Wharton",
          "daysBetweenCommits": 44.22,
          "commitsBetweenForRepo": 22,
          "commitsBetweenForFile": 1,
          "actualSource": "RealConnection get(Address address, StreamAllocation streamAllocation, Route route) {\n    assert (Thread.holdsLock(this));\n    for (RealConnection connection : connections) {\n        if (connection.isEligible(address, route)) {\n            streamAllocation.acquire(connection);\n            return connection;\n        }\n    }\n    return null;\n}",
          "path": "okhttp/src/main/java/okhttp3/ConnectionPool.java",
          "functionStartLine": 121,
          "functionName": "get",
          "functionAnnotation": "",
          "functionDoc": "Returns a recycled connection to {@code address}, or null if no such connection exists. The\nroute is null if the address has not yet been routed.\n",
          "diff": "@@ -1,10 +1,10 @@\n-RealConnection get(Address address, StreamAllocation streamAllocation) {\n+RealConnection get(Address address, StreamAllocation streamAllocation, Route route) {\n     assert (Thread.holdsLock(this));\n     for (RealConnection connection : connections) {\n-        if (connection.isEligible(address)) {\n+        if (connection.isEligible(address, route)) {\n             streamAllocation.acquire(connection);\n             return connection;\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Returns a recycled connection to {@code address}, or null if no such connection exists.\n",
            "newValue": "Returns a recycled connection to {@code address}, or null if no such connection exists. The\nroute is null if the address has not yet been routed.\n"
          }
        }
      ]
    },
    "98443a9ca8ca9ad82d5fb9b05b32f180bb510601": {
      "type": "Ybodychange",
      "commitMessage": "Release duplicated multiplexed connections.\n\nIf we make concurrent requests to an HTTP/2 server, close all but\nthe first connection. Creating multiple connections and then later\nreleasing them is somewhat pessimistic; it\u0027s also much safer for\nawkward cases like connect attempts being canceled.\n\nCloses: https://github.com/square/okhttp/issues/373\n",
      "commitDate": "2017/1/8 上午3:15",
      "commitName": "98443a9ca8ca9ad82d5fb9b05b32f180bb510601",
      "commitAuthor": "jwilson",
      "commitDateOld": "2016/8/7 下午11:51",
      "commitNameOld": "ecbcd51fc99c565496be15cfd7eadca465ae4a06",
      "commitAuthorOld": "Dave Roberge",
      "daysBetweenCommits": 153.14,
      "commitsBetweenForRepo": 87,
      "commitsBetweenForFile": 1,
      "actualSource": "RealConnection get(Address address, StreamAllocation streamAllocation) {\n    assert (Thread.holdsLock(this));\n    for (RealConnection connection : connections) {\n        if (connection.isEligible(address)) {\n            streamAllocation.acquire(connection);\n            return connection;\n        }\n    }\n    return null;\n}",
      "path": "okhttp/src/main/java/okhttp3/ConnectionPool.java",
      "functionStartLine": 118,
      "functionName": "get",
      "functionAnnotation": "",
      "functionDoc": "Returns a recycled connection to {@code address}, or null if no such connection exists.\n",
      "diff": "@@ -1,10 +1,10 @@\n RealConnection get(Address address, StreamAllocation streamAllocation) {\n     assert (Thread.holdsLock(this));\n     for (RealConnection connection : connections) {\n-        if (connection.allocations.size() \u003c connection.allocationLimit \u0026\u0026 address.equals(connection.route().address) \u0026\u0026 !connection.noNewStreams) {\n+        if (connection.isEligible(address)) {\n             streamAllocation.acquire(connection);\n             return connection;\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "75ebcd5cd13995c3b70e0b621d3204b9a5996806": {
      "type": "Ybodychange",
      "commitMessage": "Use listeners to observe allocation limit changes.\n\nThis removes some awkward code where the synchronized connection pool is calling\na synchronized methond on a connection. Nested synchronized is gross.\n",
      "commitDate": "2016/1/16 下午1:29",
      "commitName": "75ebcd5cd13995c3b70e0b621d3204b9a5996806",
      "commitAuthor": "jwilson",
      "commitDateOld": "2016/1/2 下午3:07",
      "commitNameOld": "7826bcb2fb1facb697a4c512776756c05d8c9deb",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 13.93,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "actualSource": "RealConnection get(Address address, StreamAllocation streamAllocation) {\n    assert (Thread.holdsLock(this));\n    for (RealConnection connection : connections) {\n        if (connection.allocations.size() \u003c connection.allocationLimit \u0026\u0026 address.equals(connection.route().address) \u0026\u0026 !connection.noNewStreams) {\n            streamAllocation.acquire(connection);\n            return connection;\n        }\n    }\n    return null;\n}",
      "path": "okhttp/src/main/java/okhttp3/ConnectionPool.java",
      "functionStartLine": 117,
      "functionName": "get",
      "functionAnnotation": "",
      "functionDoc": "Returns a recycled connection to {@code address}, or null if no such connection exists.\n",
      "diff": "@@ -1,10 +1,10 @@\n RealConnection get(Address address, StreamAllocation streamAllocation) {\n     assert (Thread.holdsLock(this));\n     for (RealConnection connection : connections) {\n-        if (connection.allocations.size() \u003c connection.allocationLimit() \u0026\u0026 address.equals(connection.route().address) \u0026\u0026 !connection.noNewStreams) {\n+        if (connection.allocations.size() \u003c connection.allocationLimit \u0026\u0026 address.equals(connection.route().address) \u0026\u0026 !connection.noNewStreams) {\n             streamAllocation.acquire(connection);\n             return connection;\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "02d6b4e78c4f1bda5f20e3089af024c58fe6baf6": {
      "type": "Ybodychange",
      "commitMessage": "Drop the get prefix on Connection accessors.\n",
      "commitDate": "2015/12/22 上午10:10",
      "commitName": "02d6b4e78c4f1bda5f20e3089af024c58fe6baf6",
      "commitAuthor": "jwilson",
      "commitDateOld": "2015/12/16 下午2:34",
      "commitNameOld": "c9a89876de476983f273edbf108c365127c18c5e",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 5.82,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "RealConnection get(Address address, StreamAllocation streamAllocation) {\n    assert (Thread.holdsLock(this));\n    for (RealConnection connection : connections) {\n        if (connection.allocations.size() \u003c connection.allocationLimit() \u0026\u0026 address.equals(connection.route().address) \u0026\u0026 !connection.noNewStreams) {\n            streamAllocation.acquire(connection);\n            return connection;\n        }\n    }\n    return null;\n}",
      "path": "okhttp/src/main/java/okhttp3/ConnectionPool.java",
      "functionStartLine": 167,
      "functionName": "get",
      "functionAnnotation": "",
      "functionDoc": "Returns a recycled connection to {@code address}, or null if no such connection exists.\n",
      "diff": "@@ -1,10 +1,10 @@\n RealConnection get(Address address, StreamAllocation streamAllocation) {\n     assert (Thread.holdsLock(this));\n     for (RealConnection connection : connections) {\n-        if (connection.allocations.size() \u003c connection.allocationLimit() \u0026\u0026 address.equals(connection.getRoute().address) \u0026\u0026 !connection.noNewStreams) {\n+        if (connection.allocations.size() \u003c connection.allocationLimit() \u0026\u0026 address.equals(connection.route().address) \u0026\u0026 !connection.noNewStreams) {\n             streamAllocation.acquire(connection);\n             return connection;\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c9a89876de476983f273edbf108c365127c18c5e": {
      "type": "Ymovefromfile",
      "commitMessage": "Rename com.squareup.okhttp to okhttp3\n\nMaven group changes will come in follow up.\n",
      "commitDate": "2015/12/16 下午2:34",
      "commitName": "c9a89876de476983f273edbf108c365127c18c5e",
      "commitAuthor": "jwilson",
      "commitDateOld": "2015/12/16 上午10:36",
      "commitNameOld": "54dc2df914f2aae37fb48cc2c2f7560ee664bc2b",
      "commitAuthorOld": "Jake Wharton",
      "daysBetweenCommits": 0.17,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "RealConnection get(Address address, StreamAllocation streamAllocation) {\n    assert (Thread.holdsLock(this));\n    for (RealConnection connection : connections) {\n        if (connection.allocations.size() \u003c connection.allocationLimit() \u0026\u0026 address.equals(connection.getRoute().address) \u0026\u0026 !connection.noNewStreams) {\n            streamAllocation.acquire(connection);\n            return connection;\n        }\n    }\n    return null;\n}",
      "path": "okhttp/src/main/java/okhttp3/ConnectionPool.java",
      "functionStartLine": 165,
      "functionName": "get",
      "functionAnnotation": "",
      "functionDoc": "Returns a recycled connection to {@code address}, or null if no such connection exists.\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java",
        "newPath": "okhttp/src/main/java/okhttp3/ConnectionPool.java",
        "oldMethodName": "get",
        "newMethodName": "get"
      }
    },
    "c099f69d0b7198a40e4a6373ae564b65d04363ef": {
      "type": "Ymultichange(Yreturntypechange,Ymodifierchange,Ybodychange)",
      "commitMessage": "Hide overly-visible APIs in ConnectionPool.\n",
      "commitDate": "2015/12/13 下午10:18",
      "commitName": "c099f69d0b7198a40e4a6373ae564b65d04363ef",
      "commitAuthor": "jwilson",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "Hide overly-visible APIs in ConnectionPool.\n",
          "commitDate": "2015/12/13 下午10:18",
          "commitName": "c099f69d0b7198a40e4a6373ae564b65d04363ef",
          "commitAuthor": "jwilson",
          "commitDateOld": "2015/12/9 上午11:05",
          "commitNameOld": "4ae314a1f21d07ee5dbad024bc098182219e9e07",
          "commitAuthorOld": "jwilson",
          "daysBetweenCommits": 4.47,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "actualSource": "RealConnection get(Address address, StreamAllocation streamAllocation) {\n    assert (Thread.holdsLock(this));\n    for (RealConnection connection : connections) {\n        if (connection.allocations.size() \u003c connection.allocationLimit() \u0026\u0026 address.equals(connection.getRoute().address) \u0026\u0026 !connection.noNewStreams) {\n            streamAllocation.acquire(connection);\n            return connection;\n        }\n    }\n    return null;\n}",
          "path": "okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java",
          "functionStartLine": 171,
          "functionName": "get",
          "functionAnnotation": "",
          "functionDoc": "Returns a recycled connection to {@code address}, or null if no such connection exists.\n",
          "diff": "@@ -1,9 +1,10 @@\n-public synchronized Connection get(Address address, StreamAllocation streamAllocation) {\n+RealConnection get(Address address, StreamAllocation streamAllocation) {\n+    assert (Thread.holdsLock(this));\n     for (RealConnection connection : connections) {\n         if (connection.allocations.size() \u003c connection.allocationLimit() \u0026\u0026 address.equals(connection.getRoute().address) \u0026\u0026 !connection.noNewStreams) {\n             streamAllocation.acquire(connection);\n             return connection;\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Connection",
            "newValue": "RealConnection"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "Hide overly-visible APIs in ConnectionPool.\n",
          "commitDate": "2015/12/13 下午10:18",
          "commitName": "c099f69d0b7198a40e4a6373ae564b65d04363ef",
          "commitAuthor": "jwilson",
          "commitDateOld": "2015/12/9 上午11:05",
          "commitNameOld": "4ae314a1f21d07ee5dbad024bc098182219e9e07",
          "commitAuthorOld": "jwilson",
          "daysBetweenCommits": 4.47,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "actualSource": "RealConnection get(Address address, StreamAllocation streamAllocation) {\n    assert (Thread.holdsLock(this));\n    for (RealConnection connection : connections) {\n        if (connection.allocations.size() \u003c connection.allocationLimit() \u0026\u0026 address.equals(connection.getRoute().address) \u0026\u0026 !connection.noNewStreams) {\n            streamAllocation.acquire(connection);\n            return connection;\n        }\n    }\n    return null;\n}",
          "path": "okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java",
          "functionStartLine": 171,
          "functionName": "get",
          "functionAnnotation": "",
          "functionDoc": "Returns a recycled connection to {@code address}, or null if no such connection exists.\n",
          "diff": "@@ -1,9 +1,10 @@\n-public synchronized Connection get(Address address, StreamAllocation streamAllocation) {\n+RealConnection get(Address address, StreamAllocation streamAllocation) {\n+    assert (Thread.holdsLock(this));\n     for (RealConnection connection : connections) {\n         if (connection.allocations.size() \u003c connection.allocationLimit() \u0026\u0026 address.equals(connection.getRoute().address) \u0026\u0026 !connection.noNewStreams) {\n             streamAllocation.acquire(connection);\n             return connection;\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[public, synchronized]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Hide overly-visible APIs in ConnectionPool.\n",
          "commitDate": "2015/12/13 下午10:18",
          "commitName": "c099f69d0b7198a40e4a6373ae564b65d04363ef",
          "commitAuthor": "jwilson",
          "commitDateOld": "2015/12/9 上午11:05",
          "commitNameOld": "4ae314a1f21d07ee5dbad024bc098182219e9e07",
          "commitAuthorOld": "jwilson",
          "daysBetweenCommits": 4.47,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "actualSource": "RealConnection get(Address address, StreamAllocation streamAllocation) {\n    assert (Thread.holdsLock(this));\n    for (RealConnection connection : connections) {\n        if (connection.allocations.size() \u003c connection.allocationLimit() \u0026\u0026 address.equals(connection.getRoute().address) \u0026\u0026 !connection.noNewStreams) {\n            streamAllocation.acquire(connection);\n            return connection;\n        }\n    }\n    return null;\n}",
          "path": "okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java",
          "functionStartLine": 171,
          "functionName": "get",
          "functionAnnotation": "",
          "functionDoc": "Returns a recycled connection to {@code address}, or null if no such connection exists.\n",
          "diff": "@@ -1,9 +1,10 @@\n-public synchronized Connection get(Address address, StreamAllocation streamAllocation) {\n+RealConnection get(Address address, StreamAllocation streamAllocation) {\n+    assert (Thread.holdsLock(this));\n     for (RealConnection connection : connections) {\n         if (connection.allocations.size() \u003c connection.allocationLimit() \u0026\u0026 address.equals(connection.getRoute().address) \u0026\u0026 !connection.noNewStreams) {\n             streamAllocation.acquire(connection);\n             return connection;\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "4ae314a1f21d07ee5dbad024bc098182219e9e07": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Detect leaked connections.\n\nThis is already suggesting some bugs in OkHttp itself.\n",
      "commitDate": "2015/12/9 上午11:05",
      "commitName": "4ae314a1f21d07ee5dbad024bc098182219e9e07",
      "commitAuthor": "jwilson",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Detect leaked connections.\n\nThis is already suggesting some bugs in OkHttp itself.\n",
          "commitDate": "2015/12/9 上午11:05",
          "commitName": "4ae314a1f21d07ee5dbad024bc098182219e9e07",
          "commitAuthor": "jwilson",
          "commitDateOld": "2015/12/8 上午11:43",
          "commitNameOld": "9ffc45dbe0b9ef80ab5cf972a176548781d2206a",
          "commitAuthorOld": "jwilson",
          "daysBetweenCommits": 0.97,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public synchronized Connection get(Address address, StreamAllocation streamAllocation) {\n    for (RealConnection connection : connections) {\n        if (connection.allocations.size() \u003c connection.allocationLimit() \u0026\u0026 address.equals(connection.getRoute().address) \u0026\u0026 !connection.noNewStreams) {\n            streamAllocation.acquire(connection);\n            return connection;\n        }\n    }\n    return null;\n}",
          "path": "okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java",
          "functionStartLine": 171,
          "functionName": "get",
          "functionAnnotation": "",
          "functionDoc": "Returns a recycled connection to {@code address}, or null if no such connection exists.\n",
          "diff": "@@ -1,9 +1,9 @@\n-public synchronized Connection get(Address address) {\n+public synchronized Connection get(Address address, StreamAllocation streamAllocation) {\n     for (RealConnection connection : connections) {\n-        if (connection.allocationCount \u003c connection.allocationLimit() \u0026\u0026 address.equals(connection.getRoute().address) \u0026\u0026 !connection.noNewStreams) {\n-            connection.allocationCount++;\n+        if (connection.allocations.size() \u003c connection.allocationLimit() \u0026\u0026 address.equals(connection.getRoute().address) \u0026\u0026 !connection.noNewStreams) {\n+            streamAllocation.acquire(connection);\n             return connection;\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[address-Address]",
            "newValue": "[address-Address, streamAllocation-StreamAllocation]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Detect leaked connections.\n\nThis is already suggesting some bugs in OkHttp itself.\n",
          "commitDate": "2015/12/9 上午11:05",
          "commitName": "4ae314a1f21d07ee5dbad024bc098182219e9e07",
          "commitAuthor": "jwilson",
          "commitDateOld": "2015/12/8 上午11:43",
          "commitNameOld": "9ffc45dbe0b9ef80ab5cf972a176548781d2206a",
          "commitAuthorOld": "jwilson",
          "daysBetweenCommits": 0.97,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public synchronized Connection get(Address address, StreamAllocation streamAllocation) {\n    for (RealConnection connection : connections) {\n        if (connection.allocations.size() \u003c connection.allocationLimit() \u0026\u0026 address.equals(connection.getRoute().address) \u0026\u0026 !connection.noNewStreams) {\n            streamAllocation.acquire(connection);\n            return connection;\n        }\n    }\n    return null;\n}",
          "path": "okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java",
          "functionStartLine": 171,
          "functionName": "get",
          "functionAnnotation": "",
          "functionDoc": "Returns a recycled connection to {@code address}, or null if no such connection exists.\n",
          "diff": "@@ -1,9 +1,9 @@\n-public synchronized Connection get(Address address) {\n+public synchronized Connection get(Address address, StreamAllocation streamAllocation) {\n     for (RealConnection connection : connections) {\n-        if (connection.allocationCount \u003c connection.allocationLimit() \u0026\u0026 address.equals(connection.getRoute().address) \u0026\u0026 !connection.noNewStreams) {\n-            connection.allocationCount++;\n+        if (connection.allocations.size() \u003c connection.allocationLimit() \u0026\u0026 address.equals(connection.getRoute().address) \u0026\u0026 !connection.noNewStreams) {\n+            streamAllocation.acquire(connection);\n             return connection;\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "c5f58e45454d1ffc621c65e377cb91345018e087": {
      "type": "Ybodychange",
      "commitMessage": "Honor the max concurrent streams setting.\n\nCloses https://github.com/square/okhttp/issues/1484\n",
      "commitDate": "2015/12/3 上午1:44",
      "commitName": "c5f58e45454d1ffc621c65e377cb91345018e087",
      "commitAuthor": "jwilson",
      "commitDateOld": "2015/11/28 下午10:36",
      "commitNameOld": "c358656c8799d30fd422448153e99a5dd37e298a",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 4.13,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "public synchronized Connection get(Address address) {\n    for (RealConnection connection : connections) {\n        if (connection.allocationCount \u003c connection.allocationLimit() \u0026\u0026 address.equals(connection.getRoute().address) \u0026\u0026 !connection.noNewStreams) {\n            connection.allocationCount++;\n            return connection;\n        }\n    }\n    return null;\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java",
      "functionStartLine": 127,
      "functionName": "get",
      "functionAnnotation": "",
      "functionDoc": "Returns a recycled connection to {@code address}, or null if no such connection exists.\n",
      "diff": "@@ -1,9 +1,9 @@\n public synchronized Connection get(Address address) {\n     for (RealConnection connection : connections) {\n-        if (connection.allocationCount \u003c connection.allocationLimit \u0026\u0026 address.equals(connection.getRoute().address) \u0026\u0026 !connection.noNewStreams) {\n+        if (connection.allocationCount \u003c connection.allocationLimit() \u0026\u0026 address.equals(connection.getRoute().address) \u0026\u0026 !connection.noNewStreams) {\n             connection.allocationCount++;\n             return connection;\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c358656c8799d30fd422448153e99a5dd37e298a": {
      "type": "Ybodychange",
      "commitMessage": "First draft of the new new stream allocations model.\n",
      "commitDate": "2015/11/28 下午10:36",
      "commitName": "c358656c8799d30fd422448153e99a5dd37e298a",
      "commitAuthor": "jwilson",
      "commitDateOld": "2015/11/9 下午9:12",
      "commitNameOld": "49a331385343f3ca49d26c4ddd947546867bcd3b",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 19.06,
      "commitsBetweenForRepo": 34,
      "commitsBetweenForFile": 1,
      "actualSource": "public synchronized Connection get(Address address) {\n    for (RealConnection connection : connections) {\n        if (connection.allocationCount \u003c connection.allocationLimit \u0026\u0026 address.equals(connection.getRoute().address) \u0026\u0026 !connection.noNewStreams) {\n            connection.allocationCount++;\n            return connection;\n        }\n    }\n    return null;\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java",
      "functionStartLine": 127,
      "functionName": "get",
      "functionAnnotation": "",
      "functionDoc": "Returns a recycled connection to {@code address}, or null if no such connection exists.\n",
      "diff": "@@ -1,25 +1,9 @@\n public synchronized Connection get(Address address) {\n-    Connection foundConnection \u003d null;\n-    for (Iterator\u003cConnection\u003e i \u003d connections.descendingIterator(); i.hasNext(); ) {\n-        Connection connection \u003d i.next();\n-        if (!connection.getRoute().getAddress().equals(address) || !connection.isAlive() || System.nanoTime() - connection.getIdleStartTimeNs() \u003e\u003d keepAliveDurationNs) {\n-            continue;\n+    for (RealConnection connection : connections) {\n+        if (connection.allocationCount \u003c connection.allocationLimit \u0026\u0026 address.equals(connection.getRoute().address) \u0026\u0026 !connection.noNewStreams) {\n+            connection.allocationCount++;\n+            return connection;\n         }\n-        i.remove();\n-        if (!connection.isFramed()) {\n-            try {\n-                Platform.get().tagSocket(connection.getSocket());\n-            } catch (SocketException e) {\n-                Util.closeQuietly(connection.getSocket());\n-                Platform.get().logW(\"Unable to tagSocket(): \" + e);\n-                continue;\n-            }\n-        }\n-        foundConnection \u003d connection;\n-        break;\n     }\n-    if (foundConnection !\u003d null \u0026\u0026 foundConnection.isFramed()) {\n-        connections.addFirst(foundConnection);\n-    }\n-    return foundConnection;\n+    return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "49a331385343f3ca49d26c4ddd947546867bcd3b": {
      "type": "Ybodychange",
      "commitMessage": "Connection allocations model.\n\nThis is intended to replace some of the state machines in HttpConnection, HttpEngine,\nand ConnectionPool. With this we\u0027ll keep track of all streams in flight, not just\nthe connections currently idle.\n\nNote that I\u0027ve sketched this out into a new Connection.java class. In a follow up\nchange I\u0027ll attempt to combine this with the existing Connection class.\n",
      "commitDate": "2015/11/9 下午9:12",
      "commitName": "49a331385343f3ca49d26c4ddd947546867bcd3b",
      "commitAuthor": "jwilson",
      "commitDateOld": "2015/6/18 上午6:40",
      "commitNameOld": "c753d2e41ba667f9b5a31451a16ecbaecdc65d80",
      "commitAuthorOld": "Jake Wharton",
      "daysBetweenCommits": 144.61,
      "commitsBetweenForRepo": 79,
      "commitsBetweenForFile": 1,
      "actualSource": "public synchronized Connection get(Address address) {\n    Connection foundConnection \u003d null;\n    for (Iterator\u003cConnection\u003e i \u003d connections.descendingIterator(); i.hasNext(); ) {\n        Connection connection \u003d i.next();\n        if (!connection.getRoute().getAddress().equals(address) || !connection.isAlive() || System.nanoTime() - connection.getIdleStartTimeNs() \u003e\u003d keepAliveDurationNs) {\n            continue;\n        }\n        i.remove();\n        if (!connection.isFramed()) {\n            try {\n                Platform.get().tagSocket(connection.getSocket());\n            } catch (SocketException e) {\n                Util.closeQuietly(connection.getSocket());\n                Platform.get().logW(\"Unable to tagSocket(): \" + e);\n                continue;\n            }\n        }\n        foundConnection \u003d connection;\n        break;\n    }\n    if (foundConnection !\u003d null \u0026\u0026 foundConnection.isFramed()) {\n        connections.addFirst(foundConnection);\n    }\n    return foundConnection;\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java",
      "functionStartLine": 137,
      "functionName": "get",
      "functionAnnotation": "",
      "functionDoc": "Returns a recycled connection to {@code address}, or null if no such connection exists.\n",
      "diff": "@@ -1,25 +1,25 @@\n public synchronized Connection get(Address address) {\n     Connection foundConnection \u003d null;\n-    for (ListIterator\u003cConnection\u003e i \u003d connections.listIterator(connections.size()); i.hasPrevious(); ) {\n-        Connection connection \u003d i.previous();\n+    for (Iterator\u003cConnection\u003e i \u003d connections.descendingIterator(); i.hasNext(); ) {\n+        Connection connection \u003d i.next();\n         if (!connection.getRoute().getAddress().equals(address) || !connection.isAlive() || System.nanoTime() - connection.getIdleStartTimeNs() \u003e\u003d keepAliveDurationNs) {\n             continue;\n         }\n         i.remove();\n         if (!connection.isFramed()) {\n             try {\n                 Platform.get().tagSocket(connection.getSocket());\n             } catch (SocketException e) {\n                 Util.closeQuietly(connection.getSocket());\n                 Platform.get().logW(\"Unable to tagSocket(): \" + e);\n                 continue;\n             }\n         }\n         foundConnection \u003d connection;\n         break;\n     }\n     if (foundConnection !\u003d null \u0026\u0026 foundConnection.isFramed()) {\n         connections.addFirst(foundConnection);\n     }\n     return foundConnection;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c753d2e41ba667f9b5a31451a16ecbaecdc65d80": {
      "type": "Ybodychange",
      "commitMessage": "Rename \u0027spdy\u0027 references to \u0027framed\u0027 where appropriate.\n",
      "commitDate": "2015/6/18 上午6:40",
      "commitName": "c753d2e41ba667f9b5a31451a16ecbaecdc65d80",
      "commitAuthor": "Jake Wharton",
      "commitDateOld": "2015/1/14 上午7:33",
      "commitNameOld": "e3d39f7ec069ad49bac7c59c2f2384dd2adf71dd",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 154.96,
      "commitsBetweenForRepo": 131,
      "commitsBetweenForFile": 1,
      "actualSource": "public synchronized Connection get(Address address) {\n    Connection foundConnection \u003d null;\n    for (ListIterator\u003cConnection\u003e i \u003d connections.listIterator(connections.size()); i.hasPrevious(); ) {\n        Connection connection \u003d i.previous();\n        if (!connection.getRoute().getAddress().equals(address) || !connection.isAlive() || System.nanoTime() - connection.getIdleStartTimeNs() \u003e\u003d keepAliveDurationNs) {\n            continue;\n        }\n        i.remove();\n        if (!connection.isFramed()) {\n            try {\n                Platform.get().tagSocket(connection.getSocket());\n            } catch (SocketException e) {\n                Util.closeQuietly(connection.getSocket());\n                Platform.get().logW(\"Unable to tagSocket(): \" + e);\n                continue;\n            }\n        }\n        foundConnection \u003d connection;\n        break;\n    }\n    if (foundConnection !\u003d null \u0026\u0026 foundConnection.isFramed()) {\n        connections.addFirst(foundConnection);\n    }\n    return foundConnection;\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java",
      "functionStartLine": 136,
      "functionName": "get",
      "functionAnnotation": "",
      "functionDoc": "Returns a recycled connection to {@code address}, or null if no such connection exists.\n",
      "diff": "@@ -1,25 +1,25 @@\n public synchronized Connection get(Address address) {\n     Connection foundConnection \u003d null;\n     for (ListIterator\u003cConnection\u003e i \u003d connections.listIterator(connections.size()); i.hasPrevious(); ) {\n         Connection connection \u003d i.previous();\n         if (!connection.getRoute().getAddress().equals(address) || !connection.isAlive() || System.nanoTime() - connection.getIdleStartTimeNs() \u003e\u003d keepAliveDurationNs) {\n             continue;\n         }\n         i.remove();\n-        if (!connection.isSpdy()) {\n+        if (!connection.isFramed()) {\n             try {\n                 Platform.get().tagSocket(connection.getSocket());\n             } catch (SocketException e) {\n                 Util.closeQuietly(connection.getSocket());\n                 Platform.get().logW(\"Unable to tagSocket(): \" + e);\n                 continue;\n             }\n         }\n         foundConnection \u003d connection;\n         break;\n     }\n-    if (foundConnection !\u003d null \u0026\u0026 foundConnection.isSpdy()) {\n+    if (foundConnection !\u003d null \u0026\u0026 foundConnection.isFramed()) {\n         connections.addFirst(foundConnection);\n     }\n     return foundConnection;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "98c74ace40b089f2769afb3e56c59a64eef327cb": {
      "type": "Ybodychange",
      "commitMessage": "Respect the max idle connections limit.\n\nThe structure here is a bit ugly. But it permits a single \u0027synchronized\u0027\nblock, which makes the method easier to reason about.\n\nCloses https://github.com/square/okhttp/issues/1239\n",
      "commitDate": "2014/12/29 下午11:10",
      "commitName": "98c74ace40b089f2769afb3e56c59a64eef327cb",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "2014/12/26 下午2:20",
      "commitNameOld": "8c7c963c24c3e347fd0d0fd641c27058d4eadc2c",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 3.37,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "public synchronized Connection get(Address address) {\n    Connection foundConnection \u003d null;\n    for (ListIterator\u003cConnection\u003e i \u003d connections.listIterator(connections.size()); i.hasPrevious(); ) {\n        Connection connection \u003d i.previous();\n        if (!connection.getRoute().getAddress().equals(address) || !connection.isAlive() || System.nanoTime() - connection.getIdleStartTimeNs() \u003e\u003d keepAliveDurationNs) {\n            continue;\n        }\n        i.remove();\n        if (!connection.isSpdy()) {\n            try {\n                Platform.get().tagSocket(connection.getSocket());\n            } catch (SocketException e) {\n                Util.closeQuietly(connection.getSocket());\n                Platform.get().logW(\"Unable to tagSocket(): \" + e);\n                continue;\n            }\n        }\n        foundConnection \u003d connection;\n        break;\n    }\n    if (foundConnection !\u003d null \u0026\u0026 foundConnection.isSpdy()) {\n        connections.addFirst(foundConnection);\n    }\n    return foundConnection;\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java",
      "functionStartLine": 136,
      "functionName": "get",
      "functionAnnotation": "",
      "functionDoc": "Returns a recycled connection to {@code address}, or null if no such connection exists.\n",
      "diff": "@@ -1,26 +1,25 @@\n public synchronized Connection get(Address address) {\n     Connection foundConnection \u003d null;\n     for (ListIterator\u003cConnection\u003e i \u003d connections.listIterator(connections.size()); i.hasPrevious(); ) {\n         Connection connection \u003d i.previous();\n         if (!connection.getRoute().getAddress().equals(address) || !connection.isAlive() || System.nanoTime() - connection.getIdleStartTimeNs() \u003e\u003d keepAliveDurationNs) {\n             continue;\n         }\n         i.remove();\n         if (!connection.isSpdy()) {\n             try {\n                 Platform.get().tagSocket(connection.getSocket());\n             } catch (SocketException e) {\n                 Util.closeQuietly(connection.getSocket());\n                 Platform.get().logW(\"Unable to tagSocket(): \" + e);\n                 continue;\n             }\n         }\n         foundConnection \u003d connection;\n         break;\n     }\n     if (foundConnection !\u003d null \u0026\u0026 foundConnection.isSpdy()) {\n         connections.addFirst(foundConnection);\n-        scheduleCleanupAsRequired();\n     }\n     return foundConnection;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a8327d121b9eeb3b61ae63f06095d423936a5da2": {
      "type": "Ybodychange",
      "commitMessage": "Fix for a socket leak in OkHttp on Android\n\nWhen the preferred Android network changes from\ncell -\u003e wifi or wifi -\u003e cell the HTTP connection\npool in use is abandoned to avoid reuse of\nconnections on the old network. This was added\nin commit 8bced3e.\n\nThe design for the connection pool was such that\ncontinuous use of the connection pool was required to\nclean up idle / expired connections. If a connection\npool becomes idle (as when it is dereferenced on a\nnetwork change) it is possible for some connections\nto remain in the pool indefinitely.\n\nAfter the preferred network change, because the old\nconnection pool was no longer referenced the pool\nwould be garbage collected and Android\u0027s \"Strict Mode\"\nwould complain about sockets not being closed.\n\nThe only existing way to avoid this was to call\n\"evictAll()\", which would have had issues when a\nlarge number of connections were returned to the pool\nafter evictAll() was called. It also wouldn\u0027t work\nfor SPDY connections which are shared but not reference\ncounted, which makes knowing whether it is safe to\nclose them difficult.\n\nThe cleanModeRunnable serves two purposes:\n\n1) While scheduled / executing, it pins the connection\npool in memory to avoid it being garbage collected.\n2) It continues to close connections (safely) until the\npool is empty.\n\nIf a connection is then added back to the pool the\ncleanModeRunnable is restarted.\n",
      "commitDate": "2014/12/19 上午12:19",
      "commitName": "a8327d121b9eeb3b61ae63f06095d423936a5da2",
      "commitAuthor": "Neil Fuller",
      "commitDateOld": "2014/6/18 上午4:36",
      "commitNameOld": "cdd71f1bbd32f20d63d7100787b91c327d1b5b0c",
      "commitAuthorOld": "Jake Wharton",
      "daysBetweenCommits": 183.82,
      "commitsBetweenForRepo": 121,
      "commitsBetweenForFile": 1,
      "actualSource": "public synchronized Connection get(Address address) {\n    Connection foundConnection \u003d null;\n    for (ListIterator\u003cConnection\u003e i \u003d connections.listIterator(connections.size()); i.hasPrevious(); ) {\n        Connection connection \u003d i.previous();\n        if (!connection.getRoute().getAddress().equals(address) || !connection.isAlive() || System.nanoTime() - connection.getIdleStartTimeNs() \u003e\u003d keepAliveDurationNs) {\n            continue;\n        }\n        i.remove();\n        if (!connection.isSpdy()) {\n            try {\n                Platform.get().tagSocket(connection.getSocket());\n            } catch (SocketException e) {\n                Util.closeQuietly(connection.getSocket());\n                Platform.get().logW(\"Unable to tagSocket(): \" + e);\n                continue;\n            }\n        }\n        foundConnection \u003d connection;\n        break;\n    }\n    if (foundConnection !\u003d null \u0026\u0026 foundConnection.isSpdy()) {\n        connections.addFirst(foundConnection);\n        scheduleCleanupAsRequired();\n    }\n    return foundConnection;\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java",
      "functionStartLine": 162,
      "functionName": "get",
      "functionAnnotation": "",
      "functionDoc": "Returns a recycled connection to {@code address}, or null if no such connection exists.\n",
      "diff": "@@ -1,26 +1,26 @@\n public synchronized Connection get(Address address) {\n     Connection foundConnection \u003d null;\n     for (ListIterator\u003cConnection\u003e i \u003d connections.listIterator(connections.size()); i.hasPrevious(); ) {\n         Connection connection \u003d i.previous();\n         if (!connection.getRoute().getAddress().equals(address) || !connection.isAlive() || System.nanoTime() - connection.getIdleStartTimeNs() \u003e\u003d keepAliveDurationNs) {\n             continue;\n         }\n         i.remove();\n         if (!connection.isSpdy()) {\n             try {\n                 Platform.get().tagSocket(connection.getSocket());\n             } catch (SocketException e) {\n                 Util.closeQuietly(connection.getSocket());\n                 Platform.get().logW(\"Unable to tagSocket(): \" + e);\n                 continue;\n             }\n         }\n         foundConnection \u003d connection;\n         break;\n     }\n     if (foundConnection !\u003d null \u0026\u0026 foundConnection.isSpdy()) {\n         connections.addFirst(foundConnection);\n+        scheduleCleanupAsRequired();\n     }\n-    executorService.execute(connectionsCleanupRunnable);\n     return foundConnection;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c26f9af0489869a9e1873ed5010c65f8464cff26": {
      "type": "Ybodychange",
      "commitMessage": "Hide ConnectionPool.recycle and share.\n",
      "commitDate": "2014/5/1 上午10:02",
      "commitName": "c26f9af0489869a9e1873ed5010c65f8464cff26",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "2014/4/20 下午11:26",
      "commitNameOld": "6e373d870e1be071cd67c350928e44745c72f499",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 10.44,
      "commitsBetweenForRepo": 34,
      "commitsBetweenForFile": 1,
      "actualSource": "public synchronized Connection get(Address address) {\n    Connection foundConnection \u003d null;\n    for (ListIterator\u003cConnection\u003e i \u003d connections.listIterator(connections.size()); i.hasPrevious(); ) {\n        Connection connection \u003d i.previous();\n        if (!connection.getRoute().getAddress().equals(address) || !connection.isAlive() || System.nanoTime() - connection.getIdleStartTimeNs() \u003e\u003d keepAliveDurationNs) {\n            continue;\n        }\n        i.remove();\n        if (!connection.isSpdy()) {\n            try {\n                Platform.get().tagSocket(connection.getSocket());\n            } catch (SocketException e) {\n                Util.closeQuietly(connection.getSocket());\n                Platform.get().logW(\"Unable to tagSocket(): \" + e);\n                continue;\n            }\n        }\n        foundConnection \u003d connection;\n        break;\n    }\n    if (foundConnection !\u003d null \u0026\u0026 foundConnection.isSpdy()) {\n        connections.addFirst(foundConnection);\n    }\n    executorService.execute(connectionsCleanupRunnable);\n    return foundConnection;\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java",
      "functionStartLine": 177,
      "functionName": "get",
      "functionAnnotation": "",
      "functionDoc": "Returns a recycled connection to {@code address}, or null if no such connection exists.\n",
      "diff": "@@ -1,26 +1,26 @@\n public synchronized Connection get(Address address) {\n     Connection foundConnection \u003d null;\n     for (ListIterator\u003cConnection\u003e i \u003d connections.listIterator(connections.size()); i.hasPrevious(); ) {\n         Connection connection \u003d i.previous();\n         if (!connection.getRoute().getAddress().equals(address) || !connection.isAlive() || System.nanoTime() - connection.getIdleStartTimeNs() \u003e\u003d keepAliveDurationNs) {\n             continue;\n         }\n         i.remove();\n         if (!connection.isSpdy()) {\n             try {\n                 Platform.get().tagSocket(connection.getSocket());\n             } catch (SocketException e) {\n-                Util.closeQuietly(connection);\n+                Util.closeQuietly(connection.getSocket());\n                 Platform.get().logW(\"Unable to tagSocket(): \" + e);\n                 continue;\n             }\n         }\n         foundConnection \u003d connection;\n         break;\n     }\n     if (foundConnection !\u003d null \u0026\u0026 foundConnection.isSpdy()) {\n         connections.addFirst(foundConnection);\n     }\n     executorService.execute(connectionsCleanupRunnable);\n     return foundConnection;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fdee6f13a4c5bf5bd24f2c237c2996aea01cc5ff": {
      "type": "Ybodychange",
      "commitMessage": "FindBugs sweep.\n",
      "commitDate": "2014/2/6 上午12:18",
      "commitName": "fdee6f13a4c5bf5bd24f2c237c2996aea01cc5ff",
      "commitAuthor": "Adrian Cole and Jesse Wilson",
      "commitDateOld": "2014/1/12 下午10:47",
      "commitNameOld": "749a65b776c8fc4b39b6463695980275da34da51",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 24.06,
      "commitsBetweenForRepo": 66,
      "commitsBetweenForFile": 1,
      "actualSource": "public synchronized Connection get(Address address) {\n    Connection foundConnection \u003d null;\n    for (ListIterator\u003cConnection\u003e i \u003d connections.listIterator(connections.size()); i.hasPrevious(); ) {\n        Connection connection \u003d i.previous();\n        if (!connection.getRoute().getAddress().equals(address) || !connection.isAlive() || System.nanoTime() - connection.getIdleStartTimeNs() \u003e\u003d keepAliveDurationNs) {\n            continue;\n        }\n        i.remove();\n        if (!connection.isSpdy()) {\n            try {\n                Platform.get().tagSocket(connection.getSocket());\n            } catch (SocketException e) {\n                Util.closeQuietly(connection);\n                Platform.get().logW(\"Unable to tagSocket(): \" + e);\n                continue;\n            }\n        }\n        foundConnection \u003d connection;\n        break;\n    }\n    if (foundConnection !\u003d null \u0026\u0026 foundConnection.isSpdy()) {\n        connections.addFirst(foundConnection);\n    }\n    executorService.execute(connectionsCleanupRunnable);\n    return foundConnection;\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java",
      "functionStartLine": 177,
      "functionName": "get",
      "functionAnnotation": "",
      "functionDoc": "Returns a recycled connection to {@code address}, or null if no such connection exists.\n",
      "diff": "@@ -1,26 +1,26 @@\n public synchronized Connection get(Address address) {\n     Connection foundConnection \u003d null;\n     for (ListIterator\u003cConnection\u003e i \u003d connections.listIterator(connections.size()); i.hasPrevious(); ) {\n         Connection connection \u003d i.previous();\n         if (!connection.getRoute().getAddress().equals(address) || !connection.isAlive() || System.nanoTime() - connection.getIdleStartTimeNs() \u003e\u003d keepAliveDurationNs) {\n             continue;\n         }\n         i.remove();\n         if (!connection.isSpdy()) {\n             try {\n                 Platform.get().tagSocket(connection.getSocket());\n             } catch (SocketException e) {\n                 Util.closeQuietly(connection);\n                 Platform.get().logW(\"Unable to tagSocket(): \" + e);\n                 continue;\n             }\n         }\n         foundConnection \u003d connection;\n         break;\n     }\n     if (foundConnection !\u003d null \u0026\u0026 foundConnection.isSpdy()) {\n         connections.addFirst(foundConnection);\n     }\n-    executorService.submit(connectionsCleanupCallable);\n+    executorService.execute(connectionsCleanupRunnable);\n     return foundConnection;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1ece746c815a26782042b1fca6069eb527d1029b": {
      "type": "Ybodychange",
      "commitMessage": "RouteSelector tries previously failed routes last #106\n",
      "commitDate": "2013/4/11 上午6:19",
      "commitName": "1ece746c815a26782042b1fca6069eb527d1029b",
      "commitAuthor": "Marcelo Cortes",
      "commitDateOld": "2013/3/26 上午11:04",
      "commitNameOld": "7ccbf48838b7cfe42759c67790636d442ea5daa3",
      "commitAuthorOld": "Jake Wharton",
      "daysBetweenCommits": 15.8,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "actualSource": "public synchronized Connection get(Address address) {\n    Connection foundConnection \u003d null;\n    for (ListIterator\u003cConnection\u003e i \u003d connections.listIterator(connections.size()); i.hasPrevious(); ) {\n        Connection connection \u003d i.previous();\n        if (!connection.getRoute().getAddress().equals(address) || !connection.isAlive() || System.nanoTime() - connection.getIdleStartTimeNs() \u003e\u003d keepAliveDurationNs) {\n            continue;\n        }\n        i.remove();\n        if (!connection.isSpdy()) {\n            try {\n                Platform.get().tagSocket(connection.getSocket());\n            } catch (SocketException e) {\n                Util.closeQuietly(connection);\n                Platform.get().logW(\"Unable to tagSocket(): \" + e);\n                continue;\n            }\n        }\n        foundConnection \u003d connection;\n        break;\n    }\n    if (foundConnection !\u003d null \u0026\u0026 foundConnection.isSpdy()) {\n        connections.addFirst(foundConnection);\n    }\n    executorService.submit(connectionsCleanupCallable);\n    return foundConnection;\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java",
      "functionStartLine": 162,
      "functionName": "get",
      "functionAnnotation": "",
      "functionDoc": "Returns a recycled connection to {@code address}, or null if no such connection exists.\n",
      "diff": "@@ -1,26 +1,26 @@\n public synchronized Connection get(Address address) {\n     Connection foundConnection \u003d null;\n     for (ListIterator\u003cConnection\u003e i \u003d connections.listIterator(connections.size()); i.hasPrevious(); ) {\n         Connection connection \u003d i.previous();\n-        if (!connection.getAddress().equals(address) || !connection.isAlive() || System.nanoTime() - connection.getIdleStartTimeNs() \u003e\u003d keepAliveDurationNs) {\n+        if (!connection.getRoute().getAddress().equals(address) || !connection.isAlive() || System.nanoTime() - connection.getIdleStartTimeNs() \u003e\u003d keepAliveDurationNs) {\n             continue;\n         }\n         i.remove();\n         if (!connection.isSpdy()) {\n             try {\n                 Platform.get().tagSocket(connection.getSocket());\n             } catch (SocketException e) {\n                 Util.closeQuietly(connection);\n                 Platform.get().logW(\"Unable to tagSocket(): \" + e);\n                 continue;\n             }\n         }\n         foundConnection \u003d connection;\n         break;\n     }\n     if (foundConnection !\u003d null \u0026\u0026 foundConnection.isSpdy()) {\n         connections.addFirst(foundConnection);\n     }\n     executorService.submit(connectionsCleanupCallable);\n     return foundConnection;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7ccbf48838b7cfe42759c67790636d442ea5daa3": {
      "type": "Yfilerename",
      "commitMessage": "Move library into a module. Introduce sample module with simple GitHub client.\n",
      "commitDate": "2013/3/26 上午11:04",
      "commitName": "7ccbf48838b7cfe42759c67790636d442ea5daa3",
      "commitAuthor": "Jake Wharton",
      "commitDateOld": "2013/3/15 下午10:39",
      "commitNameOld": "ba2b7432cb9fabfc725b09a9f14878cb128ef208",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 10.52,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public synchronized Connection get(Address address) {\n    Connection foundConnection \u003d null;\n    for (ListIterator\u003cConnection\u003e i \u003d connections.listIterator(connections.size()); i.hasPrevious(); ) {\n        Connection connection \u003d i.previous();\n        if (!connection.getAddress().equals(address) || !connection.isAlive() || System.nanoTime() - connection.getIdleStartTimeNs() \u003e\u003d keepAliveDurationNs) {\n            continue;\n        }\n        i.remove();\n        if (!connection.isSpdy()) {\n            try {\n                Platform.get().tagSocket(connection.getSocket());\n            } catch (SocketException e) {\n                Util.closeQuietly(connection);\n                Platform.get().logW(\"Unable to tagSocket(): \" + e);\n                continue;\n            }\n        }\n        foundConnection \u003d connection;\n        break;\n    }\n    if (foundConnection !\u003d null \u0026\u0026 foundConnection.isSpdy()) {\n        connections.addFirst(foundConnection);\n    }\n    executorService.submit(connectionsCleanupCallable);\n    return foundConnection;\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java",
      "functionStartLine": 162,
      "functionName": "get",
      "functionAnnotation": "",
      "functionDoc": "Returns a recycled connection to {@code address}, or null if no such connection exists.\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/main/java/com/squareup/okhttp/ConnectionPool.java",
        "newPath": "okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java"
      }
    },
    "f373e2d6e5bfaa86afc147b877a72d600c224c5d": {
      "type": "Ybodychange",
      "commitMessage": "Fix froyo bug: no more descendingIterator\n",
      "commitDate": "2013/2/28 上午8:19",
      "commitName": "f373e2d6e5bfaa86afc147b877a72d600c224c5d",
      "commitAuthor": "Eric Denman",
      "commitDateOld": "2013/2/28 上午12:31",
      "commitNameOld": "220b5f9a3bac6b78f6ad2d2e159057eb9bcb9908",
      "commitAuthorOld": "Jake Wharton",
      "daysBetweenCommits": 0.33,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public synchronized Connection get(Address address) {\n    Connection foundConnection \u003d null;\n    for (ListIterator\u003cConnection\u003e i \u003d connections.listIterator(connections.size()); i.hasPrevious(); ) {\n        Connection connection \u003d i.previous();\n        if (!connection.getAddress().equals(address) || !connection.isAlive() || System.nanoTime() - connection.getIdleStartTimeNs() \u003e\u003d keepAliveDurationNs) {\n            continue;\n        }\n        i.remove();\n        if (!connection.isSpdy()) {\n            try {\n                Platform.get().tagSocket(connection.getSocket());\n            } catch (SocketException e) {\n                Util.closeQuietly(connection);\n                Platform.get().logW(\"Unable to tagSocket(): \" + e);\n                continue;\n            }\n        }\n        foundConnection \u003d connection;\n        break;\n    }\n    if (foundConnection !\u003d null \u0026\u0026 foundConnection.isSpdy()) {\n        connections.addFirst(foundConnection);\n    }\n    executorService.submit(connectionsCleanupCallable);\n    return foundConnection;\n}",
      "path": "src/main/java/com/squareup/okhttp/ConnectionPool.java",
      "functionStartLine": 162,
      "functionName": "get",
      "functionAnnotation": "",
      "functionDoc": "Returns a recycled connection to {@code address}, or null if no such connection exists.\n",
      "diff": "@@ -1,26 +1,26 @@\n public synchronized Connection get(Address address) {\n     Connection foundConnection \u003d null;\n-    for (Iterator\u003cConnection\u003e i \u003d connections.descendingIterator(); i.hasNext(); ) {\n-        Connection connection \u003d i.next();\n+    for (ListIterator\u003cConnection\u003e i \u003d connections.listIterator(connections.size()); i.hasPrevious(); ) {\n+        Connection connection \u003d i.previous();\n         if (!connection.getAddress().equals(address) || !connection.isAlive() || System.nanoTime() - connection.getIdleStartTimeNs() \u003e\u003d keepAliveDurationNs) {\n             continue;\n         }\n         i.remove();\n         if (!connection.isSpdy()) {\n             try {\n                 Platform.get().tagSocket(connection.getSocket());\n             } catch (SocketException e) {\n                 Util.closeQuietly(connection);\n                 Platform.get().logW(\"Unable to tagSocket(): \" + e);\n                 continue;\n             }\n         }\n         foundConnection \u003d connection;\n         break;\n     }\n     if (foundConnection !\u003d null \u0026\u0026 foundConnection.isSpdy()) {\n         connections.addFirst(foundConnection);\n     }\n     executorService.submit(connectionsCleanupCallable);\n     return foundConnection;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6f6d959fdae64065521990413f86bc7ab038d7c1": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange,Ydocchange)",
      "commitMessage": "Improvements to connection pool\n",
      "commitDate": "2013/2/1 上午6:23",
      "commitName": "6f6d959fdae64065521990413f86bc7ab038d7c1",
      "commitAuthor": "Marcelo Cortes",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "Improvements to connection pool\n",
          "commitDate": "2013/2/1 上午6:23",
          "commitName": "6f6d959fdae64065521990413f86bc7ab038d7c1",
          "commitAuthor": "Marcelo Cortes",
          "commitDateOld": "2013/1/7 上午7:30",
          "commitNameOld": "06579c5bfb6a051a9fbca5be2d15a52fcf77f38c",
          "commitAuthorOld": "jwilson",
          "daysBetweenCommits": 24.95,
          "commitsBetweenForRepo": 10,
          "commitsBetweenForFile": 1,
          "actualSource": "public synchronized Connection get(Address address) {\n    Connection foundConnection \u003d null;\n    for (Iterator\u003cConnection\u003e i \u003d connections.descendingIterator(); i.hasNext(); ) {\n        Connection connection \u003d i.next();\n        if (!connection.getAddress().equals(address) || !connection.isAlive() || System.nanoTime() - connection.getIdleStartTimeNs() \u003e\u003d keepAliveDurationNs) {\n            continue;\n        }\n        i.remove();\n        if (!connection.isSpdy()) {\n            try {\n                Platform.get().tagSocket(connection.getSocket());\n            } catch (SocketException e) {\n                Util.closeQuietly(connection);\n                Platform.get().logW(\"Unable to tagSocket(): \" + e);\n                continue;\n            }\n        }\n        foundConnection \u003d connection;\n        break;\n    }\n    if (foundConnection !\u003d null \u0026\u0026 foundConnection.isSpdy()) {\n        connections.addFirst(foundConnection);\n    }\n    executorService.submit(connectionsCleanupCallable);\n    return foundConnection;\n}",
          "path": "src/main/java/com/squareup/okhttp/ConnectionPool.java",
          "functionStartLine": 163,
          "functionName": "get",
          "functionAnnotation": "",
          "functionDoc": "Returns a recycled connection to {@code address}, or null if no such connection exists.\n",
          "diff": "@@ -1,30 +1,26 @@\n-public Connection get(Address address) {\n-    synchronized (connectionPool) {\n-        List\u003cConnection\u003e connections \u003d connectionPool.get(address);\n-        while (connections !\u003d null) {\n-            Connection connection \u003d connections.get(connections.size() - 1);\n-            boolean usable \u003d connection.isEligibleForRecycling();\n-            if (usable \u0026\u0026 !connection.isSpdy()) {\n-                try {\n-                    Platform.get().tagSocket(connection.getSocket());\n-                } catch (SocketException e) {\n-                    Platform.get().logW(\"Unable to tagSocket(): \" + e);\n-                    usable \u003d false;\n-                }\n-            }\n-            if (!connection.isSpdy() || !usable) {\n-                connections.remove(connections.size() - 1);\n-                if (connections.isEmpty()) {\n-                    connectionPool.remove(address);\n-                    connections \u003d null;\n-                }\n-            }\n-            if (usable) {\n-                return connection;\n-            } else {\n+public synchronized Connection get(Address address) {\n+    Connection foundConnection \u003d null;\n+    for (Iterator\u003cConnection\u003e i \u003d connections.descendingIterator(); i.hasNext(); ) {\n+        Connection connection \u003d i.next();\n+        if (!connection.getAddress().equals(address) || !connection.isAlive() || System.nanoTime() - connection.getIdleStartTimeNs() \u003e\u003d keepAliveDurationNs) {\n+            continue;\n+        }\n+        i.remove();\n+        if (!connection.isSpdy()) {\n+            try {\n+                Platform.get().tagSocket(connection.getSocket());\n+            } catch (SocketException e) {\n                 Util.closeQuietly(connection);\n+                Platform.get().logW(\"Unable to tagSocket(): \" + e);\n+                continue;\n             }\n         }\n+        foundConnection \u003d connection;\n+        break;\n     }\n-    return null;\n+    if (foundConnection !\u003d null \u0026\u0026 foundConnection.isSpdy()) {\n+        connections.addFirst(foundConnection);\n+    }\n+    executorService.submit(connectionsCleanupCallable);\n+    return foundConnection;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[public]",
            "newValue": "[public, synchronized]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Improvements to connection pool\n",
          "commitDate": "2013/2/1 上午6:23",
          "commitName": "6f6d959fdae64065521990413f86bc7ab038d7c1",
          "commitAuthor": "Marcelo Cortes",
          "commitDateOld": "2013/1/7 上午7:30",
          "commitNameOld": "06579c5bfb6a051a9fbca5be2d15a52fcf77f38c",
          "commitAuthorOld": "jwilson",
          "daysBetweenCommits": 24.95,
          "commitsBetweenForRepo": 10,
          "commitsBetweenForFile": 1,
          "actualSource": "public synchronized Connection get(Address address) {\n    Connection foundConnection \u003d null;\n    for (Iterator\u003cConnection\u003e i \u003d connections.descendingIterator(); i.hasNext(); ) {\n        Connection connection \u003d i.next();\n        if (!connection.getAddress().equals(address) || !connection.isAlive() || System.nanoTime() - connection.getIdleStartTimeNs() \u003e\u003d keepAliveDurationNs) {\n            continue;\n        }\n        i.remove();\n        if (!connection.isSpdy()) {\n            try {\n                Platform.get().tagSocket(connection.getSocket());\n            } catch (SocketException e) {\n                Util.closeQuietly(connection);\n                Platform.get().logW(\"Unable to tagSocket(): \" + e);\n                continue;\n            }\n        }\n        foundConnection \u003d connection;\n        break;\n    }\n    if (foundConnection !\u003d null \u0026\u0026 foundConnection.isSpdy()) {\n        connections.addFirst(foundConnection);\n    }\n    executorService.submit(connectionsCleanupCallable);\n    return foundConnection;\n}",
          "path": "src/main/java/com/squareup/okhttp/ConnectionPool.java",
          "functionStartLine": 163,
          "functionName": "get",
          "functionAnnotation": "",
          "functionDoc": "Returns a recycled connection to {@code address}, or null if no such connection exists.\n",
          "diff": "@@ -1,30 +1,26 @@\n-public Connection get(Address address) {\n-    synchronized (connectionPool) {\n-        List\u003cConnection\u003e connections \u003d connectionPool.get(address);\n-        while (connections !\u003d null) {\n-            Connection connection \u003d connections.get(connections.size() - 1);\n-            boolean usable \u003d connection.isEligibleForRecycling();\n-            if (usable \u0026\u0026 !connection.isSpdy()) {\n-                try {\n-                    Platform.get().tagSocket(connection.getSocket());\n-                } catch (SocketException e) {\n-                    Platform.get().logW(\"Unable to tagSocket(): \" + e);\n-                    usable \u003d false;\n-                }\n-            }\n-            if (!connection.isSpdy() || !usable) {\n-                connections.remove(connections.size() - 1);\n-                if (connections.isEmpty()) {\n-                    connectionPool.remove(address);\n-                    connections \u003d null;\n-                }\n-            }\n-            if (usable) {\n-                return connection;\n-            } else {\n+public synchronized Connection get(Address address) {\n+    Connection foundConnection \u003d null;\n+    for (Iterator\u003cConnection\u003e i \u003d connections.descendingIterator(); i.hasNext(); ) {\n+        Connection connection \u003d i.next();\n+        if (!connection.getAddress().equals(address) || !connection.isAlive() || System.nanoTime() - connection.getIdleStartTimeNs() \u003e\u003d keepAliveDurationNs) {\n+            continue;\n+        }\n+        i.remove();\n+        if (!connection.isSpdy()) {\n+            try {\n+                Platform.get().tagSocket(connection.getSocket());\n+            } catch (SocketException e) {\n                 Util.closeQuietly(connection);\n+                Platform.get().logW(\"Unable to tagSocket(): \" + e);\n+                continue;\n             }\n         }\n+        foundConnection \u003d connection;\n+        break;\n     }\n-    return null;\n+    if (foundConnection !\u003d null \u0026\u0026 foundConnection.isSpdy()) {\n+        connections.addFirst(foundConnection);\n+    }\n+    executorService.submit(connectionsCleanupCallable);\n+    return foundConnection;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Improvements to connection pool\n",
          "commitDate": "2013/2/1 上午6:23",
          "commitName": "6f6d959fdae64065521990413f86bc7ab038d7c1",
          "commitAuthor": "Marcelo Cortes",
          "commitDateOld": "2013/1/7 上午7:30",
          "commitNameOld": "06579c5bfb6a051a9fbca5be2d15a52fcf77f38c",
          "commitAuthorOld": "jwilson",
          "daysBetweenCommits": 24.95,
          "commitsBetweenForRepo": 10,
          "commitsBetweenForFile": 1,
          "actualSource": "public synchronized Connection get(Address address) {\n    Connection foundConnection \u003d null;\n    for (Iterator\u003cConnection\u003e i \u003d connections.descendingIterator(); i.hasNext(); ) {\n        Connection connection \u003d i.next();\n        if (!connection.getAddress().equals(address) || !connection.isAlive() || System.nanoTime() - connection.getIdleStartTimeNs() \u003e\u003d keepAliveDurationNs) {\n            continue;\n        }\n        i.remove();\n        if (!connection.isSpdy()) {\n            try {\n                Platform.get().tagSocket(connection.getSocket());\n            } catch (SocketException e) {\n                Util.closeQuietly(connection);\n                Platform.get().logW(\"Unable to tagSocket(): \" + e);\n                continue;\n            }\n        }\n        foundConnection \u003d connection;\n        break;\n    }\n    if (foundConnection !\u003d null \u0026\u0026 foundConnection.isSpdy()) {\n        connections.addFirst(foundConnection);\n    }\n    executorService.submit(connectionsCleanupCallable);\n    return foundConnection;\n}",
          "path": "src/main/java/com/squareup/okhttp/ConnectionPool.java",
          "functionStartLine": 163,
          "functionName": "get",
          "functionAnnotation": "",
          "functionDoc": "Returns a recycled connection to {@code address}, or null if no such connection exists.\n",
          "diff": "@@ -1,30 +1,26 @@\n-public Connection get(Address address) {\n-    synchronized (connectionPool) {\n-        List\u003cConnection\u003e connections \u003d connectionPool.get(address);\n-        while (connections !\u003d null) {\n-            Connection connection \u003d connections.get(connections.size() - 1);\n-            boolean usable \u003d connection.isEligibleForRecycling();\n-            if (usable \u0026\u0026 !connection.isSpdy()) {\n-                try {\n-                    Platform.get().tagSocket(connection.getSocket());\n-                } catch (SocketException e) {\n-                    Platform.get().logW(\"Unable to tagSocket(): \" + e);\n-                    usable \u003d false;\n-                }\n-            }\n-            if (!connection.isSpdy() || !usable) {\n-                connections.remove(connections.size() - 1);\n-                if (connections.isEmpty()) {\n-                    connectionPool.remove(address);\n-                    connections \u003d null;\n-                }\n-            }\n-            if (usable) {\n-                return connection;\n-            } else {\n+public synchronized Connection get(Address address) {\n+    Connection foundConnection \u003d null;\n+    for (Iterator\u003cConnection\u003e i \u003d connections.descendingIterator(); i.hasNext(); ) {\n+        Connection connection \u003d i.next();\n+        if (!connection.getAddress().equals(address) || !connection.isAlive() || System.nanoTime() - connection.getIdleStartTimeNs() \u003e\u003d keepAliveDurationNs) {\n+            continue;\n+        }\n+        i.remove();\n+        if (!connection.isSpdy()) {\n+            try {\n+                Platform.get().tagSocket(connection.getSocket());\n+            } catch (SocketException e) {\n                 Util.closeQuietly(connection);\n+                Platform.get().logW(\"Unable to tagSocket(): \" + e);\n+                continue;\n             }\n         }\n+        foundConnection \u003d connection;\n+        break;\n     }\n-    return null;\n+    if (foundConnection !\u003d null \u0026\u0026 foundConnection.isSpdy()) {\n+        connections.addFirst(foundConnection);\n+    }\n+    executorService.submit(connectionsCleanupCallable);\n+    return foundConnection;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Returns a recycled connection to {@code address}, or null if no such\nconnection exists.\n",
            "newValue": "Returns a recycled connection to {@code address}, or null if no such connection exists.\n"
          }
        }
      ]
    },
    "06579c5bfb6a051a9fbca5be2d15a52fcf77f38c": {
      "type": "Ybodychange",
      "commitMessage": "Upgrade from spdy/2 to spdy/3.\n",
      "commitDate": "2013/1/7 上午7:30",
      "commitName": "06579c5bfb6a051a9fbca5be2d15a52fcf77f38c",
      "commitAuthor": "jwilson",
      "commitDateOld": "2013/1/2 上午11:50",
      "commitNameOld": "689f66222bd8984dd69229a4ee9caf8da528ae12",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 4.82,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public Connection get(Address address) {\n    synchronized (connectionPool) {\n        List\u003cConnection\u003e connections \u003d connectionPool.get(address);\n        while (connections !\u003d null) {\n            Connection connection \u003d connections.get(connections.size() - 1);\n            boolean usable \u003d connection.isEligibleForRecycling();\n            if (usable \u0026\u0026 !connection.isSpdy()) {\n                try {\n                    Platform.get().tagSocket(connection.getSocket());\n                } catch (SocketException e) {\n                    Platform.get().logW(\"Unable to tagSocket(): \" + e);\n                    usable \u003d false;\n                }\n            }\n            if (!connection.isSpdy() || !usable) {\n                connections.remove(connections.size() - 1);\n                if (connections.isEmpty()) {\n                    connectionPool.remove(address);\n                    connections \u003d null;\n                }\n            }\n            if (usable) {\n                return connection;\n            } else {\n                Util.closeQuietly(connection);\n            }\n        }\n    }\n    return null;\n}",
      "path": "src/main/java/com/squareup/okhttp/ConnectionPool.java",
      "functionStartLine": 77,
      "functionName": "get",
      "functionAnnotation": "",
      "functionDoc": "Returns a recycled connection to {@code address}, or null if no such\nconnection exists.\n",
      "diff": "@@ -1,28 +1,30 @@\n public Connection get(Address address) {\n     synchronized (connectionPool) {\n         List\u003cConnection\u003e connections \u003d connectionPool.get(address);\n         while (connections !\u003d null) {\n             Connection connection \u003d connections.get(connections.size() - 1);\n-            if (!connection.isSpdy()) {\n+            boolean usable \u003d connection.isEligibleForRecycling();\n+            if (usable \u0026\u0026 !connection.isSpdy()) {\n+                try {\n+                    Platform.get().tagSocket(connection.getSocket());\n+                } catch (SocketException e) {\n+                    Platform.get().logW(\"Unable to tagSocket(): \" + e);\n+                    usable \u003d false;\n+                }\n+            }\n+            if (!connection.isSpdy() || !usable) {\n                 connections.remove(connections.size() - 1);\n+                if (connections.isEmpty()) {\n+                    connectionPool.remove(address);\n+                    connections \u003d null;\n+                }\n             }\n-            if (connections.isEmpty()) {\n-                connectionPool.remove(address);\n-                connections \u003d null;\n-            }\n-            if (!connection.isEligibleForRecycling()) {\n+            if (usable) {\n+                return connection;\n+            } else {\n                 Util.closeQuietly(connection);\n-                continue;\n             }\n-            try {\n-                Platform.get().tagSocket(connection.getSocket());\n-            } catch (SocketException e) {\n-                Platform.get().logW(\"Unable to tagSocket(): \" + e);\n-                Util.closeQuietly(connection);\n-                continue;\n-            }\n-            return connection;\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "689f66222bd8984dd69229a4ee9caf8da528ae12": {
      "type": "Ybodychange",
      "commitMessage": "Flatten internal packages and utility classes.\n\nThe previous structure had hierarchy that was useful\nfor libcore but overkill for OkHttp.\n",
      "commitDate": "2013/1/2 上午11:50",
      "commitName": "689f66222bd8984dd69229a4ee9caf8da528ae12",
      "commitAuthor": "jwilson",
      "commitDateOld": "2012/12/31 下午3:35",
      "commitNameOld": "60d5852c6676ece85b0e3d0c6e45fb0186303f83",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 1.84,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "public Connection get(Address address) {\n    synchronized (connectionPool) {\n        List\u003cConnection\u003e connections \u003d connectionPool.get(address);\n        while (connections !\u003d null) {\n            Connection connection \u003d connections.get(connections.size() - 1);\n            if (!connection.isSpdy()) {\n                connections.remove(connections.size() - 1);\n            }\n            if (connections.isEmpty()) {\n                connectionPool.remove(address);\n                connections \u003d null;\n            }\n            if (!connection.isEligibleForRecycling()) {\n                Util.closeQuietly(connection);\n                continue;\n            }\n            try {\n                Platform.get().tagSocket(connection.getSocket());\n            } catch (SocketException e) {\n                Platform.get().logW(\"Unable to tagSocket(): \" + e);\n                Util.closeQuietly(connection);\n                continue;\n            }\n            return connection;\n        }\n    }\n    return null;\n}",
      "path": "src/main/java/com/squareup/okhttp/ConnectionPool.java",
      "functionStartLine": 77,
      "functionName": "get",
      "functionAnnotation": "",
      "functionDoc": "Returns a recycled connection to {@code address}, or null if no such\nconnection exists.\n",
      "diff": "@@ -1,28 +1,28 @@\n public Connection get(Address address) {\n     synchronized (connectionPool) {\n         List\u003cConnection\u003e connections \u003d connectionPool.get(address);\n         while (connections !\u003d null) {\n             Connection connection \u003d connections.get(connections.size() - 1);\n             if (!connection.isSpdy()) {\n                 connections.remove(connections.size() - 1);\n             }\n             if (connections.isEmpty()) {\n                 connectionPool.remove(address);\n                 connections \u003d null;\n             }\n             if (!connection.isEligibleForRecycling()) {\n-                IoUtils.closeQuietly(connection);\n+                Util.closeQuietly(connection);\n                 continue;\n             }\n             try {\n                 Platform.get().tagSocket(connection.getSocket());\n             } catch (SocketException e) {\n                 Platform.get().logW(\"Unable to tagSocket(): \" + e);\n-                IoUtils.closeQuietly(connection);\n+                Util.closeQuietly(connection);\n                 continue;\n             }\n             return connection;\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "67604f618d96ae00318ce696ec29a66bec6aafa8": {
      "type": "Ybodychange",
      "commitMessage": "Clean up utility code for submission to AOSP.\n\nThis moves methods that will have Android-specific implementations\nto Platform.java; all other utility methods are in a junk drawer\nclass called Utils.java.\n\nThis also moves method names (like \"GET\") to compare with .equals\ninstead of \u0027\u003d\u003d\u0027. The old code took advantage of a hidden agreement\nbetween HttpURLConnection and HttpEngine; with these in separate\nprojects that behavior isn\u0027t as obvious and shouldn\u0027t be relied\nupon.\n",
      "commitDate": "2012/12/27 上午2:31",
      "commitName": "67604f618d96ae00318ce696ec29a66bec6aafa8",
      "commitAuthor": "jwilson",
      "commitDateOld": "2012/12/24 下午1:39",
      "commitNameOld": "78c6624b11d5f33504dae8211b4592383468343e",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 2.54,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public Connection get(Address address) {\n    synchronized (connectionPool) {\n        List\u003cConnection\u003e connections \u003d connectionPool.get(address);\n        while (connections !\u003d null) {\n            Connection connection \u003d connections.get(connections.size() - 1);\n            if (!connection.isSpdy()) {\n                connections.remove(connections.size() - 1);\n            }\n            if (connections.isEmpty()) {\n                connectionPool.remove(address);\n                connections \u003d null;\n            }\n            if (!connection.isEligibleForRecycling()) {\n                IoUtils.closeQuietly(connection);\n                continue;\n            }\n            try {\n                Platform.get().tagSocket(connection.getSocket());\n            } catch (SocketException e) {\n                Platform.get().logW(\"Unable to tagSocket(): \" + e);\n                IoUtils.closeQuietly(connection);\n                continue;\n            }\n            return connection;\n        }\n    }\n    return null;\n}",
      "path": "src/main/java/com/squareup/okhttp/ConnectionPool.java",
      "functionStartLine": 77,
      "functionName": "get",
      "functionAnnotation": "",
      "functionDoc": "Returns a recycled connection to {@code address}, or null if no such\nconnection exists.\n",
      "diff": "@@ -1,21 +1,28 @@\n public Connection get(Address address) {\n     synchronized (connectionPool) {\n         List\u003cConnection\u003e connections \u003d connectionPool.get(address);\n         while (connections !\u003d null) {\n             Connection connection \u003d connections.get(connections.size() - 1);\n             if (!connection.isSpdy()) {\n                 connections.remove(connections.size() - 1);\n             }\n             if (connections.isEmpty()) {\n                 connectionPool.remove(address);\n                 connections \u003d null;\n             }\n-            if (connection.isEligibleForRecycling()) {\n-                Libcore.tagSocket(connection.getSocket());\n-                return connection;\n-            } else {\n+            if (!connection.isEligibleForRecycling()) {\n+                IoUtils.closeQuietly(connection);\n+                continue;\n             }\n+            try {\n+                Platform.get().tagSocket(connection.getSocket());\n+            } catch (SocketException e) {\n+                Platform.get().logW(\"Unable to tagSocket(): \" + e);\n+                IoUtils.closeQuietly(connection);\n+                continue;\n+            }\n+            return connection;\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "78c6624b11d5f33504dae8211b4592383468343e": {
      "type": "Ymultichange(Yfilerename,Yreturntypechange,Ybodychange,Ydocchange,Yparameterchange)",
      "commitMessage": "Promote Connection, ConnectionPool and Address APIs.\n\nThis moves HttpConnection.Address and HttpConnection.TunnelConfig\nto their own top-level classes.\n",
      "commitDate": "2012/12/24 下午1:39",
      "commitName": "78c6624b11d5f33504dae8211b4592383468343e",
      "commitAuthor": "jwilson",
      "subchanges": [
        {
          "type": "Yfilerename",
          "commitMessage": "Promote Connection, ConnectionPool and Address APIs.\n\nThis moves HttpConnection.Address and HttpConnection.TunnelConfig\nto their own top-level classes.\n",
          "commitDate": "2012/12/24 下午1:39",
          "commitName": "78c6624b11d5f33504dae8211b4592383468343e",
          "commitAuthor": "jwilson",
          "commitDateOld": "2012/12/24 上午5:38",
          "commitNameOld": "73291e89c43de449949450c216a5220d9b903da6",
          "commitAuthorOld": "Jake Wharton",
          "daysBetweenCommits": 0.33,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public Connection get(Address address) {\n    synchronized (connectionPool) {\n        List\u003cConnection\u003e connections \u003d connectionPool.get(address);\n        while (connections !\u003d null) {\n            Connection connection \u003d connections.get(connections.size() - 1);\n            if (!connection.isSpdy()) {\n                connections.remove(connections.size() - 1);\n            }\n            if (connections.isEmpty()) {\n                connectionPool.remove(address);\n                connections \u003d null;\n            }\n            if (connection.isEligibleForRecycling()) {\n                Libcore.tagSocket(connection.getSocket());\n                return connection;\n            } else {\n            }\n        }\n    }\n    return null;\n}",
          "path": "src/main/java/com/squareup/okhttp/ConnectionPool.java",
          "functionStartLine": 77,
          "functionName": "get",
          "functionAnnotation": "",
          "functionDoc": "Returns a recycled connection to {@code address}, or null if no such\nconnection exists.\n",
          "diff": "@@ -1,21 +1,21 @@\n-public HttpConnection get(HttpConnection.Address address) {\n+public Connection get(Address address) {\n     synchronized (connectionPool) {\n-        List\u003cHttpConnection\u003e connections \u003d connectionPool.get(address);\n+        List\u003cConnection\u003e connections \u003d connectionPool.get(address);\n         while (connections !\u003d null) {\n-            HttpConnection connection \u003d connections.get(connections.size() - 1);\n+            Connection connection \u003d connections.get(connections.size() - 1);\n             if (!connection.isSpdy()) {\n                 connections.remove(connections.size() - 1);\n             }\n             if (connections.isEmpty()) {\n                 connectionPool.remove(address);\n                 connections \u003d null;\n             }\n             if (connection.isEligibleForRecycling()) {\n                 Libcore.tagSocket(connection.getSocket());\n                 return connection;\n             } else {\n             }\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldPath": "src/main/java/com/squareup/okhttp/internal/net/http/HttpConnectionPool.java",
            "newPath": "src/main/java/com/squareup/okhttp/ConnectionPool.java"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "Promote Connection, ConnectionPool and Address APIs.\n\nThis moves HttpConnection.Address and HttpConnection.TunnelConfig\nto their own top-level classes.\n",
          "commitDate": "2012/12/24 下午1:39",
          "commitName": "78c6624b11d5f33504dae8211b4592383468343e",
          "commitAuthor": "jwilson",
          "commitDateOld": "2012/12/24 上午5:38",
          "commitNameOld": "73291e89c43de449949450c216a5220d9b903da6",
          "commitAuthorOld": "Jake Wharton",
          "daysBetweenCommits": 0.33,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public Connection get(Address address) {\n    synchronized (connectionPool) {\n        List\u003cConnection\u003e connections \u003d connectionPool.get(address);\n        while (connections !\u003d null) {\n            Connection connection \u003d connections.get(connections.size() - 1);\n            if (!connection.isSpdy()) {\n                connections.remove(connections.size() - 1);\n            }\n            if (connections.isEmpty()) {\n                connectionPool.remove(address);\n                connections \u003d null;\n            }\n            if (connection.isEligibleForRecycling()) {\n                Libcore.tagSocket(connection.getSocket());\n                return connection;\n            } else {\n            }\n        }\n    }\n    return null;\n}",
          "path": "src/main/java/com/squareup/okhttp/ConnectionPool.java",
          "functionStartLine": 77,
          "functionName": "get",
          "functionAnnotation": "",
          "functionDoc": "Returns a recycled connection to {@code address}, or null if no such\nconnection exists.\n",
          "diff": "@@ -1,21 +1,21 @@\n-public HttpConnection get(HttpConnection.Address address) {\n+public Connection get(Address address) {\n     synchronized (connectionPool) {\n-        List\u003cHttpConnection\u003e connections \u003d connectionPool.get(address);\n+        List\u003cConnection\u003e connections \u003d connectionPool.get(address);\n         while (connections !\u003d null) {\n-            HttpConnection connection \u003d connections.get(connections.size() - 1);\n+            Connection connection \u003d connections.get(connections.size() - 1);\n             if (!connection.isSpdy()) {\n                 connections.remove(connections.size() - 1);\n             }\n             if (connections.isEmpty()) {\n                 connectionPool.remove(address);\n                 connections \u003d null;\n             }\n             if (connection.isEligibleForRecycling()) {\n                 Libcore.tagSocket(connection.getSocket());\n                 return connection;\n             } else {\n             }\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "HttpConnection",
            "newValue": "Connection"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Promote Connection, ConnectionPool and Address APIs.\n\nThis moves HttpConnection.Address and HttpConnection.TunnelConfig\nto their own top-level classes.\n",
          "commitDate": "2012/12/24 下午1:39",
          "commitName": "78c6624b11d5f33504dae8211b4592383468343e",
          "commitAuthor": "jwilson",
          "commitDateOld": "2012/12/24 上午5:38",
          "commitNameOld": "73291e89c43de449949450c216a5220d9b903da6",
          "commitAuthorOld": "Jake Wharton",
          "daysBetweenCommits": 0.33,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public Connection get(Address address) {\n    synchronized (connectionPool) {\n        List\u003cConnection\u003e connections \u003d connectionPool.get(address);\n        while (connections !\u003d null) {\n            Connection connection \u003d connections.get(connections.size() - 1);\n            if (!connection.isSpdy()) {\n                connections.remove(connections.size() - 1);\n            }\n            if (connections.isEmpty()) {\n                connectionPool.remove(address);\n                connections \u003d null;\n            }\n            if (connection.isEligibleForRecycling()) {\n                Libcore.tagSocket(connection.getSocket());\n                return connection;\n            } else {\n            }\n        }\n    }\n    return null;\n}",
          "path": "src/main/java/com/squareup/okhttp/ConnectionPool.java",
          "functionStartLine": 77,
          "functionName": "get",
          "functionAnnotation": "",
          "functionDoc": "Returns a recycled connection to {@code address}, or null if no such\nconnection exists.\n",
          "diff": "@@ -1,21 +1,21 @@\n-public HttpConnection get(HttpConnection.Address address) {\n+public Connection get(Address address) {\n     synchronized (connectionPool) {\n-        List\u003cHttpConnection\u003e connections \u003d connectionPool.get(address);\n+        List\u003cConnection\u003e connections \u003d connectionPool.get(address);\n         while (connections !\u003d null) {\n-            HttpConnection connection \u003d connections.get(connections.size() - 1);\n+            Connection connection \u003d connections.get(connections.size() - 1);\n             if (!connection.isSpdy()) {\n                 connections.remove(connections.size() - 1);\n             }\n             if (connections.isEmpty()) {\n                 connectionPool.remove(address);\n                 connections \u003d null;\n             }\n             if (connection.isEligibleForRecycling()) {\n                 Libcore.tagSocket(connection.getSocket());\n                 return connection;\n             } else {\n             }\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Promote Connection, ConnectionPool and Address APIs.\n\nThis moves HttpConnection.Address and HttpConnection.TunnelConfig\nto their own top-level classes.\n",
          "commitDate": "2012/12/24 下午1:39",
          "commitName": "78c6624b11d5f33504dae8211b4592383468343e",
          "commitAuthor": "jwilson",
          "commitDateOld": "2012/12/24 上午5:38",
          "commitNameOld": "73291e89c43de449949450c216a5220d9b903da6",
          "commitAuthorOld": "Jake Wharton",
          "daysBetweenCommits": 0.33,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public Connection get(Address address) {\n    synchronized (connectionPool) {\n        List\u003cConnection\u003e connections \u003d connectionPool.get(address);\n        while (connections !\u003d null) {\n            Connection connection \u003d connections.get(connections.size() - 1);\n            if (!connection.isSpdy()) {\n                connections.remove(connections.size() - 1);\n            }\n            if (connections.isEmpty()) {\n                connectionPool.remove(address);\n                connections \u003d null;\n            }\n            if (connection.isEligibleForRecycling()) {\n                Libcore.tagSocket(connection.getSocket());\n                return connection;\n            } else {\n            }\n        }\n    }\n    return null;\n}",
          "path": "src/main/java/com/squareup/okhttp/ConnectionPool.java",
          "functionStartLine": 77,
          "functionName": "get",
          "functionAnnotation": "",
          "functionDoc": "Returns a recycled connection to {@code address}, or null if no such\nconnection exists.\n",
          "diff": "@@ -1,21 +1,21 @@\n-public HttpConnection get(HttpConnection.Address address) {\n+public Connection get(Address address) {\n     synchronized (connectionPool) {\n-        List\u003cHttpConnection\u003e connections \u003d connectionPool.get(address);\n+        List\u003cConnection\u003e connections \u003d connectionPool.get(address);\n         while (connections !\u003d null) {\n-            HttpConnection connection \u003d connections.get(connections.size() - 1);\n+            Connection connection \u003d connections.get(connections.size() - 1);\n             if (!connection.isSpdy()) {\n                 connections.remove(connections.size() - 1);\n             }\n             if (connections.isEmpty()) {\n                 connectionPool.remove(address);\n                 connections \u003d null;\n             }\n             if (connection.isEligibleForRecycling()) {\n                 Libcore.tagSocket(connection.getSocket());\n                 return connection;\n             } else {\n             }\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "",
            "newValue": "Returns a recycled connection to {@code address}, or null if no such\nconnection exists.\n"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "Promote Connection, ConnectionPool and Address APIs.\n\nThis moves HttpConnection.Address and HttpConnection.TunnelConfig\nto their own top-level classes.\n",
          "commitDate": "2012/12/24 下午1:39",
          "commitName": "78c6624b11d5f33504dae8211b4592383468343e",
          "commitAuthor": "jwilson",
          "commitDateOld": "2012/12/24 上午5:38",
          "commitNameOld": "73291e89c43de449949450c216a5220d9b903da6",
          "commitAuthorOld": "Jake Wharton",
          "daysBetweenCommits": 0.33,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public Connection get(Address address) {\n    synchronized (connectionPool) {\n        List\u003cConnection\u003e connections \u003d connectionPool.get(address);\n        while (connections !\u003d null) {\n            Connection connection \u003d connections.get(connections.size() - 1);\n            if (!connection.isSpdy()) {\n                connections.remove(connections.size() - 1);\n            }\n            if (connections.isEmpty()) {\n                connectionPool.remove(address);\n                connections \u003d null;\n            }\n            if (connection.isEligibleForRecycling()) {\n                Libcore.tagSocket(connection.getSocket());\n                return connection;\n            } else {\n            }\n        }\n    }\n    return null;\n}",
          "path": "src/main/java/com/squareup/okhttp/ConnectionPool.java",
          "functionStartLine": 77,
          "functionName": "get",
          "functionAnnotation": "",
          "functionDoc": "Returns a recycled connection to {@code address}, or null if no such\nconnection exists.\n",
          "diff": "@@ -1,21 +1,21 @@\n-public HttpConnection get(HttpConnection.Address address) {\n+public Connection get(Address address) {\n     synchronized (connectionPool) {\n-        List\u003cHttpConnection\u003e connections \u003d connectionPool.get(address);\n+        List\u003cConnection\u003e connections \u003d connectionPool.get(address);\n         while (connections !\u003d null) {\n-            HttpConnection connection \u003d connections.get(connections.size() - 1);\n+            Connection connection \u003d connections.get(connections.size() - 1);\n             if (!connection.isSpdy()) {\n                 connections.remove(connections.size() - 1);\n             }\n             if (connections.isEmpty()) {\n                 connectionPool.remove(address);\n                 connections \u003d null;\n             }\n             if (connection.isEligibleForRecycling()) {\n                 Libcore.tagSocket(connection.getSocket());\n                 return connection;\n             } else {\n             }\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[address-HttpConnection.Address]",
            "newValue": "[address-Address]"
          }
        }
      ]
    },
    "70e64037ff295874602133a1d254e5a0440ae4e3": {
      "type": "Ybodychange",
      "commitMessage": "Prepare to promote HttpConnection + Pool to public API.\n\nGiving the application code access to the connection pool\nis tricky: it exposes more implementation details from\nOkHttp; details that are quite inaccessible through the\nconventional HttpURLConnection APIs. Currently the only\nthing regular users get are a pair of awkward system\nproperties.\n\nBut exposing these should also be useful: it\u0027ll allow the\napplication to observe the pool (for performance monitoring)\nand possibly also to directly manage it (by setting policy,\nor to evict when the application is paused).\n",
      "commitDate": "2012/12/23 上午7:05",
      "commitName": "70e64037ff295874602133a1d254e5a0440ae4e3",
      "commitAuthor": "jwilson",
      "commitDateOld": "2012/12/23 上午2:40",
      "commitNameOld": "3d2547f18886e771aaa9baa996a21136c93460c4",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 0.18,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public HttpConnection get(HttpConnection.Address address) {\n    synchronized (connectionPool) {\n        List\u003cHttpConnection\u003e connections \u003d connectionPool.get(address);\n        while (connections !\u003d null) {\n            HttpConnection connection \u003d connections.get(connections.size() - 1);\n            if (!connection.isSpdy()) {\n                connections.remove(connections.size() - 1);\n            }\n            if (connections.isEmpty()) {\n                connectionPool.remove(address);\n                connections \u003d null;\n            }\n            if (connection.isEligibleForRecycling()) {\n                Libcore.tagSocket(connection.getSocket());\n                return connection;\n            } else {\n            }\n        }\n    }\n    return null;\n}",
      "path": "src/main/java/com/squareup/okhttp/internal/net/http/HttpConnectionPool.java",
      "functionStartLine": 61,
      "functionName": "get",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,20 +1,21 @@\n public HttpConnection get(HttpConnection.Address address) {\n     synchronized (connectionPool) {\n         List\u003cHttpConnection\u003e connections \u003d connectionPool.get(address);\n         while (connections !\u003d null) {\n             HttpConnection connection \u003d connections.get(connections.size() - 1);\n             if (!connection.isSpdy()) {\n                 connections.remove(connections.size() - 1);\n             }\n             if (connections.isEmpty()) {\n                 connectionPool.remove(address);\n                 connections \u003d null;\n             }\n             if (connection.isEligibleForRecycling()) {\n                 Libcore.tagSocket(connection.getSocket());\n                 return connection;\n+            } else {\n             }\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3d2547f18886e771aaa9baa996a21136c93460c4": {
      "type": "Ybodychange",
      "commitMessage": "Restore tests for response caching + TLS.\n\nOne of the test cases bitrotted to failure as a consequence\nof the HTTP route selector change. I stopped assigning the\nsocket, which it needed to cache the TLS metadata. This is\nfixed.\n",
      "commitDate": "2012/12/23 上午2:40",
      "commitName": "3d2547f18886e771aaa9baa996a21136c93460c4",
      "commitAuthor": "jwilson",
      "commitDateOld": "2012/12/16 上午5:55",
      "commitNameOld": "50999cceb5f5bcdaf79baa5ac7eeef90c72bda8d",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 6.86,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "public HttpConnection get(HttpConnection.Address address) {\n    synchronized (connectionPool) {\n        List\u003cHttpConnection\u003e connections \u003d connectionPool.get(address);\n        while (connections !\u003d null) {\n            HttpConnection connection \u003d connections.get(connections.size() - 1);\n            if (!connection.isSpdy()) {\n                connections.remove(connections.size() - 1);\n            }\n            if (connections.isEmpty()) {\n                connectionPool.remove(address);\n                connections \u003d null;\n            }\n            if (connection.isEligibleForRecycling()) {\n                Libcore.tagSocket(connection.getSocket());\n                return connection;\n            }\n        }\n    }\n    return null;\n}",
      "path": "src/main/java/com/squareup/okhttp/internal/net/http/HttpConnectionPool.java",
      "functionStartLine": 60,
      "functionName": "get",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,21 +1,20 @@\n public HttpConnection get(HttpConnection.Address address) {\n     synchronized (connectionPool) {\n         List\u003cHttpConnection\u003e connections \u003d connectionPool.get(address);\n         while (connections !\u003d null) {\n             HttpConnection connection \u003d connections.get(connections.size() - 1);\n             if (!connection.isSpdy()) {\n                 connections.remove(connections.size() - 1);\n             }\n             if (connections.isEmpty()) {\n                 connectionPool.remove(address);\n                 connections \u003d null;\n             }\n             if (connection.isEligibleForRecycling()) {\n-                Socket socket \u003d connection.getSocket();\n-                Libcore.tagSocket(socket);\n+                Libcore.tagSocket(connection.getSocket());\n                 return connection;\n             }\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "50999cceb5f5bcdaf79baa5ac7eeef90c72bda8d": {
      "type": "Yfilerename",
      "commitMessage": "Move out of the libcore package.\n\nTo promote the code into AOSP, we\u0027ll keep this package as-is\nand do the jarjar in Android instead.\n",
      "commitDate": "2012/12/16 上午5:55",
      "commitName": "50999cceb5f5bcdaf79baa5ac7eeef90c72bda8d",
      "commitAuthor": "jwilson",
      "commitDateOld": "2012/12/16 上午5:17",
      "commitNameOld": "7f7aa90bc5d41d8f818fc988d2a91d22393c7329",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public HttpConnection get(HttpConnection.Address address) {\n    synchronized (connectionPool) {\n        List\u003cHttpConnection\u003e connections \u003d connectionPool.get(address);\n        while (connections !\u003d null) {\n            HttpConnection connection \u003d connections.get(connections.size() - 1);\n            if (!connection.isSpdy()) {\n                connections.remove(connections.size() - 1);\n            }\n            if (connections.isEmpty()) {\n                connectionPool.remove(address);\n                connections \u003d null;\n            }\n            if (connection.isEligibleForRecycling()) {\n                Socket socket \u003d connection.getSocket();\n                Libcore.tagSocket(socket);\n                return connection;\n            }\n        }\n    }\n    return null;\n}",
      "path": "src/main/java/com/squareup/okhttp/internal/net/http/HttpConnectionPool.java",
      "functionStartLine": 61,
      "functionName": "get",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/main/java/libcore/net/http/HttpConnectionPool.java",
        "newPath": "src/main/java/com/squareup/okhttp/internal/net/http/HttpConnectionPool.java"
      }
    },
    "40ff76547064c3fb5acb9047a6f679dd4379a4d0": {
      "type": "Ymultichange(Yparameterchange,Yexceptionschange,Ybodychange)",
      "commitMessage": "Make HttpConnection.connect return full working connections.\n\nPreviously the returned connections required the caller to\ndo extra work: setting up tunnels (which could require auth)\nand performing an SSL handshake. With this change we make a\ncomplete working connection in HttpConnection.connect().\n\nThis will make it easier to fix fallback when a single domain\nhas multiple IP addresses and some of those addresses are not\nreachable.\n\nThis will also make it easier to do SPDY through HTTP proxies.\n",
      "commitDate": "2012/11/6 下午12:25",
      "commitName": "40ff76547064c3fb5acb9047a6f679dd4379a4d0",
      "commitAuthor": "Jesse Wilson",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Make HttpConnection.connect return full working connections.\n\nPreviously the returned connections required the caller to\ndo extra work: setting up tunnels (which could require auth)\nand performing an SSL handshake. With this change we make a\ncomplete working connection in HttpConnection.connect().\n\nThis will make it easier to fix fallback when a single domain\nhas multiple IP addresses and some of those addresses are not\nreachable.\n\nThis will also make it easier to do SPDY through HTTP proxies.\n",
          "commitDate": "2012/11/6 下午12:25",
          "commitName": "40ff76547064c3fb5acb9047a6f679dd4379a4d0",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "2012/9/26 上午2:29",
          "commitNameOld": "60b3a6dd6240f40c29fffd897c2dac314af49836",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 41.41,
          "commitsBetweenForRepo": 14,
          "commitsBetweenForFile": 1,
          "actualSource": "public HttpConnection get(HttpConnection.Address address) {\n    synchronized (connectionPool) {\n        List\u003cHttpConnection\u003e connections \u003d connectionPool.get(address);\n        while (connections !\u003d null) {\n            HttpConnection connection \u003d connections.get(connections.size() - 1);\n            if (!connection.isSpdy()) {\n                connections.remove(connections.size() - 1);\n            }\n            if (connections.isEmpty()) {\n                connectionPool.remove(address);\n                connections \u003d null;\n            }\n            if (connection.isEligibleForRecycling()) {\n                Socket socket \u003d connection.getSocket();\n                Libcore.tagSocket(socket);\n                return connection;\n            }\n        }\n    }\n    return null;\n}",
          "path": "src/main/java/libcore/net/http/HttpConnectionPool.java",
          "functionStartLine": 61,
          "functionName": "get",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,21 +1,21 @@\n-public HttpConnection get(HttpConnection.Address address, int connectTimeout) throws IOException {\n+public HttpConnection get(HttpConnection.Address address) {\n     synchronized (connectionPool) {\n         List\u003cHttpConnection\u003e connections \u003d connectionPool.get(address);\n         while (connections !\u003d null) {\n             HttpConnection connection \u003d connections.get(connections.size() - 1);\n             if (!connection.isSpdy()) {\n                 connections.remove(connections.size() - 1);\n             }\n             if (connections.isEmpty()) {\n                 connectionPool.remove(address);\n                 connections \u003d null;\n             }\n             if (connection.isEligibleForRecycling()) {\n                 Socket socket \u003d connection.getSocket();\n                 Libcore.tagSocket(socket);\n                 return connection;\n             }\n         }\n     }\n-    return address.connect(connectTimeout);\n+    return null;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[address-HttpConnection.Address, connectTimeout-int]",
            "newValue": "[address-HttpConnection.Address]"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "Make HttpConnection.connect return full working connections.\n\nPreviously the returned connections required the caller to\ndo extra work: setting up tunnels (which could require auth)\nand performing an SSL handshake. With this change we make a\ncomplete working connection in HttpConnection.connect().\n\nThis will make it easier to fix fallback when a single domain\nhas multiple IP addresses and some of those addresses are not\nreachable.\n\nThis will also make it easier to do SPDY through HTTP proxies.\n",
          "commitDate": "2012/11/6 下午12:25",
          "commitName": "40ff76547064c3fb5acb9047a6f679dd4379a4d0",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "2012/9/26 上午2:29",
          "commitNameOld": "60b3a6dd6240f40c29fffd897c2dac314af49836",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 41.41,
          "commitsBetweenForRepo": 14,
          "commitsBetweenForFile": 1,
          "actualSource": "public HttpConnection get(HttpConnection.Address address) {\n    synchronized (connectionPool) {\n        List\u003cHttpConnection\u003e connections \u003d connectionPool.get(address);\n        while (connections !\u003d null) {\n            HttpConnection connection \u003d connections.get(connections.size() - 1);\n            if (!connection.isSpdy()) {\n                connections.remove(connections.size() - 1);\n            }\n            if (connections.isEmpty()) {\n                connectionPool.remove(address);\n                connections \u003d null;\n            }\n            if (connection.isEligibleForRecycling()) {\n                Socket socket \u003d connection.getSocket();\n                Libcore.tagSocket(socket);\n                return connection;\n            }\n        }\n    }\n    return null;\n}",
          "path": "src/main/java/libcore/net/http/HttpConnectionPool.java",
          "functionStartLine": 61,
          "functionName": "get",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,21 +1,21 @@\n-public HttpConnection get(HttpConnection.Address address, int connectTimeout) throws IOException {\n+public HttpConnection get(HttpConnection.Address address) {\n     synchronized (connectionPool) {\n         List\u003cHttpConnection\u003e connections \u003d connectionPool.get(address);\n         while (connections !\u003d null) {\n             HttpConnection connection \u003d connections.get(connections.size() - 1);\n             if (!connection.isSpdy()) {\n                 connections.remove(connections.size() - 1);\n             }\n             if (connections.isEmpty()) {\n                 connectionPool.remove(address);\n                 connections \u003d null;\n             }\n             if (connection.isEligibleForRecycling()) {\n                 Socket socket \u003d connection.getSocket();\n                 Libcore.tagSocket(socket);\n                 return connection;\n             }\n         }\n     }\n-    return address.connect(connectTimeout);\n+    return null;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[IOException]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Make HttpConnection.connect return full working connections.\n\nPreviously the returned connections required the caller to\ndo extra work: setting up tunnels (which could require auth)\nand performing an SSL handshake. With this change we make a\ncomplete working connection in HttpConnection.connect().\n\nThis will make it easier to fix fallback when a single domain\nhas multiple IP addresses and some of those addresses are not\nreachable.\n\nThis will also make it easier to do SPDY through HTTP proxies.\n",
          "commitDate": "2012/11/6 下午12:25",
          "commitName": "40ff76547064c3fb5acb9047a6f679dd4379a4d0",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "2012/9/26 上午2:29",
          "commitNameOld": "60b3a6dd6240f40c29fffd897c2dac314af49836",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 41.41,
          "commitsBetweenForRepo": 14,
          "commitsBetweenForFile": 1,
          "actualSource": "public HttpConnection get(HttpConnection.Address address) {\n    synchronized (connectionPool) {\n        List\u003cHttpConnection\u003e connections \u003d connectionPool.get(address);\n        while (connections !\u003d null) {\n            HttpConnection connection \u003d connections.get(connections.size() - 1);\n            if (!connection.isSpdy()) {\n                connections.remove(connections.size() - 1);\n            }\n            if (connections.isEmpty()) {\n                connectionPool.remove(address);\n                connections \u003d null;\n            }\n            if (connection.isEligibleForRecycling()) {\n                Socket socket \u003d connection.getSocket();\n                Libcore.tagSocket(socket);\n                return connection;\n            }\n        }\n    }\n    return null;\n}",
          "path": "src/main/java/libcore/net/http/HttpConnectionPool.java",
          "functionStartLine": 61,
          "functionName": "get",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,21 +1,21 @@\n-public HttpConnection get(HttpConnection.Address address, int connectTimeout) throws IOException {\n+public HttpConnection get(HttpConnection.Address address) {\n     synchronized (connectionPool) {\n         List\u003cHttpConnection\u003e connections \u003d connectionPool.get(address);\n         while (connections !\u003d null) {\n             HttpConnection connection \u003d connections.get(connections.size() - 1);\n             if (!connection.isSpdy()) {\n                 connections.remove(connections.size() - 1);\n             }\n             if (connections.isEmpty()) {\n                 connectionPool.remove(address);\n                 connections \u003d null;\n             }\n             if (connection.isEligibleForRecycling()) {\n                 Socket socket \u003d connection.getSocket();\n                 Libcore.tagSocket(socket);\n                 return connection;\n             }\n         }\n     }\n-    return address.connect(connectTimeout);\n+    return null;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "ea63463c2ff8a67f63e541036f0d5998b5bb1f3e": {
      "type": "Yintroduced",
      "commitMessage": "Initial import.\n\nThis is a fork of okhttp from http://code.google.com/p/okhttp.\nI\u0027m moving it to Github since that\u0027s where my code reviewers\nare. I\u0027ve renamed the core package from com.google.okhttp to\ncom.squareup.okhttp because Square is where I expect ongoing\ndevelopment of this project to take place.\n\nAll code in this project is subject to be contributed upstream\nto AOSP. In particular, all code in the libcore package is\nderived from AOSP and intended to be contributed back to AOSP\non an ongoing basis.\n",
      "commitDate": "2012/7/23 下午10:02",
      "commitName": "ea63463c2ff8a67f63e541036f0d5998b5bb1f3e",
      "commitAuthor": "Jesse Wilson",
      "diff": "@@ -0,0 +1,21 @@\n+public HttpConnection get(HttpConnection.Address address, int connectTimeout) throws IOException {\n+    synchronized (connectionPool) {\n+        List\u003cHttpConnection\u003e connections \u003d connectionPool.get(address);\n+        while (connections !\u003d null) {\n+            HttpConnection connection \u003d connections.get(connections.size() - 1);\n+            if (!connection.isSpdy()) {\n+                connections.remove(connections.size() - 1);\n+            }\n+            if (connections.isEmpty()) {\n+                connectionPool.remove(address);\n+                connections \u003d null;\n+            }\n+            if (connection.isEligibleForRecycling()) {\n+                Socket socket \u003d connection.getSocket();\n+                Libcore.tagSocket(socket);\n+                return connection;\n+            }\n+        }\n+    }\n+    return address.connect(connectTimeout);\n+}\n\\ No newline at end of file\n",
      "actualSource": "public HttpConnection get(HttpConnection.Address address, int connectTimeout) throws IOException {\n    synchronized (connectionPool) {\n        List\u003cHttpConnection\u003e connections \u003d connectionPool.get(address);\n        while (connections !\u003d null) {\n            HttpConnection connection \u003d connections.get(connections.size() - 1);\n            if (!connection.isSpdy()) {\n                connections.remove(connections.size() - 1);\n            }\n            if (connections.isEmpty()) {\n                connectionPool.remove(address);\n                connections \u003d null;\n            }\n            if (connection.isEligibleForRecycling()) {\n                Socket socket \u003d connection.getSocket();\n                Libcore.tagSocket(socket);\n                return connection;\n            }\n        }\n    }\n    return address.connect(connectTimeout);\n}",
      "path": "src/main/java/libcore/net/http/HttpConnectionPool.java",
      "functionStartLine": 62,
      "functionName": "get",
      "functionAnnotation": "",
      "functionDoc": ""
    }
  }
}