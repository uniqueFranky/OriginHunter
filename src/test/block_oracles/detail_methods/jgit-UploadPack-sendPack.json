{
  "origin": "codeshovel",
  "repositoryName": "jgit",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/jgit/.git",
  "startCommitName": "bd1a82502680b5de5bf86f6c4470185fd1602386",
  "sourceFileName": "UploadPack.java",
  "functionName": "sendPack",
  "functionId": "sendPack___sideband-boolean(modifiers-final)__accumulator-PackStatistics.Accumulator__allTags-Collection__Ref__(annotations-@Nullable)__unshallowCommits-List__ObjectId__",
  "sourceFilePath": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
  "functionAnnotation": "",
  "functionDoc": "Send the requested objects to the client.\n\n@param sideband whether to wrap the pack in side-band pkt-lines,\n               interleaved with progress messages and errors.\n@param accumulator where to write statistics about the content of the pack.\n@param allTags refs to search for annotated tags to include in the pack\n               if the {@link #OPTION_INCLUDE_TAG} capability was\n               requested.\n@param unshallowCommits shallow commits on the client that are now becoming\n               unshallow\n@throws IOException\n               if an error occured while generating or writing the pack.\n",
  "functionStartLine": 1983,
  "functionEndLine": 2128,
  "numCommitsSeen": 514,
  "timeTaken": 5187,
  "changeHistory": [
    "cd0d69ffec9eedff24a2692d18024e752cadc7c8",
    "f6c4a492d06e0dd345679bfba3399dabbf778f41",
    "c79e7f1c27c73732310bc64c2071a79902447dcc",
    "4ac32e79b751944107470d5f4cb290eacd1b7cf9",
    "67df4986cef270144c7cae3485dc8541ca180649",
    "d88d5b94c669b4c23af4e1de797a4d130b6612f8",
    "cc19f649666704e5bf0184d3839be0c0c17439fc",
    "302596cc675d00e41f0ff07efef58063afe20c79",
    "21d22e6f63a1adcfaeaee155f1be32f8123fd789",
    "c46c720e99baa081bff0dd7bcc1ae8ca48b5e3d1",
    "3b4448637fbb9d74e0c9d44048ba76bb7c1214ce",
    "01935f8f50699db09e9e6f4e725913b907d7cbd5",
    "b16e207742beb6a82b2b74df7bb87893a38bdd04",
    "f84370feaaf319b7fe9bd272a7ceba235cc1e86a",
    "1fa6f3a7509dc937551006e11dfd3bdaea921cd0",
    "bbcbcab8d39dd4bdf194cdba02c97a9eb70b2379",
    "6a415915c2dab31f9e69b9a55dcb87c579649bf5",
    "d9bbb04c3ef28db1d2e492506a819b7ac5c5f9df",
    "0e73d395061d1bfee365acaa2f79c392175d13bf",
    "7b7d033ee1fdd8e81ae2ad7dc9e1ae12cbd9ddfa",
    "b0174a089ce886d02c8d7fb80d63f0e50329bec3",
    "557471da2eee6752ad4305a883843bcdc8d66536",
    "6e896ba66ba095b97a89a622d43f05ce9ad501e7",
    "eb17495ca4ce95c63bacf81af16ab19ff042b65c",
    "43ea887c8b43de26a6b7a9ea547033d3c04022e7",
    "9b86cf574b230a9b3a71d7cb53a4f6712bfa33eb",
    "1f2022e3a7e9482caa4823e031504b6bbe8246af",
    "d6172dc0de2cbaeb0bd38a9d30278dd5f9b140b3",
    "01888db892aa9590862d886c01f3b293140db153",
    "9952223e0645fd7a8cddc6093a7f449c6390238d",
    "7ff6eb584cf8b83f83a3b5edf897feb53dbf42c0"
  ],
  "changeHistoryShort": {
    "cd0d69ffec9eedff24a2692d18024e752cadc7c8": "Ymultichange(Yparameterchange,Ydocchange)",
    "f6c4a492d06e0dd345679bfba3399dabbf778f41": "Ybodychange",
    "c79e7f1c27c73732310bc64c2071a79902447dcc": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
    "4ac32e79b751944107470d5f4cb290eacd1b7cf9": "Ybodychange",
    "67df4986cef270144c7cae3485dc8541ca180649": "Ybodychange",
    "d88d5b94c669b4c23af4e1de797a4d130b6612f8": "Yannotationchange",
    "cc19f649666704e5bf0184d3839be0c0c17439fc": "Ybodychange",
    "302596cc675d00e41f0ff07efef58063afe20c79": "Ymultichange(Yparameterchange,Ybodychange)",
    "21d22e6f63a1adcfaeaee155f1be32f8123fd789": "Ybodychange",
    "c46c720e99baa081bff0dd7bcc1ae8ca48b5e3d1": "Ybodychange",
    "3b4448637fbb9d74e0c9d44048ba76bb7c1214ce": "Ybodychange",
    "01935f8f50699db09e9e6f4e725913b907d7cbd5": "Yannotationchange",
    "b16e207742beb6a82b2b74df7bb87893a38bdd04": "Ybodychange",
    "f84370feaaf319b7fe9bd272a7ceba235cc1e86a": "Ybodychange",
    "1fa6f3a7509dc937551006e11dfd3bdaea921cd0": "Ybodychange",
    "bbcbcab8d39dd4bdf194cdba02c97a9eb70b2379": "Ybodychange",
    "6a415915c2dab31f9e69b9a55dcb87c579649bf5": "Ybodychange",
    "d9bbb04c3ef28db1d2e492506a819b7ac5c5f9df": "Ybodychange",
    "0e73d395061d1bfee365acaa2f79c392175d13bf": "Ybodychange",
    "7b7d033ee1fdd8e81ae2ad7dc9e1ae12cbd9ddfa": "Ybodychange",
    "b0174a089ce886d02c8d7fb80d63f0e50329bec3": "Ybodychange",
    "557471da2eee6752ad4305a883843bcdc8d66536": "Ybodychange",
    "6e896ba66ba095b97a89a622d43f05ce9ad501e7": "Ybodychange",
    "eb17495ca4ce95c63bacf81af16ab19ff042b65c": "Ybodychange",
    "43ea887c8b43de26a6b7a9ea547033d3c04022e7": "Ybodychange",
    "9b86cf574b230a9b3a71d7cb53a4f6712bfa33eb": "Ybodychange",
    "1f2022e3a7e9482caa4823e031504b6bbe8246af": "Ybodychange",
    "d6172dc0de2cbaeb0bd38a9d30278dd5f9b140b3": "Ybodychange",
    "01888db892aa9590862d886c01f3b293140db153": "Ybodychange",
    "9952223e0645fd7a8cddc6093a7f449c6390238d": "Ybodychange",
    "7ff6eb584cf8b83f83a3b5edf897feb53dbf42c0": "Yintroduced"
  },
  "changeHistoryDetails": {
    "cd0d69ffec9eedff24a2692d18024e752cadc7c8": {
      "type": "Ymultichange(Yparameterchange,Ydocchange)",
      "commitMessage": "Refactor unshallowCommits to local variable\n\nThis reduces the amount of state held as instance variables in\nUploadPack, and makes it easier for a future patch to contain a clearer\nversion of UploadPack#processShallow.\n\nChange-Id: I6df80b42f9e5118fda1420692e02e417670cced3\nSigned-off-by: Jonathan Tan \u003cjonathantanmy@google.com\u003e\nSigned-off-by: Jonathan Nieder \u003cjrn@google.com\u003e\n",
      "commitDate": "2018/6/5 下午1:04",
      "commitName": "cd0d69ffec9eedff24a2692d18024e752cadc7c8",
      "commitAuthor": "Jonathan Tan",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Refactor unshallowCommits to local variable\n\nThis reduces the amount of state held as instance variables in\nUploadPack, and makes it easier for a future patch to contain a clearer\nversion of UploadPack#processShallow.\n\nChange-Id: I6df80b42f9e5118fda1420692e02e417670cced3\nSigned-off-by: Jonathan Tan \u003cjonathantanmy@google.com\u003e\nSigned-off-by: Jonathan Nieder \u003cjrn@google.com\u003e\n",
          "commitDate": "2018/6/5 下午1:04",
          "commitName": "cd0d69ffec9eedff24a2692d18024e752cadc7c8",
          "commitAuthor": "Jonathan Tan",
          "commitDateOld": "2018/6/5 下午12:59",
          "commitNameOld": "f516c1df9d18ff9aaba1dd5668db1776d42dd2bb",
          "commitAuthorOld": "Jonathan Tan",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private void sendPack(final boolean sideband, PackStatistics.Accumulator accumulator, @Nullable Collection\u003cRef\u003e allTags, List\u003cObjectId\u003e unshallowCommits) throws IOException {\n    ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n    OutputStream packOut \u003d rawOut;\n    if (sideband) {\n        int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz \u003d SideBandOutputStream.MAX_BUF;\n        packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm \u003d new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n        msgOut.flush();\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n            noPack.setOutput();\n            @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg \u003d packConfig;\n    if (cfg \u003d\u003d null)\n        cfg \u003d new PackConfig(db);\n    @SuppressWarnings(\"resource\") final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader(), accumulator);\n    try {\n        pw.setIndexDisabled(true);\n        if (filterBlobLimit \u003e\u003d 0) {\n            pw.setFilterBlobLimit(filterBlobLimit);\n            pw.setUseCachedPacks(false);\n        } else {\n            pw.setUseCachedPacks(true);\n        }\n        pw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n        pw.setClientShallowCommits(clientShallowCommits);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n            Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003c\u003e();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() !\u003d null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() \u003d\u003d null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        RevWalk rw \u003d walk;\n        if (depth \u003e 0) {\n            pw.setShallowPack(depth, unshallowCommits);\n            rw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n            rw.assumeShallow(clientShallowCommits);\n        }\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n        } else {\n            walk.reset();\n            ObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n            rw \u003d ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 allTags !\u003d null) {\n            for (Ref ref : allTags) {\n                ObjectId objectId \u003d ref.getObjectId();\n                if (objectId \u003d\u003d null) {\n                    continue;\n                }\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj \u003d rw.lookupOrNull(objectId);\n                    if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref \u003d db.getRefDatabase().peel(ref);\n                ObjectId peeledId \u003d ref.getPeeledObjectId();\n                objectId \u003d ref.getObjectId();\n                if (peeledId \u003d\u003d null || objectId \u003d\u003d null)\n                    continue;\n                if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId)) {\n                    pw.addObject(rw.parseAny(objectId));\n                }\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        if (msgOut !\u003d NullOutputStream.INSTANCE) {\n            String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        statistics \u003d pw.getStatistics();\n        if (statistics !\u003d null) {\n            postUploadHook.onPostUpload(statistics);\n        }\n        pw.close();\n    }\n    if (sideband)\n        pckOut.end();\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
          "functionStartLine": 1859,
          "functionName": "sendPack",
          "functionAnnotation": "",
          "functionDoc": "Send the requested objects to the client.\n\n@param sideband whether to wrap the pack in side-band pkt-lines,\n               interleaved with progress messages and errors.\n@param accumulator where to write statistics about the content of the pack.\n@param allTags refs to search for annotated tags to include in the pack\n               if the {@link #OPTION_INCLUDE_TAG} capability was\n               requested.\n@param unshallowCommits shallow commits on the client that are now becoming\n               unshallow\n@throws IOException\n               if an error occured while generating or writing the pack.\n",
          "diff": "@@ -1,114 +1,114 @@\n-private void sendPack(final boolean sideband, PackStatistics.Accumulator accumulator, @Nullable Collection\u003cRef\u003e allTags) throws IOException {\n+private void sendPack(final boolean sideband, PackStatistics.Accumulator accumulator, @Nullable Collection\u003cRef\u003e allTags, List\u003cObjectId\u003e unshallowCommits) throws IOException {\n     ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n     OutputStream packOut \u003d rawOut;\n     if (sideband) {\n         int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n         if (options.contains(OPTION_SIDE_BAND_64K))\n             bufsz \u003d SideBandOutputStream.MAX_BUF;\n         packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n         if (!options.contains(OPTION_NO_PROGRESS)) {\n             msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n             pm \u003d new SideBandProgressMonitor(msgOut);\n         }\n     }\n     try {\n         if (wantAll.isEmpty()) {\n             preUploadHook.onSendPack(this, wantIds, commonBase);\n         } else {\n             preUploadHook.onSendPack(this, wantAll, commonBase);\n         }\n         msgOut.flush();\n     } catch (ServiceMayNotContinueException noPack) {\n         if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n             noPack.setOutput();\n             @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n             err.write(Constants.encode(noPack.getMessage()));\n             err.flush();\n         }\n         throw noPack;\n     }\n     PackConfig cfg \u003d packConfig;\n     if (cfg \u003d\u003d null)\n         cfg \u003d new PackConfig(db);\n     @SuppressWarnings(\"resource\") final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader(), accumulator);\n     try {\n         pw.setIndexDisabled(true);\n         if (filterBlobLimit \u003e\u003d 0) {\n             pw.setFilterBlobLimit(filterBlobLimit);\n             pw.setUseCachedPacks(false);\n         } else {\n             pw.setUseCachedPacks(true);\n         }\n         pw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n         pw.setClientShallowCommits(clientShallowCommits);\n         pw.setReuseDeltaCommits(true);\n         pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n         pw.setThin(options.contains(OPTION_THIN_PACK));\n         pw.setReuseValidatingObjects(false);\n         if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n             Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003c\u003e();\n             for (Ref ref : refs.values()) {\n                 if (ref.getPeeledObjectId() !\u003d null)\n                     tagTargets.add(ref.getPeeledObjectId());\n                 else if (ref.getObjectId() \u003d\u003d null)\n                     continue;\n                 else if (ref.getName().startsWith(Constants.R_HEADS))\n                     tagTargets.add(ref.getObjectId());\n             }\n             pw.setTagTargets(tagTargets);\n         }\n         RevWalk rw \u003d walk;\n         if (depth \u003e 0) {\n             pw.setShallowPack(depth, unshallowCommits);\n             rw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n             rw.assumeShallow(clientShallowCommits);\n         }\n         if (wantAll.isEmpty()) {\n             pw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n         } else {\n             walk.reset();\n             ObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n             pw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n             rw \u003d ow;\n         }\n         if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 allTags !\u003d null) {\n             for (Ref ref : allTags) {\n                 ObjectId objectId \u003d ref.getObjectId();\n                 if (objectId \u003d\u003d null) {\n                     continue;\n                 }\n                 if (wantAll.isEmpty()) {\n                     if (wantIds.contains(objectId))\n                         continue;\n                 } else {\n                     RevObject obj \u003d rw.lookupOrNull(objectId);\n                     if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                         continue;\n                 }\n                 if (!ref.isPeeled())\n                     ref \u003d db.getRefDatabase().peel(ref);\n                 ObjectId peeledId \u003d ref.getPeeledObjectId();\n                 objectId \u003d ref.getObjectId();\n                 if (peeledId \u003d\u003d null || objectId \u003d\u003d null)\n                     continue;\n                 if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId)) {\n                     pw.addObject(rw.parseAny(objectId));\n                 }\n             }\n         }\n         pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n         if (msgOut !\u003d NullOutputStream.INSTANCE) {\n             String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n             msgOut.write(Constants.encode(msg));\n             msgOut.flush();\n         }\n     } finally {\n         statistics \u003d pw.getStatistics();\n         if (statistics !\u003d null) {\n             postUploadHook.onPostUpload(statistics);\n         }\n         pw.close();\n     }\n     if (sideband)\n         pckOut.end();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[sideband-boolean(modifiers-final), accumulator-PackStatistics.Accumulator, allTags-Collection\u003cRef\u003e(annotations-@Nullable)]",
            "newValue": "[sideband-boolean(modifiers-final), accumulator-PackStatistics.Accumulator, allTags-Collection\u003cRef\u003e(annotations-@Nullable), unshallowCommits-List\u003cObjectId\u003e]"
          }
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Refactor unshallowCommits to local variable\n\nThis reduces the amount of state held as instance variables in\nUploadPack, and makes it easier for a future patch to contain a clearer\nversion of UploadPack#processShallow.\n\nChange-Id: I6df80b42f9e5118fda1420692e02e417670cced3\nSigned-off-by: Jonathan Tan \u003cjonathantanmy@google.com\u003e\nSigned-off-by: Jonathan Nieder \u003cjrn@google.com\u003e\n",
          "commitDate": "2018/6/5 下午1:04",
          "commitName": "cd0d69ffec9eedff24a2692d18024e752cadc7c8",
          "commitAuthor": "Jonathan Tan",
          "commitDateOld": "2018/6/5 下午12:59",
          "commitNameOld": "f516c1df9d18ff9aaba1dd5668db1776d42dd2bb",
          "commitAuthorOld": "Jonathan Tan",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private void sendPack(final boolean sideband, PackStatistics.Accumulator accumulator, @Nullable Collection\u003cRef\u003e allTags, List\u003cObjectId\u003e unshallowCommits) throws IOException {\n    ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n    OutputStream packOut \u003d rawOut;\n    if (sideband) {\n        int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz \u003d SideBandOutputStream.MAX_BUF;\n        packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm \u003d new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n        msgOut.flush();\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n            noPack.setOutput();\n            @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg \u003d packConfig;\n    if (cfg \u003d\u003d null)\n        cfg \u003d new PackConfig(db);\n    @SuppressWarnings(\"resource\") final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader(), accumulator);\n    try {\n        pw.setIndexDisabled(true);\n        if (filterBlobLimit \u003e\u003d 0) {\n            pw.setFilterBlobLimit(filterBlobLimit);\n            pw.setUseCachedPacks(false);\n        } else {\n            pw.setUseCachedPacks(true);\n        }\n        pw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n        pw.setClientShallowCommits(clientShallowCommits);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n            Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003c\u003e();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() !\u003d null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() \u003d\u003d null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        RevWalk rw \u003d walk;\n        if (depth \u003e 0) {\n            pw.setShallowPack(depth, unshallowCommits);\n            rw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n            rw.assumeShallow(clientShallowCommits);\n        }\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n        } else {\n            walk.reset();\n            ObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n            rw \u003d ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 allTags !\u003d null) {\n            for (Ref ref : allTags) {\n                ObjectId objectId \u003d ref.getObjectId();\n                if (objectId \u003d\u003d null) {\n                    continue;\n                }\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj \u003d rw.lookupOrNull(objectId);\n                    if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref \u003d db.getRefDatabase().peel(ref);\n                ObjectId peeledId \u003d ref.getPeeledObjectId();\n                objectId \u003d ref.getObjectId();\n                if (peeledId \u003d\u003d null || objectId \u003d\u003d null)\n                    continue;\n                if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId)) {\n                    pw.addObject(rw.parseAny(objectId));\n                }\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        if (msgOut !\u003d NullOutputStream.INSTANCE) {\n            String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        statistics \u003d pw.getStatistics();\n        if (statistics !\u003d null) {\n            postUploadHook.onPostUpload(statistics);\n        }\n        pw.close();\n    }\n    if (sideband)\n        pckOut.end();\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
          "functionStartLine": 1859,
          "functionName": "sendPack",
          "functionAnnotation": "",
          "functionDoc": "Send the requested objects to the client.\n\n@param sideband whether to wrap the pack in side-band pkt-lines,\n               interleaved with progress messages and errors.\n@param accumulator where to write statistics about the content of the pack.\n@param allTags refs to search for annotated tags to include in the pack\n               if the {@link #OPTION_INCLUDE_TAG} capability was\n               requested.\n@param unshallowCommits shallow commits on the client that are now becoming\n               unshallow\n@throws IOException\n               if an error occured while generating or writing the pack.\n",
          "diff": "@@ -1,114 +1,114 @@\n-private void sendPack(final boolean sideband, PackStatistics.Accumulator accumulator, @Nullable Collection\u003cRef\u003e allTags) throws IOException {\n+private void sendPack(final boolean sideband, PackStatistics.Accumulator accumulator, @Nullable Collection\u003cRef\u003e allTags, List\u003cObjectId\u003e unshallowCommits) throws IOException {\n     ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n     OutputStream packOut \u003d rawOut;\n     if (sideband) {\n         int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n         if (options.contains(OPTION_SIDE_BAND_64K))\n             bufsz \u003d SideBandOutputStream.MAX_BUF;\n         packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n         if (!options.contains(OPTION_NO_PROGRESS)) {\n             msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n             pm \u003d new SideBandProgressMonitor(msgOut);\n         }\n     }\n     try {\n         if (wantAll.isEmpty()) {\n             preUploadHook.onSendPack(this, wantIds, commonBase);\n         } else {\n             preUploadHook.onSendPack(this, wantAll, commonBase);\n         }\n         msgOut.flush();\n     } catch (ServiceMayNotContinueException noPack) {\n         if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n             noPack.setOutput();\n             @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n             err.write(Constants.encode(noPack.getMessage()));\n             err.flush();\n         }\n         throw noPack;\n     }\n     PackConfig cfg \u003d packConfig;\n     if (cfg \u003d\u003d null)\n         cfg \u003d new PackConfig(db);\n     @SuppressWarnings(\"resource\") final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader(), accumulator);\n     try {\n         pw.setIndexDisabled(true);\n         if (filterBlobLimit \u003e\u003d 0) {\n             pw.setFilterBlobLimit(filterBlobLimit);\n             pw.setUseCachedPacks(false);\n         } else {\n             pw.setUseCachedPacks(true);\n         }\n         pw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n         pw.setClientShallowCommits(clientShallowCommits);\n         pw.setReuseDeltaCommits(true);\n         pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n         pw.setThin(options.contains(OPTION_THIN_PACK));\n         pw.setReuseValidatingObjects(false);\n         if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n             Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003c\u003e();\n             for (Ref ref : refs.values()) {\n                 if (ref.getPeeledObjectId() !\u003d null)\n                     tagTargets.add(ref.getPeeledObjectId());\n                 else if (ref.getObjectId() \u003d\u003d null)\n                     continue;\n                 else if (ref.getName().startsWith(Constants.R_HEADS))\n                     tagTargets.add(ref.getObjectId());\n             }\n             pw.setTagTargets(tagTargets);\n         }\n         RevWalk rw \u003d walk;\n         if (depth \u003e 0) {\n             pw.setShallowPack(depth, unshallowCommits);\n             rw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n             rw.assumeShallow(clientShallowCommits);\n         }\n         if (wantAll.isEmpty()) {\n             pw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n         } else {\n             walk.reset();\n             ObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n             pw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n             rw \u003d ow;\n         }\n         if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 allTags !\u003d null) {\n             for (Ref ref : allTags) {\n                 ObjectId objectId \u003d ref.getObjectId();\n                 if (objectId \u003d\u003d null) {\n                     continue;\n                 }\n                 if (wantAll.isEmpty()) {\n                     if (wantIds.contains(objectId))\n                         continue;\n                 } else {\n                     RevObject obj \u003d rw.lookupOrNull(objectId);\n                     if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                         continue;\n                 }\n                 if (!ref.isPeeled())\n                     ref \u003d db.getRefDatabase().peel(ref);\n                 ObjectId peeledId \u003d ref.getPeeledObjectId();\n                 objectId \u003d ref.getObjectId();\n                 if (peeledId \u003d\u003d null || objectId \u003d\u003d null)\n                     continue;\n                 if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId)) {\n                     pw.addObject(rw.parseAny(objectId));\n                 }\n             }\n         }\n         pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n         if (msgOut !\u003d NullOutputStream.INSTANCE) {\n             String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n             msgOut.write(Constants.encode(msg));\n             msgOut.flush();\n         }\n     } finally {\n         statistics \u003d pw.getStatistics();\n         if (statistics !\u003d null) {\n             postUploadHook.onPostUpload(statistics);\n         }\n         pw.close();\n     }\n     if (sideband)\n         pckOut.end();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Send the requested objects to the client.\n\n@param sideband whether to wrap the pack in side-band pkt-lines,\n               interleaved with progress messages and errors.\n@param accumulator where to write statistics about the content of the pack.\n@param allTags refs to search for annotated tags to include in the pack\n               if the {@link #OPTION_INCLUDE_TAG} capability was\n               requested.\n@throws IOException\n               if an error occured while generating or writing the pack.\n",
            "newValue": "Send the requested objects to the client.\n\n@param sideband whether to wrap the pack in side-band pkt-lines,\n               interleaved with progress messages and errors.\n@param accumulator where to write statistics about the content of the pack.\n@param allTags refs to search for annotated tags to include in the pack\n               if the {@link #OPTION_INCLUDE_TAG} capability was\n               requested.\n@param unshallowCommits shallow commits on the client that are now becoming\n               unshallow\n@throws IOException\n               if an error occured while generating or writing the pack.\n"
          }
        }
      ]
    },
    "f6c4a492d06e0dd345679bfba3399dabbf778f41": {
      "type": "Ybodychange",
      "commitMessage": "Repository: Deprecate #peel method\n\nCallers should use getRefDatabase().peel(ref) instead since it\ndoesn\u0027t swallow the IOException.\n\nAdapt all trivial callers to user the alternative.\n\nDescribeCommand still uses the deprecated method and is not adapted in\nthis change since it will require more refactoring to add handling of\nthe IOException.\n\nChange-Id: I14d4a95a5e0570548753b9fc5c03d024dc3ff832\nSigned-off-by: David Pursehouse \u003cdavid.pursehouse@gmail.com\u003e\n",
      "commitDate": "2018/5/22 上午10:49",
      "commitName": "f6c4a492d06e0dd345679bfba3399dabbf778f41",
      "commitAuthor": "David Pursehouse",
      "commitDateOld": "2018/5/18 上午10:15",
      "commitNameOld": "667e30678a6bad26f4d4d412e996b293e52e5b87",
      "commitAuthorOld": "Masaya Suzuki",
      "daysBetweenCommits": 4.02,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "actualSource": "private void sendPack(final boolean sideband, PackStatistics.Accumulator accumulator, @Nullable Collection\u003cRef\u003e allTags) throws IOException {\n    ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n    OutputStream packOut \u003d rawOut;\n    if (sideband) {\n        int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz \u003d SideBandOutputStream.MAX_BUF;\n        packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm \u003d new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n        msgOut.flush();\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n            noPack.setOutput();\n            @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg \u003d packConfig;\n    if (cfg \u003d\u003d null)\n        cfg \u003d new PackConfig(db);\n    @SuppressWarnings(\"resource\") final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader(), accumulator);\n    try {\n        pw.setIndexDisabled(true);\n        if (filterBlobLimit \u003e\u003d 0) {\n            pw.setFilterBlobLimit(filterBlobLimit);\n            pw.setUseCachedPacks(false);\n        } else {\n            pw.setUseCachedPacks(true);\n        }\n        pw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n        pw.setClientShallowCommits(clientShallowCommits);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n            Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003c\u003e();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() !\u003d null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() \u003d\u003d null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        RevWalk rw \u003d walk;\n        if (depth \u003e 0) {\n            pw.setShallowPack(depth, unshallowCommits);\n            rw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n            rw.assumeShallow(clientShallowCommits);\n        }\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n        } else {\n            walk.reset();\n            ObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n            rw \u003d ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 allTags !\u003d null) {\n            for (Ref ref : allTags) {\n                ObjectId objectId \u003d ref.getObjectId();\n                if (objectId \u003d\u003d null) {\n                    continue;\n                }\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj \u003d rw.lookupOrNull(objectId);\n                    if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref \u003d db.getRefDatabase().peel(ref);\n                ObjectId peeledId \u003d ref.getPeeledObjectId();\n                objectId \u003d ref.getObjectId();\n                if (peeledId \u003d\u003d null || objectId \u003d\u003d null)\n                    continue;\n                if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId)) {\n                    pw.addObject(rw.parseAny(objectId));\n                }\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        if (msgOut !\u003d NullOutputStream.INSTANCE) {\n            String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        statistics \u003d pw.getStatistics();\n        if (statistics !\u003d null) {\n            postUploadHook.onPostUpload(statistics);\n        }\n        pw.close();\n    }\n    if (sideband)\n        pckOut.end();\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
      "functionStartLine": 1822,
      "functionName": "sendPack",
      "functionAnnotation": "",
      "functionDoc": "Send the requested objects to the client.\n\n@param sideband whether to wrap the pack in side-band pkt-lines,\n               interleaved with progress messages and errors.\n@param accumulator where to write statistics about the content of the pack.\n@param allTags refs to search for annotated tags to include in the pack\n               if the {@link #OPTION_INCLUDE_TAG} capability was\n               requested.\n@throws IOException\n               if an error occured while generating or writing the pack.\n",
      "diff": "@@ -1,114 +1,114 @@\n private void sendPack(final boolean sideband, PackStatistics.Accumulator accumulator, @Nullable Collection\u003cRef\u003e allTags) throws IOException {\n     ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n     OutputStream packOut \u003d rawOut;\n     if (sideband) {\n         int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n         if (options.contains(OPTION_SIDE_BAND_64K))\n             bufsz \u003d SideBandOutputStream.MAX_BUF;\n         packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n         if (!options.contains(OPTION_NO_PROGRESS)) {\n             msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n             pm \u003d new SideBandProgressMonitor(msgOut);\n         }\n     }\n     try {\n         if (wantAll.isEmpty()) {\n             preUploadHook.onSendPack(this, wantIds, commonBase);\n         } else {\n             preUploadHook.onSendPack(this, wantAll, commonBase);\n         }\n         msgOut.flush();\n     } catch (ServiceMayNotContinueException noPack) {\n         if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n             noPack.setOutput();\n             @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n             err.write(Constants.encode(noPack.getMessage()));\n             err.flush();\n         }\n         throw noPack;\n     }\n     PackConfig cfg \u003d packConfig;\n     if (cfg \u003d\u003d null)\n         cfg \u003d new PackConfig(db);\n     @SuppressWarnings(\"resource\") final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader(), accumulator);\n     try {\n         pw.setIndexDisabled(true);\n         if (filterBlobLimit \u003e\u003d 0) {\n             pw.setFilterBlobLimit(filterBlobLimit);\n             pw.setUseCachedPacks(false);\n         } else {\n             pw.setUseCachedPacks(true);\n         }\n         pw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n         pw.setClientShallowCommits(clientShallowCommits);\n         pw.setReuseDeltaCommits(true);\n         pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n         pw.setThin(options.contains(OPTION_THIN_PACK));\n         pw.setReuseValidatingObjects(false);\n         if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n             Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003c\u003e();\n             for (Ref ref : refs.values()) {\n                 if (ref.getPeeledObjectId() !\u003d null)\n                     tagTargets.add(ref.getPeeledObjectId());\n                 else if (ref.getObjectId() \u003d\u003d null)\n                     continue;\n                 else if (ref.getName().startsWith(Constants.R_HEADS))\n                     tagTargets.add(ref.getObjectId());\n             }\n             pw.setTagTargets(tagTargets);\n         }\n         RevWalk rw \u003d walk;\n         if (depth \u003e 0) {\n             pw.setShallowPack(depth, unshallowCommits);\n             rw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n             rw.assumeShallow(clientShallowCommits);\n         }\n         if (wantAll.isEmpty()) {\n             pw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n         } else {\n             walk.reset();\n             ObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n             pw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n             rw \u003d ow;\n         }\n         if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 allTags !\u003d null) {\n             for (Ref ref : allTags) {\n                 ObjectId objectId \u003d ref.getObjectId();\n                 if (objectId \u003d\u003d null) {\n                     continue;\n                 }\n                 if (wantAll.isEmpty()) {\n                     if (wantIds.contains(objectId))\n                         continue;\n                 } else {\n                     RevObject obj \u003d rw.lookupOrNull(objectId);\n                     if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                         continue;\n                 }\n                 if (!ref.isPeeled())\n-                    ref \u003d db.peel(ref);\n+                    ref \u003d db.getRefDatabase().peel(ref);\n                 ObjectId peeledId \u003d ref.getPeeledObjectId();\n                 objectId \u003d ref.getObjectId();\n                 if (peeledId \u003d\u003d null || objectId \u003d\u003d null)\n                     continue;\n                 if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId)) {\n                     pw.addObject(rw.parseAny(objectId));\n                 }\n             }\n         }\n         pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n         if (msgOut !\u003d NullOutputStream.INSTANCE) {\n             String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n             msgOut.write(Constants.encode(msg));\n             msgOut.flush();\n         }\n     } finally {\n         statistics \u003d pw.getStatistics();\n         if (statistics !\u003d null) {\n             postUploadHook.onPostUpload(statistics);\n         }\n         pw.close();\n     }\n     if (sideband)\n         pckOut.end();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c79e7f1c27c73732310bc64c2071a79902447dcc": {
      "type": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
      "commitMessage": "Avoid using #refs in UploadPack#sendPack\n\nWhen OPTION_INCLUDE_TAG is set, UploadPack#sendPack uses the #refs\ninstance variable as a source of information of tags. A subsequent patch\nwill need to supply this information to #sendPack without\nmodifying #refs, so refactor #sendPack to take in this information\nthrough a parameter instead.\n\nNote that prior to this patch, #refs was used twice in #sendPack: once\nto generate the argument to PackWriter#setTagTargets, and once to\ndetermine if any tags need to be included in the packfile. This patch\nonly updates the latter use, since the former is meant not only for\n\"true\" tag targets but any object that should be hoisted earlier during\npacking (see the documentation of PackWriter#setTagTargets).\n\nThis patch does not introduce any functionality change.\n\nChange-Id: I70ed65a1041334abeda8d4bac98cce7cae7efcdf\nSigned-off-by: Jonathan Tan \u003cjonathantanmy@google.com\u003e\nSigned-off-by: Jonathan Nieder \u003cjrn@google.com\u003e\n",
      "commitDate": "2018/5/17 上午7:57",
      "commitName": "c79e7f1c27c73732310bc64c2071a79902447dcc",
      "commitAuthor": "Jonathan Tan",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Avoid using #refs in UploadPack#sendPack\n\nWhen OPTION_INCLUDE_TAG is set, UploadPack#sendPack uses the #refs\ninstance variable as a source of information of tags. A subsequent patch\nwill need to supply this information to #sendPack without\nmodifying #refs, so refactor #sendPack to take in this information\nthrough a parameter instead.\n\nNote that prior to this patch, #refs was used twice in #sendPack: once\nto generate the argument to PackWriter#setTagTargets, and once to\ndetermine if any tags need to be included in the packfile. This patch\nonly updates the latter use, since the former is meant not only for\n\"true\" tag targets but any object that should be hoisted earlier during\npacking (see the documentation of PackWriter#setTagTargets).\n\nThis patch does not introduce any functionality change.\n\nChange-Id: I70ed65a1041334abeda8d4bac98cce7cae7efcdf\nSigned-off-by: Jonathan Tan \u003cjonathantanmy@google.com\u003e\nSigned-off-by: Jonathan Nieder \u003cjrn@google.com\u003e\n",
          "commitDate": "2018/5/17 上午7:57",
          "commitName": "c79e7f1c27c73732310bc64c2071a79902447dcc",
          "commitAuthor": "Jonathan Tan",
          "commitDateOld": "2018/5/16 上午5:05",
          "commitNameOld": "6d370d837c5faa7caff2e6e3e4723b887f2fbdca",
          "commitAuthorOld": "Han-Wen Nienhuys",
          "daysBetweenCommits": 1.12,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "actualSource": "private void sendPack(final boolean sideband, PackStatistics.Accumulator accumulator, @Nullable Collection\u003cRef\u003e allTags) throws IOException {\n    ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n    OutputStream packOut \u003d rawOut;\n    if (sideband) {\n        int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz \u003d SideBandOutputStream.MAX_BUF;\n        packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm \u003d new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n        msgOut.flush();\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n            noPack.setOutput();\n            @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg \u003d packConfig;\n    if (cfg \u003d\u003d null)\n        cfg \u003d new PackConfig(db);\n    @SuppressWarnings(\"resource\") final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader(), accumulator);\n    try {\n        pw.setIndexDisabled(true);\n        if (filterBlobLimit \u003e\u003d 0) {\n            pw.setFilterBlobLimit(filterBlobLimit);\n            pw.setUseCachedPacks(false);\n        } else {\n            pw.setUseCachedPacks(true);\n        }\n        pw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n        pw.setClientShallowCommits(clientShallowCommits);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n            Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003c\u003e();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() !\u003d null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() \u003d\u003d null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        RevWalk rw \u003d walk;\n        if (depth \u003e 0) {\n            pw.setShallowPack(depth, unshallowCommits);\n            rw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n            rw.assumeShallow(clientShallowCommits);\n        }\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n        } else {\n            walk.reset();\n            ObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n            rw \u003d ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 allTags !\u003d null) {\n            for (Ref ref : allTags) {\n                ObjectId objectId \u003d ref.getObjectId();\n                if (objectId \u003d\u003d null) {\n                    continue;\n                }\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj \u003d rw.lookupOrNull(objectId);\n                    if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref \u003d db.peel(ref);\n                ObjectId peeledId \u003d ref.getPeeledObjectId();\n                objectId \u003d ref.getObjectId();\n                if (peeledId \u003d\u003d null || objectId \u003d\u003d null)\n                    continue;\n                if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId)) {\n                    pw.addObject(rw.parseAny(objectId));\n                }\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        if (msgOut !\u003d NullOutputStream.INSTANCE) {\n            String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        statistics \u003d pw.getStatistics();\n        if (statistics !\u003d null) {\n            postUploadHook.onPostUpload(statistics);\n        }\n        pw.close();\n    }\n    if (sideband)\n        pckOut.end();\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
          "functionStartLine": 1813,
          "functionName": "sendPack",
          "functionAnnotation": "",
          "functionDoc": "Send the requested objects to the client.\n\n@param sideband whether to wrap the pack in side-band pkt-lines,\n               interleaved with progress messages and errors.\n@param accumulator where to write statistics about the content of the pack.\n@param allTags refs to search for annotated tags to include in the pack\n               if the {@link #OPTION_INCLUDE_TAG} capability was\n               requested.\n@throws IOException\n               if an error occured while generating or writing the pack.\n",
          "diff": "@@ -1,114 +1,114 @@\n-private void sendPack(final boolean sideband, PackStatistics.Accumulator accumulator) throws IOException {\n+private void sendPack(final boolean sideband, PackStatistics.Accumulator accumulator, @Nullable Collection\u003cRef\u003e allTags) throws IOException {\n     ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n     OutputStream packOut \u003d rawOut;\n     if (sideband) {\n         int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n         if (options.contains(OPTION_SIDE_BAND_64K))\n             bufsz \u003d SideBandOutputStream.MAX_BUF;\n         packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n         if (!options.contains(OPTION_NO_PROGRESS)) {\n             msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n             pm \u003d new SideBandProgressMonitor(msgOut);\n         }\n     }\n     try {\n         if (wantAll.isEmpty()) {\n             preUploadHook.onSendPack(this, wantIds, commonBase);\n         } else {\n             preUploadHook.onSendPack(this, wantAll, commonBase);\n         }\n         msgOut.flush();\n     } catch (ServiceMayNotContinueException noPack) {\n         if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n             noPack.setOutput();\n             @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n             err.write(Constants.encode(noPack.getMessage()));\n             err.flush();\n         }\n         throw noPack;\n     }\n     PackConfig cfg \u003d packConfig;\n     if (cfg \u003d\u003d null)\n         cfg \u003d new PackConfig(db);\n     @SuppressWarnings(\"resource\") final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader(), accumulator);\n     try {\n         pw.setIndexDisabled(true);\n         if (filterBlobLimit \u003e\u003d 0) {\n             pw.setFilterBlobLimit(filterBlobLimit);\n             pw.setUseCachedPacks(false);\n         } else {\n             pw.setUseCachedPacks(true);\n         }\n         pw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n         pw.setClientShallowCommits(clientShallowCommits);\n         pw.setReuseDeltaCommits(true);\n         pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n         pw.setThin(options.contains(OPTION_THIN_PACK));\n         pw.setReuseValidatingObjects(false);\n         if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n             Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003c\u003e();\n             for (Ref ref : refs.values()) {\n                 if (ref.getPeeledObjectId() !\u003d null)\n                     tagTargets.add(ref.getPeeledObjectId());\n                 else if (ref.getObjectId() \u003d\u003d null)\n                     continue;\n                 else if (ref.getName().startsWith(Constants.R_HEADS))\n                     tagTargets.add(ref.getObjectId());\n             }\n             pw.setTagTargets(tagTargets);\n         }\n         RevWalk rw \u003d walk;\n         if (depth \u003e 0) {\n             pw.setShallowPack(depth, unshallowCommits);\n             rw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n             rw.assumeShallow(clientShallowCommits);\n         }\n         if (wantAll.isEmpty()) {\n             pw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n         } else {\n             walk.reset();\n             ObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n             pw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n             rw \u003d ow;\n         }\n-        if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n-            for (Ref ref : refs.values()) {\n+        if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 allTags !\u003d null) {\n+            for (Ref ref : allTags) {\n                 ObjectId objectId \u003d ref.getObjectId();\n                 if (objectId \u003d\u003d null) {\n                     continue;\n                 }\n                 if (wantAll.isEmpty()) {\n                     if (wantIds.contains(objectId))\n                         continue;\n                 } else {\n                     RevObject obj \u003d rw.lookupOrNull(objectId);\n                     if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                         continue;\n                 }\n                 if (!ref.isPeeled())\n                     ref \u003d db.peel(ref);\n                 ObjectId peeledId \u003d ref.getPeeledObjectId();\n                 objectId \u003d ref.getObjectId();\n                 if (peeledId \u003d\u003d null || objectId \u003d\u003d null)\n                     continue;\n                 if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId)) {\n                     pw.addObject(rw.parseAny(objectId));\n                 }\n             }\n         }\n         pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n         if (msgOut !\u003d NullOutputStream.INSTANCE) {\n             String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n             msgOut.write(Constants.encode(msg));\n             msgOut.flush();\n         }\n     } finally {\n         statistics \u003d pw.getStatistics();\n         if (statistics !\u003d null) {\n             postUploadHook.onPostUpload(statistics);\n         }\n         pw.close();\n     }\n     if (sideband)\n         pckOut.end();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[sideband-boolean(modifiers-final), accumulator-PackStatistics.Accumulator]",
            "newValue": "[sideband-boolean(modifiers-final), accumulator-PackStatistics.Accumulator, allTags-Collection\u003cRef\u003e(annotations-@Nullable)]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Avoid using #refs in UploadPack#sendPack\n\nWhen OPTION_INCLUDE_TAG is set, UploadPack#sendPack uses the #refs\ninstance variable as a source of information of tags. A subsequent patch\nwill need to supply this information to #sendPack without\nmodifying #refs, so refactor #sendPack to take in this information\nthrough a parameter instead.\n\nNote that prior to this patch, #refs was used twice in #sendPack: once\nto generate the argument to PackWriter#setTagTargets, and once to\ndetermine if any tags need to be included in the packfile. This patch\nonly updates the latter use, since the former is meant not only for\n\"true\" tag targets but any object that should be hoisted earlier during\npacking (see the documentation of PackWriter#setTagTargets).\n\nThis patch does not introduce any functionality change.\n\nChange-Id: I70ed65a1041334abeda8d4bac98cce7cae7efcdf\nSigned-off-by: Jonathan Tan \u003cjonathantanmy@google.com\u003e\nSigned-off-by: Jonathan Nieder \u003cjrn@google.com\u003e\n",
          "commitDate": "2018/5/17 上午7:57",
          "commitName": "c79e7f1c27c73732310bc64c2071a79902447dcc",
          "commitAuthor": "Jonathan Tan",
          "commitDateOld": "2018/5/16 上午5:05",
          "commitNameOld": "6d370d837c5faa7caff2e6e3e4723b887f2fbdca",
          "commitAuthorOld": "Han-Wen Nienhuys",
          "daysBetweenCommits": 1.12,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "actualSource": "private void sendPack(final boolean sideband, PackStatistics.Accumulator accumulator, @Nullable Collection\u003cRef\u003e allTags) throws IOException {\n    ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n    OutputStream packOut \u003d rawOut;\n    if (sideband) {\n        int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz \u003d SideBandOutputStream.MAX_BUF;\n        packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm \u003d new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n        msgOut.flush();\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n            noPack.setOutput();\n            @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg \u003d packConfig;\n    if (cfg \u003d\u003d null)\n        cfg \u003d new PackConfig(db);\n    @SuppressWarnings(\"resource\") final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader(), accumulator);\n    try {\n        pw.setIndexDisabled(true);\n        if (filterBlobLimit \u003e\u003d 0) {\n            pw.setFilterBlobLimit(filterBlobLimit);\n            pw.setUseCachedPacks(false);\n        } else {\n            pw.setUseCachedPacks(true);\n        }\n        pw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n        pw.setClientShallowCommits(clientShallowCommits);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n            Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003c\u003e();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() !\u003d null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() \u003d\u003d null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        RevWalk rw \u003d walk;\n        if (depth \u003e 0) {\n            pw.setShallowPack(depth, unshallowCommits);\n            rw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n            rw.assumeShallow(clientShallowCommits);\n        }\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n        } else {\n            walk.reset();\n            ObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n            rw \u003d ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 allTags !\u003d null) {\n            for (Ref ref : allTags) {\n                ObjectId objectId \u003d ref.getObjectId();\n                if (objectId \u003d\u003d null) {\n                    continue;\n                }\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj \u003d rw.lookupOrNull(objectId);\n                    if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref \u003d db.peel(ref);\n                ObjectId peeledId \u003d ref.getPeeledObjectId();\n                objectId \u003d ref.getObjectId();\n                if (peeledId \u003d\u003d null || objectId \u003d\u003d null)\n                    continue;\n                if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId)) {\n                    pw.addObject(rw.parseAny(objectId));\n                }\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        if (msgOut !\u003d NullOutputStream.INSTANCE) {\n            String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        statistics \u003d pw.getStatistics();\n        if (statistics !\u003d null) {\n            postUploadHook.onPostUpload(statistics);\n        }\n        pw.close();\n    }\n    if (sideband)\n        pckOut.end();\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
          "functionStartLine": 1813,
          "functionName": "sendPack",
          "functionAnnotation": "",
          "functionDoc": "Send the requested objects to the client.\n\n@param sideband whether to wrap the pack in side-band pkt-lines,\n               interleaved with progress messages and errors.\n@param accumulator where to write statistics about the content of the pack.\n@param allTags refs to search for annotated tags to include in the pack\n               if the {@link #OPTION_INCLUDE_TAG} capability was\n               requested.\n@throws IOException\n               if an error occured while generating or writing the pack.\n",
          "diff": "@@ -1,114 +1,114 @@\n-private void sendPack(final boolean sideband, PackStatistics.Accumulator accumulator) throws IOException {\n+private void sendPack(final boolean sideband, PackStatistics.Accumulator accumulator, @Nullable Collection\u003cRef\u003e allTags) throws IOException {\n     ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n     OutputStream packOut \u003d rawOut;\n     if (sideband) {\n         int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n         if (options.contains(OPTION_SIDE_BAND_64K))\n             bufsz \u003d SideBandOutputStream.MAX_BUF;\n         packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n         if (!options.contains(OPTION_NO_PROGRESS)) {\n             msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n             pm \u003d new SideBandProgressMonitor(msgOut);\n         }\n     }\n     try {\n         if (wantAll.isEmpty()) {\n             preUploadHook.onSendPack(this, wantIds, commonBase);\n         } else {\n             preUploadHook.onSendPack(this, wantAll, commonBase);\n         }\n         msgOut.flush();\n     } catch (ServiceMayNotContinueException noPack) {\n         if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n             noPack.setOutput();\n             @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n             err.write(Constants.encode(noPack.getMessage()));\n             err.flush();\n         }\n         throw noPack;\n     }\n     PackConfig cfg \u003d packConfig;\n     if (cfg \u003d\u003d null)\n         cfg \u003d new PackConfig(db);\n     @SuppressWarnings(\"resource\") final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader(), accumulator);\n     try {\n         pw.setIndexDisabled(true);\n         if (filterBlobLimit \u003e\u003d 0) {\n             pw.setFilterBlobLimit(filterBlobLimit);\n             pw.setUseCachedPacks(false);\n         } else {\n             pw.setUseCachedPacks(true);\n         }\n         pw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n         pw.setClientShallowCommits(clientShallowCommits);\n         pw.setReuseDeltaCommits(true);\n         pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n         pw.setThin(options.contains(OPTION_THIN_PACK));\n         pw.setReuseValidatingObjects(false);\n         if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n             Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003c\u003e();\n             for (Ref ref : refs.values()) {\n                 if (ref.getPeeledObjectId() !\u003d null)\n                     tagTargets.add(ref.getPeeledObjectId());\n                 else if (ref.getObjectId() \u003d\u003d null)\n                     continue;\n                 else if (ref.getName().startsWith(Constants.R_HEADS))\n                     tagTargets.add(ref.getObjectId());\n             }\n             pw.setTagTargets(tagTargets);\n         }\n         RevWalk rw \u003d walk;\n         if (depth \u003e 0) {\n             pw.setShallowPack(depth, unshallowCommits);\n             rw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n             rw.assumeShallow(clientShallowCommits);\n         }\n         if (wantAll.isEmpty()) {\n             pw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n         } else {\n             walk.reset();\n             ObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n             pw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n             rw \u003d ow;\n         }\n-        if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n-            for (Ref ref : refs.values()) {\n+        if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 allTags !\u003d null) {\n+            for (Ref ref : allTags) {\n                 ObjectId objectId \u003d ref.getObjectId();\n                 if (objectId \u003d\u003d null) {\n                     continue;\n                 }\n                 if (wantAll.isEmpty()) {\n                     if (wantIds.contains(objectId))\n                         continue;\n                 } else {\n                     RevObject obj \u003d rw.lookupOrNull(objectId);\n                     if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                         continue;\n                 }\n                 if (!ref.isPeeled())\n                     ref \u003d db.peel(ref);\n                 ObjectId peeledId \u003d ref.getPeeledObjectId();\n                 objectId \u003d ref.getObjectId();\n                 if (peeledId \u003d\u003d null || objectId \u003d\u003d null)\n                     continue;\n                 if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId)) {\n                     pw.addObject(rw.parseAny(objectId));\n                 }\n             }\n         }\n         pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n         if (msgOut !\u003d NullOutputStream.INSTANCE) {\n             String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n             msgOut.write(Constants.encode(msg));\n             msgOut.flush();\n         }\n     } finally {\n         statistics \u003d pw.getStatistics();\n         if (statistics !\u003d null) {\n             postUploadHook.onPostUpload(statistics);\n         }\n         pw.close();\n     }\n     if (sideband)\n         pckOut.end();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Avoid using #refs in UploadPack#sendPack\n\nWhen OPTION_INCLUDE_TAG is set, UploadPack#sendPack uses the #refs\ninstance variable as a source of information of tags. A subsequent patch\nwill need to supply this information to #sendPack without\nmodifying #refs, so refactor #sendPack to take in this information\nthrough a parameter instead.\n\nNote that prior to this patch, #refs was used twice in #sendPack: once\nto generate the argument to PackWriter#setTagTargets, and once to\ndetermine if any tags need to be included in the packfile. This patch\nonly updates the latter use, since the former is meant not only for\n\"true\" tag targets but any object that should be hoisted earlier during\npacking (see the documentation of PackWriter#setTagTargets).\n\nThis patch does not introduce any functionality change.\n\nChange-Id: I70ed65a1041334abeda8d4bac98cce7cae7efcdf\nSigned-off-by: Jonathan Tan \u003cjonathantanmy@google.com\u003e\nSigned-off-by: Jonathan Nieder \u003cjrn@google.com\u003e\n",
          "commitDate": "2018/5/17 上午7:57",
          "commitName": "c79e7f1c27c73732310bc64c2071a79902447dcc",
          "commitAuthor": "Jonathan Tan",
          "commitDateOld": "2018/5/16 上午5:05",
          "commitNameOld": "6d370d837c5faa7caff2e6e3e4723b887f2fbdca",
          "commitAuthorOld": "Han-Wen Nienhuys",
          "daysBetweenCommits": 1.12,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "actualSource": "private void sendPack(final boolean sideband, PackStatistics.Accumulator accumulator, @Nullable Collection\u003cRef\u003e allTags) throws IOException {\n    ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n    OutputStream packOut \u003d rawOut;\n    if (sideband) {\n        int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz \u003d SideBandOutputStream.MAX_BUF;\n        packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm \u003d new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n        msgOut.flush();\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n            noPack.setOutput();\n            @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg \u003d packConfig;\n    if (cfg \u003d\u003d null)\n        cfg \u003d new PackConfig(db);\n    @SuppressWarnings(\"resource\") final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader(), accumulator);\n    try {\n        pw.setIndexDisabled(true);\n        if (filterBlobLimit \u003e\u003d 0) {\n            pw.setFilterBlobLimit(filterBlobLimit);\n            pw.setUseCachedPacks(false);\n        } else {\n            pw.setUseCachedPacks(true);\n        }\n        pw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n        pw.setClientShallowCommits(clientShallowCommits);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n            Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003c\u003e();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() !\u003d null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() \u003d\u003d null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        RevWalk rw \u003d walk;\n        if (depth \u003e 0) {\n            pw.setShallowPack(depth, unshallowCommits);\n            rw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n            rw.assumeShallow(clientShallowCommits);\n        }\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n        } else {\n            walk.reset();\n            ObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n            rw \u003d ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 allTags !\u003d null) {\n            for (Ref ref : allTags) {\n                ObjectId objectId \u003d ref.getObjectId();\n                if (objectId \u003d\u003d null) {\n                    continue;\n                }\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj \u003d rw.lookupOrNull(objectId);\n                    if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref \u003d db.peel(ref);\n                ObjectId peeledId \u003d ref.getPeeledObjectId();\n                objectId \u003d ref.getObjectId();\n                if (peeledId \u003d\u003d null || objectId \u003d\u003d null)\n                    continue;\n                if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId)) {\n                    pw.addObject(rw.parseAny(objectId));\n                }\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        if (msgOut !\u003d NullOutputStream.INSTANCE) {\n            String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        statistics \u003d pw.getStatistics();\n        if (statistics !\u003d null) {\n            postUploadHook.onPostUpload(statistics);\n        }\n        pw.close();\n    }\n    if (sideband)\n        pckOut.end();\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
          "functionStartLine": 1813,
          "functionName": "sendPack",
          "functionAnnotation": "",
          "functionDoc": "Send the requested objects to the client.\n\n@param sideband whether to wrap the pack in side-band pkt-lines,\n               interleaved with progress messages and errors.\n@param accumulator where to write statistics about the content of the pack.\n@param allTags refs to search for annotated tags to include in the pack\n               if the {@link #OPTION_INCLUDE_TAG} capability was\n               requested.\n@throws IOException\n               if an error occured while generating or writing the pack.\n",
          "diff": "@@ -1,114 +1,114 @@\n-private void sendPack(final boolean sideband, PackStatistics.Accumulator accumulator) throws IOException {\n+private void sendPack(final boolean sideband, PackStatistics.Accumulator accumulator, @Nullable Collection\u003cRef\u003e allTags) throws IOException {\n     ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n     OutputStream packOut \u003d rawOut;\n     if (sideband) {\n         int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n         if (options.contains(OPTION_SIDE_BAND_64K))\n             bufsz \u003d SideBandOutputStream.MAX_BUF;\n         packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n         if (!options.contains(OPTION_NO_PROGRESS)) {\n             msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n             pm \u003d new SideBandProgressMonitor(msgOut);\n         }\n     }\n     try {\n         if (wantAll.isEmpty()) {\n             preUploadHook.onSendPack(this, wantIds, commonBase);\n         } else {\n             preUploadHook.onSendPack(this, wantAll, commonBase);\n         }\n         msgOut.flush();\n     } catch (ServiceMayNotContinueException noPack) {\n         if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n             noPack.setOutput();\n             @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n             err.write(Constants.encode(noPack.getMessage()));\n             err.flush();\n         }\n         throw noPack;\n     }\n     PackConfig cfg \u003d packConfig;\n     if (cfg \u003d\u003d null)\n         cfg \u003d new PackConfig(db);\n     @SuppressWarnings(\"resource\") final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader(), accumulator);\n     try {\n         pw.setIndexDisabled(true);\n         if (filterBlobLimit \u003e\u003d 0) {\n             pw.setFilterBlobLimit(filterBlobLimit);\n             pw.setUseCachedPacks(false);\n         } else {\n             pw.setUseCachedPacks(true);\n         }\n         pw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n         pw.setClientShallowCommits(clientShallowCommits);\n         pw.setReuseDeltaCommits(true);\n         pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n         pw.setThin(options.contains(OPTION_THIN_PACK));\n         pw.setReuseValidatingObjects(false);\n         if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n             Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003c\u003e();\n             for (Ref ref : refs.values()) {\n                 if (ref.getPeeledObjectId() !\u003d null)\n                     tagTargets.add(ref.getPeeledObjectId());\n                 else if (ref.getObjectId() \u003d\u003d null)\n                     continue;\n                 else if (ref.getName().startsWith(Constants.R_HEADS))\n                     tagTargets.add(ref.getObjectId());\n             }\n             pw.setTagTargets(tagTargets);\n         }\n         RevWalk rw \u003d walk;\n         if (depth \u003e 0) {\n             pw.setShallowPack(depth, unshallowCommits);\n             rw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n             rw.assumeShallow(clientShallowCommits);\n         }\n         if (wantAll.isEmpty()) {\n             pw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n         } else {\n             walk.reset();\n             ObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n             pw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n             rw \u003d ow;\n         }\n-        if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n-            for (Ref ref : refs.values()) {\n+        if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 allTags !\u003d null) {\n+            for (Ref ref : allTags) {\n                 ObjectId objectId \u003d ref.getObjectId();\n                 if (objectId \u003d\u003d null) {\n                     continue;\n                 }\n                 if (wantAll.isEmpty()) {\n                     if (wantIds.contains(objectId))\n                         continue;\n                 } else {\n                     RevObject obj \u003d rw.lookupOrNull(objectId);\n                     if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                         continue;\n                 }\n                 if (!ref.isPeeled())\n                     ref \u003d db.peel(ref);\n                 ObjectId peeledId \u003d ref.getPeeledObjectId();\n                 objectId \u003d ref.getObjectId();\n                 if (peeledId \u003d\u003d null || objectId \u003d\u003d null)\n                     continue;\n                 if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId)) {\n                     pw.addObject(rw.parseAny(objectId));\n                 }\n             }\n         }\n         pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n         if (msgOut !\u003d NullOutputStream.INSTANCE) {\n             String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n             msgOut.write(Constants.encode(msg));\n             msgOut.flush();\n         }\n     } finally {\n         statistics \u003d pw.getStatistics();\n         if (statistics !\u003d null) {\n             postUploadHook.onPostUpload(statistics);\n         }\n         pw.close();\n     }\n     if (sideband)\n         pckOut.end();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "",
            "newValue": "Send the requested objects to the client.\n\n@param sideband whether to wrap the pack in side-band pkt-lines,\n               interleaved with progress messages and errors.\n@param accumulator where to write statistics about the content of the pack.\n@param allTags refs to search for annotated tags to include in the pack\n               if the {@link #OPTION_INCLUDE_TAG} capability was\n               requested.\n@throws IOException\n               if an error occured while generating or writing the pack.\n"
          }
        }
      ]
    },
    "4ac32e79b751944107470d5f4cb290eacd1b7cf9": {
      "type": "Ybodychange",
      "commitMessage": "Teach UploadPack to support filtering by blob size\n\nTeach UploadPack to advertise the filter capability and support a\n\"filter\" line in the request, accepting blob sizes only, if the\nconfiguration variable \"uploadpack.allowfilter\" is true. This feature is\ncurrently in the \"master\" branch of Git, and as of the time of writing,\nthis feature is to be released in Git 2.17.\n\nThis is incomplete in that the filter-by-sparse-specification feature\nalso supported by Git is not included in this patch.\n\nIf a JGit server were to be patched with this commit, and a repository\non that server configured with RequestPolicy.ANY or\nRequestPolicy.REACHABLE_COMMIT_TIP, a Git client built from the \"master\"\nbranch would be able to perform a partial clone.\n\nChange-Id: If72b4b422c06ab432137e9e5272d353b14b73259\nSigned-off-by: Jonathan Tan \u003cjonathantanmy@google.com\u003e\n",
      "commitDate": "2018/3/16 上午4:46",
      "commitName": "4ac32e79b751944107470d5f4cb290eacd1b7cf9",
      "commitAuthor": "Jonathan Tan",
      "commitDateOld": "2018/3/14 上午9:44",
      "commitNameOld": "67df4986cef270144c7cae3485dc8541ca180649",
      "commitAuthorOld": "David Pursehouse",
      "daysBetweenCommits": 1.79,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "actualSource": "private void sendPack(final boolean sideband, PackStatistics.Accumulator accumulator) throws IOException {\n    ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n    OutputStream packOut \u003d rawOut;\n    if (sideband) {\n        int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz \u003d SideBandOutputStream.MAX_BUF;\n        packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm \u003d new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n        msgOut.flush();\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n            noPack.setOutput();\n            @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg \u003d packConfig;\n    if (cfg \u003d\u003d null)\n        cfg \u003d new PackConfig(db);\n    @SuppressWarnings(\"resource\") final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader(), accumulator);\n    try {\n        pw.setIndexDisabled(true);\n        if (filterBlobLimit \u003e\u003d 0) {\n            pw.setFilterBlobLimit(filterBlobLimit);\n            pw.setUseCachedPacks(false);\n        } else {\n            pw.setUseCachedPacks(true);\n        }\n        pw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n        pw.setClientShallowCommits(clientShallowCommits);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n            Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003c\u003e();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() !\u003d null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() \u003d\u003d null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        RevWalk rw \u003d walk;\n        if (depth \u003e 0) {\n            pw.setShallowPack(depth, unshallowCommits);\n            rw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n            rw.assumeShallow(clientShallowCommits);\n        }\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n        } else {\n            walk.reset();\n            ObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n            rw \u003d ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId \u003d ref.getObjectId();\n                if (objectId \u003d\u003d null) {\n                    continue;\n                }\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj \u003d rw.lookupOrNull(objectId);\n                    if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref \u003d db.peel(ref);\n                ObjectId peeledId \u003d ref.getPeeledObjectId();\n                objectId \u003d ref.getObjectId();\n                if (peeledId \u003d\u003d null || objectId \u003d\u003d null)\n                    continue;\n                if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId)) {\n                    pw.addObject(rw.parseAny(objectId));\n                }\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        if (msgOut !\u003d NullOutputStream.INSTANCE) {\n            String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        statistics \u003d pw.getStatistics();\n        if (statistics !\u003d null) {\n            postUploadHook.onPostUpload(statistics);\n        }\n        pw.close();\n    }\n    if (sideband)\n        pckOut.end();\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
      "functionStartLine": 1544,
      "functionName": "sendPack",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,109 +1,114 @@\n private void sendPack(final boolean sideband, PackStatistics.Accumulator accumulator) throws IOException {\n     ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n     OutputStream packOut \u003d rawOut;\n     if (sideband) {\n         int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n         if (options.contains(OPTION_SIDE_BAND_64K))\n             bufsz \u003d SideBandOutputStream.MAX_BUF;\n         packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n         if (!options.contains(OPTION_NO_PROGRESS)) {\n             msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n             pm \u003d new SideBandProgressMonitor(msgOut);\n         }\n     }\n     try {\n         if (wantAll.isEmpty()) {\n             preUploadHook.onSendPack(this, wantIds, commonBase);\n         } else {\n             preUploadHook.onSendPack(this, wantAll, commonBase);\n         }\n         msgOut.flush();\n     } catch (ServiceMayNotContinueException noPack) {\n         if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n             noPack.setOutput();\n             @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n             err.write(Constants.encode(noPack.getMessage()));\n             err.flush();\n         }\n         throw noPack;\n     }\n     PackConfig cfg \u003d packConfig;\n     if (cfg \u003d\u003d null)\n         cfg \u003d new PackConfig(db);\n     @SuppressWarnings(\"resource\") final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader(), accumulator);\n     try {\n         pw.setIndexDisabled(true);\n-        pw.setUseCachedPacks(true);\n+        if (filterBlobLimit \u003e\u003d 0) {\n+            pw.setFilterBlobLimit(filterBlobLimit);\n+            pw.setUseCachedPacks(false);\n+        } else {\n+            pw.setUseCachedPacks(true);\n+        }\n         pw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n         pw.setClientShallowCommits(clientShallowCommits);\n         pw.setReuseDeltaCommits(true);\n         pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n         pw.setThin(options.contains(OPTION_THIN_PACK));\n         pw.setReuseValidatingObjects(false);\n         if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n             Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003c\u003e();\n             for (Ref ref : refs.values()) {\n                 if (ref.getPeeledObjectId() !\u003d null)\n                     tagTargets.add(ref.getPeeledObjectId());\n                 else if (ref.getObjectId() \u003d\u003d null)\n                     continue;\n                 else if (ref.getName().startsWith(Constants.R_HEADS))\n                     tagTargets.add(ref.getObjectId());\n             }\n             pw.setTagTargets(tagTargets);\n         }\n         RevWalk rw \u003d walk;\n         if (depth \u003e 0) {\n             pw.setShallowPack(depth, unshallowCommits);\n             rw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n             rw.assumeShallow(clientShallowCommits);\n         }\n         if (wantAll.isEmpty()) {\n             pw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n         } else {\n             walk.reset();\n             ObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n             pw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n             rw \u003d ow;\n         }\n         if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n             for (Ref ref : refs.values()) {\n                 ObjectId objectId \u003d ref.getObjectId();\n                 if (objectId \u003d\u003d null) {\n                     continue;\n                 }\n                 if (wantAll.isEmpty()) {\n                     if (wantIds.contains(objectId))\n                         continue;\n                 } else {\n                     RevObject obj \u003d rw.lookupOrNull(objectId);\n                     if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                         continue;\n                 }\n                 if (!ref.isPeeled())\n                     ref \u003d db.peel(ref);\n                 ObjectId peeledId \u003d ref.getPeeledObjectId();\n                 objectId \u003d ref.getObjectId();\n                 if (peeledId \u003d\u003d null || objectId \u003d\u003d null)\n                     continue;\n                 if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId)) {\n                     pw.addObject(rw.parseAny(objectId));\n                 }\n             }\n         }\n         pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n         if (msgOut !\u003d NullOutputStream.INSTANCE) {\n             String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n             msgOut.write(Constants.encode(msg));\n             msgOut.flush();\n         }\n     } finally {\n         statistics \u003d pw.getStatistics();\n         if (statistics !\u003d null) {\n             postUploadHook.onPostUpload(statistics);\n         }\n         pw.close();\n     }\n     if (sideband)\n         pckOut.end();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "67df4986cef270144c7cae3485dc8541ca180649": {
      "type": "Ybodychange",
      "commitMessage": "UploadPack: Suppress resource warning about PackWriter\n\nPackWriter is auto-closeable and should be opened in try-with-resource,\nbut this is not possible since the variable is being referenced in the\nfinally block before being explicitly closed there.\n\nSuppress the warning and add an explanatory comment.\n\nChange-Id: I161923f35142132234fd951c0146d3cb30920b7b\nSigned-off-by: David Pursehouse \u003cdavid.pursehouse@gmail.com\u003e\n",
      "commitDate": "2018/3/14 上午9:44",
      "commitName": "67df4986cef270144c7cae3485dc8541ca180649",
      "commitAuthor": "David Pursehouse",
      "commitDateOld": "2018/3/12 上午9:52",
      "commitNameOld": "d88d5b94c669b4c23af4e1de797a4d130b6612f8",
      "commitAuthorOld": "David Pursehouse",
      "daysBetweenCommits": 1.99,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "actualSource": "private void sendPack(final boolean sideband, PackStatistics.Accumulator accumulator) throws IOException {\n    ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n    OutputStream packOut \u003d rawOut;\n    if (sideband) {\n        int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz \u003d SideBandOutputStream.MAX_BUF;\n        packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm \u003d new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n        msgOut.flush();\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n            noPack.setOutput();\n            @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg \u003d packConfig;\n    if (cfg \u003d\u003d null)\n        cfg \u003d new PackConfig(db);\n    @SuppressWarnings(\"resource\") final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader(), accumulator);\n    try {\n        pw.setIndexDisabled(true);\n        pw.setUseCachedPacks(true);\n        pw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n        pw.setClientShallowCommits(clientShallowCommits);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n            Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003c\u003e();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() !\u003d null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() \u003d\u003d null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        RevWalk rw \u003d walk;\n        if (depth \u003e 0) {\n            pw.setShallowPack(depth, unshallowCommits);\n            rw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n            rw.assumeShallow(clientShallowCommits);\n        }\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n        } else {\n            walk.reset();\n            ObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n            rw \u003d ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId \u003d ref.getObjectId();\n                if (objectId \u003d\u003d null) {\n                    continue;\n                }\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj \u003d rw.lookupOrNull(objectId);\n                    if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref \u003d db.peel(ref);\n                ObjectId peeledId \u003d ref.getPeeledObjectId();\n                objectId \u003d ref.getObjectId();\n                if (peeledId \u003d\u003d null || objectId \u003d\u003d null)\n                    continue;\n                if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId)) {\n                    pw.addObject(rw.parseAny(objectId));\n                }\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        if (msgOut !\u003d NullOutputStream.INSTANCE) {\n            String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        statistics \u003d pw.getStatistics();\n        if (statistics !\u003d null) {\n            postUploadHook.onPostUpload(statistics);\n        }\n        pw.close();\n    }\n    if (sideband)\n        pckOut.end();\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
      "functionStartLine": 1502,
      "functionName": "sendPack",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,109 +1,109 @@\n private void sendPack(final boolean sideband, PackStatistics.Accumulator accumulator) throws IOException {\n     ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n     OutputStream packOut \u003d rawOut;\n     if (sideband) {\n         int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n         if (options.contains(OPTION_SIDE_BAND_64K))\n             bufsz \u003d SideBandOutputStream.MAX_BUF;\n         packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n         if (!options.contains(OPTION_NO_PROGRESS)) {\n             msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n             pm \u003d new SideBandProgressMonitor(msgOut);\n         }\n     }\n     try {\n         if (wantAll.isEmpty()) {\n             preUploadHook.onSendPack(this, wantIds, commonBase);\n         } else {\n             preUploadHook.onSendPack(this, wantAll, commonBase);\n         }\n         msgOut.flush();\n     } catch (ServiceMayNotContinueException noPack) {\n         if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n             noPack.setOutput();\n             @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n             err.write(Constants.encode(noPack.getMessage()));\n             err.flush();\n         }\n         throw noPack;\n     }\n     PackConfig cfg \u003d packConfig;\n     if (cfg \u003d\u003d null)\n         cfg \u003d new PackConfig(db);\n-    final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader(), accumulator);\n+    @SuppressWarnings(\"resource\") final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader(), accumulator);\n     try {\n         pw.setIndexDisabled(true);\n         pw.setUseCachedPacks(true);\n         pw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n         pw.setClientShallowCommits(clientShallowCommits);\n         pw.setReuseDeltaCommits(true);\n         pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n         pw.setThin(options.contains(OPTION_THIN_PACK));\n         pw.setReuseValidatingObjects(false);\n         if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n             Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003c\u003e();\n             for (Ref ref : refs.values()) {\n                 if (ref.getPeeledObjectId() !\u003d null)\n                     tagTargets.add(ref.getPeeledObjectId());\n                 else if (ref.getObjectId() \u003d\u003d null)\n                     continue;\n                 else if (ref.getName().startsWith(Constants.R_HEADS))\n                     tagTargets.add(ref.getObjectId());\n             }\n             pw.setTagTargets(tagTargets);\n         }\n         RevWalk rw \u003d walk;\n         if (depth \u003e 0) {\n             pw.setShallowPack(depth, unshallowCommits);\n             rw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n             rw.assumeShallow(clientShallowCommits);\n         }\n         if (wantAll.isEmpty()) {\n             pw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n         } else {\n             walk.reset();\n             ObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n             pw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n             rw \u003d ow;\n         }\n         if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n             for (Ref ref : refs.values()) {\n                 ObjectId objectId \u003d ref.getObjectId();\n                 if (objectId \u003d\u003d null) {\n                     continue;\n                 }\n                 if (wantAll.isEmpty()) {\n                     if (wantIds.contains(objectId))\n                         continue;\n                 } else {\n                     RevObject obj \u003d rw.lookupOrNull(objectId);\n                     if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                         continue;\n                 }\n                 if (!ref.isPeeled())\n                     ref \u003d db.peel(ref);\n                 ObjectId peeledId \u003d ref.getPeeledObjectId();\n                 objectId \u003d ref.getObjectId();\n                 if (peeledId \u003d\u003d null || objectId \u003d\u003d null)\n                     continue;\n                 if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId)) {\n                     pw.addObject(rw.parseAny(objectId));\n                 }\n             }\n         }\n         pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n         if (msgOut !\u003d NullOutputStream.INSTANCE) {\n             String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n             msgOut.write(Constants.encode(msg));\n             msgOut.flush();\n         }\n     } finally {\n         statistics \u003d pw.getStatistics();\n         if (statistics !\u003d null) {\n             postUploadHook.onPostUpload(statistics);\n         }\n         pw.close();\n     }\n     if (sideband)\n         pckOut.end();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d88d5b94c669b4c23af4e1de797a4d130b6612f8": {
      "type": "Yannotationchange",
      "commitMessage": "UploadPack: Remove redundant suppression of deprecation warning\n\nChange-Id: I9a7f46e1da42fd86adedc18b3394d5f755722624\nSigned-off-by: David Pursehouse \u003cdavid.pursehouse@gmail.com\u003e\n",
      "commitDate": "2018/3/12 上午9:52",
      "commitName": "d88d5b94c669b4c23af4e1de797a4d130b6612f8",
      "commitAuthor": "David Pursehouse",
      "commitDateOld": "2018/3/11 上午2:38",
      "commitNameOld": "cc19f649666704e5bf0184d3839be0c0c17439fc",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 1.3,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "actualSource": "private void sendPack(final boolean sideband, PackStatistics.Accumulator accumulator) throws IOException {\n    ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n    OutputStream packOut \u003d rawOut;\n    if (sideband) {\n        int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz \u003d SideBandOutputStream.MAX_BUF;\n        packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm \u003d new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n        msgOut.flush();\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n            noPack.setOutput();\n            @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg \u003d packConfig;\n    if (cfg \u003d\u003d null)\n        cfg \u003d new PackConfig(db);\n    final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader(), accumulator);\n    try {\n        pw.setIndexDisabled(true);\n        pw.setUseCachedPacks(true);\n        pw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n        pw.setClientShallowCommits(clientShallowCommits);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n            Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003c\u003e();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() !\u003d null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() \u003d\u003d null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        RevWalk rw \u003d walk;\n        if (depth \u003e 0) {\n            pw.setShallowPack(depth, unshallowCommits);\n            rw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n            rw.assumeShallow(clientShallowCommits);\n        }\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n        } else {\n            walk.reset();\n            ObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n            rw \u003d ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId \u003d ref.getObjectId();\n                if (objectId \u003d\u003d null) {\n                    continue;\n                }\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj \u003d rw.lookupOrNull(objectId);\n                    if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref \u003d db.peel(ref);\n                ObjectId peeledId \u003d ref.getPeeledObjectId();\n                objectId \u003d ref.getObjectId();\n                if (peeledId \u003d\u003d null || objectId \u003d\u003d null)\n                    continue;\n                if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId)) {\n                    pw.addObject(rw.parseAny(objectId));\n                }\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        if (msgOut !\u003d NullOutputStream.INSTANCE) {\n            String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        statistics \u003d pw.getStatistics();\n        if (statistics !\u003d null) {\n            postUploadHook.onPostUpload(statistics);\n        }\n        pw.close();\n    }\n    if (sideband)\n        pckOut.end();\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
      "functionStartLine": 1502,
      "functionName": "sendPack",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,110 +1,109 @@\n-@SuppressWarnings(\"deprecation\")\n private void sendPack(final boolean sideband, PackStatistics.Accumulator accumulator) throws IOException {\n     ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n     OutputStream packOut \u003d rawOut;\n     if (sideband) {\n         int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n         if (options.contains(OPTION_SIDE_BAND_64K))\n             bufsz \u003d SideBandOutputStream.MAX_BUF;\n         packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n         if (!options.contains(OPTION_NO_PROGRESS)) {\n             msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n             pm \u003d new SideBandProgressMonitor(msgOut);\n         }\n     }\n     try {\n         if (wantAll.isEmpty()) {\n             preUploadHook.onSendPack(this, wantIds, commonBase);\n         } else {\n             preUploadHook.onSendPack(this, wantAll, commonBase);\n         }\n         msgOut.flush();\n     } catch (ServiceMayNotContinueException noPack) {\n         if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n             noPack.setOutput();\n             @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n             err.write(Constants.encode(noPack.getMessage()));\n             err.flush();\n         }\n         throw noPack;\n     }\n     PackConfig cfg \u003d packConfig;\n     if (cfg \u003d\u003d null)\n         cfg \u003d new PackConfig(db);\n     final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader(), accumulator);\n     try {\n         pw.setIndexDisabled(true);\n         pw.setUseCachedPacks(true);\n         pw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n         pw.setClientShallowCommits(clientShallowCommits);\n         pw.setReuseDeltaCommits(true);\n         pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n         pw.setThin(options.contains(OPTION_THIN_PACK));\n         pw.setReuseValidatingObjects(false);\n         if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n             Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003c\u003e();\n             for (Ref ref : refs.values()) {\n                 if (ref.getPeeledObjectId() !\u003d null)\n                     tagTargets.add(ref.getPeeledObjectId());\n                 else if (ref.getObjectId() \u003d\u003d null)\n                     continue;\n                 else if (ref.getName().startsWith(Constants.R_HEADS))\n                     tagTargets.add(ref.getObjectId());\n             }\n             pw.setTagTargets(tagTargets);\n         }\n         RevWalk rw \u003d walk;\n         if (depth \u003e 0) {\n             pw.setShallowPack(depth, unshallowCommits);\n             rw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n             rw.assumeShallow(clientShallowCommits);\n         }\n         if (wantAll.isEmpty()) {\n             pw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n         } else {\n             walk.reset();\n             ObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n             pw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n             rw \u003d ow;\n         }\n         if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n             for (Ref ref : refs.values()) {\n                 ObjectId objectId \u003d ref.getObjectId();\n                 if (objectId \u003d\u003d null) {\n                     continue;\n                 }\n                 if (wantAll.isEmpty()) {\n                     if (wantIds.contains(objectId))\n                         continue;\n                 } else {\n                     RevObject obj \u003d rw.lookupOrNull(objectId);\n                     if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                         continue;\n                 }\n                 if (!ref.isPeeled())\n                     ref \u003d db.peel(ref);\n                 ObjectId peeledId \u003d ref.getPeeledObjectId();\n                 objectId \u003d ref.getObjectId();\n                 if (peeledId \u003d\u003d null || objectId \u003d\u003d null)\n                     continue;\n                 if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId)) {\n                     pw.addObject(rw.parseAny(objectId));\n                 }\n             }\n         }\n         pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n         if (msgOut !\u003d NullOutputStream.INSTANCE) {\n             String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n             msgOut.write(Constants.encode(msg));\n             msgOut.flush();\n         }\n     } finally {\n         statistics \u003d pw.getStatistics();\n         if (statistics !\u003d null) {\n             postUploadHook.onPostUpload(statistics);\n         }\n         pw.close();\n     }\n     if (sideband)\n         pckOut.end();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "@SuppressWarnings(\"deprecation\")",
        "newValue": ""
      }
    },
    "cc19f649666704e5bf0184d3839be0c0c17439fc": {
      "type": "Ybodychange",
      "commitMessage": "Remove deprecated Statistics, UploadPackLogger, UploadPackLoggerChain\n\nUse PackStatistics and PostUploadHook and PostUploadHookChain instead.\nAlso remove\n- UploadPack#getPackStatistics replaced by #getStatistics\n- UploadPack#getLogger and UploadPack#setLogger\n\nChange-Id: I70881c539af3094d68d594f19983dea0973604e8\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2018/3/11 上午2:38",
      "commitName": "cc19f649666704e5bf0184d3839be0c0c17439fc",
      "commitAuthor": "Matthias Sohn",
      "commitDateOld": "2018/2/13 上午5:59",
      "commitNameOld": "302596cc675d00e41f0ff07efef58063afe20c79",
      "commitAuthorOld": "Terry Parker",
      "daysBetweenCommits": 25.86,
      "commitsBetweenForRepo": 125,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"deprecation\")\nprivate void sendPack(final boolean sideband, PackStatistics.Accumulator accumulator) throws IOException {\n    ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n    OutputStream packOut \u003d rawOut;\n    if (sideband) {\n        int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz \u003d SideBandOutputStream.MAX_BUF;\n        packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm \u003d new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n        msgOut.flush();\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n            noPack.setOutput();\n            @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg \u003d packConfig;\n    if (cfg \u003d\u003d null)\n        cfg \u003d new PackConfig(db);\n    final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader(), accumulator);\n    try {\n        pw.setIndexDisabled(true);\n        pw.setUseCachedPacks(true);\n        pw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n        pw.setClientShallowCommits(clientShallowCommits);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n            Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003c\u003e();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() !\u003d null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() \u003d\u003d null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        RevWalk rw \u003d walk;\n        if (depth \u003e 0) {\n            pw.setShallowPack(depth, unshallowCommits);\n            rw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n            rw.assumeShallow(clientShallowCommits);\n        }\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n        } else {\n            walk.reset();\n            ObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n            rw \u003d ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId \u003d ref.getObjectId();\n                if (objectId \u003d\u003d null) {\n                    continue;\n                }\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj \u003d rw.lookupOrNull(objectId);\n                    if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref \u003d db.peel(ref);\n                ObjectId peeledId \u003d ref.getPeeledObjectId();\n                objectId \u003d ref.getObjectId();\n                if (peeledId \u003d\u003d null || objectId \u003d\u003d null)\n                    continue;\n                if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId)) {\n                    pw.addObject(rw.parseAny(objectId));\n                }\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        if (msgOut !\u003d NullOutputStream.INSTANCE) {\n            String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        statistics \u003d pw.getStatistics();\n        if (statistics !\u003d null) {\n            postUploadHook.onPostUpload(statistics);\n        }\n        pw.close();\n    }\n    if (sideband)\n        pckOut.end();\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
      "functionStartLine": 1503,
      "functionName": "sendPack",
      "functionAnnotation": "@SuppressWarnings(\"deprecation\")",
      "functionDoc": "",
      "diff": "@@ -1,111 +1,110 @@\n @SuppressWarnings(\"deprecation\")\n private void sendPack(final boolean sideband, PackStatistics.Accumulator accumulator) throws IOException {\n     ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n     OutputStream packOut \u003d rawOut;\n     if (sideband) {\n         int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n         if (options.contains(OPTION_SIDE_BAND_64K))\n             bufsz \u003d SideBandOutputStream.MAX_BUF;\n         packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n         if (!options.contains(OPTION_NO_PROGRESS)) {\n             msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n             pm \u003d new SideBandProgressMonitor(msgOut);\n         }\n     }\n     try {\n         if (wantAll.isEmpty()) {\n             preUploadHook.onSendPack(this, wantIds, commonBase);\n         } else {\n             preUploadHook.onSendPack(this, wantAll, commonBase);\n         }\n         msgOut.flush();\n     } catch (ServiceMayNotContinueException noPack) {\n         if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n             noPack.setOutput();\n             @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n             err.write(Constants.encode(noPack.getMessage()));\n             err.flush();\n         }\n         throw noPack;\n     }\n     PackConfig cfg \u003d packConfig;\n     if (cfg \u003d\u003d null)\n         cfg \u003d new PackConfig(db);\n     final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader(), accumulator);\n     try {\n         pw.setIndexDisabled(true);\n         pw.setUseCachedPacks(true);\n         pw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n         pw.setClientShallowCommits(clientShallowCommits);\n         pw.setReuseDeltaCommits(true);\n         pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n         pw.setThin(options.contains(OPTION_THIN_PACK));\n         pw.setReuseValidatingObjects(false);\n         if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n             Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003c\u003e();\n             for (Ref ref : refs.values()) {\n                 if (ref.getPeeledObjectId() !\u003d null)\n                     tagTargets.add(ref.getPeeledObjectId());\n                 else if (ref.getObjectId() \u003d\u003d null)\n                     continue;\n                 else if (ref.getName().startsWith(Constants.R_HEADS))\n                     tagTargets.add(ref.getObjectId());\n             }\n             pw.setTagTargets(tagTargets);\n         }\n         RevWalk rw \u003d walk;\n         if (depth \u003e 0) {\n             pw.setShallowPack(depth, unshallowCommits);\n             rw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n             rw.assumeShallow(clientShallowCommits);\n         }\n         if (wantAll.isEmpty()) {\n             pw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n         } else {\n             walk.reset();\n             ObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n             pw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n             rw \u003d ow;\n         }\n         if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n             for (Ref ref : refs.values()) {\n                 ObjectId objectId \u003d ref.getObjectId();\n                 if (objectId \u003d\u003d null) {\n                     continue;\n                 }\n                 if (wantAll.isEmpty()) {\n                     if (wantIds.contains(objectId))\n                         continue;\n                 } else {\n                     RevObject obj \u003d rw.lookupOrNull(objectId);\n                     if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                         continue;\n                 }\n                 if (!ref.isPeeled())\n                     ref \u003d db.peel(ref);\n                 ObjectId peeledId \u003d ref.getPeeledObjectId();\n                 objectId \u003d ref.getObjectId();\n                 if (peeledId \u003d\u003d null || objectId \u003d\u003d null)\n                     continue;\n                 if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId)) {\n                     pw.addObject(rw.parseAny(objectId));\n                 }\n             }\n         }\n         pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n         if (msgOut !\u003d NullOutputStream.INSTANCE) {\n             String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n             msgOut.write(Constants.encode(msg));\n             msgOut.flush();\n         }\n     } finally {\n         statistics \u003d pw.getStatistics();\n         if (statistics !\u003d null) {\n             postUploadHook.onPostUpload(statistics);\n-            logger.onPackStatistics(new PackWriter.Statistics(statistics));\n         }\n         pw.close();\n     }\n     if (sideband)\n         pckOut.end();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "302596cc675d00e41f0ff07efef58063afe20c79": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Add negotiation statistics to PackStatistics\n\nAdd fetch statistics for the counts of advertised refs, wants and haves.\nAlso add the duration in milliseconds for the negotiation phase. For\nnon-bidirectional transports like HTTP, this is the time for the final\nround that sends the pack back to the user.\n\nChange-Id: I1af7ffd3cb7b62182340682e2a243691ea24ec2e\nSigned-off-by: Terry Parker \u003ctparker@google.com\u003e\n",
      "commitDate": "2018/2/13 上午5:59",
      "commitName": "302596cc675d00e41f0ff07efef58063afe20c79",
      "commitAuthor": "Terry Parker",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Add negotiation statistics to PackStatistics\n\nAdd fetch statistics for the counts of advertised refs, wants and haves.\nAlso add the duration in milliseconds for the negotiation phase. For\nnon-bidirectional transports like HTTP, this is the time for the final\nround that sends the pack back to the user.\n\nChange-Id: I1af7ffd3cb7b62182340682e2a243691ea24ec2e\nSigned-off-by: Terry Parker \u003ctparker@google.com\u003e\n",
          "commitDate": "2018/2/13 上午5:59",
          "commitName": "302596cc675d00e41f0ff07efef58063afe20c79",
          "commitAuthor": "Terry Parker",
          "commitDateOld": "2018/1/4 上午6:21",
          "commitNameOld": "21d22e6f63a1adcfaeaee155f1be32f8123fd789",
          "commitAuthorOld": "Zhen Chen",
          "daysBetweenCommits": 39.99,
          "commitsBetweenForRepo": 46,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"deprecation\")\nprivate void sendPack(final boolean sideband, PackStatistics.Accumulator accumulator) throws IOException {\n    ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n    OutputStream packOut \u003d rawOut;\n    if (sideband) {\n        int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz \u003d SideBandOutputStream.MAX_BUF;\n        packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm \u003d new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n        msgOut.flush();\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n            noPack.setOutput();\n            @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg \u003d packConfig;\n    if (cfg \u003d\u003d null)\n        cfg \u003d new PackConfig(db);\n    final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader(), accumulator);\n    try {\n        pw.setIndexDisabled(true);\n        pw.setUseCachedPacks(true);\n        pw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n        pw.setClientShallowCommits(clientShallowCommits);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n            Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003c\u003e();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() !\u003d null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() \u003d\u003d null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        RevWalk rw \u003d walk;\n        if (depth \u003e 0) {\n            pw.setShallowPack(depth, unshallowCommits);\n            rw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n            rw.assumeShallow(clientShallowCommits);\n        }\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n        } else {\n            walk.reset();\n            ObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n            rw \u003d ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId \u003d ref.getObjectId();\n                if (objectId \u003d\u003d null) {\n                    continue;\n                }\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj \u003d rw.lookupOrNull(objectId);\n                    if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref \u003d db.peel(ref);\n                ObjectId peeledId \u003d ref.getPeeledObjectId();\n                objectId \u003d ref.getObjectId();\n                if (peeledId \u003d\u003d null || objectId \u003d\u003d null)\n                    continue;\n                if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId)) {\n                    pw.addObject(rw.parseAny(objectId));\n                }\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        if (msgOut !\u003d NullOutputStream.INSTANCE) {\n            String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        statistics \u003d pw.getStatistics();\n        if (statistics !\u003d null) {\n            postUploadHook.onPostUpload(statistics);\n            logger.onPackStatistics(new PackWriter.Statistics(statistics));\n        }\n        pw.close();\n    }\n    if (sideband)\n        pckOut.end();\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
          "functionStartLine": 1544,
          "functionName": "sendPack",
          "functionAnnotation": "@SuppressWarnings(\"deprecation\")",
          "functionDoc": "",
          "diff": "@@ -1,111 +1,111 @@\n @SuppressWarnings(\"deprecation\")\n-private void sendPack(final boolean sideband) throws IOException {\n+private void sendPack(final boolean sideband, PackStatistics.Accumulator accumulator) throws IOException {\n     ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n     OutputStream packOut \u003d rawOut;\n     if (sideband) {\n         int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n         if (options.contains(OPTION_SIDE_BAND_64K))\n             bufsz \u003d SideBandOutputStream.MAX_BUF;\n         packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n         if (!options.contains(OPTION_NO_PROGRESS)) {\n             msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n             pm \u003d new SideBandProgressMonitor(msgOut);\n         }\n     }\n     try {\n         if (wantAll.isEmpty()) {\n             preUploadHook.onSendPack(this, wantIds, commonBase);\n         } else {\n             preUploadHook.onSendPack(this, wantAll, commonBase);\n         }\n         msgOut.flush();\n     } catch (ServiceMayNotContinueException noPack) {\n         if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n             noPack.setOutput();\n             @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n             err.write(Constants.encode(noPack.getMessage()));\n             err.flush();\n         }\n         throw noPack;\n     }\n     PackConfig cfg \u003d packConfig;\n     if (cfg \u003d\u003d null)\n         cfg \u003d new PackConfig(db);\n-    final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n+    final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader(), accumulator);\n     try {\n         pw.setIndexDisabled(true);\n         pw.setUseCachedPacks(true);\n         pw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n         pw.setClientShallowCommits(clientShallowCommits);\n         pw.setReuseDeltaCommits(true);\n         pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n         pw.setThin(options.contains(OPTION_THIN_PACK));\n         pw.setReuseValidatingObjects(false);\n         if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n             Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003c\u003e();\n             for (Ref ref : refs.values()) {\n                 if (ref.getPeeledObjectId() !\u003d null)\n                     tagTargets.add(ref.getPeeledObjectId());\n                 else if (ref.getObjectId() \u003d\u003d null)\n                     continue;\n                 else if (ref.getName().startsWith(Constants.R_HEADS))\n                     tagTargets.add(ref.getObjectId());\n             }\n             pw.setTagTargets(tagTargets);\n         }\n         RevWalk rw \u003d walk;\n         if (depth \u003e 0) {\n             pw.setShallowPack(depth, unshallowCommits);\n             rw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n             rw.assumeShallow(clientShallowCommits);\n         }\n         if (wantAll.isEmpty()) {\n             pw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n         } else {\n             walk.reset();\n             ObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n             pw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n             rw \u003d ow;\n         }\n         if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n             for (Ref ref : refs.values()) {\n                 ObjectId objectId \u003d ref.getObjectId();\n                 if (objectId \u003d\u003d null) {\n                     continue;\n                 }\n                 if (wantAll.isEmpty()) {\n                     if (wantIds.contains(objectId))\n                         continue;\n                 } else {\n                     RevObject obj \u003d rw.lookupOrNull(objectId);\n                     if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                         continue;\n                 }\n                 if (!ref.isPeeled())\n                     ref \u003d db.peel(ref);\n                 ObjectId peeledId \u003d ref.getPeeledObjectId();\n                 objectId \u003d ref.getObjectId();\n                 if (peeledId \u003d\u003d null || objectId \u003d\u003d null)\n                     continue;\n                 if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId)) {\n                     pw.addObject(rw.parseAny(objectId));\n                 }\n             }\n         }\n         pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n         if (msgOut !\u003d NullOutputStream.INSTANCE) {\n             String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n             msgOut.write(Constants.encode(msg));\n             msgOut.flush();\n         }\n     } finally {\n         statistics \u003d pw.getStatistics();\n         if (statistics !\u003d null) {\n             postUploadHook.onPostUpload(statistics);\n             logger.onPackStatistics(new PackWriter.Statistics(statistics));\n         }\n         pw.close();\n     }\n     if (sideband)\n         pckOut.end();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[sideband-boolean(modifiers-final)]",
            "newValue": "[sideband-boolean(modifiers-final), accumulator-PackStatistics.Accumulator]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Add negotiation statistics to PackStatistics\n\nAdd fetch statistics for the counts of advertised refs, wants and haves.\nAlso add the duration in milliseconds for the negotiation phase. For\nnon-bidirectional transports like HTTP, this is the time for the final\nround that sends the pack back to the user.\n\nChange-Id: I1af7ffd3cb7b62182340682e2a243691ea24ec2e\nSigned-off-by: Terry Parker \u003ctparker@google.com\u003e\n",
          "commitDate": "2018/2/13 上午5:59",
          "commitName": "302596cc675d00e41f0ff07efef58063afe20c79",
          "commitAuthor": "Terry Parker",
          "commitDateOld": "2018/1/4 上午6:21",
          "commitNameOld": "21d22e6f63a1adcfaeaee155f1be32f8123fd789",
          "commitAuthorOld": "Zhen Chen",
          "daysBetweenCommits": 39.99,
          "commitsBetweenForRepo": 46,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"deprecation\")\nprivate void sendPack(final boolean sideband, PackStatistics.Accumulator accumulator) throws IOException {\n    ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n    OutputStream packOut \u003d rawOut;\n    if (sideband) {\n        int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz \u003d SideBandOutputStream.MAX_BUF;\n        packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm \u003d new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n        msgOut.flush();\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n            noPack.setOutput();\n            @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg \u003d packConfig;\n    if (cfg \u003d\u003d null)\n        cfg \u003d new PackConfig(db);\n    final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader(), accumulator);\n    try {\n        pw.setIndexDisabled(true);\n        pw.setUseCachedPacks(true);\n        pw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n        pw.setClientShallowCommits(clientShallowCommits);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n            Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003c\u003e();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() !\u003d null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() \u003d\u003d null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        RevWalk rw \u003d walk;\n        if (depth \u003e 0) {\n            pw.setShallowPack(depth, unshallowCommits);\n            rw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n            rw.assumeShallow(clientShallowCommits);\n        }\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n        } else {\n            walk.reset();\n            ObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n            rw \u003d ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId \u003d ref.getObjectId();\n                if (objectId \u003d\u003d null) {\n                    continue;\n                }\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj \u003d rw.lookupOrNull(objectId);\n                    if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref \u003d db.peel(ref);\n                ObjectId peeledId \u003d ref.getPeeledObjectId();\n                objectId \u003d ref.getObjectId();\n                if (peeledId \u003d\u003d null || objectId \u003d\u003d null)\n                    continue;\n                if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId)) {\n                    pw.addObject(rw.parseAny(objectId));\n                }\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        if (msgOut !\u003d NullOutputStream.INSTANCE) {\n            String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        statistics \u003d pw.getStatistics();\n        if (statistics !\u003d null) {\n            postUploadHook.onPostUpload(statistics);\n            logger.onPackStatistics(new PackWriter.Statistics(statistics));\n        }\n        pw.close();\n    }\n    if (sideband)\n        pckOut.end();\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
          "functionStartLine": 1544,
          "functionName": "sendPack",
          "functionAnnotation": "@SuppressWarnings(\"deprecation\")",
          "functionDoc": "",
          "diff": "@@ -1,111 +1,111 @@\n @SuppressWarnings(\"deprecation\")\n-private void sendPack(final boolean sideband) throws IOException {\n+private void sendPack(final boolean sideband, PackStatistics.Accumulator accumulator) throws IOException {\n     ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n     OutputStream packOut \u003d rawOut;\n     if (sideband) {\n         int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n         if (options.contains(OPTION_SIDE_BAND_64K))\n             bufsz \u003d SideBandOutputStream.MAX_BUF;\n         packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n         if (!options.contains(OPTION_NO_PROGRESS)) {\n             msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n             pm \u003d new SideBandProgressMonitor(msgOut);\n         }\n     }\n     try {\n         if (wantAll.isEmpty()) {\n             preUploadHook.onSendPack(this, wantIds, commonBase);\n         } else {\n             preUploadHook.onSendPack(this, wantAll, commonBase);\n         }\n         msgOut.flush();\n     } catch (ServiceMayNotContinueException noPack) {\n         if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n             noPack.setOutput();\n             @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n             err.write(Constants.encode(noPack.getMessage()));\n             err.flush();\n         }\n         throw noPack;\n     }\n     PackConfig cfg \u003d packConfig;\n     if (cfg \u003d\u003d null)\n         cfg \u003d new PackConfig(db);\n-    final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n+    final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader(), accumulator);\n     try {\n         pw.setIndexDisabled(true);\n         pw.setUseCachedPacks(true);\n         pw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n         pw.setClientShallowCommits(clientShallowCommits);\n         pw.setReuseDeltaCommits(true);\n         pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n         pw.setThin(options.contains(OPTION_THIN_PACK));\n         pw.setReuseValidatingObjects(false);\n         if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n             Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003c\u003e();\n             for (Ref ref : refs.values()) {\n                 if (ref.getPeeledObjectId() !\u003d null)\n                     tagTargets.add(ref.getPeeledObjectId());\n                 else if (ref.getObjectId() \u003d\u003d null)\n                     continue;\n                 else if (ref.getName().startsWith(Constants.R_HEADS))\n                     tagTargets.add(ref.getObjectId());\n             }\n             pw.setTagTargets(tagTargets);\n         }\n         RevWalk rw \u003d walk;\n         if (depth \u003e 0) {\n             pw.setShallowPack(depth, unshallowCommits);\n             rw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n             rw.assumeShallow(clientShallowCommits);\n         }\n         if (wantAll.isEmpty()) {\n             pw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n         } else {\n             walk.reset();\n             ObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n             pw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n             rw \u003d ow;\n         }\n         if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n             for (Ref ref : refs.values()) {\n                 ObjectId objectId \u003d ref.getObjectId();\n                 if (objectId \u003d\u003d null) {\n                     continue;\n                 }\n                 if (wantAll.isEmpty()) {\n                     if (wantIds.contains(objectId))\n                         continue;\n                 } else {\n                     RevObject obj \u003d rw.lookupOrNull(objectId);\n                     if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                         continue;\n                 }\n                 if (!ref.isPeeled())\n                     ref \u003d db.peel(ref);\n                 ObjectId peeledId \u003d ref.getPeeledObjectId();\n                 objectId \u003d ref.getObjectId();\n                 if (peeledId \u003d\u003d null || objectId \u003d\u003d null)\n                     continue;\n                 if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId)) {\n                     pw.addObject(rw.parseAny(objectId));\n                 }\n             }\n         }\n         pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n         if (msgOut !\u003d NullOutputStream.INSTANCE) {\n             String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n             msgOut.write(Constants.encode(msg));\n             msgOut.flush();\n         }\n     } finally {\n         statistics \u003d pw.getStatistics();\n         if (statistics !\u003d null) {\n             postUploadHook.onPostUpload(statistics);\n             logger.onPackStatistics(new PackWriter.Statistics(statistics));\n         }\n         pw.close();\n     }\n     if (sideband)\n         pckOut.end();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "21d22e6f63a1adcfaeaee155f1be32f8123fd789": {
      "type": "Ybodychange",
      "commitMessage": "Skip unborn branches in UploadPack\n\nThe ObjectId of an unborn branch is null, skip those in UploadPack.\n\nChange-Id: I7cbf66b05dff98c4fe9f33e20a647ba6acf364b2\nSigned-off-by: Zhen Chen \u003cczhen@google.com\u003e\n",
      "commitDate": "2018/1/4 上午6:21",
      "commitName": "21d22e6f63a1adcfaeaee155f1be32f8123fd789",
      "commitAuthor": "Zhen Chen",
      "commitDateOld": "2017/12/21 上午5:10",
      "commitNameOld": "781e106a2607665a7a47b626fd5b67fa8b491d18",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 14.05,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"deprecation\")\nprivate void sendPack(final boolean sideband) throws IOException {\n    ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n    OutputStream packOut \u003d rawOut;\n    if (sideband) {\n        int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz \u003d SideBandOutputStream.MAX_BUF;\n        packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm \u003d new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n        msgOut.flush();\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n            noPack.setOutput();\n            @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg \u003d packConfig;\n    if (cfg \u003d\u003d null)\n        cfg \u003d new PackConfig(db);\n    final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n    try {\n        pw.setIndexDisabled(true);\n        pw.setUseCachedPacks(true);\n        pw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n        pw.setClientShallowCommits(clientShallowCommits);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n            Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003c\u003e();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() !\u003d null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() \u003d\u003d null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        RevWalk rw \u003d walk;\n        if (depth \u003e 0) {\n            pw.setShallowPack(depth, unshallowCommits);\n            rw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n            rw.assumeShallow(clientShallowCommits);\n        }\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n        } else {\n            walk.reset();\n            ObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n            rw \u003d ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId \u003d ref.getObjectId();\n                if (objectId \u003d\u003d null) {\n                    continue;\n                }\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj \u003d rw.lookupOrNull(objectId);\n                    if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref \u003d db.peel(ref);\n                ObjectId peeledId \u003d ref.getPeeledObjectId();\n                objectId \u003d ref.getObjectId();\n                if (peeledId \u003d\u003d null || objectId \u003d\u003d null)\n                    continue;\n                if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId)) {\n                    pw.addObject(rw.parseAny(objectId));\n                }\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        if (msgOut !\u003d NullOutputStream.INSTANCE) {\n            String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        statistics \u003d pw.getStatistics();\n        if (statistics !\u003d null) {\n            postUploadHook.onPostUpload(statistics);\n            logger.onPackStatistics(new PackWriter.Statistics(statistics));\n        }\n        pw.close();\n    }\n    if (sideband)\n        pckOut.end();\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
      "functionStartLine": 1535,
      "functionName": "sendPack",
      "functionAnnotation": "@SuppressWarnings(\"deprecation\")",
      "functionDoc": "",
      "diff": "@@ -1,107 +1,111 @@\n @SuppressWarnings(\"deprecation\")\n private void sendPack(final boolean sideband) throws IOException {\n     ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n     OutputStream packOut \u003d rawOut;\n     if (sideband) {\n         int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n         if (options.contains(OPTION_SIDE_BAND_64K))\n             bufsz \u003d SideBandOutputStream.MAX_BUF;\n         packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n         if (!options.contains(OPTION_NO_PROGRESS)) {\n             msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n             pm \u003d new SideBandProgressMonitor(msgOut);\n         }\n     }\n     try {\n         if (wantAll.isEmpty()) {\n             preUploadHook.onSendPack(this, wantIds, commonBase);\n         } else {\n             preUploadHook.onSendPack(this, wantAll, commonBase);\n         }\n         msgOut.flush();\n     } catch (ServiceMayNotContinueException noPack) {\n         if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n             noPack.setOutput();\n             @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n             err.write(Constants.encode(noPack.getMessage()));\n             err.flush();\n         }\n         throw noPack;\n     }\n     PackConfig cfg \u003d packConfig;\n     if (cfg \u003d\u003d null)\n         cfg \u003d new PackConfig(db);\n     final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n     try {\n         pw.setIndexDisabled(true);\n         pw.setUseCachedPacks(true);\n         pw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n         pw.setClientShallowCommits(clientShallowCommits);\n         pw.setReuseDeltaCommits(true);\n         pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n         pw.setThin(options.contains(OPTION_THIN_PACK));\n         pw.setReuseValidatingObjects(false);\n         if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n             Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003c\u003e();\n             for (Ref ref : refs.values()) {\n                 if (ref.getPeeledObjectId() !\u003d null)\n                     tagTargets.add(ref.getPeeledObjectId());\n                 else if (ref.getObjectId() \u003d\u003d null)\n                     continue;\n                 else if (ref.getName().startsWith(Constants.R_HEADS))\n                     tagTargets.add(ref.getObjectId());\n             }\n             pw.setTagTargets(tagTargets);\n         }\n         RevWalk rw \u003d walk;\n         if (depth \u003e 0) {\n             pw.setShallowPack(depth, unshallowCommits);\n             rw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n             rw.assumeShallow(clientShallowCommits);\n         }\n         if (wantAll.isEmpty()) {\n             pw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n         } else {\n             walk.reset();\n             ObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n             pw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n             rw \u003d ow;\n         }\n         if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n             for (Ref ref : refs.values()) {\n                 ObjectId objectId \u003d ref.getObjectId();\n+                if (objectId \u003d\u003d null) {\n+                    continue;\n+                }\n                 if (wantAll.isEmpty()) {\n                     if (wantIds.contains(objectId))\n                         continue;\n                 } else {\n                     RevObject obj \u003d rw.lookupOrNull(objectId);\n                     if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                         continue;\n                 }\n                 if (!ref.isPeeled())\n                     ref \u003d db.peel(ref);\n                 ObjectId peeledId \u003d ref.getPeeledObjectId();\n-                if (peeledId \u003d\u003d null)\n-                    continue;\n                 objectId \u003d ref.getObjectId();\n-                if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n+                if (peeledId \u003d\u003d null || objectId \u003d\u003d null)\n+                    continue;\n+                if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId)) {\n                     pw.addObject(rw.parseAny(objectId));\n+                }\n             }\n         }\n         pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n         if (msgOut !\u003d NullOutputStream.INSTANCE) {\n             String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n             msgOut.write(Constants.encode(msg));\n             msgOut.flush();\n         }\n     } finally {\n         statistics \u003d pw.getStatistics();\n         if (statistics !\u003d null) {\n             postUploadHook.onPostUpload(statistics);\n             logger.onPackStatistics(new PackWriter.Statistics(statistics));\n         }\n         pw.close();\n     }\n     if (sideband)\n         pckOut.end();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c46c720e99baa081bff0dd7bcc1ae8ca48b5e3d1": {
      "type": "Ybodychange",
      "commitMessage": "Exclude refs/tags from bitmap commit selection\n\nCommit db77610 ensured that all refs/tags commits are added to the\nprimary GC pack. It did that by adding all of the refs/tags commits\nto the primary GC pack PackWriter\u0027s \"interesting\" object set.\n\nUnfortunately, all commit objects in the \"interesting\" set are\nselected as commits for which bitmap indices will be built. In a\nrepository like chromium with lots of tags, this changed the number of\nbitmaps created from \u003c700 to \u003e10000. That puts huge memory pressure on\nthe GC task.\n\nThis change restores the original behavior of ignoring tags when\nselecting commits for bitmaps.\n\nIn the \"uninteresting\" set, commits for refs/heads and refs/tags for\nunannotated tags can not be differentiated. We instead identify\nrefs/tags commits by passing their ObjectIds as a new \"noBitmaps\"\nparameter to the PackWriter.preparePack() methods.\nPackWriterBitmapPreparer.setupTipCommitBitmaps() can then use that\n\"noBitmaps\" parameter to exclude those commits.\n\nChange-Id: Icd287c6b04fc1e48de773033fe432a9b0e904ac5\nSigned-off-by: Terry Parker \u003ctparker@google.com\u003e\n",
      "commitDate": "2017/5/19 上午6:25",
      "commitName": "c46c720e99baa081bff0dd7bcc1ae8ca48b5e3d1",
      "commitAuthor": "Terry Parker",
      "commitDateOld": "2017/4/5 下午3:51",
      "commitNameOld": "7476baebfc457e75c984de61dc8ae08a359b52e8",
      "commitAuthorOld": "Andrey Loskutov",
      "daysBetweenCommits": 43.61,
      "commitsBetweenForRepo": 47,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"deprecation\")\nprivate void sendPack(final boolean sideband) throws IOException {\n    ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n    OutputStream packOut \u003d rawOut;\n    if (sideband) {\n        int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz \u003d SideBandOutputStream.MAX_BUF;\n        packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm \u003d new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n        msgOut.flush();\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n            noPack.setOutput();\n            @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg \u003d packConfig;\n    if (cfg \u003d\u003d null)\n        cfg \u003d new PackConfig(db);\n    final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n    try {\n        pw.setIndexDisabled(true);\n        pw.setUseCachedPacks(true);\n        pw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n        pw.setClientShallowCommits(clientShallowCommits);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n            Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003c\u003e();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() !\u003d null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() \u003d\u003d null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        RevWalk rw \u003d walk;\n        if (depth \u003e 0) {\n            pw.setShallowPack(depth, unshallowCommits);\n            rw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n            rw.assumeShallow(clientShallowCommits);\n        }\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n        } else {\n            walk.reset();\n            ObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n            rw \u003d ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId \u003d ref.getObjectId();\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj \u003d rw.lookupOrNull(objectId);\n                    if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref \u003d db.peel(ref);\n                ObjectId peeledId \u003d ref.getPeeledObjectId();\n                if (peeledId \u003d\u003d null)\n                    continue;\n                objectId \u003d ref.getObjectId();\n                if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n                    pw.addObject(rw.parseAny(objectId));\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        if (msgOut !\u003d NullOutputStream.INSTANCE) {\n            String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        statistics \u003d pw.getStatistics();\n        if (statistics !\u003d null) {\n            postUploadHook.onPostUpload(statistics);\n            logger.onPackStatistics(new PackWriter.Statistics(statistics));\n        }\n        pw.close();\n    }\n    if (sideband)\n        pckOut.end();\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
      "functionStartLine": 1448,
      "functionName": "sendPack",
      "functionAnnotation": "@SuppressWarnings(\"deprecation\")",
      "functionDoc": "",
      "diff": "@@ -1,107 +1,107 @@\n @SuppressWarnings(\"deprecation\")\n private void sendPack(final boolean sideband) throws IOException {\n     ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n     OutputStream packOut \u003d rawOut;\n     if (sideband) {\n         int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n         if (options.contains(OPTION_SIDE_BAND_64K))\n             bufsz \u003d SideBandOutputStream.MAX_BUF;\n         packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n         if (!options.contains(OPTION_NO_PROGRESS)) {\n             msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n             pm \u003d new SideBandProgressMonitor(msgOut);\n         }\n     }\n     try {\n         if (wantAll.isEmpty()) {\n             preUploadHook.onSendPack(this, wantIds, commonBase);\n         } else {\n             preUploadHook.onSendPack(this, wantAll, commonBase);\n         }\n         msgOut.flush();\n     } catch (ServiceMayNotContinueException noPack) {\n         if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n             noPack.setOutput();\n             @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n             err.write(Constants.encode(noPack.getMessage()));\n             err.flush();\n         }\n         throw noPack;\n     }\n     PackConfig cfg \u003d packConfig;\n     if (cfg \u003d\u003d null)\n         cfg \u003d new PackConfig(db);\n     final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n     try {\n         pw.setIndexDisabled(true);\n         pw.setUseCachedPacks(true);\n         pw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n         pw.setClientShallowCommits(clientShallowCommits);\n         pw.setReuseDeltaCommits(true);\n         pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n         pw.setThin(options.contains(OPTION_THIN_PACK));\n         pw.setReuseValidatingObjects(false);\n         if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n             Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003c\u003e();\n             for (Ref ref : refs.values()) {\n                 if (ref.getPeeledObjectId() !\u003d null)\n                     tagTargets.add(ref.getPeeledObjectId());\n                 else if (ref.getObjectId() \u003d\u003d null)\n                     continue;\n                 else if (ref.getName().startsWith(Constants.R_HEADS))\n                     tagTargets.add(ref.getObjectId());\n             }\n             pw.setTagTargets(tagTargets);\n         }\n         RevWalk rw \u003d walk;\n         if (depth \u003e 0) {\n             pw.setShallowPack(depth, unshallowCommits);\n             rw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n             rw.assumeShallow(clientShallowCommits);\n         }\n         if (wantAll.isEmpty()) {\n             pw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n         } else {\n             walk.reset();\n             ObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n-            pw.preparePack(pm, ow, wantAll, commonBase);\n+            pw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n             rw \u003d ow;\n         }\n         if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n             for (Ref ref : refs.values()) {\n                 ObjectId objectId \u003d ref.getObjectId();\n                 if (wantAll.isEmpty()) {\n                     if (wantIds.contains(objectId))\n                         continue;\n                 } else {\n                     RevObject obj \u003d rw.lookupOrNull(objectId);\n                     if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                         continue;\n                 }\n                 if (!ref.isPeeled())\n                     ref \u003d db.peel(ref);\n                 ObjectId peeledId \u003d ref.getPeeledObjectId();\n                 if (peeledId \u003d\u003d null)\n                     continue;\n                 objectId \u003d ref.getObjectId();\n                 if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n                     pw.addObject(rw.parseAny(objectId));\n             }\n         }\n         pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n         if (msgOut !\u003d NullOutputStream.INSTANCE) {\n             String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n             msgOut.write(Constants.encode(msg));\n             msgOut.flush();\n         }\n     } finally {\n         statistics \u003d pw.getStatistics();\n         if (statistics !\u003d null) {\n             postUploadHook.onPostUpload(statistics);\n             logger.onPackStatistics(new PackWriter.Statistics(statistics));\n         }\n         pw.close();\n     }\n     if (sideband)\n         pckOut.end();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3b4448637fbb9d74e0c9d44048ba76bb7c1214ce": {
      "type": "Ybodychange",
      "commitMessage": "Enable and fix warnings about redundant specification of type arguments\n\nSince the introduction of generic type parameter inference in Java 7,\nit\u0027s not necessary to explicitly specify the type of generic parameters.\n\nEnable the warning in Eclipse, and fix all occurrences.\n\nChange-Id: I9158caf1beca5e4980b6240ac401f3868520aad0\nSigned-off-by: David Pursehouse \u003cdavid.pursehouse@gmail.com\u003e\n",
      "commitDate": "2017/2/21 上午5:47",
      "commitName": "3b4448637fbb9d74e0c9d44048ba76bb7c1214ce",
      "commitAuthor": "David Pursehouse",
      "commitDateOld": "2017/2/20 上午8:05",
      "commitNameOld": "7ac182f4e427e0d5a986b8ca67a56fc22828b1a0",
      "commitAuthorOld": "David Pursehouse",
      "daysBetweenCommits": 0.9,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"deprecation\")\nprivate void sendPack(final boolean sideband) throws IOException {\n    ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n    OutputStream packOut \u003d rawOut;\n    if (sideband) {\n        int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz \u003d SideBandOutputStream.MAX_BUF;\n        packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm \u003d new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n        msgOut.flush();\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n            noPack.setOutput();\n            @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg \u003d packConfig;\n    if (cfg \u003d\u003d null)\n        cfg \u003d new PackConfig(db);\n    final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n    try {\n        pw.setIndexDisabled(true);\n        pw.setUseCachedPacks(true);\n        pw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n        pw.setClientShallowCommits(clientShallowCommits);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n            Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003c\u003e();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() !\u003d null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() \u003d\u003d null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        RevWalk rw \u003d walk;\n        if (depth \u003e 0) {\n            pw.setShallowPack(depth, unshallowCommits);\n            rw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n            rw.assumeShallow(clientShallowCommits);\n        }\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n        } else {\n            walk.reset();\n            ObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase);\n            rw \u003d ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId \u003d ref.getObjectId();\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj \u003d rw.lookupOrNull(objectId);\n                    if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref \u003d db.peel(ref);\n                ObjectId peeledId \u003d ref.getPeeledObjectId();\n                if (peeledId \u003d\u003d null)\n                    continue;\n                objectId \u003d ref.getObjectId();\n                if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n                    pw.addObject(rw.parseAny(objectId));\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        if (msgOut !\u003d NullOutputStream.INSTANCE) {\n            String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        statistics \u003d pw.getStatistics();\n        if (statistics !\u003d null) {\n            postUploadHook.onPostUpload(statistics);\n            logger.onPackStatistics(new PackWriter.Statistics(statistics));\n        }\n        pw.close();\n    }\n    if (sideband)\n        pckOut.end();\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
      "functionStartLine": 1438,
      "functionName": "sendPack",
      "functionAnnotation": "@SuppressWarnings(\"deprecation\")",
      "functionDoc": "",
      "diff": "@@ -1,107 +1,107 @@\n @SuppressWarnings(\"deprecation\")\n private void sendPack(final boolean sideband) throws IOException {\n     ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n     OutputStream packOut \u003d rawOut;\n     if (sideband) {\n         int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n         if (options.contains(OPTION_SIDE_BAND_64K))\n             bufsz \u003d SideBandOutputStream.MAX_BUF;\n         packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n         if (!options.contains(OPTION_NO_PROGRESS)) {\n             msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n             pm \u003d new SideBandProgressMonitor(msgOut);\n         }\n     }\n     try {\n         if (wantAll.isEmpty()) {\n             preUploadHook.onSendPack(this, wantIds, commonBase);\n         } else {\n             preUploadHook.onSendPack(this, wantAll, commonBase);\n         }\n         msgOut.flush();\n     } catch (ServiceMayNotContinueException noPack) {\n         if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n             noPack.setOutput();\n             @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n             err.write(Constants.encode(noPack.getMessage()));\n             err.flush();\n         }\n         throw noPack;\n     }\n     PackConfig cfg \u003d packConfig;\n     if (cfg \u003d\u003d null)\n         cfg \u003d new PackConfig(db);\n     final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n     try {\n         pw.setIndexDisabled(true);\n         pw.setUseCachedPacks(true);\n         pw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n         pw.setClientShallowCommits(clientShallowCommits);\n         pw.setReuseDeltaCommits(true);\n         pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n         pw.setThin(options.contains(OPTION_THIN_PACK));\n         pw.setReuseValidatingObjects(false);\n         if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n-            Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n+            Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003c\u003e();\n             for (Ref ref : refs.values()) {\n                 if (ref.getPeeledObjectId() !\u003d null)\n                     tagTargets.add(ref.getPeeledObjectId());\n                 else if (ref.getObjectId() \u003d\u003d null)\n                     continue;\n                 else if (ref.getName().startsWith(Constants.R_HEADS))\n                     tagTargets.add(ref.getObjectId());\n             }\n             pw.setTagTargets(tagTargets);\n         }\n         RevWalk rw \u003d walk;\n         if (depth \u003e 0) {\n             pw.setShallowPack(depth, unshallowCommits);\n             rw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n             rw.assumeShallow(clientShallowCommits);\n         }\n         if (wantAll.isEmpty()) {\n             pw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n         } else {\n             walk.reset();\n             ObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n             pw.preparePack(pm, ow, wantAll, commonBase);\n             rw \u003d ow;\n         }\n         if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n             for (Ref ref : refs.values()) {\n                 ObjectId objectId \u003d ref.getObjectId();\n                 if (wantAll.isEmpty()) {\n                     if (wantIds.contains(objectId))\n                         continue;\n                 } else {\n                     RevObject obj \u003d rw.lookupOrNull(objectId);\n                     if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                         continue;\n                 }\n                 if (!ref.isPeeled())\n                     ref \u003d db.peel(ref);\n                 ObjectId peeledId \u003d ref.getPeeledObjectId();\n                 if (peeledId \u003d\u003d null)\n                     continue;\n                 objectId \u003d ref.getObjectId();\n                 if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n                     pw.addObject(rw.parseAny(objectId));\n             }\n         }\n         pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n         if (msgOut !\u003d NullOutputStream.INSTANCE) {\n             String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n             msgOut.write(Constants.encode(msg));\n             msgOut.flush();\n         }\n     } finally {\n         statistics \u003d pw.getStatistics();\n         if (statistics !\u003d null) {\n             postUploadHook.onPostUpload(statistics);\n             logger.onPackStatistics(new PackWriter.Statistics(statistics));\n         }\n         pw.close();\n     }\n     if (sideband)\n         pckOut.end();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "01935f8f50699db09e9e6f4e725913b907d7cbd5": {
      "type": "Yannotationchange",
      "commitMessage": "Suppress deprecation warnings related to UploadPackLogger\n\nUploadPackLogger is deprecated but will not be removed until\nJGit version 5.0.\n\nSuppress the unavoidable deprecation warnings on usages of the\ninterface that are kept for backwards compatibility.\n\nAdd a TODO so that we don\u0027t forget to remove it in 5.0.\n\nChange-Id: Id248002b9bdf23db192427196d54c722a012106c\nSigned-off-by: David Pursehouse \u003cdavid.pursehouse@gmail.com\u003e\n",
      "commitDate": "2016/9/22 下午3:46",
      "commitName": "01935f8f50699db09e9e6f4e725913b907d7cbd5",
      "commitAuthor": "David Pursehouse",
      "commitDateOld": "2016/8/9 上午4:50",
      "commitNameOld": "3b0b7677fffa1fe826485f383e6b724703742d08",
      "commitAuthorOld": "",
      "daysBetweenCommits": 44.46,
      "commitsBetweenForRepo": 65,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"deprecation\")\nprivate void sendPack(final boolean sideband) throws IOException {\n    ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n    OutputStream packOut \u003d rawOut;\n    if (sideband) {\n        int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz \u003d SideBandOutputStream.MAX_BUF;\n        packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm \u003d new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n        msgOut.flush();\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n            noPack.setOutput();\n            @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg \u003d packConfig;\n    if (cfg \u003d\u003d null)\n        cfg \u003d new PackConfig(db);\n    final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n    try {\n        pw.setIndexDisabled(true);\n        pw.setUseCachedPacks(true);\n        pw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n        pw.setClientShallowCommits(clientShallowCommits);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n            Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() !\u003d null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() \u003d\u003d null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        RevWalk rw \u003d walk;\n        if (depth \u003e 0) {\n            pw.setShallowPack(depth, unshallowCommits);\n            rw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n            rw.assumeShallow(clientShallowCommits);\n        }\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n        } else {\n            walk.reset();\n            ObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase);\n            rw \u003d ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId \u003d ref.getObjectId();\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj \u003d rw.lookupOrNull(objectId);\n                    if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref \u003d db.peel(ref);\n                ObjectId peeledId \u003d ref.getPeeledObjectId();\n                if (peeledId \u003d\u003d null)\n                    continue;\n                objectId \u003d ref.getObjectId();\n                if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n                    pw.addObject(rw.parseAny(objectId));\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        if (msgOut !\u003d NullOutputStream.INSTANCE) {\n            String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        statistics \u003d pw.getStatistics();\n        if (statistics !\u003d null) {\n            postUploadHook.onPostUpload(statistics);\n            logger.onPackStatistics(new PackWriter.Statistics(statistics));\n        }\n        pw.close();\n    }\n    if (sideband)\n        pckOut.end();\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
      "functionStartLine": 1433,
      "functionName": "sendPack",
      "functionAnnotation": "@SuppressWarnings(\"deprecation\")",
      "functionDoc": "",
      "diff": "@@ -1,106 +1,107 @@\n+@SuppressWarnings(\"deprecation\")\n private void sendPack(final boolean sideband) throws IOException {\n     ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n     OutputStream packOut \u003d rawOut;\n     if (sideband) {\n         int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n         if (options.contains(OPTION_SIDE_BAND_64K))\n             bufsz \u003d SideBandOutputStream.MAX_BUF;\n         packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n         if (!options.contains(OPTION_NO_PROGRESS)) {\n             msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n             pm \u003d new SideBandProgressMonitor(msgOut);\n         }\n     }\n     try {\n         if (wantAll.isEmpty()) {\n             preUploadHook.onSendPack(this, wantIds, commonBase);\n         } else {\n             preUploadHook.onSendPack(this, wantAll, commonBase);\n         }\n         msgOut.flush();\n     } catch (ServiceMayNotContinueException noPack) {\n         if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n             noPack.setOutput();\n             @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n             err.write(Constants.encode(noPack.getMessage()));\n             err.flush();\n         }\n         throw noPack;\n     }\n     PackConfig cfg \u003d packConfig;\n     if (cfg \u003d\u003d null)\n         cfg \u003d new PackConfig(db);\n     final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n     try {\n         pw.setIndexDisabled(true);\n         pw.setUseCachedPacks(true);\n         pw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n         pw.setClientShallowCommits(clientShallowCommits);\n         pw.setReuseDeltaCommits(true);\n         pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n         pw.setThin(options.contains(OPTION_THIN_PACK));\n         pw.setReuseValidatingObjects(false);\n         if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n             Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n             for (Ref ref : refs.values()) {\n                 if (ref.getPeeledObjectId() !\u003d null)\n                     tagTargets.add(ref.getPeeledObjectId());\n                 else if (ref.getObjectId() \u003d\u003d null)\n                     continue;\n                 else if (ref.getName().startsWith(Constants.R_HEADS))\n                     tagTargets.add(ref.getObjectId());\n             }\n             pw.setTagTargets(tagTargets);\n         }\n         RevWalk rw \u003d walk;\n         if (depth \u003e 0) {\n             pw.setShallowPack(depth, unshallowCommits);\n             rw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n             rw.assumeShallow(clientShallowCommits);\n         }\n         if (wantAll.isEmpty()) {\n             pw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n         } else {\n             walk.reset();\n             ObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n             pw.preparePack(pm, ow, wantAll, commonBase);\n             rw \u003d ow;\n         }\n         if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n             for (Ref ref : refs.values()) {\n                 ObjectId objectId \u003d ref.getObjectId();\n                 if (wantAll.isEmpty()) {\n                     if (wantIds.contains(objectId))\n                         continue;\n                 } else {\n                     RevObject obj \u003d rw.lookupOrNull(objectId);\n                     if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                         continue;\n                 }\n                 if (!ref.isPeeled())\n                     ref \u003d db.peel(ref);\n                 ObjectId peeledId \u003d ref.getPeeledObjectId();\n                 if (peeledId \u003d\u003d null)\n                     continue;\n                 objectId \u003d ref.getObjectId();\n                 if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n                     pw.addObject(rw.parseAny(objectId));\n             }\n         }\n         pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n         if (msgOut !\u003d NullOutputStream.INSTANCE) {\n             String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n             msgOut.write(Constants.encode(msg));\n             msgOut.flush();\n         }\n     } finally {\n         statistics \u003d pw.getStatistics();\n         if (statistics !\u003d null) {\n             postUploadHook.onPostUpload(statistics);\n             logger.onPackStatistics(new PackWriter.Statistics(statistics));\n         }\n         pw.close();\n     }\n     if (sideband)\n         pckOut.end();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "",
        "newValue": "@SuppressWarnings(\"deprecation\")"
      }
    },
    "b16e207742beb6a82b2b74df7bb87893a38bdd04": {
      "type": "Ybodychange",
      "commitMessage": "Shallow fetch: Pass along \"shallow\"s in unparsed-wants case, too\n\nSince 84d2738ff21c (Don\u0027t skip want validation when the client sends no\nhaves, 2013-06-21), this branch is not taken.  Process the\n\"shallow\"s anyway as a defensive measure in case the code path gets\nrevived.\n\nChange-Id: Idfb834825d77f51e17191c1635c9d78c78738cfd\nSigned-off-by: Jonathan Nieder \u003cjrn@google.com\u003e\n",
      "commitDate": "2016/8/9 上午4:49",
      "commitName": "b16e207742beb6a82b2b74df7bb87893a38bdd04",
      "commitAuthor": "Jonathan Nieder",
      "commitDateOld": "2016/8/9 上午4:48",
      "commitNameOld": "f84370feaaf319b7fe9bd272a7ceba235cc1e86a",
      "commitAuthorOld": "Jonathan Nieder",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private void sendPack(final boolean sideband) throws IOException {\n    ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n    OutputStream packOut \u003d rawOut;\n    if (sideband) {\n        int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz \u003d SideBandOutputStream.MAX_BUF;\n        packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm \u003d new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n        msgOut.flush();\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n            noPack.setOutput();\n            @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg \u003d packConfig;\n    if (cfg \u003d\u003d null)\n        cfg \u003d new PackConfig(db);\n    final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n    try {\n        pw.setIndexDisabled(true);\n        pw.setUseCachedPacks(true);\n        pw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n        pw.setClientShallowCommits(clientShallowCommits);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n            Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() !\u003d null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() \u003d\u003d null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        RevWalk rw \u003d walk;\n        if (depth \u003e 0) {\n            pw.setShallowPack(depth, unshallowCommits);\n            rw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth);\n            rw.assumeShallow(clientShallowCommits);\n        }\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n        } else {\n            walk.reset();\n            ObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase);\n            rw \u003d ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId \u003d ref.getObjectId();\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj \u003d rw.lookupOrNull(objectId);\n                    if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref \u003d db.peel(ref);\n                ObjectId peeledId \u003d ref.getPeeledObjectId();\n                if (peeledId \u003d\u003d null)\n                    continue;\n                objectId \u003d ref.getObjectId();\n                if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n                    pw.addObject(rw.parseAny(objectId));\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        if (msgOut !\u003d NullOutputStream.INSTANCE) {\n            String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        statistics \u003d pw.getStatistics();\n        if (statistics !\u003d null) {\n            postUploadHook.onPostUpload(statistics);\n            logger.onPackStatistics(new PackWriter.Statistics(statistics));\n        }\n        pw.close();\n    }\n    if (sideband)\n        pckOut.end();\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
      "functionStartLine": 1422,
      "functionName": "sendPack",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,106 +1,106 @@\n private void sendPack(final boolean sideband) throws IOException {\n     ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n     OutputStream packOut \u003d rawOut;\n     if (sideband) {\n         int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n         if (options.contains(OPTION_SIDE_BAND_64K))\n             bufsz \u003d SideBandOutputStream.MAX_BUF;\n         packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n         if (!options.contains(OPTION_NO_PROGRESS)) {\n             msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n             pm \u003d new SideBandProgressMonitor(msgOut);\n         }\n     }\n     try {\n         if (wantAll.isEmpty()) {\n             preUploadHook.onSendPack(this, wantIds, commonBase);\n         } else {\n             preUploadHook.onSendPack(this, wantAll, commonBase);\n         }\n         msgOut.flush();\n     } catch (ServiceMayNotContinueException noPack) {\n         if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n             noPack.setOutput();\n             @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n             err.write(Constants.encode(noPack.getMessage()));\n             err.flush();\n         }\n         throw noPack;\n     }\n     PackConfig cfg \u003d packConfig;\n     if (cfg \u003d\u003d null)\n         cfg \u003d new PackConfig(db);\n     final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n     try {\n         pw.setIndexDisabled(true);\n         pw.setUseCachedPacks(true);\n         pw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n         pw.setClientShallowCommits(clientShallowCommits);\n         pw.setReuseDeltaCommits(true);\n         pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n         pw.setThin(options.contains(OPTION_THIN_PACK));\n         pw.setReuseValidatingObjects(false);\n         if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n             Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n             for (Ref ref : refs.values()) {\n                 if (ref.getPeeledObjectId() !\u003d null)\n                     tagTargets.add(ref.getPeeledObjectId());\n                 else if (ref.getObjectId() \u003d\u003d null)\n                     continue;\n                 else if (ref.getName().startsWith(Constants.R_HEADS))\n                     tagTargets.add(ref.getObjectId());\n             }\n             pw.setTagTargets(tagTargets);\n         }\n         RevWalk rw \u003d walk;\n         if (depth \u003e 0) {\n             pw.setShallowPack(depth, unshallowCommits);\n             rw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth);\n             rw.assumeShallow(clientShallowCommits);\n         }\n         if (wantAll.isEmpty()) {\n-            pw.preparePack(pm, wantIds, commonBase);\n+            pw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n         } else {\n             walk.reset();\n             ObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n             pw.preparePack(pm, ow, wantAll, commonBase);\n             rw \u003d ow;\n         }\n         if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n             for (Ref ref : refs.values()) {\n                 ObjectId objectId \u003d ref.getObjectId();\n                 if (wantAll.isEmpty()) {\n                     if (wantIds.contains(objectId))\n                         continue;\n                 } else {\n                     RevObject obj \u003d rw.lookupOrNull(objectId);\n                     if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                         continue;\n                 }\n                 if (!ref.isPeeled())\n                     ref \u003d db.peel(ref);\n                 ObjectId peeledId \u003d ref.getPeeledObjectId();\n                 if (peeledId \u003d\u003d null)\n                     continue;\n                 objectId \u003d ref.getObjectId();\n                 if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n                     pw.addObject(rw.parseAny(objectId));\n             }\n         }\n         pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n         if (msgOut !\u003d NullOutputStream.INSTANCE) {\n             String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n             msgOut.write(Constants.encode(msg));\n             msgOut.flush();\n         }\n     } finally {\n         statistics \u003d pw.getStatistics();\n         if (statistics !\u003d null) {\n             postUploadHook.onPostUpload(statistics);\n             logger.onPackStatistics(new PackWriter.Statistics(statistics));\n         }\n         pw.close();\n     }\n     if (sideband)\n         pckOut.end();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f84370feaaf319b7fe9bd272a7ceba235cc1e86a": {
      "type": "Ybodychange",
      "commitMessage": "Shallow fetch: Pass a DepthWalk to PackWriter\n\nd385a7a5e5ca (Shallow fetch: Respect \"shallow\" lines, 2016-08-03) forgot\nthat UploadPack wasn\u0027t passing a DepthWalk to PackWriter in the first\nplace.  As a result, shallow clones fail:\n\n  java.lang.IllegalArgumentException: Shallow packs require a DepthWalk\n        at org.eclipse.jgit.internal.storage.pack.PackWriter.preparePack(PackWriter.java:756)\n        at org.eclipse.jgit.transport.UploadPack.sendPack(UploadPack.java:1497)\n        at org.eclipse.jgit.transport.UploadPack.sendPack(UploadPack.java:1381)\n        at org.eclipse.jgit.transport.UploadPack.service(UploadPack.java:774)\n        at org.eclipse.jgit.transport.UploadPack.upload(UploadPack.java:667)\n        at org.eclipse.jgit.http.server.UploadPackServlet.doPost(UploadPackServlet.java:191)\n\nChange-Id: Ib0d8c2946eebfea910a2b767fb92e23da15d4749\n",
      "commitDate": "2016/8/9 上午4:48",
      "commitName": "f84370feaaf319b7fe9bd272a7ceba235cc1e86a",
      "commitAuthor": "Jonathan Nieder",
      "commitDateOld": "2016/7/6 上午12:18",
      "commitNameOld": "5196798cb743aa9e9a0e7d92c64e9c930656acaa",
      "commitAuthorOld": "Shawn Pearce",
      "daysBetweenCommits": 34.19,
      "commitsBetweenForRepo": 42,
      "commitsBetweenForFile": 1,
      "actualSource": "private void sendPack(final boolean sideband) throws IOException {\n    ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n    OutputStream packOut \u003d rawOut;\n    if (sideband) {\n        int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz \u003d SideBandOutputStream.MAX_BUF;\n        packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm \u003d new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n        msgOut.flush();\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n            noPack.setOutput();\n            @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg \u003d packConfig;\n    if (cfg \u003d\u003d null)\n        cfg \u003d new PackConfig(db);\n    final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n    try {\n        pw.setIndexDisabled(true);\n        pw.setUseCachedPacks(true);\n        pw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n        pw.setClientShallowCommits(clientShallowCommits);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n            Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() !\u003d null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() \u003d\u003d null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        RevWalk rw \u003d walk;\n        if (depth \u003e 0) {\n            pw.setShallowPack(depth, unshallowCommits);\n            rw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth);\n            rw.assumeShallow(clientShallowCommits);\n        }\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase);\n        } else {\n            walk.reset();\n            ObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase);\n            rw \u003d ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId \u003d ref.getObjectId();\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj \u003d rw.lookupOrNull(objectId);\n                    if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref \u003d db.peel(ref);\n                ObjectId peeledId \u003d ref.getPeeledObjectId();\n                if (peeledId \u003d\u003d null)\n                    continue;\n                objectId \u003d ref.getObjectId();\n                if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n                    pw.addObject(rw.parseAny(objectId));\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        if (msgOut !\u003d NullOutputStream.INSTANCE) {\n            String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        statistics \u003d pw.getStatistics();\n        if (statistics !\u003d null) {\n            postUploadHook.onPostUpload(statistics);\n            logger.onPackStatistics(new PackWriter.Statistics(statistics));\n        }\n        pw.close();\n    }\n    if (sideband)\n        pckOut.end();\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
      "functionStartLine": 1422,
      "functionName": "sendPack",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,103 +1,106 @@\n private void sendPack(final boolean sideband) throws IOException {\n     ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n     OutputStream packOut \u003d rawOut;\n     if (sideband) {\n         int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n         if (options.contains(OPTION_SIDE_BAND_64K))\n             bufsz \u003d SideBandOutputStream.MAX_BUF;\n         packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n         if (!options.contains(OPTION_NO_PROGRESS)) {\n             msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n             pm \u003d new SideBandProgressMonitor(msgOut);\n         }\n     }\n     try {\n         if (wantAll.isEmpty()) {\n             preUploadHook.onSendPack(this, wantIds, commonBase);\n         } else {\n             preUploadHook.onSendPack(this, wantAll, commonBase);\n         }\n         msgOut.flush();\n     } catch (ServiceMayNotContinueException noPack) {\n         if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n             noPack.setOutput();\n             @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n             err.write(Constants.encode(noPack.getMessage()));\n             err.flush();\n         }\n         throw noPack;\n     }\n     PackConfig cfg \u003d packConfig;\n     if (cfg \u003d\u003d null)\n         cfg \u003d new PackConfig(db);\n     final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n     try {\n         pw.setIndexDisabled(true);\n         pw.setUseCachedPacks(true);\n         pw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n         pw.setClientShallowCommits(clientShallowCommits);\n         pw.setReuseDeltaCommits(true);\n         pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n         pw.setThin(options.contains(OPTION_THIN_PACK));\n         pw.setReuseValidatingObjects(false);\n         if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n             Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n             for (Ref ref : refs.values()) {\n                 if (ref.getPeeledObjectId() !\u003d null)\n                     tagTargets.add(ref.getPeeledObjectId());\n                 else if (ref.getObjectId() \u003d\u003d null)\n                     continue;\n                 else if (ref.getName().startsWith(Constants.R_HEADS))\n                     tagTargets.add(ref.getObjectId());\n             }\n             pw.setTagTargets(tagTargets);\n         }\n-        if (depth \u003e 0)\n-            pw.setShallowPack(depth, unshallowCommits);\n         RevWalk rw \u003d walk;\n+        if (depth \u003e 0) {\n+            pw.setShallowPack(depth, unshallowCommits);\n+            rw \u003d new DepthWalk.RevWalk(walk.getObjectReader(), depth);\n+            rw.assumeShallow(clientShallowCommits);\n+        }\n         if (wantAll.isEmpty()) {\n             pw.preparePack(pm, wantIds, commonBase);\n         } else {\n             walk.reset();\n-            ObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n+            ObjectWalk ow \u003d rw.toObjectWalkWithSameObjects();\n             pw.preparePack(pm, ow, wantAll, commonBase);\n             rw \u003d ow;\n         }\n         if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n             for (Ref ref : refs.values()) {\n                 ObjectId objectId \u003d ref.getObjectId();\n                 if (wantAll.isEmpty()) {\n                     if (wantIds.contains(objectId))\n                         continue;\n                 } else {\n                     RevObject obj \u003d rw.lookupOrNull(objectId);\n                     if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                         continue;\n                 }\n                 if (!ref.isPeeled())\n                     ref \u003d db.peel(ref);\n                 ObjectId peeledId \u003d ref.getPeeledObjectId();\n                 if (peeledId \u003d\u003d null)\n                     continue;\n                 objectId \u003d ref.getObjectId();\n                 if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n                     pw.addObject(rw.parseAny(objectId));\n             }\n         }\n         pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n         if (msgOut !\u003d NullOutputStream.INSTANCE) {\n             String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n             msgOut.write(Constants.encode(msg));\n             msgOut.flush();\n         }\n     } finally {\n         statistics \u003d pw.getStatistics();\n         if (statistics !\u003d null) {\n             postUploadHook.onPostUpload(statistics);\n             logger.onPackStatistics(new PackWriter.Statistics(statistics));\n         }\n         pw.close();\n     }\n     if (sideband)\n         pckOut.end();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1fa6f3a7509dc937551006e11dfd3bdaea921cd0": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"Remove PackWriter.Statistics and other deprecated classes\"\n\nThis reverts commit bbcbcab8d39dd4bdf194cdba02c97a9eb70b2379.\nThese classes were part of the public API and should not be removed\nuntil JGit 5.0.\n\nChange-Id: Ife4bee69f82151de6ef8ea1a4c6c146d91bbf0d5\n",
      "commitDate": "2015/11/11 上午9:14",
      "commitName": "1fa6f3a7509dc937551006e11dfd3bdaea921cd0",
      "commitAuthor": "Jonathan Nieder",
      "commitDateOld": "2015/11/10 上午10:55",
      "commitNameOld": "bbcbcab8d39dd4bdf194cdba02c97a9eb70b2379",
      "commitAuthorOld": "Terry Parker",
      "daysBetweenCommits": 0.93,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private void sendPack(final boolean sideband) throws IOException {\n    ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n    OutputStream packOut \u003d rawOut;\n    if (sideband) {\n        int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz \u003d SideBandOutputStream.MAX_BUF;\n        packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm \u003d new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n        msgOut.flush();\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n            noPack.setOutput();\n            @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg \u003d packConfig;\n    if (cfg \u003d\u003d null)\n        cfg \u003d new PackConfig(db);\n    final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n    try {\n        pw.setIndexDisabled(true);\n        pw.setUseCachedPacks(true);\n        pw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n        pw.setClientShallowCommits(clientShallowCommits);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n            Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() !\u003d null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() \u003d\u003d null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        if (depth \u003e 0)\n            pw.setShallowPack(depth, unshallowCommits);\n        RevWalk rw \u003d walk;\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase);\n        } else {\n            walk.reset();\n            ObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase);\n            rw \u003d ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId \u003d ref.getObjectId();\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj \u003d rw.lookupOrNull(objectId);\n                    if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref \u003d db.peel(ref);\n                ObjectId peeledId \u003d ref.getPeeledObjectId();\n                if (peeledId \u003d\u003d null)\n                    continue;\n                objectId \u003d ref.getObjectId();\n                if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n                    pw.addObject(rw.parseAny(objectId));\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        if (msgOut !\u003d NullOutputStream.INSTANCE) {\n            String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        statistics \u003d pw.getStatistics();\n        if (statistics !\u003d null) {\n            postUploadHook.onPostUpload(statistics);\n            logger.onPackStatistics(new PackWriter.Statistics(statistics));\n        }\n        pw.close();\n    }\n    if (sideband)\n        pckOut.end();\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
      "functionStartLine": 1432,
      "functionName": "sendPack",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,102 +1,103 @@\n private void sendPack(final boolean sideband) throws IOException {\n     ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n     OutputStream packOut \u003d rawOut;\n     if (sideband) {\n         int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n         if (options.contains(OPTION_SIDE_BAND_64K))\n             bufsz \u003d SideBandOutputStream.MAX_BUF;\n         packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n         if (!options.contains(OPTION_NO_PROGRESS)) {\n             msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n             pm \u003d new SideBandProgressMonitor(msgOut);\n         }\n     }\n     try {\n         if (wantAll.isEmpty()) {\n             preUploadHook.onSendPack(this, wantIds, commonBase);\n         } else {\n             preUploadHook.onSendPack(this, wantAll, commonBase);\n         }\n         msgOut.flush();\n     } catch (ServiceMayNotContinueException noPack) {\n         if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n             noPack.setOutput();\n             @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n             err.write(Constants.encode(noPack.getMessage()));\n             err.flush();\n         }\n         throw noPack;\n     }\n     PackConfig cfg \u003d packConfig;\n     if (cfg \u003d\u003d null)\n         cfg \u003d new PackConfig(db);\n     final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n     try {\n         pw.setIndexDisabled(true);\n         pw.setUseCachedPacks(true);\n         pw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n         pw.setClientShallowCommits(clientShallowCommits);\n         pw.setReuseDeltaCommits(true);\n         pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n         pw.setThin(options.contains(OPTION_THIN_PACK));\n         pw.setReuseValidatingObjects(false);\n         if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n             Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n             for (Ref ref : refs.values()) {\n                 if (ref.getPeeledObjectId() !\u003d null)\n                     tagTargets.add(ref.getPeeledObjectId());\n                 else if (ref.getObjectId() \u003d\u003d null)\n                     continue;\n                 else if (ref.getName().startsWith(Constants.R_HEADS))\n                     tagTargets.add(ref.getObjectId());\n             }\n             pw.setTagTargets(tagTargets);\n         }\n         if (depth \u003e 0)\n             pw.setShallowPack(depth, unshallowCommits);\n         RevWalk rw \u003d walk;\n         if (wantAll.isEmpty()) {\n             pw.preparePack(pm, wantIds, commonBase);\n         } else {\n             walk.reset();\n             ObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n             pw.preparePack(pm, ow, wantAll, commonBase);\n             rw \u003d ow;\n         }\n         if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n             for (Ref ref : refs.values()) {\n                 ObjectId objectId \u003d ref.getObjectId();\n                 if (wantAll.isEmpty()) {\n                     if (wantIds.contains(objectId))\n                         continue;\n                 } else {\n                     RevObject obj \u003d rw.lookupOrNull(objectId);\n                     if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                         continue;\n                 }\n                 if (!ref.isPeeled())\n                     ref \u003d db.peel(ref);\n                 ObjectId peeledId \u003d ref.getPeeledObjectId();\n                 if (peeledId \u003d\u003d null)\n                     continue;\n                 objectId \u003d ref.getObjectId();\n                 if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n                     pw.addObject(rw.parseAny(objectId));\n             }\n         }\n         pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n         if (msgOut !\u003d NullOutputStream.INSTANCE) {\n             String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n             msgOut.write(Constants.encode(msg));\n             msgOut.flush();\n         }\n     } finally {\n         statistics \u003d pw.getStatistics();\n         if (statistics !\u003d null) {\n             postUploadHook.onPostUpload(statistics);\n+            logger.onPackStatistics(new PackWriter.Statistics(statistics));\n         }\n         pw.close();\n     }\n     if (sideband)\n         pckOut.end();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "bbcbcab8d39dd4bdf194cdba02c97a9eb70b2379": {
      "type": "Ybodychange",
      "commitMessage": "Remove PackWriter.Statistics and other deprecated classes\n\nThese classes make improper use of internal classes in the public API\nand were replaced by corresponding classes in the JGit 4.1 release.\n\nChange-Id: I3d474210e49089aa788314b4e08f505f0d26619b\nSigned-off-by: Terry Parker \u003ctparker@google.com\u003e\n",
      "commitDate": "2015/11/10 上午10:55",
      "commitName": "bbcbcab8d39dd4bdf194cdba02c97a9eb70b2379",
      "commitAuthor": "Terry Parker",
      "commitDateOld": "2015/9/15 上午3:53",
      "commitNameOld": "b46c4463959f45b32e471e4c10b5ddc71232949e",
      "commitAuthorOld": "Shawn Pearce",
      "daysBetweenCommits": 56.29,
      "commitsBetweenForRepo": 84,
      "commitsBetweenForFile": 1,
      "actualSource": "private void sendPack(final boolean sideband) throws IOException {\n    ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n    OutputStream packOut \u003d rawOut;\n    if (sideband) {\n        int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz \u003d SideBandOutputStream.MAX_BUF;\n        packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm \u003d new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n        msgOut.flush();\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n            noPack.setOutput();\n            @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg \u003d packConfig;\n    if (cfg \u003d\u003d null)\n        cfg \u003d new PackConfig(db);\n    final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n    try {\n        pw.setIndexDisabled(true);\n        pw.setUseCachedPacks(true);\n        pw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n        pw.setClientShallowCommits(clientShallowCommits);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n            Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() !\u003d null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() \u003d\u003d null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        if (depth \u003e 0)\n            pw.setShallowPack(depth, unshallowCommits);\n        RevWalk rw \u003d walk;\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase);\n        } else {\n            walk.reset();\n            ObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase);\n            rw \u003d ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId \u003d ref.getObjectId();\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj \u003d rw.lookupOrNull(objectId);\n                    if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref \u003d db.peel(ref);\n                ObjectId peeledId \u003d ref.getPeeledObjectId();\n                if (peeledId \u003d\u003d null)\n                    continue;\n                objectId \u003d ref.getObjectId();\n                if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n                    pw.addObject(rw.parseAny(objectId));\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        if (msgOut !\u003d NullOutputStream.INSTANCE) {\n            String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        statistics \u003d pw.getStatistics();\n        if (statistics !\u003d null) {\n            postUploadHook.onPostUpload(statistics);\n        }\n        pw.close();\n    }\n    if (sideband)\n        pckOut.end();\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
      "functionStartLine": 1393,
      "functionName": "sendPack",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,103 +1,102 @@\n private void sendPack(final boolean sideband) throws IOException {\n     ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n     OutputStream packOut \u003d rawOut;\n     if (sideband) {\n         int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n         if (options.contains(OPTION_SIDE_BAND_64K))\n             bufsz \u003d SideBandOutputStream.MAX_BUF;\n         packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n         if (!options.contains(OPTION_NO_PROGRESS)) {\n             msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n             pm \u003d new SideBandProgressMonitor(msgOut);\n         }\n     }\n     try {\n         if (wantAll.isEmpty()) {\n             preUploadHook.onSendPack(this, wantIds, commonBase);\n         } else {\n             preUploadHook.onSendPack(this, wantAll, commonBase);\n         }\n         msgOut.flush();\n     } catch (ServiceMayNotContinueException noPack) {\n         if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n             noPack.setOutput();\n             @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n             err.write(Constants.encode(noPack.getMessage()));\n             err.flush();\n         }\n         throw noPack;\n     }\n     PackConfig cfg \u003d packConfig;\n     if (cfg \u003d\u003d null)\n         cfg \u003d new PackConfig(db);\n     final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n     try {\n         pw.setIndexDisabled(true);\n         pw.setUseCachedPacks(true);\n         pw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n         pw.setClientShallowCommits(clientShallowCommits);\n         pw.setReuseDeltaCommits(true);\n         pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n         pw.setThin(options.contains(OPTION_THIN_PACK));\n         pw.setReuseValidatingObjects(false);\n         if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n             Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n             for (Ref ref : refs.values()) {\n                 if (ref.getPeeledObjectId() !\u003d null)\n                     tagTargets.add(ref.getPeeledObjectId());\n                 else if (ref.getObjectId() \u003d\u003d null)\n                     continue;\n                 else if (ref.getName().startsWith(Constants.R_HEADS))\n                     tagTargets.add(ref.getObjectId());\n             }\n             pw.setTagTargets(tagTargets);\n         }\n         if (depth \u003e 0)\n             pw.setShallowPack(depth, unshallowCommits);\n         RevWalk rw \u003d walk;\n         if (wantAll.isEmpty()) {\n             pw.preparePack(pm, wantIds, commonBase);\n         } else {\n             walk.reset();\n             ObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n             pw.preparePack(pm, ow, wantAll, commonBase);\n             rw \u003d ow;\n         }\n         if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n             for (Ref ref : refs.values()) {\n                 ObjectId objectId \u003d ref.getObjectId();\n                 if (wantAll.isEmpty()) {\n                     if (wantIds.contains(objectId))\n                         continue;\n                 } else {\n                     RevObject obj \u003d rw.lookupOrNull(objectId);\n                     if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                         continue;\n                 }\n                 if (!ref.isPeeled())\n                     ref \u003d db.peel(ref);\n                 ObjectId peeledId \u003d ref.getPeeledObjectId();\n                 if (peeledId \u003d\u003d null)\n                     continue;\n                 objectId \u003d ref.getObjectId();\n                 if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n                     pw.addObject(rw.parseAny(objectId));\n             }\n         }\n         pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n         if (msgOut !\u003d NullOutputStream.INSTANCE) {\n             String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n             msgOut.write(Constants.encode(msg));\n             msgOut.flush();\n         }\n     } finally {\n         statistics \u003d pw.getStatistics();\n         if (statistics !\u003d null) {\n             postUploadHook.onPostUpload(statistics);\n-            logger.onPackStatistics(new PackWriter.Statistics(statistics));\n         }\n         pw.close();\n     }\n     if (sideband)\n         pckOut.end();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6a415915c2dab31f9e69b9a55dcb87c579649bf5": {
      "type": "Ybodychange",
      "commitMessage": "Add the set of shallow commits to PackStatistics\n\nChange-Id: I976102e054369b045340d4b9209984b5243e3750\nSigned-off-by: Terry Parker \u003ctparker@google.com\u003e\n",
      "commitDate": "2015/6/16 上午5:49",
      "commitName": "6a415915c2dab31f9e69b9a55dcb87c579649bf5",
      "commitAuthor": "Terry Parker",
      "commitDateOld": "2015/6/13 上午4:56",
      "commitNameOld": "d9bbb04c3ef28db1d2e492506a819b7ac5c5f9df",
      "commitAuthorOld": "Terry Parker",
      "daysBetweenCommits": 3.04,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "private void sendPack(final boolean sideband) throws IOException {\n    ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n    OutputStream packOut \u003d rawOut;\n    if (sideband) {\n        int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz \u003d SideBandOutputStream.MAX_BUF;\n        packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm \u003d new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n        msgOut.flush();\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n            noPack.setOutput();\n            @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg \u003d packConfig;\n    if (cfg \u003d\u003d null)\n        cfg \u003d new PackConfig(db);\n    final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n    try {\n        pw.setIndexDisabled(true);\n        pw.setUseCachedPacks(true);\n        pw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n        pw.setClientShallowCommits(clientShallowCommits);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n            Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() !\u003d null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() \u003d\u003d null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        if (depth \u003e 0)\n            pw.setShallowPack(depth, unshallowCommits);\n        RevWalk rw \u003d walk;\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase);\n        } else {\n            walk.reset();\n            ObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase);\n            rw \u003d ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId \u003d ref.getObjectId();\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj \u003d rw.lookupOrNull(objectId);\n                    if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref \u003d db.peel(ref);\n                ObjectId peeledId \u003d ref.getPeeledObjectId();\n                if (peeledId \u003d\u003d null)\n                    continue;\n                objectId \u003d ref.getObjectId();\n                if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n                    pw.addObject(rw.parseAny(objectId));\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        if (msgOut !\u003d NullOutputStream.INSTANCE) {\n            String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        statistics \u003d pw.getStatistics();\n        if (statistics !\u003d null) {\n            postUploadHook.onPostUpload(statistics);\n            logger.onPackStatistics(new PackWriter.Statistics(statistics));\n        }\n        pw.close();\n    }\n    if (sideband)\n        pckOut.end();\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
      "functionStartLine": 1401,
      "functionName": "sendPack",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,102 +1,103 @@\n private void sendPack(final boolean sideband) throws IOException {\n     ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n     OutputStream packOut \u003d rawOut;\n     if (sideband) {\n         int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n         if (options.contains(OPTION_SIDE_BAND_64K))\n             bufsz \u003d SideBandOutputStream.MAX_BUF;\n         packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n         if (!options.contains(OPTION_NO_PROGRESS)) {\n             msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n             pm \u003d new SideBandProgressMonitor(msgOut);\n         }\n     }\n     try {\n         if (wantAll.isEmpty()) {\n             preUploadHook.onSendPack(this, wantIds, commonBase);\n         } else {\n             preUploadHook.onSendPack(this, wantAll, commonBase);\n         }\n         msgOut.flush();\n     } catch (ServiceMayNotContinueException noPack) {\n         if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n             noPack.setOutput();\n             @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n             err.write(Constants.encode(noPack.getMessage()));\n             err.flush();\n         }\n         throw noPack;\n     }\n     PackConfig cfg \u003d packConfig;\n     if (cfg \u003d\u003d null)\n         cfg \u003d new PackConfig(db);\n     final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n     try {\n         pw.setIndexDisabled(true);\n         pw.setUseCachedPacks(true);\n         pw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n+        pw.setClientShallowCommits(clientShallowCommits);\n         pw.setReuseDeltaCommits(true);\n         pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n         pw.setThin(options.contains(OPTION_THIN_PACK));\n         pw.setReuseValidatingObjects(false);\n         if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n             Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n             for (Ref ref : refs.values()) {\n                 if (ref.getPeeledObjectId() !\u003d null)\n                     tagTargets.add(ref.getPeeledObjectId());\n                 else if (ref.getObjectId() \u003d\u003d null)\n                     continue;\n                 else if (ref.getName().startsWith(Constants.R_HEADS))\n                     tagTargets.add(ref.getObjectId());\n             }\n             pw.setTagTargets(tagTargets);\n         }\n         if (depth \u003e 0)\n             pw.setShallowPack(depth, unshallowCommits);\n         RevWalk rw \u003d walk;\n         if (wantAll.isEmpty()) {\n             pw.preparePack(pm, wantIds, commonBase);\n         } else {\n             walk.reset();\n             ObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n             pw.preparePack(pm, ow, wantAll, commonBase);\n             rw \u003d ow;\n         }\n         if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n             for (Ref ref : refs.values()) {\n                 ObjectId objectId \u003d ref.getObjectId();\n                 if (wantAll.isEmpty()) {\n                     if (wantIds.contains(objectId))\n                         continue;\n                 } else {\n                     RevObject obj \u003d rw.lookupOrNull(objectId);\n                     if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                         continue;\n                 }\n                 if (!ref.isPeeled())\n                     ref \u003d db.peel(ref);\n                 ObjectId peeledId \u003d ref.getPeeledObjectId();\n                 if (peeledId \u003d\u003d null)\n                     continue;\n                 objectId \u003d ref.getObjectId();\n                 if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n                     pw.addObject(rw.parseAny(objectId));\n             }\n         }\n         pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n         if (msgOut !\u003d NullOutputStream.INSTANCE) {\n             String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n             msgOut.write(Constants.encode(msg));\n             msgOut.flush();\n         }\n     } finally {\n         statistics \u003d pw.getStatistics();\n         if (statistics !\u003d null) {\n             postUploadHook.onPostUpload(statistics);\n             logger.onPackStatistics(new PackWriter.Statistics(statistics));\n         }\n         pw.close();\n     }\n     if (sideband)\n         pckOut.end();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d9bbb04c3ef28db1d2e492506a819b7ac5c5f9df": {
      "type": "Ybodychange",
      "commitMessage": "Introduce PostUploadHook to replace UploadPackLogger\n\nUploadPackLogger is incorrectly named--it can be used to trigger any\npost upload action, such as GC/compaction. This change introduces\nPostUploadHook/PostUploadHookChain to replace\nUploadPackLogger/UploadPackLoggerChain and deprecates the latter.\n\nIt also introduces PackStatistics as a replacement for\nPackWriter.Statistics, since the latter is not public API.\nIt changes PackWriter to use PackStatistics and reimplements\nPackWriter.Statistics to delegate to PackStatistics.\n\nChange-Id: Ic51df1613e471f568ffee25ae67e118425b38986\nSigned-off-by: Terry Parker \u003ctparker@google.com\u003e\n",
      "commitDate": "2015/6/13 上午4:56",
      "commitName": "d9bbb04c3ef28db1d2e492506a819b7ac5c5f9df",
      "commitAuthor": "Terry Parker",
      "commitDateOld": "2015/6/10 上午12:43",
      "commitNameOld": "96f210f4b7172a0d427061d2f9624872efbcad39",
      "commitAuthorOld": "Fredrik Medley",
      "daysBetweenCommits": 3.18,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "actualSource": "private void sendPack(final boolean sideband) throws IOException {\n    ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n    OutputStream packOut \u003d rawOut;\n    if (sideband) {\n        int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz \u003d SideBandOutputStream.MAX_BUF;\n        packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm \u003d new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n        msgOut.flush();\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n            noPack.setOutput();\n            @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg \u003d packConfig;\n    if (cfg \u003d\u003d null)\n        cfg \u003d new PackConfig(db);\n    final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n    try {\n        pw.setIndexDisabled(true);\n        pw.setUseCachedPacks(true);\n        pw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n            Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() !\u003d null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() \u003d\u003d null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        if (depth \u003e 0)\n            pw.setShallowPack(depth, unshallowCommits);\n        RevWalk rw \u003d walk;\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase);\n        } else {\n            walk.reset();\n            ObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase);\n            rw \u003d ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId \u003d ref.getObjectId();\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj \u003d rw.lookupOrNull(objectId);\n                    if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref \u003d db.peel(ref);\n                ObjectId peeledId \u003d ref.getPeeledObjectId();\n                if (peeledId \u003d\u003d null)\n                    continue;\n                objectId \u003d ref.getObjectId();\n                if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n                    pw.addObject(rw.parseAny(objectId));\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        if (msgOut !\u003d NullOutputStream.INSTANCE) {\n            String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        statistics \u003d pw.getStatistics();\n        if (statistics !\u003d null) {\n            postUploadHook.onPostUpload(statistics);\n            logger.onPackStatistics(new PackWriter.Statistics(statistics));\n        }\n        pw.close();\n    }\n    if (sideband)\n        pckOut.end();\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
      "functionStartLine": 1401,
      "functionName": "sendPack",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,100 +1,102 @@\n private void sendPack(final boolean sideband) throws IOException {\n     ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n     OutputStream packOut \u003d rawOut;\n     if (sideband) {\n         int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n         if (options.contains(OPTION_SIDE_BAND_64K))\n             bufsz \u003d SideBandOutputStream.MAX_BUF;\n         packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n         if (!options.contains(OPTION_NO_PROGRESS)) {\n             msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n             pm \u003d new SideBandProgressMonitor(msgOut);\n         }\n     }\n     try {\n         if (wantAll.isEmpty()) {\n             preUploadHook.onSendPack(this, wantIds, commonBase);\n         } else {\n             preUploadHook.onSendPack(this, wantAll, commonBase);\n         }\n         msgOut.flush();\n     } catch (ServiceMayNotContinueException noPack) {\n         if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n             noPack.setOutput();\n             @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n             err.write(Constants.encode(noPack.getMessage()));\n             err.flush();\n         }\n         throw noPack;\n     }\n     PackConfig cfg \u003d packConfig;\n     if (cfg \u003d\u003d null)\n         cfg \u003d new PackConfig(db);\n     final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n     try {\n         pw.setIndexDisabled(true);\n         pw.setUseCachedPacks(true);\n         pw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n         pw.setReuseDeltaCommits(true);\n         pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n         pw.setThin(options.contains(OPTION_THIN_PACK));\n         pw.setReuseValidatingObjects(false);\n         if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n             Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n             for (Ref ref : refs.values()) {\n                 if (ref.getPeeledObjectId() !\u003d null)\n                     tagTargets.add(ref.getPeeledObjectId());\n                 else if (ref.getObjectId() \u003d\u003d null)\n                     continue;\n                 else if (ref.getName().startsWith(Constants.R_HEADS))\n                     tagTargets.add(ref.getObjectId());\n             }\n             pw.setTagTargets(tagTargets);\n         }\n         if (depth \u003e 0)\n             pw.setShallowPack(depth, unshallowCommits);\n         RevWalk rw \u003d walk;\n         if (wantAll.isEmpty()) {\n             pw.preparePack(pm, wantIds, commonBase);\n         } else {\n             walk.reset();\n             ObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n             pw.preparePack(pm, ow, wantAll, commonBase);\n             rw \u003d ow;\n         }\n         if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n             for (Ref ref : refs.values()) {\n                 ObjectId objectId \u003d ref.getObjectId();\n                 if (wantAll.isEmpty()) {\n                     if (wantIds.contains(objectId))\n                         continue;\n                 } else {\n                     RevObject obj \u003d rw.lookupOrNull(objectId);\n                     if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                         continue;\n                 }\n                 if (!ref.isPeeled())\n                     ref \u003d db.peel(ref);\n                 ObjectId peeledId \u003d ref.getPeeledObjectId();\n                 if (peeledId \u003d\u003d null)\n                     continue;\n                 objectId \u003d ref.getObjectId();\n                 if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n                     pw.addObject(rw.parseAny(objectId));\n             }\n         }\n         pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n         if (msgOut !\u003d NullOutputStream.INSTANCE) {\n             String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n             msgOut.write(Constants.encode(msg));\n             msgOut.flush();\n         }\n     } finally {\n         statistics \u003d pw.getStatistics();\n-        if (statistics !\u003d null)\n-            logger.onPackStatistics(statistics);\n+        if (statistics !\u003d null) {\n+            postUploadHook.onPostUpload(statistics);\n+            logger.onPackStatistics(new PackWriter.Statistics(statistics));\n+        }\n         pw.close();\n     }\n     if (sideband)\n         pckOut.end();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0e73d395061d1bfee365acaa2f79c392175d13bf": {
      "type": "Ybodychange",
      "commitMessage": "Use AutoClosable to close resources in bundle org.eclipse.jgit\n\n- use try-with-resource where possible\n- replace use of deprecated release() by close()\n\nChange-Id: I0f139c3535679087b7fa09649166bca514750b81\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2015/5/21 上午6:01",
      "commitName": "0e73d395061d1bfee365acaa2f79c392175d13bf",
      "commitAuthor": "Matthias Sohn",
      "commitDateOld": "2015/5/1 上午5:40",
      "commitNameOld": "4a984e20332a765a81cadeaa4875b228ebf290fb",
      "commitAuthorOld": "Shawn Pearce",
      "daysBetweenCommits": 20.01,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "actualSource": "private void sendPack(final boolean sideband) throws IOException {\n    ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n    OutputStream packOut \u003d rawOut;\n    if (sideband) {\n        int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz \u003d SideBandOutputStream.MAX_BUF;\n        packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm \u003d new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n        msgOut.flush();\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n            noPack.setOutput();\n            @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg \u003d packConfig;\n    if (cfg \u003d\u003d null)\n        cfg \u003d new PackConfig(db);\n    final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n    try {\n        pw.setIndexDisabled(true);\n        pw.setUseCachedPacks(true);\n        pw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n            Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() !\u003d null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() \u003d\u003d null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        if (depth \u003e 0)\n            pw.setShallowPack(depth, unshallowCommits);\n        RevWalk rw \u003d walk;\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase);\n        } else {\n            walk.reset();\n            ObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase);\n            rw \u003d ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId \u003d ref.getObjectId();\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj \u003d rw.lookupOrNull(objectId);\n                    if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref \u003d db.peel(ref);\n                ObjectId peeledId \u003d ref.getPeeledObjectId();\n                if (peeledId \u003d\u003d null)\n                    continue;\n                objectId \u003d ref.getObjectId();\n                if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n                    pw.addObject(rw.parseAny(objectId));\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        if (msgOut !\u003d NullOutputStream.INSTANCE) {\n            String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        statistics \u003d pw.getStatistics();\n        if (statistics !\u003d null)\n            logger.onPackStatistics(statistics);\n        pw.close();\n    }\n    if (sideband)\n        pckOut.end();\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
      "functionStartLine": 1346,
      "functionName": "sendPack",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,100 +1,100 @@\n private void sendPack(final boolean sideband) throws IOException {\n     ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n     OutputStream packOut \u003d rawOut;\n     if (sideband) {\n         int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n         if (options.contains(OPTION_SIDE_BAND_64K))\n             bufsz \u003d SideBandOutputStream.MAX_BUF;\n         packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n         if (!options.contains(OPTION_NO_PROGRESS)) {\n             msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n             pm \u003d new SideBandProgressMonitor(msgOut);\n         }\n     }\n     try {\n         if (wantAll.isEmpty()) {\n             preUploadHook.onSendPack(this, wantIds, commonBase);\n         } else {\n             preUploadHook.onSendPack(this, wantAll, commonBase);\n         }\n         msgOut.flush();\n     } catch (ServiceMayNotContinueException noPack) {\n         if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n             noPack.setOutput();\n             @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n             err.write(Constants.encode(noPack.getMessage()));\n             err.flush();\n         }\n         throw noPack;\n     }\n     PackConfig cfg \u003d packConfig;\n     if (cfg \u003d\u003d null)\n         cfg \u003d new PackConfig(db);\n     final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n     try {\n         pw.setIndexDisabled(true);\n         pw.setUseCachedPacks(true);\n         pw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n         pw.setReuseDeltaCommits(true);\n         pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n         pw.setThin(options.contains(OPTION_THIN_PACK));\n         pw.setReuseValidatingObjects(false);\n         if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n             Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n             for (Ref ref : refs.values()) {\n                 if (ref.getPeeledObjectId() !\u003d null)\n                     tagTargets.add(ref.getPeeledObjectId());\n                 else if (ref.getObjectId() \u003d\u003d null)\n                     continue;\n                 else if (ref.getName().startsWith(Constants.R_HEADS))\n                     tagTargets.add(ref.getObjectId());\n             }\n             pw.setTagTargets(tagTargets);\n         }\n         if (depth \u003e 0)\n             pw.setShallowPack(depth, unshallowCommits);\n         RevWalk rw \u003d walk;\n         if (wantAll.isEmpty()) {\n             pw.preparePack(pm, wantIds, commonBase);\n         } else {\n             walk.reset();\n             ObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n             pw.preparePack(pm, ow, wantAll, commonBase);\n             rw \u003d ow;\n         }\n         if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n             for (Ref ref : refs.values()) {\n                 ObjectId objectId \u003d ref.getObjectId();\n                 if (wantAll.isEmpty()) {\n                     if (wantIds.contains(objectId))\n                         continue;\n                 } else {\n                     RevObject obj \u003d rw.lookupOrNull(objectId);\n                     if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                         continue;\n                 }\n                 if (!ref.isPeeled())\n                     ref \u003d db.peel(ref);\n                 ObjectId peeledId \u003d ref.getPeeledObjectId();\n                 if (peeledId \u003d\u003d null)\n                     continue;\n                 objectId \u003d ref.getObjectId();\n                 if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n                     pw.addObject(rw.parseAny(objectId));\n             }\n         }\n         pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n         if (msgOut !\u003d NullOutputStream.INSTANCE) {\n             String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n             msgOut.write(Constants.encode(msg));\n             msgOut.flush();\n         }\n     } finally {\n         statistics \u003d pw.getStatistics();\n         if (statistics !\u003d null)\n             logger.onPackStatistics(statistics);\n-        pw.release();\n+        pw.close();\n     }\n     if (sideband)\n         pckOut.end();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7b7d033ee1fdd8e81ae2ad7dc9e1ae12cbd9ddfa": {
      "type": "Ybodychange",
      "commitMessage": "UploadPack: Always make PackWriter.Statistics available\n\nIf the packer fails, still obtain the stats and make them available\nto the logger and the caller. Failures can frequently happen when\na client disconnects in the middle of a pack stream. Server admins\nmay still want to examine the timing metrics from counting and\ncompressing phases.\n\nChange-Id: Iceae4f68b5473f4223d85c9edfb57837fc818eed\n",
      "commitDate": "2014/8/30 上午3:56",
      "commitName": "7b7d033ee1fdd8e81ae2ad7dc9e1ae12cbd9ddfa",
      "commitAuthor": "Shawn Pearce",
      "commitDateOld": "2014/1/29 上午9:29",
      "commitNameOld": "b0174a089ce886d02c8d7fb80d63f0e50329bec3",
      "commitAuthorOld": "Shawn Pearce",
      "daysBetweenCommits": 212.77,
      "commitsBetweenForRepo": 300,
      "commitsBetweenForFile": 1,
      "actualSource": "private void sendPack(final boolean sideband) throws IOException {\n    ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n    OutputStream packOut \u003d rawOut;\n    if (sideband) {\n        int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz \u003d SideBandOutputStream.MAX_BUF;\n        packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm \u003d new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n        msgOut.flush();\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n            noPack.setOutput();\n            @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg \u003d packConfig;\n    if (cfg \u003d\u003d null)\n        cfg \u003d new PackConfig(db);\n    final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n    try {\n        pw.setIndexDisabled(true);\n        pw.setUseCachedPacks(true);\n        pw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n            Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() !\u003d null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() \u003d\u003d null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        if (depth \u003e 0)\n            pw.setShallowPack(depth, unshallowCommits);\n        RevWalk rw \u003d walk;\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase);\n        } else {\n            walk.reset();\n            ObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase);\n            rw \u003d ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId \u003d ref.getObjectId();\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj \u003d rw.lookupOrNull(objectId);\n                    if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref \u003d db.peel(ref);\n                ObjectId peeledId \u003d ref.getPeeledObjectId();\n                if (peeledId \u003d\u003d null)\n                    continue;\n                objectId \u003d ref.getObjectId();\n                if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n                    pw.addObject(rw.parseAny(objectId));\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        if (msgOut !\u003d NullOutputStream.INSTANCE) {\n            String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        statistics \u003d pw.getStatistics();\n        if (statistics !\u003d null)\n            logger.onPackStatistics(statistics);\n        pw.release();\n    }\n    if (sideband)\n        pckOut.end();\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
      "functionStartLine": 1310,
      "functionName": "sendPack",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,100 +1,100 @@\n private void sendPack(final boolean sideband) throws IOException {\n     ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n     OutputStream packOut \u003d rawOut;\n     if (sideband) {\n         int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n         if (options.contains(OPTION_SIDE_BAND_64K))\n             bufsz \u003d SideBandOutputStream.MAX_BUF;\n         packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n         if (!options.contains(OPTION_NO_PROGRESS)) {\n             msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n             pm \u003d new SideBandProgressMonitor(msgOut);\n         }\n     }\n     try {\n         if (wantAll.isEmpty()) {\n             preUploadHook.onSendPack(this, wantIds, commonBase);\n         } else {\n             preUploadHook.onSendPack(this, wantAll, commonBase);\n         }\n         msgOut.flush();\n     } catch (ServiceMayNotContinueException noPack) {\n         if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n             noPack.setOutput();\n             @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n             err.write(Constants.encode(noPack.getMessage()));\n             err.flush();\n         }\n         throw noPack;\n     }\n     PackConfig cfg \u003d packConfig;\n     if (cfg \u003d\u003d null)\n         cfg \u003d new PackConfig(db);\n     final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n     try {\n         pw.setIndexDisabled(true);\n         pw.setUseCachedPacks(true);\n         pw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n         pw.setReuseDeltaCommits(true);\n         pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n         pw.setThin(options.contains(OPTION_THIN_PACK));\n         pw.setReuseValidatingObjects(false);\n         if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n             Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n             for (Ref ref : refs.values()) {\n                 if (ref.getPeeledObjectId() !\u003d null)\n                     tagTargets.add(ref.getPeeledObjectId());\n                 else if (ref.getObjectId() \u003d\u003d null)\n                     continue;\n                 else if (ref.getName().startsWith(Constants.R_HEADS))\n                     tagTargets.add(ref.getObjectId());\n             }\n             pw.setTagTargets(tagTargets);\n         }\n         if (depth \u003e 0)\n             pw.setShallowPack(depth, unshallowCommits);\n         RevWalk rw \u003d walk;\n         if (wantAll.isEmpty()) {\n             pw.preparePack(pm, wantIds, commonBase);\n         } else {\n             walk.reset();\n             ObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n             pw.preparePack(pm, ow, wantAll, commonBase);\n             rw \u003d ow;\n         }\n         if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n             for (Ref ref : refs.values()) {\n                 ObjectId objectId \u003d ref.getObjectId();\n                 if (wantAll.isEmpty()) {\n                     if (wantIds.contains(objectId))\n                         continue;\n                 } else {\n                     RevObject obj \u003d rw.lookupOrNull(objectId);\n                     if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                         continue;\n                 }\n                 if (!ref.isPeeled())\n                     ref \u003d db.peel(ref);\n                 ObjectId peeledId \u003d ref.getPeeledObjectId();\n                 if (peeledId \u003d\u003d null)\n                     continue;\n                 objectId \u003d ref.getObjectId();\n                 if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n                     pw.addObject(rw.parseAny(objectId));\n             }\n         }\n         pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n-        statistics \u003d pw.getStatistics();\n         if (msgOut !\u003d NullOutputStream.INSTANCE) {\n             String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n             msgOut.write(Constants.encode(msg));\n             msgOut.flush();\n         }\n     } finally {\n+        statistics \u003d pw.getStatistics();\n+        if (statistics !\u003d null)\n+            logger.onPackStatistics(statistics);\n         pw.release();\n     }\n     if (sideband)\n         pckOut.end();\n-    if (statistics !\u003d null)\n-        logger.onPackStatistics(statistics);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b0174a089ce886d02c8d7fb80d63f0e50329bec3": {
      "type": "Ybodychange",
      "commitMessage": "Fix serving fetch of existing shallow client\n\nIn certain cases a JGit server updating an existing shallow client\nselected a common ancestor that was behind the shallow edge of\nthe client. This allowed the server to assume the client had some\nobjects it did not have and allowed creation of pack deltas the\nclient could never inflate.\n\nAny commit the client has advertised as shallow must be treated\nby UploadPack server as though it has no parents. With no parents\nthe walker cannot visit graph history the client does not have,\nand PackWriter cannot consider delta base candidates the client\nis lacking.\n\nChange-Id: I4922b9354df9f490966a586fb693762e897345a2\n",
      "commitDate": "2014/1/29 上午9:29",
      "commitName": "b0174a089ce886d02c8d7fb80d63f0e50329bec3",
      "commitAuthor": "Shawn Pearce",
      "commitDateOld": "2013/11/2 上午10:57",
      "commitNameOld": "b0dbb78e7d2287a5391a75e399009bf2203c4f24",
      "commitAuthorOld": "Shawn Pearce",
      "daysBetweenCommits": 87.94,
      "commitsBetweenForRepo": 66,
      "commitsBetweenForFile": 1,
      "actualSource": "private void sendPack(final boolean sideband) throws IOException {\n    ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n    OutputStream packOut \u003d rawOut;\n    if (sideband) {\n        int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz \u003d SideBandOutputStream.MAX_BUF;\n        packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm \u003d new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n        msgOut.flush();\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n            noPack.setOutput();\n            @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg \u003d packConfig;\n    if (cfg \u003d\u003d null)\n        cfg \u003d new PackConfig(db);\n    final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n    try {\n        pw.setIndexDisabled(true);\n        pw.setUseCachedPacks(true);\n        pw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n            Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() !\u003d null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() \u003d\u003d null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        if (depth \u003e 0)\n            pw.setShallowPack(depth, unshallowCommits);\n        RevWalk rw \u003d walk;\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase);\n        } else {\n            walk.reset();\n            ObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase);\n            rw \u003d ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId \u003d ref.getObjectId();\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj \u003d rw.lookupOrNull(objectId);\n                    if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref \u003d db.peel(ref);\n                ObjectId peeledId \u003d ref.getPeeledObjectId();\n                if (peeledId \u003d\u003d null)\n                    continue;\n                objectId \u003d ref.getObjectId();\n                if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n                    pw.addObject(rw.parseAny(objectId));\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        statistics \u003d pw.getStatistics();\n        if (msgOut !\u003d NullOutputStream.INSTANCE) {\n            String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        pw.release();\n    }\n    if (sideband)\n        pckOut.end();\n    if (statistics !\u003d null)\n        logger.onPackStatistics(statistics);\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
      "functionStartLine": 1310,
      "functionName": "sendPack",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,100 +1,100 @@\n private void sendPack(final boolean sideband) throws IOException {\n     ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n     OutputStream packOut \u003d rawOut;\n     if (sideband) {\n         int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n         if (options.contains(OPTION_SIDE_BAND_64K))\n             bufsz \u003d SideBandOutputStream.MAX_BUF;\n         packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n         if (!options.contains(OPTION_NO_PROGRESS)) {\n             msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n             pm \u003d new SideBandProgressMonitor(msgOut);\n         }\n     }\n     try {\n         if (wantAll.isEmpty()) {\n             preUploadHook.onSendPack(this, wantIds, commonBase);\n         } else {\n             preUploadHook.onSendPack(this, wantAll, commonBase);\n         }\n         msgOut.flush();\n     } catch (ServiceMayNotContinueException noPack) {\n         if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n             noPack.setOutput();\n             @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n             err.write(Constants.encode(noPack.getMessage()));\n             err.flush();\n         }\n         throw noPack;\n     }\n     PackConfig cfg \u003d packConfig;\n     if (cfg \u003d\u003d null)\n         cfg \u003d new PackConfig(db);\n     final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n     try {\n         pw.setIndexDisabled(true);\n         pw.setUseCachedPacks(true);\n-        pw.setUseBitmaps(true);\n+        pw.setUseBitmaps(depth \u003d\u003d 0 \u0026\u0026 clientShallowCommits.isEmpty());\n         pw.setReuseDeltaCommits(true);\n         pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n         pw.setThin(options.contains(OPTION_THIN_PACK));\n         pw.setReuseValidatingObjects(false);\n         if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n             Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n             for (Ref ref : refs.values()) {\n                 if (ref.getPeeledObjectId() !\u003d null)\n                     tagTargets.add(ref.getPeeledObjectId());\n                 else if (ref.getObjectId() \u003d\u003d null)\n                     continue;\n                 else if (ref.getName().startsWith(Constants.R_HEADS))\n                     tagTargets.add(ref.getObjectId());\n             }\n             pw.setTagTargets(tagTargets);\n         }\n         if (depth \u003e 0)\n             pw.setShallowPack(depth, unshallowCommits);\n         RevWalk rw \u003d walk;\n         if (wantAll.isEmpty()) {\n             pw.preparePack(pm, wantIds, commonBase);\n         } else {\n             walk.reset();\n             ObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n             pw.preparePack(pm, ow, wantAll, commonBase);\n             rw \u003d ow;\n         }\n         if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n             for (Ref ref : refs.values()) {\n                 ObjectId objectId \u003d ref.getObjectId();\n                 if (wantAll.isEmpty()) {\n                     if (wantIds.contains(objectId))\n                         continue;\n                 } else {\n                     RevObject obj \u003d rw.lookupOrNull(objectId);\n                     if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                         continue;\n                 }\n                 if (!ref.isPeeled())\n                     ref \u003d db.peel(ref);\n                 ObjectId peeledId \u003d ref.getPeeledObjectId();\n                 if (peeledId \u003d\u003d null)\n                     continue;\n                 objectId \u003d ref.getObjectId();\n                 if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n                     pw.addObject(rw.parseAny(objectId));\n             }\n         }\n         pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n         statistics \u003d pw.getStatistics();\n         if (msgOut !\u003d NullOutputStream.INSTANCE) {\n             String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n             msgOut.write(Constants.encode(msg));\n             msgOut.flush();\n         }\n     } finally {\n         pw.release();\n     }\n     if (sideband)\n         pckOut.end();\n     if (statistics !\u003d null)\n         logger.onPackStatistics(statistics);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "557471da2eee6752ad4305a883843bcdc8d66536": {
      "type": "Ybodychange",
      "commitMessage": "Use NullOutputStream not DisabledOutputStream in UploadPack\n\nThe stream should not throw IllegalStateException if it is off.\nFlush the stream after the hook runs, in case any messages need\nto be sent ahead of the pack.\n\nChange-Id: I21c7a0258ab1308406d226293fa0e7da69b4f57b\n",
      "commitDate": "2013/5/24 上午4:07",
      "commitName": "557471da2eee6752ad4305a883843bcdc8d66536",
      "commitAuthor": "Shawn Pearce",
      "commitDateOld": "2013/5/23 上午3:14",
      "commitNameOld": "6e896ba66ba095b97a89a622d43f05ce9ad501e7",
      "commitAuthorOld": "Shawn Pearce",
      "daysBetweenCommits": 1.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private void sendPack(final boolean sideband) throws IOException {\n    ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n    OutputStream packOut \u003d rawOut;\n    if (sideband) {\n        int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz \u003d SideBandOutputStream.MAX_BUF;\n        packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm \u003d new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n        msgOut.flush();\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n            noPack.setOutput();\n            @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg \u003d packConfig;\n    if (cfg \u003d\u003d null)\n        cfg \u003d new PackConfig(db);\n    final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n    try {\n        pw.setIndexDisabled(true);\n        pw.setUseCachedPacks(true);\n        pw.setUseBitmaps(true);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n            Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() !\u003d null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() \u003d\u003d null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        if (depth \u003e 0)\n            pw.setShallowPack(depth, unshallowCommits);\n        RevWalk rw \u003d walk;\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase);\n        } else {\n            walk.reset();\n            ObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase);\n            rw \u003d ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId \u003d ref.getObjectId();\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj \u003d rw.lookupOrNull(objectId);\n                    if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref \u003d db.peel(ref);\n                ObjectId peeledId \u003d ref.getPeeledObjectId();\n                if (peeledId \u003d\u003d null)\n                    continue;\n                objectId \u003d ref.getObjectId();\n                if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n                    pw.addObject(rw.parseAny(objectId));\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        statistics \u003d pw.getStatistics();\n        if (msgOut !\u003d NullOutputStream.INSTANCE) {\n            String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        pw.release();\n    }\n    if (sideband)\n        pckOut.end();\n    if (statistics !\u003d null)\n        logger.onPackStatistics(statistics);\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
      "functionStartLine": 1106,
      "functionName": "sendPack",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,99 +1,100 @@\n private void sendPack(final boolean sideband) throws IOException {\n     ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n     OutputStream packOut \u003d rawOut;\n     if (sideband) {\n         int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n         if (options.contains(OPTION_SIDE_BAND_64K))\n             bufsz \u003d SideBandOutputStream.MAX_BUF;\n         packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n         if (!options.contains(OPTION_NO_PROGRESS)) {\n             msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n             pm \u003d new SideBandProgressMonitor(msgOut);\n         }\n     }\n     try {\n         if (wantAll.isEmpty()) {\n             preUploadHook.onSendPack(this, wantIds, commonBase);\n         } else {\n             preUploadHook.onSendPack(this, wantAll, commonBase);\n         }\n+        msgOut.flush();\n     } catch (ServiceMayNotContinueException noPack) {\n         if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n             noPack.setOutput();\n             @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n             err.write(Constants.encode(noPack.getMessage()));\n             err.flush();\n         }\n         throw noPack;\n     }\n     PackConfig cfg \u003d packConfig;\n     if (cfg \u003d\u003d null)\n         cfg \u003d new PackConfig(db);\n     final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n     try {\n         pw.setIndexDisabled(true);\n         pw.setUseCachedPacks(true);\n         pw.setUseBitmaps(true);\n         pw.setReuseDeltaCommits(true);\n         pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n         pw.setThin(options.contains(OPTION_THIN_PACK));\n         pw.setReuseValidatingObjects(false);\n         if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n             Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n             for (Ref ref : refs.values()) {\n                 if (ref.getPeeledObjectId() !\u003d null)\n                     tagTargets.add(ref.getPeeledObjectId());\n                 else if (ref.getObjectId() \u003d\u003d null)\n                     continue;\n                 else if (ref.getName().startsWith(Constants.R_HEADS))\n                     tagTargets.add(ref.getObjectId());\n             }\n             pw.setTagTargets(tagTargets);\n         }\n         if (depth \u003e 0)\n             pw.setShallowPack(depth, unshallowCommits);\n         RevWalk rw \u003d walk;\n         if (wantAll.isEmpty()) {\n             pw.preparePack(pm, wantIds, commonBase);\n         } else {\n             walk.reset();\n             ObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n             pw.preparePack(pm, ow, wantAll, commonBase);\n             rw \u003d ow;\n         }\n         if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n             for (Ref ref : refs.values()) {\n                 ObjectId objectId \u003d ref.getObjectId();\n                 if (wantAll.isEmpty()) {\n                     if (wantIds.contains(objectId))\n                         continue;\n                 } else {\n                     RevObject obj \u003d rw.lookupOrNull(objectId);\n                     if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                         continue;\n                 }\n                 if (!ref.isPeeled())\n                     ref \u003d db.peel(ref);\n                 ObjectId peeledId \u003d ref.getPeeledObjectId();\n                 if (peeledId \u003d\u003d null)\n                     continue;\n                 objectId \u003d ref.getObjectId();\n                 if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n                     pw.addObject(rw.parseAny(objectId));\n             }\n         }\n         pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n         statistics \u003d pw.getStatistics();\n-        if (msgOut !\u003d DisabledOutputStream.INSTANCE) {\n+        if (msgOut !\u003d NullOutputStream.INSTANCE) {\n             String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n             msgOut.write(Constants.encode(msg));\n             msgOut.flush();\n         }\n     } finally {\n         pw.release();\n     }\n     if (sideband)\n         pckOut.end();\n     if (statistics !\u003d null)\n         logger.onPackStatistics(statistics);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6e896ba66ba095b97a89a622d43f05ce9ad501e7": {
      "type": "Ybodychange",
      "commitMessage": "Allow PreUploadHook.onSendPack to send messages to the client\n\nBefore transmitting to the client a hook may want to send along\na text message ahead of the pack, such as a \"message of the day\".\nEnable this usage by mirroring the message sending API from\nReceivePack on the UploadPack instance, using the side band.\n\nChange-Id: I31cd254a4ddb816641397a3e9c2c20212471c37f\n",
      "commitDate": "2013/5/23 上午3:14",
      "commitName": "6e896ba66ba095b97a89a622d43f05ce9ad501e7",
      "commitAuthor": "Shawn Pearce",
      "commitDateOld": "2013/4/11 上午3:58",
      "commitNameOld": "eb17495ca4ce95c63bacf81af16ab19ff042b65c",
      "commitAuthorOld": "Shawn Pearce",
      "daysBetweenCommits": 41.97,
      "commitsBetweenForRepo": 60,
      "commitsBetweenForFile": 1,
      "actualSource": "private void sendPack(final boolean sideband) throws IOException {\n    ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n    OutputStream packOut \u003d rawOut;\n    if (sideband) {\n        int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz \u003d SideBandOutputStream.MAX_BUF;\n        packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm \u003d new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n            noPack.setOutput();\n            @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg \u003d packConfig;\n    if (cfg \u003d\u003d null)\n        cfg \u003d new PackConfig(db);\n    final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n    try {\n        pw.setIndexDisabled(true);\n        pw.setUseCachedPacks(true);\n        pw.setUseBitmaps(true);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n            Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() !\u003d null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() \u003d\u003d null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        if (depth \u003e 0)\n            pw.setShallowPack(depth, unshallowCommits);\n        RevWalk rw \u003d walk;\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase);\n        } else {\n            walk.reset();\n            ObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase);\n            rw \u003d ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId \u003d ref.getObjectId();\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj \u003d rw.lookupOrNull(objectId);\n                    if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref \u003d db.peel(ref);\n                ObjectId peeledId \u003d ref.getPeeledObjectId();\n                if (peeledId \u003d\u003d null)\n                    continue;\n                objectId \u003d ref.getObjectId();\n                if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n                    pw.addObject(rw.parseAny(objectId));\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        statistics \u003d pw.getStatistics();\n        if (msgOut !\u003d DisabledOutputStream.INSTANCE) {\n            String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        pw.release();\n    }\n    if (sideband)\n        pckOut.end();\n    if (statistics !\u003d null)\n        logger.onPackStatistics(statistics);\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
      "functionStartLine": 1105,
      "functionName": "sendPack",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,100 +1,99 @@\n private void sendPack(final boolean sideband) throws IOException {\n     ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n     OutputStream packOut \u003d rawOut;\n-    SideBandOutputStream msgOut \u003d null;\n     if (sideband) {\n         int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n         if (options.contains(OPTION_SIDE_BAND_64K))\n             bufsz \u003d SideBandOutputStream.MAX_BUF;\n         packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n         if (!options.contains(OPTION_NO_PROGRESS)) {\n             msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n             pm \u003d new SideBandProgressMonitor(msgOut);\n         }\n     }\n     try {\n         if (wantAll.isEmpty()) {\n             preUploadHook.onSendPack(this, wantIds, commonBase);\n         } else {\n             preUploadHook.onSendPack(this, wantAll, commonBase);\n         }\n     } catch (ServiceMayNotContinueException noPack) {\n         if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n             noPack.setOutput();\n             @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n             err.write(Constants.encode(noPack.getMessage()));\n             err.flush();\n         }\n         throw noPack;\n     }\n     PackConfig cfg \u003d packConfig;\n     if (cfg \u003d\u003d null)\n         cfg \u003d new PackConfig(db);\n     final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n     try {\n         pw.setIndexDisabled(true);\n         pw.setUseCachedPacks(true);\n         pw.setUseBitmaps(true);\n         pw.setReuseDeltaCommits(true);\n         pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n         pw.setThin(options.contains(OPTION_THIN_PACK));\n         pw.setReuseValidatingObjects(false);\n         if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n             Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n             for (Ref ref : refs.values()) {\n                 if (ref.getPeeledObjectId() !\u003d null)\n                     tagTargets.add(ref.getPeeledObjectId());\n                 else if (ref.getObjectId() \u003d\u003d null)\n                     continue;\n                 else if (ref.getName().startsWith(Constants.R_HEADS))\n                     tagTargets.add(ref.getObjectId());\n             }\n             pw.setTagTargets(tagTargets);\n         }\n         if (depth \u003e 0)\n             pw.setShallowPack(depth, unshallowCommits);\n         RevWalk rw \u003d walk;\n         if (wantAll.isEmpty()) {\n             pw.preparePack(pm, wantIds, commonBase);\n         } else {\n             walk.reset();\n             ObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n             pw.preparePack(pm, ow, wantAll, commonBase);\n             rw \u003d ow;\n         }\n         if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n             for (Ref ref : refs.values()) {\n                 ObjectId objectId \u003d ref.getObjectId();\n                 if (wantAll.isEmpty()) {\n                     if (wantIds.contains(objectId))\n                         continue;\n                 } else {\n                     RevObject obj \u003d rw.lookupOrNull(objectId);\n                     if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                         continue;\n                 }\n                 if (!ref.isPeeled())\n                     ref \u003d db.peel(ref);\n                 ObjectId peeledId \u003d ref.getPeeledObjectId();\n                 if (peeledId \u003d\u003d null)\n                     continue;\n                 objectId \u003d ref.getObjectId();\n                 if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n                     pw.addObject(rw.parseAny(objectId));\n             }\n         }\n         pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n         statistics \u003d pw.getStatistics();\n-        if (msgOut !\u003d null) {\n+        if (msgOut !\u003d DisabledOutputStream.INSTANCE) {\n             String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n             msgOut.write(Constants.encode(msg));\n             msgOut.flush();\n         }\n     } finally {\n         pw.release();\n     }\n     if (sideband)\n         pckOut.end();\n     if (statistics !\u003d null)\n         logger.onPackStatistics(statistics);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "eb17495ca4ce95c63bacf81af16ab19ff042b65c": {
      "type": "Ybodychange",
      "commitMessage": "Disable CRC32 computation when no PackIndex will be created\n\nIf a server is streaming 3GiB worth of pack data to a client there\nis no reason to compute the CRC32 checksum on the objects. The\nCRC32 code computed by PackWriter is used only in the new index\ncreated by writeIndex(), which is never invoked for the native Git\nnetwork protocols.\n\nObject reuse may still compute its own CRC32 to verify the data\nbeing copied from an existing pack has not been corrupted. This\ncheck is done by the ObjectReader that implements ObjectReuseAsIs\nand has no relationship to the CRC32 being skipped during output.\n\nChange-Id: I05626f2e0d6ce19119b57d8a27193922636d60a7\n",
      "commitDate": "2013/4/11 上午3:58",
      "commitName": "eb17495ca4ce95c63bacf81af16ab19ff042b65c",
      "commitAuthor": "Shawn Pearce",
      "commitDateOld": "2013/3/23 上午4:21",
      "commitNameOld": "dd6f41e4010680115c00dd8dc250b1674eb42f42",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 18.98,
      "commitsBetweenForRepo": 30,
      "commitsBetweenForFile": 1,
      "actualSource": "private void sendPack(final boolean sideband) throws IOException {\n    ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n    OutputStream packOut \u003d rawOut;\n    SideBandOutputStream msgOut \u003d null;\n    if (sideband) {\n        int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz \u003d SideBandOutputStream.MAX_BUF;\n        packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm \u003d new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n            noPack.setOutput();\n            @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg \u003d packConfig;\n    if (cfg \u003d\u003d null)\n        cfg \u003d new PackConfig(db);\n    final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n    try {\n        pw.setIndexDisabled(true);\n        pw.setUseCachedPacks(true);\n        pw.setUseBitmaps(true);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n            Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() !\u003d null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() \u003d\u003d null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        if (depth \u003e 0)\n            pw.setShallowPack(depth, unshallowCommits);\n        RevWalk rw \u003d walk;\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase);\n        } else {\n            walk.reset();\n            ObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase);\n            rw \u003d ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId \u003d ref.getObjectId();\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj \u003d rw.lookupOrNull(objectId);\n                    if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref \u003d db.peel(ref);\n                ObjectId peeledId \u003d ref.getPeeledObjectId();\n                if (peeledId \u003d\u003d null)\n                    continue;\n                objectId \u003d ref.getObjectId();\n                if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n                    pw.addObject(rw.parseAny(objectId));\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        statistics \u003d pw.getStatistics();\n        if (msgOut !\u003d null) {\n            String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        pw.release();\n    }\n    if (sideband)\n        pckOut.end();\n    if (statistics !\u003d null)\n        logger.onPackStatistics(statistics);\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
      "functionStartLine": 1076,
      "functionName": "sendPack",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,99 +1,100 @@\n private void sendPack(final boolean sideband) throws IOException {\n     ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n     OutputStream packOut \u003d rawOut;\n     SideBandOutputStream msgOut \u003d null;\n     if (sideband) {\n         int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n         if (options.contains(OPTION_SIDE_BAND_64K))\n             bufsz \u003d SideBandOutputStream.MAX_BUF;\n         packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n         if (!options.contains(OPTION_NO_PROGRESS)) {\n             msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n             pm \u003d new SideBandProgressMonitor(msgOut);\n         }\n     }\n     try {\n         if (wantAll.isEmpty()) {\n             preUploadHook.onSendPack(this, wantIds, commonBase);\n         } else {\n             preUploadHook.onSendPack(this, wantAll, commonBase);\n         }\n     } catch (ServiceMayNotContinueException noPack) {\n         if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n             noPack.setOutput();\n             @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n             err.write(Constants.encode(noPack.getMessage()));\n             err.flush();\n         }\n         throw noPack;\n     }\n     PackConfig cfg \u003d packConfig;\n     if (cfg \u003d\u003d null)\n         cfg \u003d new PackConfig(db);\n     final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n     try {\n+        pw.setIndexDisabled(true);\n         pw.setUseCachedPacks(true);\n         pw.setUseBitmaps(true);\n         pw.setReuseDeltaCommits(true);\n         pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n         pw.setThin(options.contains(OPTION_THIN_PACK));\n         pw.setReuseValidatingObjects(false);\n         if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n             Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n             for (Ref ref : refs.values()) {\n                 if (ref.getPeeledObjectId() !\u003d null)\n                     tagTargets.add(ref.getPeeledObjectId());\n                 else if (ref.getObjectId() \u003d\u003d null)\n                     continue;\n                 else if (ref.getName().startsWith(Constants.R_HEADS))\n                     tagTargets.add(ref.getObjectId());\n             }\n             pw.setTagTargets(tagTargets);\n         }\n         if (depth \u003e 0)\n             pw.setShallowPack(depth, unshallowCommits);\n         RevWalk rw \u003d walk;\n         if (wantAll.isEmpty()) {\n             pw.preparePack(pm, wantIds, commonBase);\n         } else {\n             walk.reset();\n             ObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n             pw.preparePack(pm, ow, wantAll, commonBase);\n             rw \u003d ow;\n         }\n         if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n             for (Ref ref : refs.values()) {\n                 ObjectId objectId \u003d ref.getObjectId();\n                 if (wantAll.isEmpty()) {\n                     if (wantIds.contains(objectId))\n                         continue;\n                 } else {\n                     RevObject obj \u003d rw.lookupOrNull(objectId);\n                     if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                         continue;\n                 }\n                 if (!ref.isPeeled())\n                     ref \u003d db.peel(ref);\n                 ObjectId peeledId \u003d ref.getPeeledObjectId();\n                 if (peeledId \u003d\u003d null)\n                     continue;\n                 objectId \u003d ref.getObjectId();\n                 if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n                     pw.addObject(rw.parseAny(objectId));\n             }\n         }\n         pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n         statistics \u003d pw.getStatistics();\n         if (msgOut !\u003d null) {\n             String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n             msgOut.write(Constants.encode(msg));\n             msgOut.flush();\n         }\n     } finally {\n         pw.release();\n     }\n     if (sideband)\n         pckOut.end();\n     if (statistics !\u003d null)\n         logger.onPackStatistics(statistics);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "43ea887c8b43de26a6b7a9ea547033d3c04022e7": {
      "type": "Ybodychange",
      "commitMessage": "Enable serving upload requests using bitmaps.\n\nIf the pack index has bitmaps, allow the PackWriter to use the bitmaps\nfor upload requests.\n\nChange-Id: Iefa995fe927a11e4fd78afb34530995614221fc0\n",
      "commitDate": "2013/3/6 上午3:14",
      "commitName": "43ea887c8b43de26a6b7a9ea547033d3c04022e7",
      "commitAuthor": "Colby Ranger",
      "commitDateOld": "2012/12/27 下午11:57",
      "commitNameOld": "c310fa0c802f40a774edb58641de3ac5bfad0e2c",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 68.14,
      "commitsBetweenForRepo": 93,
      "commitsBetweenForFile": 1,
      "actualSource": "private void sendPack(final boolean sideband) throws IOException {\n    ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n    OutputStream packOut \u003d rawOut;\n    SideBandOutputStream msgOut \u003d null;\n    if (sideband) {\n        int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz \u003d SideBandOutputStream.MAX_BUF;\n        packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm \u003d new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n            noPack.setOutput();\n            @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg \u003d packConfig;\n    if (cfg \u003d\u003d null)\n        cfg \u003d new PackConfig(db);\n    final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n    try {\n        pw.setUseCachedPacks(true);\n        pw.setUseBitmaps(true);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n            Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() !\u003d null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() \u003d\u003d null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        if (depth \u003e 0)\n            pw.setShallowPack(depth, unshallowCommits);\n        RevWalk rw \u003d walk;\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase);\n        } else {\n            walk.reset();\n            ObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase);\n            rw \u003d ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId \u003d ref.getObjectId();\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj \u003d rw.lookupOrNull(objectId);\n                    if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref \u003d db.peel(ref);\n                ObjectId peeledId \u003d ref.getPeeledObjectId();\n                if (peeledId \u003d\u003d null)\n                    continue;\n                objectId \u003d ref.getObjectId();\n                if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n                    pw.addObject(rw.parseAny(objectId));\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        statistics \u003d pw.getStatistics();\n        if (msgOut !\u003d null) {\n            String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        pw.release();\n    }\n    if (sideband)\n        pckOut.end();\n    if (statistics !\u003d null)\n        logger.onPackStatistics(statistics);\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
      "functionStartLine": 1096,
      "functionName": "sendPack",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,98 +1,99 @@\n private void sendPack(final boolean sideband) throws IOException {\n     ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n     OutputStream packOut \u003d rawOut;\n     SideBandOutputStream msgOut \u003d null;\n     if (sideband) {\n         int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n         if (options.contains(OPTION_SIDE_BAND_64K))\n             bufsz \u003d SideBandOutputStream.MAX_BUF;\n         packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n         if (!options.contains(OPTION_NO_PROGRESS)) {\n             msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n             pm \u003d new SideBandProgressMonitor(msgOut);\n         }\n     }\n     try {\n         if (wantAll.isEmpty()) {\n             preUploadHook.onSendPack(this, wantIds, commonBase);\n         } else {\n             preUploadHook.onSendPack(this, wantAll, commonBase);\n         }\n     } catch (ServiceMayNotContinueException noPack) {\n         if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n             noPack.setOutput();\n             @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n             err.write(Constants.encode(noPack.getMessage()));\n             err.flush();\n         }\n         throw noPack;\n     }\n     PackConfig cfg \u003d packConfig;\n     if (cfg \u003d\u003d null)\n         cfg \u003d new PackConfig(db);\n     final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n     try {\n         pw.setUseCachedPacks(true);\n+        pw.setUseBitmaps(true);\n         pw.setReuseDeltaCommits(true);\n         pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n         pw.setThin(options.contains(OPTION_THIN_PACK));\n         pw.setReuseValidatingObjects(false);\n         if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n             Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n             for (Ref ref : refs.values()) {\n                 if (ref.getPeeledObjectId() !\u003d null)\n                     tagTargets.add(ref.getPeeledObjectId());\n                 else if (ref.getObjectId() \u003d\u003d null)\n                     continue;\n                 else if (ref.getName().startsWith(Constants.R_HEADS))\n                     tagTargets.add(ref.getObjectId());\n             }\n             pw.setTagTargets(tagTargets);\n         }\n         if (depth \u003e 0)\n             pw.setShallowPack(depth, unshallowCommits);\n         RevWalk rw \u003d walk;\n         if (wantAll.isEmpty()) {\n             pw.preparePack(pm, wantIds, commonBase);\n         } else {\n             walk.reset();\n             ObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n             pw.preparePack(pm, ow, wantAll, commonBase);\n             rw \u003d ow;\n         }\n         if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n             for (Ref ref : refs.values()) {\n                 ObjectId objectId \u003d ref.getObjectId();\n                 if (wantAll.isEmpty()) {\n                     if (wantIds.contains(objectId))\n                         continue;\n                 } else {\n                     RevObject obj \u003d rw.lookupOrNull(objectId);\n                     if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                         continue;\n                 }\n                 if (!ref.isPeeled())\n                     ref \u003d db.peel(ref);\n                 ObjectId peeledId \u003d ref.getPeeledObjectId();\n                 if (peeledId \u003d\u003d null)\n                     continue;\n                 objectId \u003d ref.getObjectId();\n                 if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n                     pw.addObject(rw.parseAny(objectId));\n             }\n         }\n         pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n         statistics \u003d pw.getStatistics();\n         if (msgOut !\u003d null) {\n             String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n             msgOut.write(Constants.encode(msg));\n             msgOut.flush();\n         }\n     } finally {\n         pw.release();\n     }\n     if (sideband)\n         pckOut.end();\n     if (statistics !\u003d null)\n         logger.onPackStatistics(statistics);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9b86cf574b230a9b3a71d7cb53a4f6712bfa33eb": {
      "type": "Ybodychange",
      "commitMessage": "Suppress two resource warnings\n\nChange-Id: I829bb135b2347f79aa6d8979a0934042e40d212f\n",
      "commitDate": "2012/8/17 下午9:49",
      "commitName": "9b86cf574b230a9b3a71d7cb53a4f6712bfa33eb",
      "commitAuthor": "Robin Rosenberg",
      "commitDateOld": "2012/3/12 下午10:20",
      "commitNameOld": "95d311f8886f42f31a4475f84aa23c6345ab7059",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 157.98,
      "commitsBetweenForRepo": 158,
      "commitsBetweenForFile": 1,
      "actualSource": "private void sendPack(final boolean sideband) throws IOException {\n    ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n    OutputStream packOut \u003d rawOut;\n    SideBandOutputStream msgOut \u003d null;\n    if (sideband) {\n        int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz \u003d SideBandOutputStream.MAX_BUF;\n        packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm \u003d new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n            noPack.setOutput();\n            @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg \u003d packConfig;\n    if (cfg \u003d\u003d null)\n        cfg \u003d new PackConfig(db);\n    final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n    try {\n        pw.setUseCachedPacks(true);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n            Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() !\u003d null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() \u003d\u003d null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        if (depth \u003e 0)\n            pw.setShallowPack(depth, unshallowCommits);\n        RevWalk rw \u003d walk;\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase);\n        } else {\n            walk.reset();\n            ObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase);\n            rw \u003d ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId \u003d ref.getObjectId();\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj \u003d rw.lookupOrNull(objectId);\n                    if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref \u003d db.peel(ref);\n                ObjectId peeledId \u003d ref.getPeeledObjectId();\n                if (peeledId \u003d\u003d null)\n                    continue;\n                objectId \u003d ref.getObjectId();\n                if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n                    pw.addObject(rw.parseAny(objectId));\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        statistics \u003d pw.getStatistics();\n        if (msgOut !\u003d null) {\n            String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        pw.release();\n    }\n    if (sideband)\n        pckOut.end();\n    if (statistics !\u003d null)\n        logger.onPackStatistics(statistics);\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
      "functionStartLine": 1096,
      "functionName": "sendPack",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,98 +1,98 @@\n private void sendPack(final boolean sideband) throws IOException {\n     ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n     OutputStream packOut \u003d rawOut;\n     SideBandOutputStream msgOut \u003d null;\n     if (sideband) {\n         int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n         if (options.contains(OPTION_SIDE_BAND_64K))\n             bufsz \u003d SideBandOutputStream.MAX_BUF;\n         packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n         if (!options.contains(OPTION_NO_PROGRESS)) {\n             msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n             pm \u003d new SideBandProgressMonitor(msgOut);\n         }\n     }\n     try {\n         if (wantAll.isEmpty()) {\n             preUploadHook.onSendPack(this, wantIds, commonBase);\n         } else {\n             preUploadHook.onSendPack(this, wantAll, commonBase);\n         }\n     } catch (ServiceMayNotContinueException noPack) {\n         if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n             noPack.setOutput();\n-            SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n+            @SuppressWarnings(\"resource\") SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n             err.write(Constants.encode(noPack.getMessage()));\n             err.flush();\n         }\n         throw noPack;\n     }\n     PackConfig cfg \u003d packConfig;\n     if (cfg \u003d\u003d null)\n         cfg \u003d new PackConfig(db);\n     final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n     try {\n         pw.setUseCachedPacks(true);\n         pw.setReuseDeltaCommits(true);\n         pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n         pw.setThin(options.contains(OPTION_THIN_PACK));\n         pw.setReuseValidatingObjects(false);\n         if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n             Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n             for (Ref ref : refs.values()) {\n                 if (ref.getPeeledObjectId() !\u003d null)\n                     tagTargets.add(ref.getPeeledObjectId());\n                 else if (ref.getObjectId() \u003d\u003d null)\n                     continue;\n                 else if (ref.getName().startsWith(Constants.R_HEADS))\n                     tagTargets.add(ref.getObjectId());\n             }\n             pw.setTagTargets(tagTargets);\n         }\n         if (depth \u003e 0)\n             pw.setShallowPack(depth, unshallowCommits);\n         RevWalk rw \u003d walk;\n         if (wantAll.isEmpty()) {\n             pw.preparePack(pm, wantIds, commonBase);\n         } else {\n             walk.reset();\n             ObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n             pw.preparePack(pm, ow, wantAll, commonBase);\n             rw \u003d ow;\n         }\n         if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n             for (Ref ref : refs.values()) {\n                 ObjectId objectId \u003d ref.getObjectId();\n                 if (wantAll.isEmpty()) {\n                     if (wantIds.contains(objectId))\n                         continue;\n                 } else {\n                     RevObject obj \u003d rw.lookupOrNull(objectId);\n                     if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                         continue;\n                 }\n                 if (!ref.isPeeled())\n                     ref \u003d db.peel(ref);\n                 ObjectId peeledId \u003d ref.getPeeledObjectId();\n                 if (peeledId \u003d\u003d null)\n                     continue;\n                 objectId \u003d ref.getObjectId();\n                 if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n                     pw.addObject(rw.parseAny(objectId));\n             }\n         }\n         pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n         statistics \u003d pw.getStatistics();\n         if (msgOut !\u003d null) {\n             String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n             msgOut.write(Constants.encode(msg));\n             msgOut.flush();\n         }\n     } finally {\n         pw.release();\n     }\n     if (sideband)\n         pckOut.end();\n     if (statistics !\u003d null)\n         logger.onPackStatistics(statistics);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1f2022e3a7e9482caa4823e031504b6bbe8246af": {
      "type": "Ybodychange",
      "commitMessage": "Modify refs in UploadPack/ReceivePack using a hook interface\n\nThis is intended to replace the RefFilter interface (but does not yet,\nfor backwards compatibility). That interface required lots of extra\nscanning and copying in filter cases such as only advertising a subtree\nof the refs directory. Instead, provide a hook that can be executed\nright before ref advertisement, using the public methods on\nUploadPack/ReceivePack to explicitly set the map of advertised refs.\n\nChange-Id: I0067019a191c8148af2cfb71a675f2258c5af0ca\n",
      "commitDate": "2012/3/1 上午11:09",
      "commitName": "1f2022e3a7e9482caa4823e031504b6bbe8246af",
      "commitAuthor": "Dave Borowitz",
      "commitDateOld": "2011/12/9 上午12:26",
      "commitNameOld": "d6172dc0de2cbaeb0bd38a9d30278dd5f9b140b3",
      "commitAuthorOld": "Dave Borowitz",
      "daysBetweenCommits": 83.45,
      "commitsBetweenForRepo": 81,
      "commitsBetweenForFile": 1,
      "actualSource": "private void sendPack(final boolean sideband) throws IOException {\n    ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n    OutputStream packOut \u003d rawOut;\n    SideBandOutputStream msgOut \u003d null;\n    if (sideband) {\n        int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz \u003d SideBandOutputStream.MAX_BUF;\n        packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm \u003d new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n            noPack.setOutput();\n            SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg \u003d packConfig;\n    if (cfg \u003d\u003d null)\n        cfg \u003d new PackConfig(db);\n    final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n    try {\n        pw.setUseCachedPacks(true);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n            Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() !\u003d null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() \u003d\u003d null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        if (depth \u003e 0)\n            pw.setShallowPack(depth, unshallowCommits);\n        RevWalk rw \u003d walk;\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase);\n        } else {\n            walk.reset();\n            ObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase);\n            rw \u003d ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId \u003d ref.getObjectId();\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj \u003d rw.lookupOrNull(objectId);\n                    if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref \u003d db.peel(ref);\n                ObjectId peeledId \u003d ref.getPeeledObjectId();\n                if (peeledId \u003d\u003d null)\n                    continue;\n                objectId \u003d ref.getObjectId();\n                if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n                    pw.addObject(rw.parseAny(objectId));\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        statistics \u003d pw.getStatistics();\n        if (msgOut !\u003d null) {\n            String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        pw.release();\n    }\n    if (sideband)\n        pckOut.end();\n    if (statistics !\u003d null)\n        logger.onPackStatistics(statistics);\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
      "functionStartLine": 1043,
      "functionName": "sendPack",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,98 +1,98 @@\n private void sendPack(final boolean sideband) throws IOException {\n     ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n     OutputStream packOut \u003d rawOut;\n     SideBandOutputStream msgOut \u003d null;\n     if (sideband) {\n         int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n         if (options.contains(OPTION_SIDE_BAND_64K))\n             bufsz \u003d SideBandOutputStream.MAX_BUF;\n         packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n         if (!options.contains(OPTION_NO_PROGRESS)) {\n             msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n             pm \u003d new SideBandProgressMonitor(msgOut);\n         }\n     }\n     try {\n         if (wantAll.isEmpty()) {\n             preUploadHook.onSendPack(this, wantIds, commonBase);\n         } else {\n             preUploadHook.onSendPack(this, wantAll, commonBase);\n         }\n-    } catch (UploadPackMayNotContinueException noPack) {\n+    } catch (ServiceMayNotContinueException noPack) {\n         if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n             noPack.setOutput();\n             SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n             err.write(Constants.encode(noPack.getMessage()));\n             err.flush();\n         }\n         throw noPack;\n     }\n     PackConfig cfg \u003d packConfig;\n     if (cfg \u003d\u003d null)\n         cfg \u003d new PackConfig(db);\n     final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n     try {\n         pw.setUseCachedPacks(true);\n         pw.setReuseDeltaCommits(true);\n         pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n         pw.setThin(options.contains(OPTION_THIN_PACK));\n         pw.setReuseValidatingObjects(false);\n         if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n             Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n             for (Ref ref : refs.values()) {\n                 if (ref.getPeeledObjectId() !\u003d null)\n                     tagTargets.add(ref.getPeeledObjectId());\n                 else if (ref.getObjectId() \u003d\u003d null)\n                     continue;\n                 else if (ref.getName().startsWith(Constants.R_HEADS))\n                     tagTargets.add(ref.getObjectId());\n             }\n             pw.setTagTargets(tagTargets);\n         }\n         if (depth \u003e 0)\n             pw.setShallowPack(depth, unshallowCommits);\n         RevWalk rw \u003d walk;\n         if (wantAll.isEmpty()) {\n             pw.preparePack(pm, wantIds, commonBase);\n         } else {\n             walk.reset();\n             ObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n             pw.preparePack(pm, ow, wantAll, commonBase);\n             rw \u003d ow;\n         }\n         if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n             for (Ref ref : refs.values()) {\n                 ObjectId objectId \u003d ref.getObjectId();\n                 if (wantAll.isEmpty()) {\n                     if (wantIds.contains(objectId))\n                         continue;\n                 } else {\n                     RevObject obj \u003d rw.lookupOrNull(objectId);\n                     if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                         continue;\n                 }\n                 if (!ref.isPeeled())\n                     ref \u003d db.peel(ref);\n                 ObjectId peeledId \u003d ref.getPeeledObjectId();\n                 if (peeledId \u003d\u003d null)\n                     continue;\n                 objectId \u003d ref.getObjectId();\n                 if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n                     pw.addObject(rw.parseAny(objectId));\n             }\n         }\n         pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n         statistics \u003d pw.getStatistics();\n         if (msgOut !\u003d null) {\n             String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n             msgOut.write(Constants.encode(msg));\n             msgOut.flush();\n         }\n     } finally {\n         pw.release();\n     }\n     if (sideband)\n         pckOut.end();\n     if (statistics !\u003d null)\n         logger.onPackStatistics(statistics);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d6172dc0de2cbaeb0bd38a9d30278dd5f9b140b3": {
      "type": "Ybodychange",
      "commitMessage": "Add a no-op UploadPackLogger and use it by default\n\nThis matches the behavior of the hooks in UploadPack.\n\nChange-Id: I21277e52ee9452237d87084f06bb140dfa6bf608\n",
      "commitDate": "2011/12/9 上午12:26",
      "commitName": "d6172dc0de2cbaeb0bd38a9d30278dd5f9b140b3",
      "commitAuthor": "Dave Borowitz",
      "commitDateOld": "2011/9/15 上午6:34",
      "commitNameOld": "01888db892aa9590862d886c01f3b293140db153",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 84.74,
      "commitsBetweenForRepo": 94,
      "commitsBetweenForFile": 1,
      "actualSource": "private void sendPack(final boolean sideband) throws IOException {\n    ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n    OutputStream packOut \u003d rawOut;\n    SideBandOutputStream msgOut \u003d null;\n    if (sideband) {\n        int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz \u003d SideBandOutputStream.MAX_BUF;\n        packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm \u003d new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n    } catch (UploadPackMayNotContinueException noPack) {\n        if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n            noPack.setOutput();\n            SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg \u003d packConfig;\n    if (cfg \u003d\u003d null)\n        cfg \u003d new PackConfig(db);\n    final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n    try {\n        pw.setUseCachedPacks(true);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n            Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() !\u003d null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() \u003d\u003d null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        if (depth \u003e 0)\n            pw.setShallowPack(depth, unshallowCommits);\n        RevWalk rw \u003d walk;\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase);\n        } else {\n            walk.reset();\n            ObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase);\n            rw \u003d ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId \u003d ref.getObjectId();\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj \u003d rw.lookupOrNull(objectId);\n                    if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref \u003d db.peel(ref);\n                ObjectId peeledId \u003d ref.getPeeledObjectId();\n                if (peeledId \u003d\u003d null)\n                    continue;\n                objectId \u003d ref.getObjectId();\n                if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n                    pw.addObject(rw.parseAny(objectId));\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        statistics \u003d pw.getStatistics();\n        if (msgOut !\u003d null) {\n            String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        pw.release();\n    }\n    if (sideband)\n        pckOut.end();\n    if (statistics !\u003d null)\n        logger.onPackStatistics(statistics);\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
      "functionStartLine": 1001,
      "functionName": "sendPack",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,98 +1,98 @@\n private void sendPack(final boolean sideband) throws IOException {\n     ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n     OutputStream packOut \u003d rawOut;\n     SideBandOutputStream msgOut \u003d null;\n     if (sideband) {\n         int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n         if (options.contains(OPTION_SIDE_BAND_64K))\n             bufsz \u003d SideBandOutputStream.MAX_BUF;\n         packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n         if (!options.contains(OPTION_NO_PROGRESS)) {\n             msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n             pm \u003d new SideBandProgressMonitor(msgOut);\n         }\n     }\n     try {\n         if (wantAll.isEmpty()) {\n             preUploadHook.onSendPack(this, wantIds, commonBase);\n         } else {\n             preUploadHook.onSendPack(this, wantAll, commonBase);\n         }\n     } catch (UploadPackMayNotContinueException noPack) {\n         if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n             noPack.setOutput();\n             SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n             err.write(Constants.encode(noPack.getMessage()));\n             err.flush();\n         }\n         throw noPack;\n     }\n     PackConfig cfg \u003d packConfig;\n     if (cfg \u003d\u003d null)\n         cfg \u003d new PackConfig(db);\n     final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n     try {\n         pw.setUseCachedPacks(true);\n         pw.setReuseDeltaCommits(true);\n         pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n         pw.setThin(options.contains(OPTION_THIN_PACK));\n         pw.setReuseValidatingObjects(false);\n         if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n             Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n             for (Ref ref : refs.values()) {\n                 if (ref.getPeeledObjectId() !\u003d null)\n                     tagTargets.add(ref.getPeeledObjectId());\n                 else if (ref.getObjectId() \u003d\u003d null)\n                     continue;\n                 else if (ref.getName().startsWith(Constants.R_HEADS))\n                     tagTargets.add(ref.getObjectId());\n             }\n             pw.setTagTargets(tagTargets);\n         }\n         if (depth \u003e 0)\n             pw.setShallowPack(depth, unshallowCommits);\n         RevWalk rw \u003d walk;\n         if (wantAll.isEmpty()) {\n             pw.preparePack(pm, wantIds, commonBase);\n         } else {\n             walk.reset();\n             ObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n             pw.preparePack(pm, ow, wantAll, commonBase);\n             rw \u003d ow;\n         }\n         if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n             for (Ref ref : refs.values()) {\n                 ObjectId objectId \u003d ref.getObjectId();\n                 if (wantAll.isEmpty()) {\n                     if (wantIds.contains(objectId))\n                         continue;\n                 } else {\n                     RevObject obj \u003d rw.lookupOrNull(objectId);\n                     if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                         continue;\n                 }\n                 if (!ref.isPeeled())\n                     ref \u003d db.peel(ref);\n                 ObjectId peeledId \u003d ref.getPeeledObjectId();\n                 if (peeledId \u003d\u003d null)\n                     continue;\n                 objectId \u003d ref.getObjectId();\n                 if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n                     pw.addObject(rw.parseAny(objectId));\n             }\n         }\n         pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n         statistics \u003d pw.getStatistics();\n         if (msgOut !\u003d null) {\n             String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n             msgOut.write(Constants.encode(msg));\n             msgOut.flush();\n         }\n     } finally {\n         pw.release();\n     }\n     if (sideband)\n         pckOut.end();\n-    if (logger !\u003d null \u0026\u0026 statistics !\u003d null)\n+    if (statistics !\u003d null)\n         logger.onPackStatistics(statistics);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "01888db892aa9590862d886c01f3b293140db153": {
      "type": "Ybodychange",
      "commitMessage": "UploadPack: Fix races in smart HTTP negotiation\n\nClients cache the set of advertised references at the start of a\nnegotiation, and keep replaying the same \"want SHA1\" list to the\nserver on each negotiation step.  If another client pushes into\na branch and moves it by fast-forward, any request to obtain that\nbranch\u0027s prior SHA-1 is still valid, the commit is reachable from\nthe new position of the reference.  Unfortunately the fast-forward\ncauses smart HTTP negotations to fail, as the server no longer is\nadvertising that prior SHA-1.\n\nInstead of causing clients to fail out with a \"want invalid\" error\nand forcing the end-user retry, possibly getting into a never ending\ntry-fail-retry race while other clients are pushing into the same\nbusy repository, allow the slightly stale want request so long as\nit is still reachable.\n\nC Git implemented this same change recently to fix races on the\nsmart HTTP protocol when the C Git git-http-backend is used.\n\nThe new RequestPolicy feature also allows server authors to make\nan even more lenient configuration that exports any SHA-1 to the\nclient. This might be useful in certain settings where a server\nhas authenticated the client as the \"repository owner\" and wants\nto allow them to grab any content from the server as a complete\nunbroken history chain.\n\nThe new setAdvertisedRefs() method allows server authors to manually\nfix the references that are advertised, possibly bypassing the\ngetAllRefs() call on the Repository object.\n\nChange-Id: I7cdb563bf9c55c83653f217f6e53c3add55a0541\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2011/9/15 上午6:34",
      "commitName": "01888db892aa9590862d886c01f3b293140db153",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2011/8/22 上午5:04",
      "commitNameOld": "9952223e0645fd7a8cddc6093a7f449c6390238d",
      "commitAuthorOld": "Matt Fischer",
      "daysBetweenCommits": 24.06,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "actualSource": "private void sendPack(final boolean sideband) throws IOException {\n    ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n    OutputStream packOut \u003d rawOut;\n    SideBandOutputStream msgOut \u003d null;\n    if (sideband) {\n        int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz \u003d SideBandOutputStream.MAX_BUF;\n        packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm \u003d new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n    } catch (UploadPackMayNotContinueException noPack) {\n        if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n            noPack.setOutput();\n            SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg \u003d packConfig;\n    if (cfg \u003d\u003d null)\n        cfg \u003d new PackConfig(db);\n    final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n    try {\n        pw.setUseCachedPacks(true);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n            Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() !\u003d null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() \u003d\u003d null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        if (depth \u003e 0)\n            pw.setShallowPack(depth, unshallowCommits);\n        RevWalk rw \u003d walk;\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase);\n        } else {\n            walk.reset();\n            ObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase);\n            rw \u003d ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId \u003d ref.getObjectId();\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj \u003d rw.lookupOrNull(objectId);\n                    if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref \u003d db.peel(ref);\n                ObjectId peeledId \u003d ref.getPeeledObjectId();\n                if (peeledId \u003d\u003d null)\n                    continue;\n                objectId \u003d ref.getObjectId();\n                if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n                    pw.addObject(rw.parseAny(objectId));\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        statistics \u003d pw.getStatistics();\n        if (msgOut !\u003d null) {\n            String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        pw.release();\n    }\n    if (sideband)\n        pckOut.end();\n    if (logger !\u003d null \u0026\u0026 statistics !\u003d null)\n        logger.onPackStatistics(statistics);\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
      "functionStartLine": 996,
      "functionName": "sendPack",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,98 +1,98 @@\n private void sendPack(final boolean sideband) throws IOException {\n     ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n     OutputStream packOut \u003d rawOut;\n     SideBandOutputStream msgOut \u003d null;\n     if (sideband) {\n         int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n         if (options.contains(OPTION_SIDE_BAND_64K))\n             bufsz \u003d SideBandOutputStream.MAX_BUF;\n         packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n         if (!options.contains(OPTION_NO_PROGRESS)) {\n             msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n             pm \u003d new SideBandProgressMonitor(msgOut);\n         }\n     }\n     try {\n         if (wantAll.isEmpty()) {\n             preUploadHook.onSendPack(this, wantIds, commonBase);\n         } else {\n             preUploadHook.onSendPack(this, wantAll, commonBase);\n         }\n     } catch (UploadPackMayNotContinueException noPack) {\n         if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n             noPack.setOutput();\n             SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n             err.write(Constants.encode(noPack.getMessage()));\n             err.flush();\n         }\n         throw noPack;\n     }\n     PackConfig cfg \u003d packConfig;\n     if (cfg \u003d\u003d null)\n         cfg \u003d new PackConfig(db);\n     final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n     try {\n         pw.setUseCachedPacks(true);\n         pw.setReuseDeltaCommits(true);\n         pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n         pw.setThin(options.contains(OPTION_THIN_PACK));\n         pw.setReuseValidatingObjects(false);\n-        if (commonBase.isEmpty()) {\n+        if (commonBase.isEmpty() \u0026\u0026 refs !\u003d null) {\n             Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n             for (Ref ref : refs.values()) {\n                 if (ref.getPeeledObjectId() !\u003d null)\n                     tagTargets.add(ref.getPeeledObjectId());\n                 else if (ref.getObjectId() \u003d\u003d null)\n                     continue;\n                 else if (ref.getName().startsWith(Constants.R_HEADS))\n                     tagTargets.add(ref.getObjectId());\n             }\n             pw.setTagTargets(tagTargets);\n         }\n         if (depth \u003e 0)\n             pw.setShallowPack(depth, unshallowCommits);\n         RevWalk rw \u003d walk;\n         if (wantAll.isEmpty()) {\n             pw.preparePack(pm, wantIds, commonBase);\n         } else {\n             walk.reset();\n             ObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n             pw.preparePack(pm, ow, wantAll, commonBase);\n             rw \u003d ow;\n         }\n-        if (options.contains(OPTION_INCLUDE_TAG)) {\n+        if (options.contains(OPTION_INCLUDE_TAG) \u0026\u0026 refs !\u003d null) {\n             for (Ref ref : refs.values()) {\n                 ObjectId objectId \u003d ref.getObjectId();\n                 if (wantAll.isEmpty()) {\n                     if (wantIds.contains(objectId))\n                         continue;\n                 } else {\n                     RevObject obj \u003d rw.lookupOrNull(objectId);\n                     if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                         continue;\n                 }\n                 if (!ref.isPeeled())\n                     ref \u003d db.peel(ref);\n                 ObjectId peeledId \u003d ref.getPeeledObjectId();\n                 if (peeledId \u003d\u003d null)\n                     continue;\n                 objectId \u003d ref.getObjectId();\n                 if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n                     pw.addObject(rw.parseAny(objectId));\n             }\n         }\n         pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n         statistics \u003d pw.getStatistics();\n         if (msgOut !\u003d null) {\n             String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n             msgOut.write(Constants.encode(msg));\n             msgOut.flush();\n         }\n     } finally {\n         pw.release();\n     }\n     if (sideband)\n         pckOut.end();\n     if (logger !\u003d null \u0026\u0026 statistics !\u003d null)\n         logger.onPackStatistics(statistics);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9952223e0645fd7a8cddc6093a7f449c6390238d": {
      "type": "Ybodychange",
      "commitMessage": "Implement server support for shallow clones\n\nThis implements the server side of shallow clones only (i.e.\ngit-upload-pack), not the client side.\n\nCQ: 5517\nBug: 301627\nChange-Id: Ied5f501f9c8d1fe90ab2ba44fac5fa67ed0035a4\nSigned-off-by: Chris Aniszczyk \u003ccaniszczyk@gmail.com\u003e\n",
      "commitDate": "2011/8/22 上午5:04",
      "commitName": "9952223e0645fd7a8cddc6093a7f449c6390238d",
      "commitAuthor": "Matt Fischer",
      "commitDateOld": "2011/8/17 上午3:18",
      "commitNameOld": "74333e63b60440be5ff9f591f2203b635e26e3a0",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 5.07,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "private void sendPack(final boolean sideband) throws IOException {\n    ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n    OutputStream packOut \u003d rawOut;\n    SideBandOutputStream msgOut \u003d null;\n    if (sideband) {\n        int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz \u003d SideBandOutputStream.MAX_BUF;\n        packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm \u003d new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n    } catch (UploadPackMayNotContinueException noPack) {\n        if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n            noPack.setOutput();\n            SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg \u003d packConfig;\n    if (cfg \u003d\u003d null)\n        cfg \u003d new PackConfig(db);\n    final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n    try {\n        pw.setUseCachedPacks(true);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty()) {\n            Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() !\u003d null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() \u003d\u003d null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        if (depth \u003e 0)\n            pw.setShallowPack(depth, unshallowCommits);\n        RevWalk rw \u003d walk;\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase);\n        } else {\n            walk.reset();\n            ObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase);\n            rw \u003d ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG)) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId \u003d ref.getObjectId();\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj \u003d rw.lookupOrNull(objectId);\n                    if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref \u003d db.peel(ref);\n                ObjectId peeledId \u003d ref.getPeeledObjectId();\n                if (peeledId \u003d\u003d null)\n                    continue;\n                objectId \u003d ref.getObjectId();\n                if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n                    pw.addObject(rw.parseAny(objectId));\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        statistics \u003d pw.getStatistics();\n        if (msgOut !\u003d null) {\n            String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        pw.release();\n    }\n    if (sideband)\n        pckOut.end();\n    if (logger !\u003d null \u0026\u0026 statistics !\u003d null)\n        logger.onPackStatistics(statistics);\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
      "functionStartLine": 896,
      "functionName": "sendPack",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,96 +1,98 @@\n private void sendPack(final boolean sideband) throws IOException {\n     ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n     OutputStream packOut \u003d rawOut;\n     SideBandOutputStream msgOut \u003d null;\n     if (sideband) {\n         int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n         if (options.contains(OPTION_SIDE_BAND_64K))\n             bufsz \u003d SideBandOutputStream.MAX_BUF;\n         packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n         if (!options.contains(OPTION_NO_PROGRESS)) {\n             msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n             pm \u003d new SideBandProgressMonitor(msgOut);\n         }\n     }\n     try {\n         if (wantAll.isEmpty()) {\n             preUploadHook.onSendPack(this, wantIds, commonBase);\n         } else {\n             preUploadHook.onSendPack(this, wantAll, commonBase);\n         }\n     } catch (UploadPackMayNotContinueException noPack) {\n         if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n             noPack.setOutput();\n             SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n             err.write(Constants.encode(noPack.getMessage()));\n             err.flush();\n         }\n         throw noPack;\n     }\n     PackConfig cfg \u003d packConfig;\n     if (cfg \u003d\u003d null)\n         cfg \u003d new PackConfig(db);\n     final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n     try {\n         pw.setUseCachedPacks(true);\n         pw.setReuseDeltaCommits(true);\n         pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n         pw.setThin(options.contains(OPTION_THIN_PACK));\n         pw.setReuseValidatingObjects(false);\n         if (commonBase.isEmpty()) {\n             Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n             for (Ref ref : refs.values()) {\n                 if (ref.getPeeledObjectId() !\u003d null)\n                     tagTargets.add(ref.getPeeledObjectId());\n                 else if (ref.getObjectId() \u003d\u003d null)\n                     continue;\n                 else if (ref.getName().startsWith(Constants.R_HEADS))\n                     tagTargets.add(ref.getObjectId());\n             }\n             pw.setTagTargets(tagTargets);\n         }\n+        if (depth \u003e 0)\n+            pw.setShallowPack(depth, unshallowCommits);\n         RevWalk rw \u003d walk;\n         if (wantAll.isEmpty()) {\n             pw.preparePack(pm, wantIds, commonBase);\n         } else {\n             walk.reset();\n             ObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n             pw.preparePack(pm, ow, wantAll, commonBase);\n             rw \u003d ow;\n         }\n         if (options.contains(OPTION_INCLUDE_TAG)) {\n             for (Ref ref : refs.values()) {\n                 ObjectId objectId \u003d ref.getObjectId();\n                 if (wantAll.isEmpty()) {\n                     if (wantIds.contains(objectId))\n                         continue;\n                 } else {\n                     RevObject obj \u003d rw.lookupOrNull(objectId);\n                     if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                         continue;\n                 }\n                 if (!ref.isPeeled())\n                     ref \u003d db.peel(ref);\n                 ObjectId peeledId \u003d ref.getPeeledObjectId();\n                 if (peeledId \u003d\u003d null)\n                     continue;\n                 objectId \u003d ref.getObjectId();\n                 if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n                     pw.addObject(rw.parseAny(objectId));\n             }\n         }\n         pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n         statistics \u003d pw.getStatistics();\n         if (msgOut !\u003d null) {\n             String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n             msgOut.write(Constants.encode(msg));\n             msgOut.flush();\n         }\n     } finally {\n         pw.release();\n     }\n     if (sideband)\n         pckOut.end();\n     if (logger !\u003d null \u0026\u0026 statistics !\u003d null)\n         logger.onPackStatistics(statistics);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7ff6eb584cf8b83f83a3b5edf897feb53dbf42c0": {
      "type": "Yintroduced",
      "commitMessage": "Push errors back over sideband when possible\n\nIf an internal exception occurs while packing and the request\nneeds to abort, the HTTP response might already be committed due\nto progress message having already been delivered to the client.\nThis prevents UploadPackServlet from resetting the response and\nsending back an HTTP 500 response.\n\nTry to catch all exceptions and report internal errors over the\nsideband stream or as an ERR command during the initial ACK/NAK\nnegotiation phase. This allows JGit to transmit an error message\nthat the user will receive on their console without needing to\nworry about resetting the (already gone) HTTP response.\n\nChange-Id: Ie393fb8bb55d2b79ab1276adf71c781c1807f9fe\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2011/6/10 上午8:29",
      "commitName": "7ff6eb584cf8b83f83a3b5edf897feb53dbf42c0",
      "commitAuthor": "Shawn O. Pearce",
      "diff": "@@ -0,0 +1,96 @@\n+private void sendPack(final boolean sideband) throws IOException {\n+    ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n+    OutputStream packOut \u003d rawOut;\n+    SideBandOutputStream msgOut \u003d null;\n+    if (sideband) {\n+        int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n+        if (options.contains(OPTION_SIDE_BAND_64K))\n+            bufsz \u003d SideBandOutputStream.MAX_BUF;\n+        packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n+        if (!options.contains(OPTION_NO_PROGRESS)) {\n+            msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n+            pm \u003d new SideBandProgressMonitor(msgOut);\n+        }\n+    }\n+    try {\n+        if (wantAll.isEmpty()) {\n+            preUploadHook.onSendPack(this, wantIds, commonBase);\n+        } else {\n+            preUploadHook.onSendPack(this, wantAll, commonBase);\n+        }\n+    } catch (UploadPackMayNotContinueException noPack) {\n+        if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n+            noPack.setOutput();\n+            SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n+            err.write(Constants.encode(noPack.getMessage()));\n+            err.flush();\n+        }\n+        throw noPack;\n+    }\n+    PackConfig cfg \u003d packConfig;\n+    if (cfg \u003d\u003d null)\n+        cfg \u003d new PackConfig(db);\n+    final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n+    try {\n+        pw.setUseCachedPacks(true);\n+        pw.setReuseDeltaCommits(true);\n+        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n+        pw.setThin(options.contains(OPTION_THIN_PACK));\n+        pw.setReuseValidatingObjects(false);\n+        if (commonBase.isEmpty()) {\n+            Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n+            for (Ref ref : refs.values()) {\n+                if (ref.getPeeledObjectId() !\u003d null)\n+                    tagTargets.add(ref.getPeeledObjectId());\n+                else if (ref.getObjectId() \u003d\u003d null)\n+                    continue;\n+                else if (ref.getName().startsWith(Constants.R_HEADS))\n+                    tagTargets.add(ref.getObjectId());\n+            }\n+            pw.setTagTargets(tagTargets);\n+        }\n+        RevWalk rw \u003d walk;\n+        if (wantAll.isEmpty()) {\n+            pw.preparePack(pm, wantIds, commonBase);\n+        } else {\n+            walk.reset();\n+            ObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n+            pw.preparePack(pm, ow, wantAll, commonBase);\n+            rw \u003d ow;\n+        }\n+        if (options.contains(OPTION_INCLUDE_TAG)) {\n+            for (Ref ref : refs.values()) {\n+                ObjectId objectId \u003d ref.getObjectId();\n+                if (wantAll.isEmpty()) {\n+                    if (wantIds.contains(objectId))\n+                        continue;\n+                } else {\n+                    RevObject obj \u003d rw.lookupOrNull(objectId);\n+                    if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n+                        continue;\n+                }\n+                if (!ref.isPeeled())\n+                    ref \u003d db.peel(ref);\n+                ObjectId peeledId \u003d ref.getPeeledObjectId();\n+                if (peeledId \u003d\u003d null)\n+                    continue;\n+                objectId \u003d ref.getObjectId();\n+                if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n+                    pw.addObject(rw.parseAny(objectId));\n+            }\n+        }\n+        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n+        statistics \u003d pw.getStatistics();\n+        if (msgOut !\u003d null) {\n+            String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n+            msgOut.write(Constants.encode(msg));\n+            msgOut.flush();\n+        }\n+    } finally {\n+        pw.release();\n+    }\n+    if (sideband)\n+        pckOut.end();\n+    if (logger !\u003d null \u0026\u0026 statistics !\u003d null)\n+        logger.onPackStatistics(statistics);\n+}\n\\ No newline at end of file\n",
      "actualSource": "private void sendPack(final boolean sideband) throws IOException {\n    ProgressMonitor pm \u003d NullProgressMonitor.INSTANCE;\n    OutputStream packOut \u003d rawOut;\n    SideBandOutputStream msgOut \u003d null;\n    if (sideband) {\n        int bufsz \u003d SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz \u003d SideBandOutputStream.MAX_BUF;\n        packOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut \u003d new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm \u003d new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n    } catch (UploadPackMayNotContinueException noPack) {\n        if (sideband \u0026\u0026 noPack.getMessage() !\u003d null) {\n            noPack.setOutput();\n            SideBandOutputStream err \u003d new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg \u003d packConfig;\n    if (cfg \u003d\u003d null)\n        cfg \u003d new PackConfig(db);\n    final PackWriter pw \u003d new PackWriter(cfg, walk.getObjectReader());\n    try {\n        pw.setUseCachedPacks(true);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty()) {\n            Set\u003cObjectId\u003e tagTargets \u003d new HashSet\u003cObjectId\u003e();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() !\u003d null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() \u003d\u003d null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        RevWalk rw \u003d walk;\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase);\n        } else {\n            walk.reset();\n            ObjectWalk ow \u003d walk.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase);\n            rw \u003d ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG)) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId \u003d ref.getObjectId();\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj \u003d rw.lookupOrNull(objectId);\n                    if (obj !\u003d null \u0026\u0026 obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref \u003d db.peel(ref);\n                ObjectId peeledId \u003d ref.getPeeledObjectId();\n                if (peeledId \u003d\u003d null)\n                    continue;\n                objectId \u003d ref.getObjectId();\n                if (pw.willInclude(peeledId) \u0026\u0026 !pw.willInclude(objectId))\n                    pw.addObject(rw.parseAny(objectId));\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        statistics \u003d pw.getStatistics();\n        if (msgOut !\u003d null) {\n            String msg \u003d pw.getStatistics().getMessage() + \u0027\\n\u0027;\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        pw.release();\n    }\n    if (sideband)\n        pckOut.end();\n    if (logger !\u003d null \u0026\u0026 statistics !\u003d null)\n        logger.onPackStatistics(statistics);\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
      "functionStartLine": 829,
      "functionName": "sendPack",
      "functionAnnotation": "",
      "functionDoc": ""
    }
  }
}