{
  "statementVersions": [
    {
      "commit": "9540bc37583dfd4e995b893154039fcf031dc3c3",
      "startLine": 2,
      "endLine": 13,
      "methodCode": "protected synchronized void updateMergeThreads() {\n    final List<MergeThread> activeMerges = new ArrayList<>();\n    int threadIdx = 0;\n    while (threadIdx < mergeThreads.size()) {\n        final MergeThread mergeThread = mergeThreads.get(threadIdx);\n        if (!mergeThread.isAlive()) {\n            mergeThreads.remove(threadIdx);\n            continue;\n        }\n        activeMerges.add(mergeThread);\n        threadIdx++;\n    }\n    CollectionUtil.timSort(activeMerges);\n    final int activeMergeCount = activeMerges.size();\n    int bigMergeCount = 0;\n    for (threadIdx = activeMergeCount - 1; threadIdx >= 0; threadIdx--) {\n        MergeThread mergeThread = activeMerges.get(threadIdx);\n        if (mergeThread.merge.estimatedMergeBytes > MIN_BIG_MERGE_MB * 1024 * 1024) {\n            bigMergeCount = 1 + threadIdx;\n            break;\n        }\n    }\n    long now = System.nanoTime();\n    StringBuilder message;\n    if (verbose()) {\n        message = new StringBuilder();\n        message.append(String.format(Locale.ROOT, \"updateMergeThreads ioThrottle=%s targetMBPerSec=%.1f MB/sec\", doAutoIOThrottle, targetMBPerSec));\n    } else {\n        message = null;\n    }\n    for (threadIdx = 0; threadIdx < activeMergeCount; threadIdx++) {\n        MergeThread mergeThread = activeMerges.get(threadIdx);\n        OneMerge merge = mergeThread.merge;\n        final boolean doPause = threadIdx < bigMergeCount - maxThreadCount;\n        double newMBPerSec;\n        if (doPause) {\n            newMBPerSec = 0.0;\n        } else if (merge.maxNumSegments != -1) {\n            newMBPerSec = forceMergeMBPerSec;\n        } else if (doAutoIOThrottle == false) {\n            newMBPerSec = Double.POSITIVE_INFINITY;\n        } else if (merge.estimatedMergeBytes < MIN_BIG_MERGE_MB * 1024 * 1024) {\n            newMBPerSec = Double.POSITIVE_INFINITY;\n        } else {\n            newMBPerSec = targetMBPerSec;\n        }\n        MergeRateLimiter rateLimiter = mergeThread.rateLimiter;\n        double curMBPerSec = rateLimiter.getMBPerSec();\n        if (verbose()) {\n            long mergeStartNS = merge.mergeStartNS;\n            if (mergeStartNS == -1) {\n                mergeStartNS = now;\n            }\n            message.append('\\n');\n            message.append(String.format(Locale.ROOT, \"merge thread %s estSize=%.1f MB (written=%.1f MB) runTime=%.1fs (stopped=%.1fs, paused=%.1fs) rate=%s\\n\", mergeThread.getName(), bytesToMB(merge.estimatedMergeBytes), bytesToMB(rateLimiter.getTotalBytesWritten()), nsToSec(now - mergeStartNS), nsToSec(rateLimiter.getTotalStoppedNS()), nsToSec(rateLimiter.getTotalPausedNS()), rateToString(rateLimiter.getMBPerSec())));\n            if (newMBPerSec != curMBPerSec) {\n                if (newMBPerSec == 0.0) {\n                    message.append(\"  now stop\");\n                } else if (curMBPerSec == 0.0) {\n                    if (newMBPerSec == Double.POSITIVE_INFINITY) {\n                        message.append(\"  now resume\");\n                    } else {\n                        message.append(String.format(Locale.ROOT, \"  now resume to %.1f MB/sec\", newMBPerSec));\n                    }\n                } else {\n                    message.append(String.format(Locale.ROOT, \"  now change from %.1f MB/sec to %.1f MB/sec\", curMBPerSec, newMBPerSec));\n                }\n            } else if (curMBPerSec == 0.0) {\n                message.append(\"  leave stopped\");\n            } else {\n                message.append(String.format(Locale.ROOT, \"  leave running at %.1f MB/sec\", curMBPerSec));\n            }\n        }\n        rateLimiter.setMBPerSec(newMBPerSec);\n    }\n    if (verbose()) {\n        message(message.toString());\n    }\n}"
    },
    {
      "commit": "41fcc722ff07393586f7758d8a733c7e2e59bebc",
      "startLine": 2,
      "endLine": 13,
      "methodCode": "protected synchronized void updateMergeThreads() {\n    final List<MergeThread> activeMerges = new ArrayList<>();\n    int threadIdx = 0;\n    while (threadIdx < mergeThreads.size()) {\n        final MergeThread mergeThread = mergeThreads.get(threadIdx);\n        if (!mergeThread.isAlive()) {\n            mergeThreads.remove(threadIdx);\n            continue;\n        }\n        activeMerges.add(mergeThread);\n        threadIdx++;\n    }\n    CollectionUtil.timSort(activeMerges);\n    final int activeMergeCount = activeMerges.size();\n    int bigMergeCount = 0;\n    for (threadIdx = activeMergeCount - 1; threadIdx >= 0; threadIdx--) {\n        MergeThread mergeThread = activeMerges.get(threadIdx);\n        if (mergeThread.merge.estimatedMergeBytes > MIN_BIG_MERGE_MB * 1024 * 1024) {\n            bigMergeCount = 1 + threadIdx;\n            break;\n        }\n    }\n    long now = System.nanoTime();\n    StringBuilder message;\n    if (verbose()) {\n        message = new StringBuilder();\n        message.append(String.format(Locale.ROOT, \"updateMergeThreads ioThrottle=%s targetMBPerSec=%.1f MB/sec\", doAutoIOThrottle, targetMBPerSec));\n    } else {\n        message = null;\n    }\n    for (threadIdx = 0; threadIdx < activeMergeCount; threadIdx++) {\n        MergeThread mergeThread = activeMerges.get(threadIdx);\n        OneMerge merge = mergeThread.merge;\n        final boolean doPause = threadIdx < bigMergeCount - maxThreadCount;\n        double newMBPerSec;\n        if (doPause) {\n            newMBPerSec = 0.0;\n        } else if (merge.maxNumSegments != -1) {\n            newMBPerSec = forceMergeMBPerSec;\n        } else if (doAutoIOThrottle == false) {\n            newMBPerSec = Double.POSITIVE_INFINITY;\n        } else if (merge.estimatedMergeBytes < MIN_BIG_MERGE_MB * 1024 * 1024) {\n            newMBPerSec = Double.POSITIVE_INFINITY;\n        } else {\n            newMBPerSec = targetMBPerSec;\n        }\n        double curMBPerSec = merge.rateLimiter.getMBPerSec();\n        if (verbose()) {\n            long mergeStartNS = merge.mergeStartNS;\n            if (mergeStartNS == -1) {\n                mergeStartNS = now;\n            }\n            message.append('\\n');\n            message.append(String.format(Locale.ROOT, \"merge thread %s estSize=%.1f MB (written=%.1f MB) runTime=%.1fs (stopped=%.1fs, paused=%.1fs) rate=%s\\n\", mergeThread.getName(), bytesToMB(merge.estimatedMergeBytes), bytesToMB(merge.rateLimiter.totalBytesWritten), nsToSec(now - mergeStartNS), nsToSec(merge.rateLimiter.getTotalStoppedNS()), nsToSec(merge.rateLimiter.getTotalPausedNS()), rateToString(merge.rateLimiter.getMBPerSec())));\n            if (newMBPerSec != curMBPerSec) {\n                if (newMBPerSec == 0.0) {\n                    message.append(\"  now stop\");\n                } else if (curMBPerSec == 0.0) {\n                    if (newMBPerSec == Double.POSITIVE_INFINITY) {\n                        message.append(\"  now resume\");\n                    } else {\n                        message.append(String.format(Locale.ROOT, \"  now resume to %.1f MB/sec\", newMBPerSec));\n                    }\n                } else {\n                    message.append(String.format(Locale.ROOT, \"  now change from %.1f MB/sec to %.1f MB/sec\", curMBPerSec, newMBPerSec));\n                }\n            } else if (curMBPerSec == 0.0) {\n                message.append(\"  leave stopped\");\n            } else {\n                message.append(String.format(Locale.ROOT, \"  leave running at %.1f MB/sec\", curMBPerSec));\n            }\n        }\n        merge.rateLimiter.setMBPerSec(newMBPerSec);\n    }\n    if (verbose()) {\n        message(message.toString());\n    }\n}"
    },
    {
      "commit": "bab0b4633710f050886ab940095fd04cac824820",
      "startLine": 2,
      "endLine": 15,
      "methodCode": "protected synchronized void updateMergeThreads() {\n    final List<MergeThread> activeMerges = new ArrayList<>();\n    int threadIdx = 0;\n    while (threadIdx < mergeThreads.size()) {\n        final MergeThread mergeThread = mergeThreads.get(threadIdx);\n        if (!mergeThread.isAlive()) {\n            mergeThreads.remove(threadIdx);\n            continue;\n        }\n        if (mergeThread.getCurrentMerge() != null) {\n            activeMerges.add(mergeThread);\n        }\n        threadIdx++;\n    }\n    CollectionUtil.timSort(activeMerges, compareByMergeDocCount);\n    int pri = mergeThreadPriority;\n    final int activeMergeCount = activeMerges.size();\n    for (threadIdx = 0; threadIdx < activeMergeCount; threadIdx++) {\n        final MergeThread mergeThread = activeMerges.get(threadIdx);\n        final MergePolicy.OneMerge merge = mergeThread.getCurrentMerge();\n        if (merge == null) {\n            continue;\n        }\n        final boolean doPause = threadIdx < activeMergeCount - maxThreadCount;\n        if (verbose()) {\n            if (doPause != merge.getPause()) {\n                if (doPause) {\n                    message(\"pause thread \" + mergeThread.getName());\n                } else {\n                    message(\"unpause thread \" + mergeThread.getName());\n                }\n            }\n        }\n        if (doPause != merge.getPause()) {\n            merge.setPause(doPause);\n        }\n        if (!doPause) {\n            if (verbose()) {\n                message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n            }\n            mergeThread.setThreadPriority(pri);\n            pri = Math.min(Thread.MAX_PRIORITY, 1 + pri);\n        }\n    }\n}"
    },
    {
      "commit": "3b67b17493216f6b0c81a981073fd5f61eace6f4",
      "startLine": 2,
      "endLine": 15,
      "methodCode": "protected synchronized void updateMergeThreads() {\n    final List<MergeThread> activeMerges = new ArrayList<>();\n    int threadIdx = 0;\n    while (threadIdx < mergeThreads.size()) {\n        final MergeThread mergeThread = mergeThreads.get(threadIdx);\n        if (!mergeThread.isAlive()) {\n            mergeThreads.remove(threadIdx);\n            continue;\n        }\n        if (mergeThread.getCurrentMerge() != null) {\n            activeMerges.add(mergeThread);\n        }\n        threadIdx++;\n    }\n    CollectionUtil.timSort(activeMerges, compareByMergeDocCount);\n    int pri = mergeThreadPriority;\n    final int activeMergeCount = activeMerges.size();\n    for (threadIdx = 0; threadIdx < activeMergeCount; threadIdx++) {\n        final MergeThread mergeThread = activeMerges.get(threadIdx);\n        final MergePolicy.OneMerge merge = mergeThread.getCurrentMerge();\n        if (merge == null) {\n            continue;\n        }\n        final boolean doPause = threadIdx < activeMergeCount - maxThreadCount;\n        if (verbose()) {\n            if (doPause != merge.getPause()) {\n                if (doPause) {\n                    message(\"pause thread \" + mergeThread.getName());\n                } else {\n                    message(\"unpause thread \" + mergeThread.getName());\n                }\n            }\n        }\n        if (doPause != merge.getPause()) {\n            merge.setPause(doPause);\n        }\n        if (!doPause) {\n            if (verbose()) {\n                message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n            }\n            mergeThread.setThreadPriority(pri);\n            pri = Math.min(Thread.MAX_PRIORITY, 1 + pri);\n        }\n    }\n}"
    },
    {
      "commit": "b895ebde4340ed8ae903c7ae51750da3d9837394",
      "startLine": 2,
      "endLine": 15,
      "methodCode": "protected synchronized void updateMergeThreads() {\n    final List<MergeThread> activeMerges = new ArrayList<MergeThread>();\n    int threadIdx = 0;\n    while (threadIdx < mergeThreads.size()) {\n        final MergeThread mergeThread = mergeThreads.get(threadIdx);\n        if (!mergeThread.isAlive()) {\n            mergeThreads.remove(threadIdx);\n            continue;\n        }\n        if (mergeThread.getCurrentMerge() != null) {\n            activeMerges.add(mergeThread);\n        }\n        threadIdx++;\n    }\n    CollectionUtil.timSort(activeMerges, compareByMergeDocCount);\n    int pri = mergeThreadPriority;\n    final int activeMergeCount = activeMerges.size();\n    for (threadIdx = 0; threadIdx < activeMergeCount; threadIdx++) {\n        final MergeThread mergeThread = activeMerges.get(threadIdx);\n        final MergePolicy.OneMerge merge = mergeThread.getCurrentMerge();\n        if (merge == null) {\n            continue;\n        }\n        final boolean doPause = threadIdx < activeMergeCount - maxThreadCount;\n        if (verbose()) {\n            if (doPause != merge.getPause()) {\n                if (doPause) {\n                    message(\"pause thread \" + mergeThread.getName());\n                } else {\n                    message(\"unpause thread \" + mergeThread.getName());\n                }\n            }\n        }\n        if (doPause != merge.getPause()) {\n            merge.setPause(doPause);\n        }\n        if (!doPause) {\n            if (verbose()) {\n                message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n            }\n            mergeThread.setThreadPriority(pri);\n            pri = Math.min(Thread.MAX_PRIORITY, 1 + pri);\n        }\n    }\n}"
    },
    {
      "commit": "eb0ab3d392a42c1835f79bcd7f5404bcc50c8e4c",
      "startLine": 2,
      "endLine": 15,
      "methodCode": "protected synchronized void updateMergeThreads() {\n    final List<MergeThread> activeMerges = new ArrayList<MergeThread>();\n    int threadIdx = 0;\n    while (threadIdx < mergeThreads.size()) {\n        final MergeThread mergeThread = mergeThreads.get(threadIdx);\n        if (!mergeThread.isAlive()) {\n            mergeThreads.remove(threadIdx);\n            continue;\n        }\n        if (mergeThread.getCurrentMerge() != null) {\n            activeMerges.add(mergeThread);\n        }\n        threadIdx++;\n    }\n    CollectionUtil.mergeSort(activeMerges, compareByMergeDocCount);\n    int pri = mergeThreadPriority;\n    final int activeMergeCount = activeMerges.size();\n    for (threadIdx = 0; threadIdx < activeMergeCount; threadIdx++) {\n        final MergeThread mergeThread = activeMerges.get(threadIdx);\n        final MergePolicy.OneMerge merge = mergeThread.getCurrentMerge();\n        if (merge == null) {\n            continue;\n        }\n        final boolean doPause = threadIdx < activeMergeCount - maxThreadCount;\n        if (verbose()) {\n            if (doPause != merge.getPause()) {\n                if (doPause) {\n                    message(\"pause thread \" + mergeThread.getName());\n                } else {\n                    message(\"unpause thread \" + mergeThread.getName());\n                }\n            }\n        }\n        if (doPause != merge.getPause()) {\n            merge.setPause(doPause);\n        }\n        if (!doPause) {\n            if (verbose()) {\n                message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n            }\n            mergeThread.setThreadPriority(pri);\n            pri = Math.min(Thread.MAX_PRIORITY, 1 + pri);\n        }\n    }\n}"
    },
    {
      "commit": "3a76e3a8f59a7c65662e1fae898f076e73a51685",
      "startLine": 2,
      "endLine": 15,
      "methodCode": "protected synchronized void updateMergeThreads() {\n    final List<MergeThread> activeMerges = new ArrayList<MergeThread>();\n    int threadIdx = 0;\n    while (threadIdx < mergeThreads.size()) {\n        final MergeThread mergeThread = mergeThreads.get(threadIdx);\n        if (!mergeThread.isAlive()) {\n            mergeThreads.remove(threadIdx);\n            continue;\n        }\n        if (mergeThread.getCurrentMerge() != null) {\n            activeMerges.add(mergeThread);\n        }\n        threadIdx++;\n    }\n    CollectionUtil.mergeSort(activeMerges, compareByMergeDocCount);\n    int pri = mergeThreadPriority;\n    final int activeMergeCount = activeMerges.size();\n    for (threadIdx = 0; threadIdx < activeMergeCount; threadIdx++) {\n        final MergeThread mergeThread = activeMerges.get(threadIdx);\n        final MergePolicy.OneMerge merge = mergeThread.getCurrentMerge();\n        if (merge == null) {\n            continue;\n        }\n        final boolean doPause = threadIdx < activeMergeCount - maxThreadCount;\n        if (verbose()) {\n            if (doPause != merge.getPause()) {\n                if (doPause) {\n                    message(\"pause thread \" + mergeThread.getName());\n                } else {\n                    message(\"unpause thread \" + mergeThread.getName());\n                }\n            }\n        }\n        if (doPause != merge.getPause()) {\n            merge.setPause(doPause);\n        }\n        if (!doPause) {\n            if (verbose()) {\n                message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n            }\n            mergeThread.setThreadPriority(pri);\n            pri = Math.min(Thread.MAX_PRIORITY, 1 + pri);\n        }\n    }\n}"
    },
    {
      "commit": "9906198ff3d65f8c9b7e99462aab19feb5334790",
      "startLine": 2,
      "endLine": 15,
      "methodCode": "protected synchronized void updateMergeThreads() {\n    final List<MergeThread> activeMerges = new ArrayList<MergeThread>();\n    int threadIdx = 0;\n    while (threadIdx < mergeThreads.size()) {\n        final MergeThread mergeThread = mergeThreads.get(threadIdx);\n        if (!mergeThread.isAlive()) {\n            mergeThreads.remove(threadIdx);\n            continue;\n        }\n        if (mergeThread.getCurrentMerge() != null) {\n            activeMerges.add(mergeThread);\n        }\n        threadIdx++;\n    }\n    CollectionUtil.mergeSort(activeMerges, compareByMergeDocCount);\n    int pri = mergeThreadPriority;\n    final int activeMergeCount = activeMerges.size();\n    for (threadIdx = 0; threadIdx < activeMergeCount; threadIdx++) {\n        final MergeThread mergeThread = activeMerges.get(threadIdx);\n        final MergePolicy.OneMerge merge = mergeThread.getCurrentMerge();\n        if (merge == null) {\n            continue;\n        }\n        final boolean doPause = threadIdx < activeMergeCount - maxThreadCount;\n        if (verbose()) {\n            if (doPause != merge.getPause()) {\n                if (doPause) {\n                    message(\"pause thread \" + mergeThread.getName());\n                } else {\n                    message(\"unpause thread \" + mergeThread.getName());\n                }\n            }\n        }\n        if (doPause != merge.getPause()) {\n            merge.setPause(doPause);\n        }\n        if (!doPause) {\n            if (verbose()) {\n                message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n            }\n            mergeThread.setThreadPriority(pri);\n            pri = Math.min(Thread.MAX_PRIORITY, 1 + pri);\n        }\n    }\n}"
    },
    {
      "commit": "765eab4008f44bb655b3dbbe4cc625455711536b",
      "startLine": 2,
      "endLine": 15,
      "methodCode": "protected synchronized void updateMergeThreads() {\n    final List<MergeThread> activeMerges = new ArrayList<MergeThread>();\n    int threadIdx = 0;\n    while (threadIdx < mergeThreads.size()) {\n        final MergeThread mergeThread = mergeThreads.get(threadIdx);\n        if (!mergeThread.isAlive()) {\n            mergeThreads.remove(threadIdx);\n            continue;\n        }\n        if (mergeThread.getCurrentMerge() != null) {\n            activeMerges.add(mergeThread);\n        }\n        threadIdx++;\n    }\n    CollectionUtil.mergeSort(activeMerges, compareByMergeDocCount);\n    int pri = mergeThreadPriority;\n    final int activeMergeCount = activeMerges.size();\n    for (threadIdx = 0; threadIdx < activeMergeCount; threadIdx++) {\n        final MergeThread mergeThread = activeMerges.get(threadIdx);\n        final MergePolicy.OneMerge merge = mergeThread.getCurrentMerge();\n        if (merge == null) {\n            continue;\n        }\n        final boolean doPause;\n        if (threadIdx < activeMergeCount - maxThreadCount) {\n            doPause = true;\n        } else {\n            doPause = false;\n        }\n        if (verbose()) {\n            if (doPause != merge.getPause()) {\n                if (doPause) {\n                    message(\"pause thread \" + mergeThread.getName());\n                } else {\n                    message(\"unpause thread \" + mergeThread.getName());\n                }\n            }\n        }\n        if (doPause != merge.getPause()) {\n            merge.setPause(doPause);\n        }\n        if (!doPause) {\n            if (verbose()) {\n                message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n            }\n            mergeThread.setThreadPriority(pri);\n            pri = Math.min(Thread.MAX_PRIORITY, 1 + pri);\n        }\n    }\n}"
    },
    {
      "commit": "65b27c2adb9000b64ccd9d3a3b1a5030550b06da",
      "startLine": 2,
      "endLine": 2,
      "methodCode": "protected synchronized void updateMergeThreads() {\n    CollectionUtil.mergeSort(mergeThreads, compareByMergeDocCount);\n    final int count = mergeThreads.size();\n    int pri = mergeThreadPriority;\n    for (int i = 0; i < count; i++) {\n        final MergeThread mergeThread = mergeThreads.get(i);\n        final MergePolicy.OneMerge merge = mergeThread.getCurrentMerge();\n        if (merge == null) {\n            continue;\n        }\n        final boolean doPause;\n        if (i < count - maxThreadCount) {\n            doPause = true;\n        } else {\n            doPause = false;\n        }\n        if (verbose()) {\n            if (doPause != merge.getPause()) {\n                if (doPause) {\n                    message(\"pause thread \" + mergeThread.getName());\n                } else {\n                    message(\"unpause thread \" + mergeThread.getName());\n                }\n            }\n        }\n        if (doPause != merge.getPause()) {\n            merge.setPause(doPause);\n        }\n        if (!doPause) {\n            if (verbose()) {\n                message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n            }\n            mergeThread.setThreadPriority(pri);\n            pri = Math.min(Thread.MAX_PRIORITY, 1 + pri);\n        }\n    }\n}"
    },
    {
      "commit": "5f9bb3f0a860097352abfc5b4c2ac7d486c06c80",
      "startLine": 15,
      "endLine": 15,
      "methodCode": "protected synchronized void updateMergeThreads() {\n    final List<MergeThread> activeMerges = new ArrayList<MergeThread>();\n    int threadIdx = 0;\n    while (threadIdx < mergeThreads.size()) {\n        final MergeThread mergeThread = mergeThreads.get(threadIdx);\n        if (!mergeThread.isAlive()) {\n            mergeThreads.remove(threadIdx);\n            continue;\n        }\n        if (mergeThread.getCurrentMerge() != null) {\n            activeMerges.add(mergeThread);\n        }\n        threadIdx++;\n    }\n    CollectionUtil.mergeSort(activeMerges, compareByMergeDocCount);\n    int pri = mergeThreadPriority;\n    final int activeMergeCount = activeMerges.size();\n    for (threadIdx = 0; threadIdx < activeMergeCount; threadIdx++) {\n        final MergeThread mergeThread = activeMerges.get(threadIdx);\n        final MergePolicy.OneMerge merge = mergeThread.getCurrentMerge();\n        if (merge == null) {\n            continue;\n        }\n        final boolean doPause;\n        if (threadIdx < activeMergeCount - maxThreadCount) {\n            doPause = true;\n        } else {\n            doPause = false;\n        }\n        if (verbose()) {\n            if (doPause != merge.getPause()) {\n                if (doPause) {\n                    message(\"pause thread \" + mergeThread.getName());\n                } else {\n                    message(\"unpause thread \" + mergeThread.getName());\n                }\n            }\n        }\n        if (doPause != merge.getPause()) {\n            merge.setPause(doPause);\n        }\n        if (!doPause) {\n            if (verbose()) {\n                message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n            }\n            mergeThread.setThreadPriority(pri);\n            pri = Math.min(Thread.MAX_PRIORITY, 1 + pri);\n        }\n    }\n}"
    },
    {
      "commit": "717c67ab7c2df6901f056ae2a1b5cd8317166b93",
      "startLine": 2,
      "endLine": 2,
      "methodCode": "protected synchronized void updateMergeThreads() {\n    CollectionUtil.mergeSort(mergeThreads, compareByMergeDocCount);\n    final int count = mergeThreads.size();\n    int pri = mergeThreadPriority;\n    for (int i = 0; i < count; i++) {\n        final MergeThread mergeThread = mergeThreads.get(i);\n        final MergePolicy.OneMerge merge = mergeThread.getCurrentMerge();\n        if (merge == null) {\n            continue;\n        }\n        final boolean doPause;\n        if (i < count - maxThreadCount) {\n            doPause = true;\n        } else {\n            doPause = false;\n        }\n        if (verbose()) {\n            if (doPause != merge.getPause()) {\n                if (doPause) {\n                    message(\"pause thread \" + mergeThread.getName());\n                } else {\n                    message(\"unpause thread \" + mergeThread.getName());\n                }\n            }\n        }\n        if (doPause != merge.getPause()) {\n            merge.setPause(doPause);\n        }\n        if (!doPause) {\n            if (verbose()) {\n                message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n            }\n            mergeThread.setThreadPriority(pri);\n            pri = Math.min(Thread.MAX_PRIORITY, 1 + pri);\n        }\n    }\n}"
    },
    {
      "commit": "778d96752fa94636a2136ea2b4d58a3fcbe283ec",
      "startLine": 2,
      "endLine": 2,
      "methodCode": "protected synchronized void updateMergeThreads() {\n    Collections.sort(mergeThreads, new CompareByMergeDocCount());\n    final int count = mergeThreads.size();\n    int pri = mergeThreadPriority;\n    for (int i = 0; i < count; i++) {\n        final MergeThread mergeThread = mergeThreads.get(i);\n        final MergePolicy.OneMerge merge = mergeThread.getCurrentMerge();\n        if (merge == null) {\n            continue;\n        }\n        final boolean doPause;\n        if (i < count - maxThreadCount) {\n            doPause = true;\n        } else {\n            doPause = false;\n        }\n        if (verbose()) {\n            if (doPause != merge.getPause()) {\n                if (doPause) {\n                    message(\"pause thread \" + mergeThread.getName());\n                } else {\n                    message(\"unpause thread \" + mergeThread.getName());\n                }\n            }\n        }\n        if (doPause != merge.getPause()) {\n            merge.setPause(doPause);\n        }\n        if (!doPause) {\n            if (verbose()) {\n                message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n            }\n            mergeThread.setThreadPriority(pri);\n            pri = Math.min(Thread.MAX_PRIORITY, 1 + pri);\n        }\n    }\n}"
    },
    {
      "commit": "7d35aafe71661e51ee01639ddf88503184610329",
      "startLine": 2,
      "endLine": 2,
      "methodCode": "protected synchronized void updateMergeThreads() {\n    Collections.sort(mergeThreads, new CompareByMergeDocCount());\n    final int count = mergeThreads.size();\n    int pri = mergeThreadPriority;\n    for (int i = 0; i < count; i++) {\n        final MergeThread mergeThread = mergeThreads.get(i);\n        final MergePolicy.OneMerge merge = mergeThread.getCurrentMerge();\n        if (merge == null) {\n            continue;\n        }\n        final boolean doPause;\n        if (i < count - maxThreadCount) {\n            doPause = true;\n        } else {\n            doPause = false;\n        }\n        if (verbose()) {\n            if (doPause != merge.getPause()) {\n                if (doPause) {\n                    message(\"pause thread \" + mergeThread.getName());\n                } else {\n                    message(\"unpause thread \" + mergeThread.getName());\n                }\n            }\n        }\n        if (doPause != merge.getPause()) {\n            merge.setPause(doPause);\n        }\n        if (!doPause) {\n            if (verbose()) {\n                message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n            }\n            mergeThread.setThreadPriority(pri);\n            pri = Math.min(Thread.MAX_PRIORITY, 1 + pri);\n        }\n    }\n}"
    }
  ]
}