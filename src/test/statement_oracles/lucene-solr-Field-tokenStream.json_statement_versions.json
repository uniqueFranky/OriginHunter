{
  "statementVersions": [
    {
      "commit": "105c7eae87896762cbcb295c73c8e8b1fd8f71f8",
      "startLine": 3,
      "endLine": 22,
      "methodCode": "@Override\npublic TokenStream tokenStream(Analyzer analyzer, TokenStream reuse) {\n    if (fieldType().indexOptions() == IndexOptions.NONE) {\n        return null;\n    }\n    if (!fieldType().tokenized()) {\n        if (stringValue() != null) {\n            if (!(reuse instanceof StringTokenStream)) {\n                reuse = new StringTokenStream();\n            }\n            ((StringTokenStream) reuse).setValue(stringValue());\n            return reuse;\n        } else if (binaryValue() != null) {\n            if (!(reuse instanceof BinaryTokenStream)) {\n                reuse = new BinaryTokenStream();\n            }\n            ((BinaryTokenStream) reuse).setValue(binaryValue());\n            return reuse;\n        } else {\n            throw new IllegalArgumentException(\"Non-Tokenized Fields must have a String value\");\n        }\n    }\n    if (tokenStream != null) {\n        return tokenStream;\n    } else if (readerValue() != null) {\n        return analyzer.tokenStream(name(), readerValue());\n    } else if (stringValue() != null) {\n        return analyzer.tokenStream(name(), stringValue());\n    }\n    throw new IllegalArgumentException(\"Field must have either TokenStream, String, Reader or Number value; got \" + this);\n}"
    },
    {
      "commit": "75dd5e9f9e13c72890f1e5b1695f8281fe990d94",
      "startLine": 3,
      "endLine": 47,
      "methodCode": "@Override\npublic TokenStream tokenStream(Analyzer analyzer, TokenStream reuse) {\n    if (fieldType().indexOptions() == IndexOptions.NONE) {\n        return null;\n    }\n    final FieldType.LegacyNumericType numericType = fieldType().numericType();\n    if (numericType != null) {\n        if (!(reuse instanceof LegacyNumericTokenStream && ((LegacyNumericTokenStream) reuse).getPrecisionStep() == type.numericPrecisionStep())) {\n            reuse = new LegacyNumericTokenStream(type.numericPrecisionStep());\n        }\n        final LegacyNumericTokenStream nts = (LegacyNumericTokenStream) reuse;\n        final Number val = (Number) fieldsData;\n        switch(numericType) {\n            case INT:\n                nts.setIntValue(val.intValue());\n                break;\n            case LONG:\n                nts.setLongValue(val.longValue());\n                break;\n            case FLOAT:\n                nts.setFloatValue(val.floatValue());\n                break;\n            case DOUBLE:\n                nts.setDoubleValue(val.doubleValue());\n                break;\n            default:\n                throw new AssertionError(\"Should never get here\");\n        }\n        return reuse;\n    }\n    if (!fieldType().tokenized()) {\n        if (stringValue() != null) {\n            if (!(reuse instanceof StringTokenStream)) {\n                reuse = new StringTokenStream();\n            }\n            ((StringTokenStream) reuse).setValue(stringValue());\n            return reuse;\n        } else if (binaryValue() != null) {\n            if (!(reuse instanceof BinaryTokenStream)) {\n                reuse = new BinaryTokenStream();\n            }\n            ((BinaryTokenStream) reuse).setValue(binaryValue());\n            return reuse;\n        } else {\n            throw new IllegalArgumentException(\"Non-Tokenized Fields must have a String value\");\n        }\n    }\n    if (tokenStream != null) {\n        return tokenStream;\n    } else if (readerValue() != null) {\n        return analyzer.tokenStream(name(), readerValue());\n    } else if (stringValue() != null) {\n        return analyzer.tokenStream(name(), stringValue());\n    }\n    throw new IllegalArgumentException(\"Field must have either TokenStream, String, Reader or Number value; got \" + this);\n}"
    },
    {
      "commit": "7da175b0b6b4185ee6b5df852e59b93d9a9a1c86",
      "startLine": 3,
      "endLine": 47,
      "methodCode": "@Override\npublic TokenStream tokenStream(Analyzer analyzer, TokenStream reuse) throws IOException {\n    if (fieldType().indexOptions() == IndexOptions.NONE) {\n        return null;\n    }\n    final FieldType.LegacyNumericType numericType = fieldType().numericType();\n    if (numericType != null) {\n        if (!(reuse instanceof LegacyNumericTokenStream && ((LegacyNumericTokenStream) reuse).getPrecisionStep() == type.numericPrecisionStep())) {\n            reuse = new LegacyNumericTokenStream(type.numericPrecisionStep());\n        }\n        final LegacyNumericTokenStream nts = (LegacyNumericTokenStream) reuse;\n        final Number val = (Number) fieldsData;\n        switch(numericType) {\n            case INT:\n                nts.setIntValue(val.intValue());\n                break;\n            case LONG:\n                nts.setLongValue(val.longValue());\n                break;\n            case FLOAT:\n                nts.setFloatValue(val.floatValue());\n                break;\n            case DOUBLE:\n                nts.setDoubleValue(val.doubleValue());\n                break;\n            default:\n                throw new AssertionError(\"Should never get here\");\n        }\n        return reuse;\n    }\n    if (!fieldType().tokenized()) {\n        if (stringValue() != null) {\n            if (!(reuse instanceof StringTokenStream)) {\n                reuse = new StringTokenStream();\n            }\n            ((StringTokenStream) reuse).setValue(stringValue());\n            return reuse;\n        } else if (binaryValue() != null) {\n            if (!(reuse instanceof BinaryTokenStream)) {\n                reuse = new BinaryTokenStream();\n            }\n            ((BinaryTokenStream) reuse).setValue(binaryValue());\n            return reuse;\n        } else {\n            throw new IllegalArgumentException(\"Non-Tokenized Fields must have a String value\");\n        }\n    }\n    if (tokenStream != null) {\n        return tokenStream;\n    } else if (readerValue() != null) {\n        return analyzer.tokenStream(name(), readerValue());\n    } else if (stringValue() != null) {\n        return analyzer.tokenStream(name(), stringValue());\n    }\n    throw new IllegalArgumentException(\"Field must have either TokenStream, String, Reader or Number value; got \" + this);\n}"
    },
    {
      "commit": "249d0d25fec0c8d3aeaa8991b22c96317b6db86a",
      "startLine": 3,
      "endLine": 47,
      "methodCode": "@Override\npublic TokenStream tokenStream(Analyzer analyzer, TokenStream reuse) throws IOException {\n    if (fieldType().indexOptions() == IndexOptions.NONE) {\n        return null;\n    }\n    final NumericType numericType = fieldType().numericType();\n    if (numericType != null) {\n        if (!(reuse instanceof NumericTokenStream && ((NumericTokenStream) reuse).getPrecisionStep() == type.numericPrecisionStep())) {\n            reuse = new NumericTokenStream(type.numericPrecisionStep());\n        }\n        final NumericTokenStream nts = (NumericTokenStream) reuse;\n        final Number val = (Number) fieldsData;\n        switch(numericType) {\n            case INT:\n                nts.setIntValue(val.intValue());\n                break;\n            case LONG:\n                nts.setLongValue(val.longValue());\n                break;\n            case FLOAT:\n                nts.setFloatValue(val.floatValue());\n                break;\n            case DOUBLE:\n                nts.setDoubleValue(val.doubleValue());\n                break;\n            default:\n                throw new AssertionError(\"Should never get here\");\n        }\n        return reuse;\n    }\n    if (!fieldType().tokenized()) {\n        if (stringValue() != null) {\n            if (!(reuse instanceof StringTokenStream)) {\n                reuse = new StringTokenStream();\n            }\n            ((StringTokenStream) reuse).setValue(stringValue());\n            return reuse;\n        } else if (binaryValue() != null) {\n            if (!(reuse instanceof BinaryTokenStream)) {\n                reuse = new BinaryTokenStream();\n            }\n            ((BinaryTokenStream) reuse).setValue(binaryValue());\n            return reuse;\n        } else {\n            throw new IllegalArgumentException(\"Non-Tokenized Fields must have a String value\");\n        }\n    }\n    if (tokenStream != null) {\n        return tokenStream;\n    } else if (readerValue() != null) {\n        return analyzer.tokenStream(name(), readerValue());\n    } else if (stringValue() != null) {\n        return analyzer.tokenStream(name(), stringValue());\n    }\n    throw new IllegalArgumentException(\"Field must have either TokenStream, String, Reader or Number value; got \" + this);\n}"
    },
    {
      "commit": "6bf44e94399e474ba3285d442ce6406cdadc1d9e",
      "startLine": 3,
      "endLine": 40,
      "methodCode": "@Override\npublic TokenStream tokenStream(Analyzer analyzer, TokenStream reuse) throws IOException {\n    if (fieldType().indexOptions() == IndexOptions.NONE) {\n        return null;\n    }\n    final NumericType numericType = fieldType().numericType();\n    if (numericType != null) {\n        if (!(reuse instanceof NumericTokenStream && ((NumericTokenStream) reuse).getPrecisionStep() == type.numericPrecisionStep())) {\n            reuse = new NumericTokenStream(type.numericPrecisionStep());\n        }\n        final NumericTokenStream nts = (NumericTokenStream) reuse;\n        final Number val = (Number) fieldsData;\n        switch(numericType) {\n            case INT:\n                nts.setIntValue(val.intValue());\n                break;\n            case LONG:\n                nts.setLongValue(val.longValue());\n                break;\n            case FLOAT:\n                nts.setFloatValue(val.floatValue());\n                break;\n            case DOUBLE:\n                nts.setDoubleValue(val.doubleValue());\n                break;\n            default:\n                throw new AssertionError(\"Should never get here\");\n        }\n        return reuse;\n    }\n    if (!fieldType().tokenized()) {\n        if (stringValue() == null) {\n            throw new IllegalArgumentException(\"Non-Tokenized Fields must have a String value\");\n        }\n        if (!(reuse instanceof StringTokenStream)) {\n            reuse = new StringTokenStream();\n        }\n        ((StringTokenStream) reuse).setValue(stringValue());\n        return reuse;\n    }\n    if (tokenStream != null) {\n        return tokenStream;\n    } else if (readerValue() != null) {\n        return analyzer.tokenStream(name(), readerValue());\n    } else if (stringValue() != null) {\n        return analyzer.tokenStream(name(), stringValue());\n    }\n    throw new IllegalArgumentException(\"Field must have either TokenStream, String, Reader or Number value; got \" + this);\n}"
    },
    {
      "commit": "bc41d58cd37ab38c1a088ea67197bd3c338ac53f",
      "startLine": 3,
      "endLine": 40,
      "methodCode": "@Override\npublic TokenStream tokenStream(Analyzer analyzer, TokenStream reuse) throws IOException {\n    if (fieldType().indexOptions() == IndexOptions.NO) {\n        return null;\n    }\n    final NumericType numericType = fieldType().numericType();\n    if (numericType != null) {\n        if (!(reuse instanceof NumericTokenStream && ((NumericTokenStream) reuse).getPrecisionStep() == type.numericPrecisionStep())) {\n            reuse = new NumericTokenStream(type.numericPrecisionStep());\n        }\n        final NumericTokenStream nts = (NumericTokenStream) reuse;\n        final Number val = (Number) fieldsData;\n        switch(numericType) {\n            case INT:\n                nts.setIntValue(val.intValue());\n                break;\n            case LONG:\n                nts.setLongValue(val.longValue());\n                break;\n            case FLOAT:\n                nts.setFloatValue(val.floatValue());\n                break;\n            case DOUBLE:\n                nts.setDoubleValue(val.doubleValue());\n                break;\n            default:\n                throw new AssertionError(\"Should never get here\");\n        }\n        return reuse;\n    }\n    if (!fieldType().tokenized()) {\n        if (stringValue() == null) {\n            throw new IllegalArgumentException(\"Non-Tokenized Fields must have a String value\");\n        }\n        if (!(reuse instanceof StringTokenStream)) {\n            reuse = new StringTokenStream();\n        }\n        ((StringTokenStream) reuse).setValue(stringValue());\n        return reuse;\n    }\n    if (tokenStream != null) {\n        return tokenStream;\n    } else if (readerValue() != null) {\n        return analyzer.tokenStream(name(), readerValue());\n    } else if (stringValue() != null) {\n        return analyzer.tokenStream(name(), stringValue());\n    }\n    throw new IllegalArgumentException(\"Field must have either TokenStream, String, Reader or Number value; got \" + this);\n}"
    },
    {
      "commit": "8f9f8a3252c73428e67bc5d390e58d1370e060ba",
      "startLine": 3,
      "endLine": 40,
      "methodCode": "@Override\npublic TokenStream tokenStream(Analyzer analyzer, TokenStream reuse) throws IOException {\n    if (fieldType().indexOptions() == null) {\n        return null;\n    }\n    final NumericType numericType = fieldType().numericType();\n    if (numericType != null) {\n        if (!(reuse instanceof NumericTokenStream && ((NumericTokenStream) reuse).getPrecisionStep() == type.numericPrecisionStep())) {\n            reuse = new NumericTokenStream(type.numericPrecisionStep());\n        }\n        final NumericTokenStream nts = (NumericTokenStream) reuse;\n        final Number val = (Number) fieldsData;\n        switch(numericType) {\n            case INT:\n                nts.setIntValue(val.intValue());\n                break;\n            case LONG:\n                nts.setLongValue(val.longValue());\n                break;\n            case FLOAT:\n                nts.setFloatValue(val.floatValue());\n                break;\n            case DOUBLE:\n                nts.setDoubleValue(val.doubleValue());\n                break;\n            default:\n                throw new AssertionError(\"Should never get here\");\n        }\n        return reuse;\n    }\n    if (!fieldType().tokenized()) {\n        if (stringValue() == null) {\n            throw new IllegalArgumentException(\"Non-Tokenized Fields must have a String value\");\n        }\n        if (!(reuse instanceof StringTokenStream)) {\n            reuse = new StringTokenStream();\n        }\n        ((StringTokenStream) reuse).setValue(stringValue());\n        return reuse;\n    }\n    if (tokenStream != null) {\n        return tokenStream;\n    } else if (readerValue() != null) {\n        return analyzer.tokenStream(name(), readerValue());\n    } else if (stringValue() != null) {\n        return analyzer.tokenStream(name(), stringValue());\n    }\n    throw new IllegalArgumentException(\"Field must have either TokenStream, String, Reader or Number value; got \" + this);\n}"
    },
    {
      "commit": "1613f1882c00f28f12570e4f75f913a663e1e2c0",
      "startLine": 3,
      "endLine": 40,
      "methodCode": "@Override\npublic TokenStream tokenStream(Analyzer analyzer, TokenStream reuse) throws IOException {\n    if (!fieldType().indexed()) {\n        return null;\n    }\n    final NumericType numericType = fieldType().numericType();\n    if (numericType != null) {\n        if (!(reuse instanceof NumericTokenStream && ((NumericTokenStream) reuse).getPrecisionStep() == type.numericPrecisionStep())) {\n            reuse = new NumericTokenStream(type.numericPrecisionStep());\n        }\n        final NumericTokenStream nts = (NumericTokenStream) reuse;\n        final Number val = (Number) fieldsData;\n        switch(numericType) {\n            case INT:\n                nts.setIntValue(val.intValue());\n                break;\n            case LONG:\n                nts.setLongValue(val.longValue());\n                break;\n            case FLOAT:\n                nts.setFloatValue(val.floatValue());\n                break;\n            case DOUBLE:\n                nts.setDoubleValue(val.doubleValue());\n                break;\n            default:\n                throw new AssertionError(\"Should never get here\");\n        }\n        return reuse;\n    }\n    if (!fieldType().tokenized()) {\n        if (stringValue() == null) {\n            throw new IllegalArgumentException(\"Non-Tokenized Fields must have a String value\");\n        }\n        if (!(reuse instanceof StringTokenStream)) {\n            reuse = new StringTokenStream();\n        }\n        ((StringTokenStream) reuse).setValue(stringValue());\n        return reuse;\n    }\n    if (tokenStream != null) {\n        return tokenStream;\n    } else if (readerValue() != null) {\n        return analyzer.tokenStream(name(), readerValue());\n    } else if (stringValue() != null) {\n        return analyzer.tokenStream(name(), stringValue());\n    }\n    throw new IllegalArgumentException(\"Field must have either TokenStream, String, Reader or Number value; got \" + this);\n}"
    },
    {
      "commit": "43974d668667ba1b1dacf26a18a22c7fea909539",
      "startLine": 3,
      "endLine": 40,
      "methodCode": "@Override\npublic TokenStream tokenStream(Analyzer analyzer) throws IOException {\n    if (!fieldType().indexed()) {\n        return null;\n    }\n    final NumericType numericType = fieldType().numericType();\n    if (numericType != null) {\n        if (!(internalTokenStream instanceof NumericTokenStream)) {\n            internalTokenStream = new NumericTokenStream(type.numericPrecisionStep());\n        }\n        final NumericTokenStream nts = (NumericTokenStream) internalTokenStream;\n        final Number val = (Number) fieldsData;\n        switch(numericType) {\n            case INT:\n                nts.setIntValue(val.intValue());\n                break;\n            case LONG:\n                nts.setLongValue(val.longValue());\n                break;\n            case FLOAT:\n                nts.setFloatValue(val.floatValue());\n                break;\n            case DOUBLE:\n                nts.setDoubleValue(val.doubleValue());\n                break;\n            default:\n                throw new AssertionError(\"Should never get here\");\n        }\n        return internalTokenStream;\n    }\n    if (!fieldType().tokenized()) {\n        if (stringValue() == null) {\n            throw new IllegalArgumentException(\"Non-Tokenized Fields must have a String value\");\n        }\n        if (!(internalTokenStream instanceof StringTokenStream)) {\n            internalTokenStream = new StringTokenStream();\n        }\n        ((StringTokenStream) internalTokenStream).setValue(stringValue());\n        return internalTokenStream;\n    }\n    if (tokenStream != null) {\n        return tokenStream;\n    } else if (readerValue() != null) {\n        return analyzer.tokenStream(name(), readerValue());\n    } else if (stringValue() != null) {\n        return analyzer.tokenStream(name(), stringValue());\n    }\n    throw new IllegalArgumentException(\"Field must have either TokenStream, String, Reader or Number value; got \" + this);\n}"
    },
    {
      "commit": "18117c0b04620e0e4bb7403fca5d05d35665de08",
      "startLine": 3,
      "endLine": 40,
      "methodCode": "@Override\npublic TokenStream tokenStream(Analyzer analyzer) throws IOException {\n    if (!fieldType().indexed()) {\n        return null;\n    }\n    final NumericType numericType = fieldType().numericType();\n    if (numericType != null) {\n        if (!(internalTokenStream instanceof NumericTokenStream)) {\n            internalTokenStream = new NumericTokenStream(type.numericPrecisionStep());\n        }\n        final NumericTokenStream nts = (NumericTokenStream) internalTokenStream;\n        final Number val = (Number) fieldsData;\n        switch(numericType) {\n            case INT:\n                nts.setIntValue(val.intValue());\n                break;\n            case LONG:\n                nts.setLongValue(val.longValue());\n                break;\n            case FLOAT:\n                nts.setFloatValue(val.floatValue());\n                break;\n            case DOUBLE:\n                nts.setDoubleValue(val.doubleValue());\n                break;\n            default:\n                throw new AssertionError(\"Should never get here\");\n        }\n        return internalTokenStream;\n    }\n    if (!fieldType().tokenized()) {\n        if (stringValue() == null) {\n            throw new IllegalArgumentException(\"Non-Tokenized Fields must have a String value\");\n        }\n        if (!(internalTokenStream instanceof StringTokenStream)) {\n            internalTokenStream = new StringTokenStream();\n        }\n        ((StringTokenStream) internalTokenStream).setValue(stringValue());\n        return internalTokenStream;\n    }\n    if (tokenStream != null) {\n        return tokenStream;\n    } else if (readerValue() != null) {\n        return analyzer.tokenStream(name(), readerValue());\n    } else if (stringValue() != null) {\n        return analyzer.tokenStream(name(), stringValue());\n    }\n    throw new IllegalArgumentException(\"Field must have either TokenStream, String, Reader or Number value; this=\" + this);\n}"
    },
    {
      "commit": "f092795fe94ba727f7368b63d8eb1ecd39749fc4",
      "startLine": 3,
      "endLine": 40,
      "methodCode": "@Override\npublic TokenStream tokenStream(Analyzer analyzer) throws IOException {\n    if (!fieldType().indexed()) {\n        return null;\n    }\n    final NumericType numericType = fieldType().numericType();\n    if (numericType != null) {\n        if (!(internalTokenStream instanceof NumericTokenStream)) {\n            internalTokenStream = new NumericTokenStream(type.numericPrecisionStep());\n        }\n        final NumericTokenStream nts = (NumericTokenStream) internalTokenStream;\n        final Number val = (Number) fieldsData;\n        switch(numericType) {\n            case INT:\n                nts.setIntValue(val.intValue());\n                break;\n            case LONG:\n                nts.setLongValue(val.longValue());\n                break;\n            case FLOAT:\n                nts.setFloatValue(val.floatValue());\n                break;\n            case DOUBLE:\n                nts.setDoubleValue(val.doubleValue());\n                break;\n            default:\n                throw new AssertionError(\"Should never get here\");\n        }\n        return internalTokenStream;\n    }\n    if (!fieldType().tokenized()) {\n        if (stringValue() == null) {\n            throw new IllegalArgumentException(\"Non-Tokenized Fields must have a String value\");\n        }\n        if (!(internalTokenStream instanceof StringTokenStream)) {\n            internalTokenStream = new StringTokenStream();\n        }\n        ((StringTokenStream) internalTokenStream).setValue(stringValue());\n        return internalTokenStream;\n    }\n    if (tokenStream != null) {\n        return tokenStream;\n    } else if (readerValue() != null) {\n        return analyzer.tokenStream(name(), readerValue());\n    } else if (stringValue() != null) {\n        return analyzer.tokenStream(name(), stringValue());\n    }\n    throw new IllegalArgumentException(\"Field must have either TokenStream, String, Reader or Number value\");\n}"
    },
    {
      "commit": "e2f54df3ca7639f143b195f75adbc5ee97187b92",
      "startLine": 3,
      "endLine": 40,
      "methodCode": "@Override\npublic TokenStream tokenStream(Analyzer analyzer) throws IOException {\n    if (!fieldType().indexed()) {\n        return null;\n    }\n    final NumericType numericType = fieldType().numericType();\n    if (numericType != null) {\n        if (!(internalTokenStream instanceof NumericTokenStream)) {\n            internalTokenStream = new NumericTokenStream(type.numericPrecisionStep());\n        }\n        final NumericTokenStream nts = (NumericTokenStream) internalTokenStream;\n        final Number val = (Number) fieldsData;\n        switch(numericType) {\n            case INT:\n                nts.setIntValue(val.intValue());\n                break;\n            case LONG:\n                nts.setLongValue(val.longValue());\n                break;\n            case FLOAT:\n                nts.setFloatValue(val.floatValue());\n                break;\n            case DOUBLE:\n                nts.setDoubleValue(val.doubleValue());\n                break;\n            default:\n                throw new AssertionError(\"Should never get here\");\n        }\n        return internalTokenStream;\n    }\n    if (!fieldType().tokenized()) {\n        if (stringValue() == null) {\n            throw new IllegalArgumentException(\"Non-Tokenized Fields must have a String value\");\n        }\n        if (!(internalTokenStream instanceof StringTokenStream)) {\n            internalTokenStream = new StringTokenStream();\n        }\n        ((StringTokenStream) internalTokenStream).setValue(stringValue());\n        return internalTokenStream;\n    }\n    if (tokenStream != null) {\n        return tokenStream;\n    } else if (readerValue() != null) {\n        return analyzer.tokenStream(name(), readerValue());\n    } else if (stringValue() != null) {\n        if (internalReader == null) {\n            internalReader = new ReusableStringReader();\n        }\n        internalReader.setValue(stringValue());\n        return analyzer.tokenStream(name(), internalReader);\n    }\n    throw new IllegalArgumentException(\"Field must have either TokenStream, String, Reader or Number value\");\n}"
    },
    {
      "commit": "8f88aa64978a61125adafff544c8e5084d497fb5",
      "startLine": 2,
      "endLine": 39,
      "methodCode": "public TokenStream tokenStream(Analyzer analyzer) throws IOException {\n    if (!fieldType().indexed()) {\n        return null;\n    }\n    final NumericType numericType = fieldType().numericType();\n    if (numericType != null) {\n        if (!(internalTokenStream instanceof NumericTokenStream)) {\n            internalTokenStream = new NumericTokenStream(type.numericPrecisionStep());\n        }\n        final NumericTokenStream nts = (NumericTokenStream) internalTokenStream;\n        final Number val = (Number) fieldsData;\n        switch(numericType) {\n            case INT:\n                nts.setIntValue(val.intValue());\n                break;\n            case LONG:\n                nts.setLongValue(val.longValue());\n                break;\n            case FLOAT:\n                nts.setFloatValue(val.floatValue());\n                break;\n            case DOUBLE:\n                nts.setDoubleValue(val.doubleValue());\n                break;\n            default:\n                throw new AssertionError(\"Should never get here\");\n        }\n        return internalTokenStream;\n    }\n    if (!fieldType().tokenized()) {\n        if (stringValue() == null) {\n            throw new IllegalArgumentException(\"Non-Tokenized Fields must have a String value\");\n        }\n        if (!(internalTokenStream instanceof StringTokenStream)) {\n            internalTokenStream = new StringTokenStream();\n        }\n        ((StringTokenStream) internalTokenStream).setValue(stringValue());\n        return internalTokenStream;\n    }\n    if (tokenStream != null) {\n        return tokenStream;\n    } else if (readerValue() != null) {\n        return analyzer.tokenStream(name(), readerValue());\n    } else if (stringValue() != null) {\n        if (internalReader == null) {\n            internalReader = new ReusableStringReader();\n        }\n        internalReader.setValue(stringValue());\n        return analyzer.tokenStream(name(), internalReader);\n    }\n    throw new IllegalArgumentException(\"Field must have either TokenStream, String, Reader or Number value\");\n}"
    },
    {
      "commit": "2afa06672fe204f468a72d7c85b23158345d5597",
      "startLine": 2,
      "endLine": 39,
      "methodCode": "public TokenStream tokenStream(Analyzer analyzer) throws IOException {\n    if (!fieldType().indexed()) {\n        return null;\n    }\n    final NumericType numericType = fieldType().numericType();\n    if (numericType != null) {\n        if (!(internalTokenStream instanceof NumericTokenStream)) {\n            internalTokenStream = new NumericTokenStream(type.numericPrecisionStep());\n        }\n        final NumericTokenStream nts = (NumericTokenStream) internalTokenStream;\n        final Number val = (Number) fieldsData;\n        switch(numericType) {\n            case INT:\n                nts.setIntValue(val.intValue());\n                break;\n            case LONG:\n                nts.setLongValue(val.longValue());\n                break;\n            case FLOAT:\n                nts.setFloatValue(val.floatValue());\n                break;\n            case DOUBLE:\n                nts.setDoubleValue(val.doubleValue());\n                break;\n            default:\n                assert false : \"Should never get here\";\n        }\n        return internalTokenStream;\n    }\n    if (!fieldType().tokenized()) {\n        if (stringValue() == null) {\n            throw new IllegalArgumentException(\"Non-Tokenized Fields must have a String value\");\n        }\n        if (!(internalTokenStream instanceof StringTokenStream)) {\n            internalTokenStream = new StringTokenStream();\n        }\n        ((StringTokenStream) internalTokenStream).setValue(stringValue());\n        return internalTokenStream;\n    }\n    if (tokenStream != null) {\n        return tokenStream;\n    } else if (readerValue() != null) {\n        return analyzer.tokenStream(name(), readerValue());\n    } else if (stringValue() != null) {\n        if (internalReader == null) {\n            internalReader = new ReusableStringReader();\n        }\n        internalReader.setValue(stringValue());\n        return analyzer.tokenStream(name(), internalReader);\n    }\n    throw new IllegalArgumentException(\"Field must have either TokenStream, String, Reader or Number value\");\n}"
    },
    {
      "commit": "518fc20d1cf385650202ff9a3b35136ed9d646e5",
      "startLine": 2,
      "endLine": 39,
      "methodCode": "public TokenStream tokenStream(Analyzer analyzer) throws IOException {\n    if (!fieldType().indexed()) {\n        return null;\n    }\n    final NumericType numericType = fieldType().numericType();\n    if (numericType != null) {\n        if (!(internalTokenStream instanceof NumericTokenStream)) {\n            internalTokenStream = new NumericTokenStream(type.numericPrecisionStep());\n        }\n        final NumericTokenStream nts = (NumericTokenStream) internalTokenStream;\n        final Number val = (Number) fieldsData;\n        switch(numericType) {\n            case INT:\n                nts.setIntValue(val.intValue());\n                break;\n            case LONG:\n                nts.setLongValue(val.longValue());\n                break;\n            case FLOAT:\n                nts.setFloatValue(val.floatValue());\n                break;\n            case DOUBLE:\n                nts.setDoubleValue(val.doubleValue());\n                break;\n            default:\n                assert false : \"Should never get here\";\n        }\n        return internalTokenStream;\n    }\n    if (!fieldType().tokenized()) {\n        if (stringValue() == null) {\n            throw new IllegalArgumentException(\"Non-Tokenized Fields must have a String value\");\n        }\n        if (!(internalTokenStream instanceof StringTokenStream)) {\n            internalTokenStream = new StringTokenStream();\n        }\n        ((StringTokenStream) internalTokenStream).setValue(stringValue());\n        return internalTokenStream;\n    }\n    if (tokenStream != null) {\n        return tokenStream;\n    } else if (readerValue() != null) {\n        return analyzer.tokenStream(name(), readerValue());\n    } else if (stringValue() != null) {\n        if (internalReader == null) {\n            internalReader = new ReusableStringReader();\n        }\n        internalReader.setValue(stringValue());\n        return analyzer.tokenStream(name(), internalReader);\n    }\n    throw new IllegalArgumentException(\"Field must have either TokenStream, String, Reader or Number value\");\n}"
    },
    {
      "commit": "e53aee7739be1c04bd1673a55b4956efb63c337f",
      "startLine": 2,
      "endLine": 39,
      "methodCode": "public TokenStream tokenStream(Analyzer analyzer) throws IOException {\n    if (!fieldType().indexed()) {\n        return null;\n    }\n    final NumericType numericType = fieldType().numericType();\n    if (numericType != null) {\n        if (!(internalTokenStream instanceof NumericTokenStream)) {\n            internalTokenStream = new NumericTokenStream(type.numericPrecisionStep());\n        }\n        final NumericTokenStream nts = (NumericTokenStream) internalTokenStream;\n        final Number val = (Number) fieldsData;\n        switch(numericType) {\n            case INT:\n                nts.setIntValue(val.intValue());\n                break;\n            case LONG:\n                nts.setLongValue(val.longValue());\n                break;\n            case FLOAT:\n                nts.setFloatValue(val.floatValue());\n                break;\n            case DOUBLE:\n                nts.setDoubleValue(val.doubleValue());\n                break;\n            default:\n                assert false : \"Should never get here\";\n        }\n        return internalTokenStream;\n    }\n    if (!fieldType().tokenized()) {\n        if (stringValue() == null) {\n            throw new IllegalArgumentException(\"Non-Tokenized Fields must have a String value\");\n        }\n        if (!(internalTokenStream instanceof StringTokenStream)) {\n            internalTokenStream = new StringTokenStream();\n        }\n        ((StringTokenStream) internalTokenStream).setValue(stringValue());\n        return internalTokenStream;\n    }\n    if (tokenStream != null) {\n        return tokenStream;\n    } else if (readerValue() != null) {\n        return analyzer.tokenStream(name(), readerValue());\n    } else if (stringValue() != null) {\n        return analyzer.tokenStream(name(), new StringReader(stringValue()));\n    }\n    throw new IllegalArgumentException(\"Field must have either TokenStream, String, Reader or Number value\");\n}"
    },
    {
      "commit": "fd16190940d7495e985f44ce7504562c8bbc91e6",
      "startLine": 2,
      "endLine": 58,
      "methodCode": "public TokenStream tokenStream(Analyzer analyzer) throws IOException {\n    if (!fieldType().indexed()) {\n        return null;\n    }\n    final NumericType numericType = fieldType().numericType();\n    if (numericType != null) {\n        if (numericTokenStream == null) {\n            numericTokenStream = new NumericTokenStream(type.numericPrecisionStep());\n            final Number val = (Number) fieldsData;\n            switch(numericType) {\n                case INT:\n                    numericTokenStream.setIntValue(val.intValue());\n                    break;\n                case LONG:\n                    numericTokenStream.setLongValue(val.longValue());\n                    break;\n                case FLOAT:\n                    numericTokenStream.setFloatValue(val.floatValue());\n                    break;\n                case DOUBLE:\n                    numericTokenStream.setDoubleValue(val.doubleValue());\n                    break;\n                default:\n                    assert false : \"Should never get here\";\n            }\n        } else {\n        }\n        return numericTokenStream;\n    }\n    if (!fieldType().tokenized()) {\n        if (stringValue() == null) {\n            throw new IllegalArgumentException(\"Non-Tokenized Fields must have a String value\");\n        }\n        return new TokenStream() {\n\n            CharTermAttribute termAttribute = addAttribute(CharTermAttribute.class);\n\n            OffsetAttribute offsetAttribute = addAttribute(OffsetAttribute.class);\n\n            boolean used;\n\n            @Override\n            public boolean incrementToken() {\n                if (used) {\n                    return false;\n                }\n                termAttribute.setEmpty().append(stringValue());\n                offsetAttribute.setOffset(0, stringValue().length());\n                used = true;\n                return true;\n            }\n\n            @Override\n            public void reset() {\n                used = false;\n            }\n        };\n    }\n    if (tokenStream != null) {\n        return tokenStream;\n    } else if (readerValue() != null) {\n        return analyzer.tokenStream(name(), readerValue());\n    } else if (stringValue() != null) {\n        return analyzer.tokenStream(name(), new StringReader(stringValue()));\n    }\n    throw new IllegalArgumentException(\"Field must have either TokenStream, String, Reader or Number value\");\n}"
    },
    {
      "commit": "854c9ac45223b64acf3e7e4c0a77383a9441268f",
      "startLine": 2,
      "endLine": 58,
      "methodCode": "public TokenStream tokenStream(Analyzer analyzer) throws IOException {\n    if (!fieldType().indexed()) {\n        return null;\n    }\n    final NumericType numericType = fieldType().numericType();\n    if (numericType != null) {\n        if (numericTokenStream == null) {\n            numericTokenStream = new NumericTokenStream(type.numericPrecisionStep());\n            final Number val = (Number) fieldsData;\n            switch(numericType) {\n                case INT:\n                    numericTokenStream.setIntValue(val.intValue());\n                    break;\n                case LONG:\n                    numericTokenStream.setLongValue(val.longValue());\n                    break;\n                case FLOAT:\n                    numericTokenStream.setFloatValue(val.floatValue());\n                    break;\n                case DOUBLE:\n                    numericTokenStream.setDoubleValue(val.doubleValue());\n                    break;\n                default:\n                    assert false : \"Should never get here\";\n            }\n        } else {\n        }\n        return numericTokenStream;\n    }\n    if (!fieldType().tokenized()) {\n        if (stringValue() == null) {\n            throw new IllegalArgumentException(\"Non-Tokenized Fields must have a String value\");\n        }\n        return new TokenStream() {\n\n            CharTermAttribute termAttribute = addAttribute(CharTermAttribute.class);\n\n            OffsetAttribute offsetAttribute = addAttribute(OffsetAttribute.class);\n\n            boolean used;\n\n            @Override\n            public boolean incrementToken() throws IOException {\n                if (used) {\n                    return false;\n                }\n                termAttribute.setEmpty().append(stringValue());\n                offsetAttribute.setOffset(0, stringValue().length());\n                used = true;\n                return true;\n            }\n\n            @Override\n            public void reset() throws IOException {\n                used = false;\n            }\n        };\n    }\n    if (tokenStream != null) {\n        return tokenStream;\n    } else if (readerValue() != null) {\n        return analyzer.tokenStream(name(), readerValue());\n    } else if (stringValue() != null) {\n        return analyzer.tokenStream(name(), new StringReader(stringValue()));\n    }\n    throw new IllegalArgumentException(\"Field must have either TokenStream, String, Reader or Number value\");\n}"
    },
    {
      "commit": "eb0ab3d392a42c1835f79bcd7f5404bcc50c8e4c",
      "startLine": 2,
      "endLine": 58,
      "methodCode": "public TokenStream tokenStream(Analyzer analyzer) throws IOException {\n    if (!fieldType().indexed()) {\n        return null;\n    }\n    final NumericField.DataType numericType = fieldType().numericType();\n    if (numericType != null) {\n        if (numericTokenStream == null) {\n            numericTokenStream = new NumericTokenStream(type.numericPrecisionStep());\n            final Number val = (Number) fieldsData;\n            switch(numericType) {\n                case INT:\n                    numericTokenStream.setIntValue(val.intValue());\n                    break;\n                case LONG:\n                    numericTokenStream.setLongValue(val.longValue());\n                    break;\n                case FLOAT:\n                    numericTokenStream.setFloatValue(val.floatValue());\n                    break;\n                case DOUBLE:\n                    numericTokenStream.setDoubleValue(val.doubleValue());\n                    break;\n                default:\n                    assert false : \"Should never get here\";\n            }\n        } else {\n        }\n        return numericTokenStream;\n    }\n    if (!fieldType().tokenized()) {\n        if (stringValue() == null) {\n            throw new IllegalArgumentException(\"Non-Tokenized Fields must have a String value\");\n        }\n        return new TokenStream() {\n\n            CharTermAttribute termAttribute = addAttribute(CharTermAttribute.class);\n\n            OffsetAttribute offsetAttribute = addAttribute(OffsetAttribute.class);\n\n            boolean used;\n\n            @Override\n            public boolean incrementToken() throws IOException {\n                if (used) {\n                    return false;\n                }\n                termAttribute.setEmpty().append(stringValue());\n                offsetAttribute.setOffset(0, stringValue().length());\n                used = true;\n                return true;\n            }\n\n            @Override\n            public void reset() throws IOException {\n                used = false;\n            }\n        };\n    }\n    if (tokenStream != null) {\n        return tokenStream;\n    } else if (readerValue() != null) {\n        return analyzer.tokenStream(name(), readerValue());\n    } else if (stringValue() != null) {\n        return analyzer.tokenStream(name(), new StringReader(stringValue()));\n    }\n    throw new IllegalArgumentException(\"Field must have either TokenStream, String, Reader or Number value\");\n}"
    },
    {
      "commit": "9de01b56ebf252ffefe05e606e330a1787b94c9d",
      "startLine": 2,
      "endLine": 58,
      "methodCode": "public TokenStream tokenStream(Analyzer analyzer) throws IOException {\n    if (!fieldType().indexed()) {\n        return null;\n    }\n    final NumericField.DataType numericType = fieldType().numericType();\n    if (numericType != null) {\n        if (numericTokenStream == null) {\n            numericTokenStream = new NumericTokenStream(type.numericPrecisionStep());\n            final Number val = (Number) fieldsData;\n            switch(numericType) {\n                case INT:\n                    numericTokenStream.setIntValue(val.intValue());\n                    break;\n                case LONG:\n                    numericTokenStream.setLongValue(val.longValue());\n                    break;\n                case FLOAT:\n                    numericTokenStream.setFloatValue(val.floatValue());\n                    break;\n                case DOUBLE:\n                    numericTokenStream.setDoubleValue(val.doubleValue());\n                    break;\n                default:\n                    assert false : \"Should never get here\";\n            }\n        } else {\n        }\n        return numericTokenStream;\n    }\n    if (!fieldType().tokenized()) {\n        if (stringValue() == null) {\n            throw new IllegalArgumentException(\"Non-Tokenized Fields must have a String value\");\n        }\n        return new TokenStream() {\n\n            CharTermAttribute termAttribute = addAttribute(CharTermAttribute.class);\n\n            OffsetAttribute offsetAttribute = addAttribute(OffsetAttribute.class);\n\n            boolean used;\n\n            @Override\n            public boolean incrementToken() throws IOException {\n                if (used) {\n                    return false;\n                }\n                termAttribute.setEmpty().append(stringValue());\n                offsetAttribute.setOffset(0, stringValue().length());\n                used = true;\n                return true;\n            }\n\n            @Override\n            public void reset() throws IOException {\n                used = false;\n            }\n        };\n    }\n    if (tokenStream != null) {\n        return tokenStream;\n    } else if (readerValue() != null) {\n        return analyzer.tokenStream(name(), readerValue());\n    } else if (stringValue() != null) {\n        return analyzer.tokenStream(name(), new StringReader(stringValue()));\n    }\n    throw new IllegalArgumentException(\"Field must have either TokenStream, String, Reader or Number value\");\n}"
    },
    {
      "commit": "67c13bd2fe57d73a824f163f9c73018fa51a1a65",
      "startLine": 2,
      "endLine": 33,
      "methodCode": "public TokenStream tokenStream(Analyzer analyzer) throws IOException {\n    if (!fieldType().indexed()) {\n        return null;\n    }\n    if (!fieldType().tokenized()) {\n        if (stringValue() == null) {\n            throw new IllegalArgumentException(\"Non-Tokenized Fields must have a String value\");\n        }\n        return new TokenStream() {\n\n            CharTermAttribute termAttribute = addAttribute(CharTermAttribute.class);\n\n            OffsetAttribute offsetAttribute = addAttribute(OffsetAttribute.class);\n\n            boolean used;\n\n            @Override\n            public boolean incrementToken() throws IOException {\n                if (used) {\n                    return false;\n                }\n                termAttribute.setEmpty().append(stringValue());\n                offsetAttribute.setOffset(0, stringValue().length());\n                used = true;\n                return true;\n            }\n\n            @Override\n            public void reset() throws IOException {\n                used = false;\n            }\n        };\n    }\n    if (tokenStream != null) {\n        return tokenStream;\n    } else if (readerValue() != null) {\n        return analyzer.tokenStream(name(), readerValue());\n    } else if (stringValue() != null) {\n        return analyzer.tokenStream(name(), new StringReader(stringValue()));\n    }\n    throw new IllegalArgumentException(\"Field must have either TokenStream, String or Reader value\");\n}"
    },
    {
      "commit": "5d4502ad0a3249fec5fcc1e28ce7074f67e8a027",
      "startLine": 2,
      "endLine": 33,
      "methodCode": "public TokenStream tokenStream(Analyzer analyzer) throws IOException {\n    if (!fieldType().indexed()) {\n        return null;\n    }\n    if (!fieldType().tokenized()) {\n        if (stringValue() == null) {\n            throw new IllegalArgumentException(\"Non-Tokenized Fields must have a String value\");\n        }\n        return new TokenStream() {\n\n            CharTermAttribute termAttribute = addAttribute(CharTermAttribute.class);\n\n            OffsetAttribute offsetAttribute = addAttribute(OffsetAttribute.class);\n\n            boolean used;\n\n            @Override\n            public boolean incrementToken() throws IOException {\n                if (used) {\n                    return false;\n                }\n                termAttribute.setEmpty().append(stringValue());\n                offsetAttribute.setOffset(0, stringValue().length());\n                used = true;\n                return true;\n            }\n\n            @Override\n            public void reset() throws IOException {\n                used = false;\n            }\n        };\n    }\n    if (tokenStream != null) {\n        return tokenStream;\n    } else if (readerValue() != null) {\n        return analyzer.reusableTokenStream(name(), readerValue());\n    } else if (stringValue() != null) {\n        return analyzer.reusableTokenStream(name(), new StringReader(stringValue()));\n    }\n    throw new IllegalArgumentException(\"Field must have either TokenStream, String or Reader value\");\n}"
    }
  ]
}