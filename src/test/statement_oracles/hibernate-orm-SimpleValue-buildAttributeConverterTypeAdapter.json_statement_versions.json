{
  "statementVersions": [
    {
      "commit": "c14180ea5b16b69cdd06eb5bb159f7da1ff4db54",
      "startLine": 15,
      "endLine": 28,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprivate Type buildAttributeConverterTypeAdapter() {\n    final JpaAttributeConverter jpaAttributeConverter = attributeConverterDescriptor.createJpaAttributeConverter(new JpaAttributeConverterCreationContext() {\n\n        @Override\n        public ManagedBeanRegistry getManagedBeanRegistry() {\n            return getMetadata().getMetadataBuildingOptions().getServiceRegistry().getService(ManagedBeanRegistry.class);\n        }\n\n        @Override\n        public org.hibernate.type.descriptor.java.spi.JavaTypeDescriptorRegistry getJavaTypeDescriptorRegistry() {\n            return metadata.getTypeConfiguration().getJavaTypeDescriptorRegistry();\n        }\n    });\n    final BasicJavaDescriptor entityAttributeJavaTypeDescriptor = jpaAttributeConverter.getDomainJavaTypeDescriptor();\n    final SqlTypeDescriptor recommendedSqlType = jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJdbcRecommendedSqlType(metadata::getTypeConfiguration);\n    int jdbcTypeCode = recommendedSqlType.getSqlType();\n    if (isLob()) {\n        if (LobTypeMappings.INSTANCE.hasCorrespondingLobCode(jdbcTypeCode)) {\n            jdbcTypeCode = LobTypeMappings.INSTANCE.getCorrespondingLobCode(jdbcTypeCode);\n        } else {\n            if (Serializable.class.isAssignableFrom(entityAttributeJavaTypeDescriptor.getJavaType())) {\n                jdbcTypeCode = Types.BLOB;\n            } else {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"JDBC type-code [%s (%s)] not known to have a corresponding LOB equivalent, and Java type is not Serializable (to use BLOB)\", jdbcTypeCode, JdbcTypeNameMapper.getTypeName(jdbcTypeCode)));\n            }\n        }\n    }\n    if (isNationalized()) {\n        jdbcTypeCode = NationalizedTypeMappings.INSTANCE.getCorrespondingNationalizedCode(jdbcTypeCode);\n    }\n    final SqlTypeDescriptor sqlTypeDescriptor = getMetadata().getMetadataBuildingOptions().getServiceRegistry().getService(JdbcServices.class).getJdbcEnvironment().getDialect().remapSqlTypeDescriptor(metadata.getTypeConfiguration().getSqlTypeDescriptorRegistry().getDescriptor(jdbcTypeCode));\n    final SqlTypeDescriptor sqlTypeDescriptorAdapter = new AttributeConverterSqlTypeDescriptorAdapter(jpaAttributeConverter, sqlTypeDescriptor, jpaAttributeConverter.getRelationalJavaTypeDescriptor());\n    final String name = AttributeConverterTypeAdapter.NAME_PREFIX + jpaAttributeConverter.getConverterJavaTypeDescriptor().getJavaType().getName();\n    final String description = String.format(\"BasicType adapter for AttributeConverter<%s,%s>\", jpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType().getSimpleName(), jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType().getSimpleName());\n    return new AttributeConverterTypeAdapter(name, description, jpaAttributeConverter, sqlTypeDescriptorAdapter, jpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType(), jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType(), entityAttributeJavaTypeDescriptor);\n}"
    },
    {
      "commit": "0d82dc7c8387a954edfa971af99c16a66e33c65a",
      "startLine": 15,
      "endLine": 27,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprivate Type buildAttributeConverterTypeAdapter() {\n    final JpaAttributeConverter jpaAttributeConverter = attributeConverterDescriptor.createJpaAttributeConverter(new JpaAttributeConverterCreationContext() {\n\n        @Override\n        public ManagedBeanRegistry getManagedBeanRegistry() {\n            return getMetadata().getMetadataBuildingOptions().getServiceRegistry().getService(ManagedBeanRegistry.class);\n        }\n\n        @Override\n        public JavaTypeDescriptorRegistry getJavaTypeDescriptorRegistry() {\n            return metadata.getTypeConfiguration().getJavaTypeDescriptorRegistry();\n        }\n    });\n    final JavaTypeDescriptor entityAttributeJavaTypeDescriptor = jpaAttributeConverter.getDomainJavaTypeDescriptor();\n    int jdbcTypeCode = JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass(jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType());\n    if (isLob()) {\n        if (LobTypeMappings.INSTANCE.hasCorrespondingLobCode(jdbcTypeCode)) {\n            jdbcTypeCode = LobTypeMappings.INSTANCE.getCorrespondingLobCode(jdbcTypeCode);\n        } else {\n            if (Serializable.class.isAssignableFrom(entityAttributeJavaTypeDescriptor.getJavaType())) {\n                jdbcTypeCode = Types.BLOB;\n            } else {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"JDBC type-code [%s (%s)] not known to have a corresponding LOB equivalent, and Java type is not Serializable (to use BLOB)\", jdbcTypeCode, JdbcTypeNameMapper.getTypeName(jdbcTypeCode)));\n            }\n        }\n    }\n    if (isNationalized()) {\n        jdbcTypeCode = NationalizedTypeMappings.INSTANCE.getCorrespondingNationalizedCode(jdbcTypeCode);\n    }\n    final SqlTypeDescriptor sqlTypeDescriptor = getMetadata().getMetadataBuildingOptions().getServiceRegistry().getService(JdbcServices.class).getJdbcEnvironment().getDialect().remapSqlTypeDescriptor(metadata.getTypeConfiguration().getSqlTypeDescriptorRegistry().getDescriptor(jdbcTypeCode));\n    final SqlTypeDescriptor sqlTypeDescriptorAdapter = new AttributeConverterSqlTypeDescriptorAdapter(jpaAttributeConverter, sqlTypeDescriptor, jpaAttributeConverter.getRelationalJavaTypeDescriptor());\n    final String name = AttributeConverterTypeAdapter.NAME_PREFIX + jpaAttributeConverter.getConverterJavaTypeDescriptor().getJavaType().getName();\n    final String description = String.format(\"BasicType adapter for AttributeConverter<%s,%s>\", jpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType().getSimpleName(), jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType().getSimpleName());\n    return new AttributeConverterTypeAdapter(name, description, jpaAttributeConverter, sqlTypeDescriptorAdapter, jpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType(), jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType(), entityAttributeJavaTypeDescriptor);\n}"
    },
    {
      "commit": "9229514ed407b1610a52ab7ba97806c435352ad2",
      "startLine": 15,
      "endLine": 27,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprivate Type buildAttributeConverterTypeAdapter() {\n    final JpaAttributeConverter jpaAttributeConverter = attributeConverterDescriptor.createJpaAttributeConverter(new JpaAttributeConverterCreationContext() {\n\n        @Override\n        public ManagedBeanRegistry getManagedBeanRegistry() {\n            return getMetadata().getMetadataBuildingOptions().getServiceRegistry().getService(ManagedBeanRegistry.class);\n        }\n\n        @Override\n        public JavaTypeDescriptorRegistry getJavaTypeDescriptorRegistry() {\n            return JavaTypeDescriptorRegistry.INSTANCE;\n        }\n    });\n    final JavaTypeDescriptor entityAttributeJavaTypeDescriptor = jpaAttributeConverter.getDomainJavaTypeDescriptor();\n    int jdbcTypeCode = JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass(jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType());\n    if (isLob()) {\n        if (LobTypeMappings.INSTANCE.hasCorrespondingLobCode(jdbcTypeCode)) {\n            jdbcTypeCode = LobTypeMappings.INSTANCE.getCorrespondingLobCode(jdbcTypeCode);\n        } else {\n            if (Serializable.class.isAssignableFrom(entityAttributeJavaTypeDescriptor.getJavaType())) {\n                jdbcTypeCode = Types.BLOB;\n            } else {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"JDBC type-code [%s (%s)] not known to have a corresponding LOB equivalent, and Java type is not Serializable (to use BLOB)\", jdbcTypeCode, JdbcTypeNameMapper.getTypeName(jdbcTypeCode)));\n            }\n        }\n    }\n    if (isNationalized()) {\n        jdbcTypeCode = NationalizedTypeMappings.INSTANCE.getCorrespondingNationalizedCode(jdbcTypeCode);\n    }\n    final SqlTypeDescriptor sqlTypeDescriptor = getMetadata().getMetadataBuildingOptions().getServiceRegistry().getService(JdbcServices.class).getJdbcEnvironment().getDialect().remapSqlTypeDescriptor(SqlTypeDescriptorRegistry.INSTANCE.getDescriptor(jdbcTypeCode));\n    final SqlTypeDescriptor sqlTypeDescriptorAdapter = new AttributeConverterSqlTypeDescriptorAdapter(jpaAttributeConverter, sqlTypeDescriptor, jpaAttributeConverter.getRelationalJavaTypeDescriptor());\n    final String name = AttributeConverterTypeAdapter.NAME_PREFIX + jpaAttributeConverter.getConverterJavaTypeDescriptor().getJavaType().getName();\n    final String description = String.format(\"BasicType adapter for AttributeConverter<%s,%s>\", jpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType().getSimpleName(), jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType().getSimpleName());\n    return new AttributeConverterTypeAdapter(name, description, jpaAttributeConverter, sqlTypeDescriptorAdapter, jpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType(), jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType(), entityAttributeJavaTypeDescriptor);\n}"
    },
    {
      "commit": "8f889e95d76f47945c9ec072fd08cb045767578c",
      "startLine": 15,
      "endLine": 27,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprivate Type buildAttributeConverterTypeAdapter() {\n    final JpaAttributeConverter jpaAttributeConverter = attributeConverterDescriptor.createJpaAttributeConverter(new JpaAttributeConverterCreationContext() {\n\n        @Override\n        public ManagedBeanRegistry getManagedBeanRegistry() {\n            return buildingContext.getBootstrapContext().getMetadataBuildingOptions().getServiceRegistry().getService(ManagedBeanRegistry.class);\n        }\n\n        @Override\n        public JavaTypeDescriptorRegistry getJavaTypeDescriptorRegistry() {\n            return JavaTypeDescriptorRegistry.INSTANCE;\n        }\n    });\n    final JavaTypeDescriptor entityAttributeJavaTypeDescriptor = jpaAttributeConverter.getDomainJavaTypeDescriptor();\n    int jdbcTypeCode = JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass(jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType());\n    if (isLob()) {\n        if (LobTypeMappings.INSTANCE.hasCorrespondingLobCode(jdbcTypeCode)) {\n            jdbcTypeCode = LobTypeMappings.INSTANCE.getCorrespondingLobCode(jdbcTypeCode);\n        } else {\n            if (Serializable.class.isAssignableFrom(entityAttributeJavaTypeDescriptor.getJavaType())) {\n                jdbcTypeCode = Types.BLOB;\n            } else {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"JDBC type-code [%s (%s)] not known to have a corresponding LOB equivalent, and Java type is not Serializable (to use BLOB)\", jdbcTypeCode, JdbcTypeNameMapper.getTypeName(jdbcTypeCode)));\n            }\n        }\n    }\n    if (isNationalized()) {\n        jdbcTypeCode = NationalizedTypeMappings.INSTANCE.getCorrespondingNationalizedCode(jdbcTypeCode);\n    }\n    final SqlTypeDescriptor sqlTypeDescriptor = buildingContext.getBootstrapContext().getMetadataBuildingOptions().getServiceRegistry().getService(JdbcServices.class).getJdbcEnvironment().getDialect().remapSqlTypeDescriptor(SqlTypeDescriptorRegistry.INSTANCE.getDescriptor(jdbcTypeCode));\n    final SqlTypeDescriptor sqlTypeDescriptorAdapter = new AttributeConverterSqlTypeDescriptorAdapter(jpaAttributeConverter, sqlTypeDescriptor, jpaAttributeConverter.getRelationalJavaTypeDescriptor());\n    final String name = AttributeConverterTypeAdapter.NAME_PREFIX + jpaAttributeConverter.getConverterJavaTypeDescriptor().getJavaType().getName();\n    final String description = String.format(\"BasicType adapter for AttributeConverter<%s,%s>\", jpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType().getSimpleName(), jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType().getSimpleName());\n    return new AttributeConverterTypeAdapter(name, description, jpaAttributeConverter, sqlTypeDescriptorAdapter, jpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType(), jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType(), entityAttributeJavaTypeDescriptor);\n}"
    },
    {
      "commit": "90cabb43ad8b186d73cb6b310fb2fd6774ffe44f",
      "startLine": 15,
      "endLine": 27,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprivate Type buildAttributeConverterTypeAdapter() {\n    final JpaAttributeConverter jpaAttributeConverter = attributeConverterDescriptor.createJpaAttributeConverter(new JpaAttributeConverterCreationContext() {\n\n        @Override\n        public ManagedBeanRegistry getManagedBeanRegistry() {\n            return getMetadata().getMetadataBuildingOptions().getServiceRegistry().getService(ManagedBeanRegistry.class);\n        }\n\n        @Override\n        public JavaTypeDescriptorRegistry getJavaTypeDescriptorRegistry() {\n            return JavaTypeDescriptorRegistry.INSTANCE;\n        }\n    });\n    final JavaTypeDescriptor entityAttributeJavaTypeDescriptor = jpaAttributeConverter.getDomainJavaTypeDescriptor();\n    int jdbcTypeCode = JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass(jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType());\n    if (isLob()) {\n        if (LobTypeMappings.INSTANCE.hasCorrespondingLobCode(jdbcTypeCode)) {\n            jdbcTypeCode = LobTypeMappings.INSTANCE.getCorrespondingLobCode(jdbcTypeCode);\n        } else {\n            if (Serializable.class.isAssignableFrom(entityAttributeJavaTypeDescriptor.getJavaType())) {\n                jdbcTypeCode = Types.BLOB;\n            } else {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"JDBC type-code [%s (%s)] not known to have a corresponding LOB equivalent, and Java type is not Serializable (to use BLOB)\", jdbcTypeCode, JdbcTypeNameMapper.getTypeName(jdbcTypeCode)));\n            }\n        }\n    }\n    if (isNationalized()) {\n        jdbcTypeCode = NationalizedTypeMappings.INSTANCE.getCorrespondingNationalizedCode(jdbcTypeCode);\n    }\n    final SqlTypeDescriptor sqlTypeDescriptor = metadata.getMetadataBuildingOptions().getServiceRegistry().getService(JdbcServices.class).getJdbcEnvironment().getDialect().remapSqlTypeDescriptor(SqlTypeDescriptorRegistry.INSTANCE.getDescriptor(jdbcTypeCode));\n    final SqlTypeDescriptor sqlTypeDescriptorAdapter = new AttributeConverterSqlTypeDescriptorAdapter(jpaAttributeConverter, sqlTypeDescriptor, jpaAttributeConverter.getRelationalJavaTypeDescriptor());\n    final String name = AttributeConverterTypeAdapter.NAME_PREFIX + jpaAttributeConverter.getConverterJavaTypeDescriptor().getJavaType().getName();\n    final String description = String.format(\"BasicType adapter for AttributeConverter<%s,%s>\", jpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType().getSimpleName(), jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType().getSimpleName());\n    return new AttributeConverterTypeAdapter(name, description, jpaAttributeConverter, sqlTypeDescriptorAdapter, jpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType(), jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType(), entityAttributeJavaTypeDescriptor);\n}"
    },
    {
      "commit": "9aa164ed27b8338f592dee504a5793bc4e5bbfd9",
      "startLine": 5,
      "endLine": 17,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprivate Type buildAttributeConverterTypeAdapter() {\n    final Class entityAttributeJavaType = attributeConverterDescriptor.getDomainType();\n    final Class databaseColumnJavaType = attributeConverterDescriptor.getJdbcType();\n    final JavaTypeDescriptor entityAttributeJavaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(entityAttributeJavaType);\n    int jdbcTypeCode = JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass(databaseColumnJavaType);\n    if (isLob()) {\n        if (LobTypeMappings.INSTANCE.hasCorrespondingLobCode(jdbcTypeCode)) {\n            jdbcTypeCode = LobTypeMappings.INSTANCE.getCorrespondingLobCode(jdbcTypeCode);\n        } else {\n            if (Serializable.class.isAssignableFrom(entityAttributeJavaType)) {\n                jdbcTypeCode = Types.BLOB;\n            } else {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"JDBC type-code [%s (%s)] not known to have a corresponding LOB equivalent, and Java type is not Serializable (to use BLOB)\", jdbcTypeCode, JdbcTypeNameMapper.getTypeName(jdbcTypeCode)));\n            }\n        }\n    }\n    if (isNationalized()) {\n        jdbcTypeCode = NationalizedTypeMappings.INSTANCE.getCorrespondingNationalizedCode(jdbcTypeCode);\n    }\n    final SqlTypeDescriptor sqlTypeDescriptor = metadata.getMetadataBuildingOptions().getServiceRegistry().getService(JdbcServices.class).getJdbcEnvironment().getDialect().remapSqlTypeDescriptor(SqlTypeDescriptorRegistry.INSTANCE.getDescriptor(jdbcTypeCode));\n    final JavaTypeDescriptor intermediateJavaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(databaseColumnJavaType);\n    final SqlTypeDescriptor sqlTypeDescriptorAdapter = new AttributeConverterSqlTypeDescriptorAdapter(attributeConverterDescriptor.getAttributeConverter(), sqlTypeDescriptor, intermediateJavaTypeDescriptor);\n    final String name = AttributeConverterTypeAdapter.NAME_PREFIX + attributeConverterDescriptor.getAttributeConverter().getClass().getName();\n    final String description = String.format(\"BasicType adapter for AttributeConverter<%s,%s>\", entityAttributeJavaType.getSimpleName(), databaseColumnJavaType.getSimpleName());\n    return new AttributeConverterTypeAdapter(name, description, attributeConverterDescriptor.getAttributeConverter(), sqlTypeDescriptorAdapter, entityAttributeJavaType, databaseColumnJavaType, entityAttributeJavaTypeDescriptor);\n}"
    },
    {
      "commit": "0cf66b85e03a997dc94f8f82598ca8edac04e889",
      "startLine": 5,
      "endLine": 17,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprivate Type buildAttributeConverterTypeAdapter() {\n    final Class entityAttributeJavaType = attributeConverterDescriptor.getDomainType();\n    final Class databaseColumnJavaType = attributeConverterDescriptor.getJdbcType();\n    final JavaTypeDescriptor entityAttributeJavaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(entityAttributeJavaType);\n    int jdbcTypeCode = JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass(databaseColumnJavaType);\n    if (isLob()) {\n        if (LobTypeMappings.INSTANCE.hasCorrespondingLobCode(jdbcTypeCode)) {\n            jdbcTypeCode = LobTypeMappings.INSTANCE.getCorrespondingLobCode(jdbcTypeCode);\n        } else {\n            if (Serializable.class.isAssignableFrom(entityAttributeJavaType)) {\n                jdbcTypeCode = Types.BLOB;\n            } else {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"JDBC type-code [%s (%s)] not known to have a corresponding LOB equivalent, and Java type is not Serializable (to use BLOB)\", jdbcTypeCode, JdbcTypeNameMapper.getTypeName(jdbcTypeCode)));\n            }\n        }\n    }\n    if (isNationalized()) {\n        jdbcTypeCode = NationalizedTypeMappings.INSTANCE.getCorrespondingNationalizedCode(jdbcTypeCode);\n    }\n    final SqlTypeDescriptor sqlTypeDescriptor = SqlTypeDescriptorRegistry.INSTANCE.getDescriptor(jdbcTypeCode);\n    final JavaTypeDescriptor intermediateJavaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(databaseColumnJavaType);\n    final SqlTypeDescriptor sqlTypeDescriptorAdapter = new AttributeConverterSqlTypeDescriptorAdapter(attributeConverterDescriptor.getAttributeConverter(), sqlTypeDescriptor, intermediateJavaTypeDescriptor);\n    final String name = AttributeConverterTypeAdapter.NAME_PREFIX + attributeConverterDescriptor.getAttributeConverter().getClass().getName();\n    final String description = String.format(\"BasicType adapter for AttributeConverter<%s,%s>\", entityAttributeJavaType.getSimpleName(), databaseColumnJavaType.getSimpleName());\n    return new AttributeConverterTypeAdapter(name, description, attributeConverterDescriptor.getAttributeConverter(), sqlTypeDescriptorAdapter, entityAttributeJavaType, databaseColumnJavaType, entityAttributeJavaTypeDescriptor);\n}"
    },
    {
      "commit": "3ac508882c89ebd7c80af71d0e65ba26a017ebe3",
      "startLine": 5,
      "endLine": 17,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprivate Type buildAttributeConverterTypeAdapter() {\n    final Class entityAttributeJavaType = attributeConverterDefinition.getEntityAttributeType();\n    final Class databaseColumnJavaType = attributeConverterDefinition.getDatabaseColumnType();\n    final JavaTypeDescriptor entityAttributeJavaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(entityAttributeJavaType);\n    int jdbcTypeCode = JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass(databaseColumnJavaType);\n    if (isLob()) {\n        if (LobTypeMappings.INSTANCE.hasCorrespondingLobCode(jdbcTypeCode)) {\n            jdbcTypeCode = LobTypeMappings.INSTANCE.getCorrespondingLobCode(jdbcTypeCode);\n        } else {\n            if (Serializable.class.isAssignableFrom(entityAttributeJavaType)) {\n                jdbcTypeCode = Types.BLOB;\n            } else {\n                throw new IllegalArgumentException(String.format(Locale.ROOT, \"JDBC type-code [%s (%s)] not known to have a corresponding LOB equivalent, and Java type is not Serializable (to use BLOB)\", jdbcTypeCode, JdbcTypeNameMapper.getTypeName(jdbcTypeCode)));\n            }\n        }\n    }\n    if (isNationalized()) {\n        jdbcTypeCode = NationalizedTypeMappings.INSTANCE.getCorrespondingNationalizedCode(jdbcTypeCode);\n    }\n    final SqlTypeDescriptor sqlTypeDescriptor = SqlTypeDescriptorRegistry.INSTANCE.getDescriptor(jdbcTypeCode);\n    final JavaTypeDescriptor intermediateJavaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(databaseColumnJavaType);\n    final SqlTypeDescriptor sqlTypeDescriptorAdapter = new AttributeConverterSqlTypeDescriptorAdapter(attributeConverterDefinition.getAttributeConverter(), sqlTypeDescriptor, intermediateJavaTypeDescriptor);\n    final String name = AttributeConverterTypeAdapter.NAME_PREFIX + attributeConverterDefinition.getAttributeConverter().getClass().getName();\n    final String description = String.format(\"BasicType adapter for AttributeConverter<%s,%s>\", entityAttributeJavaType.getSimpleName(), databaseColumnJavaType.getSimpleName());\n    return new AttributeConverterTypeAdapter(name, description, attributeConverterDefinition.getAttributeConverter(), sqlTypeDescriptorAdapter, entityAttributeJavaType, databaseColumnJavaType, entityAttributeJavaTypeDescriptor);\n}"
    },
    {
      "commit": "38c004431d006ac5173d0c095f97415b5e6267a6",
      "startLine": 5,
      "endLine": 6,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprivate Type buildAttributeConverterTypeAdapter() {\n    final Class entityAttributeJavaType = attributeConverterDefinition.getEntityAttributeType();\n    final Class databaseColumnJavaType = attributeConverterDefinition.getDatabaseColumnType();\n    final JavaTypeDescriptor entityAttributeJavaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(entityAttributeJavaType);\n    int jdbcTypeCode = JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass(databaseColumnJavaType);\n    if (isNationalized()) {\n        jdbcTypeCode = NationalizedTypeMappings.INSTANCE.getCorrespondingNationalizedCode(jdbcTypeCode);\n    }\n    final SqlTypeDescriptor sqlTypeDescriptor = SqlTypeDescriptorRegistry.INSTANCE.getDescriptor(jdbcTypeCode);\n    final JavaTypeDescriptor intermediateJavaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(databaseColumnJavaType);\n    final SqlTypeDescriptor sqlTypeDescriptorAdapter = new AttributeConverterSqlTypeDescriptorAdapter(attributeConverterDefinition.getAttributeConverter(), sqlTypeDescriptor, intermediateJavaTypeDescriptor);\n    final String name = AttributeConverterTypeAdapter.NAME_PREFIX + attributeConverterDefinition.getAttributeConverter().getClass().getName();\n    final String description = String.format(\"BasicType adapter for AttributeConverter<%s,%s>\", entityAttributeJavaType.getSimpleName(), databaseColumnJavaType.getSimpleName());\n    return new AttributeConverterTypeAdapter(name, description, attributeConverterDefinition.getAttributeConverter(), sqlTypeDescriptorAdapter, entityAttributeJavaType, databaseColumnJavaType, entityAttributeJavaTypeDescriptor);\n}"
    },
    {
      "commit": "22730624fc267cd12bf1e6551158fa3057fd8d58",
      "startLine": 5,
      "endLine": 6,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprivate Type buildAttributeConverterTypeAdapter() {\n    final Class entityAttributeJavaType = attributeConverterDefinition.getEntityAttributeType();\n    final Class databaseColumnJavaType = attributeConverterDefinition.getDatabaseColumnType();\n    final JavaTypeDescriptor entityAttributeJavaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(entityAttributeJavaType);\n    final int jdbcTypeCode = JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass(databaseColumnJavaType);\n    final SqlTypeDescriptor sqlTypeDescriptor = SqlTypeDescriptorRegistry.INSTANCE.getDescriptor(jdbcTypeCode);\n    final JavaTypeDescriptor intermediateJavaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(databaseColumnJavaType);\n    final SqlTypeDescriptor sqlTypeDescriptorAdapter = new AttributeConverterSqlTypeDescriptorAdapter(attributeConverterDefinition.getAttributeConverter(), sqlTypeDescriptor, intermediateJavaTypeDescriptor);\n    final String name = AttributeConverterTypeAdapter.NAME_PREFIX + attributeConverterDefinition.getAttributeConverter().getClass().getName();\n    final String description = String.format(\"BasicType adapter for AttributeConverter<%s,%s>\", entityAttributeJavaType.getSimpleName(), databaseColumnJavaType.getSimpleName());\n    return new AttributeConverterTypeAdapter(name, description, attributeConverterDefinition.getAttributeConverter(), sqlTypeDescriptorAdapter, entityAttributeJavaType, databaseColumnJavaType, entityAttributeJavaTypeDescriptor);\n}"
    },
    {
      "commit": "498735aa3791097e0fc25e918d47336f359fa5ae",
      "startLine": 5,
      "endLine": 6,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprivate Type buildAttributeConverterTypeAdapter() {\n    final Class entityAttributeJavaType = attributeConverterDefinition.getEntityAttributeType();\n    final Class databaseColumnJavaType = attributeConverterDefinition.getDatabaseColumnType();\n    final JavaTypeDescriptor entityAttributeJavaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(entityAttributeJavaType);\n    final int jdbcTypeCode = JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass(databaseColumnJavaType);\n    final SqlTypeDescriptor sqlTypeDescriptor = SqlTypeDescriptorRegistry.INSTANCE.getDescriptor(jdbcTypeCode);\n    final JavaTypeDescriptor intermediateJavaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(databaseColumnJavaType);\n    final SqlTypeDescriptor sqlTypeDescriptorAdapter = new AttributeConverterSqlTypeDescriptorAdapter(attributeConverterDefinition.getAttributeConverter(), sqlTypeDescriptor, intermediateJavaTypeDescriptor);\n    final String name = String.format(\"BasicType adapter for AttributeConverter<%s,%s>\", entityAttributeJavaType.getSimpleName(), databaseColumnJavaType.getSimpleName());\n    return new AttributeConverterTypeAdapter(name, attributeConverterDefinition.getAttributeConverter(), sqlTypeDescriptorAdapter, entityAttributeJavaType, databaseColumnJavaType, entityAttributeJavaTypeDescriptor);\n}"
    },
    {
      "commit": "1f6daa67854e1fd6c464fe3d2a98bda1047b252d",
      "startLine": 5,
      "endLine": 6,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprivate Type buildAttributeConverterTypeAdapter() {\n    final Class entityAttributeJavaType = attributeConverterDefinition.getEntityAttributeType();\n    final Class databaseColumnJavaType = attributeConverterDefinition.getDatabaseColumnType();\n    final JavaTypeDescriptor entityAttributeJavaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(entityAttributeJavaType);\n    final int jdbcTypeCode = JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass(databaseColumnJavaType);\n    final SqlTypeDescriptor sqlTypeDescriptor = SqlTypeDescriptorRegistry.INSTANCE.getDescriptor(jdbcTypeCode);\n    final JavaTypeDescriptor intermediateJavaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(databaseColumnJavaType);\n    final SqlTypeDescriptor sqlTypeDescriptorAdapter = new AttributeConverterSqlTypeDescriptorAdapter(attributeConverterDefinition.getAttributeConverter(), sqlTypeDescriptor, intermediateJavaTypeDescriptor);\n    final String name = String.format(\"BasicType adapter for AttributeConverter<%s,%s>\", entityAttributeJavaType.getSimpleName(), databaseColumnJavaType.getSimpleName());\n    return new AttributeConverterTypeAdapter(name, attributeConverterDefinition.getAttributeConverter(), sqlTypeDescriptorAdapter, entityAttributeJavaTypeDescriptor);\n}"
    },
    {
      "commit": "9f86babd880b785b965f7f1b55d58dc6a6943ada",
      "startLine": 5,
      "endLine": 6,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprivate Type buildAttributeConverterTypeAdapter() {\n    final Class entityAttributeJavaType = jpaAttributeConverterDefinition.getEntityAttributeType();\n    final Class databaseColumnJavaType = jpaAttributeConverterDefinition.getDatabaseColumnType();\n    final JavaTypeDescriptor entityAttributeJavaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(entityAttributeJavaType);\n    final int jdbcTypeCode = JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass(databaseColumnJavaType);\n    final SqlTypeDescriptor sqlTypeDescriptor = SqlTypeDescriptorRegistry.INSTANCE.getDescriptor(jdbcTypeCode);\n    final JavaTypeDescriptor intermediateJavaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(databaseColumnJavaType);\n    final SqlTypeDescriptor sqlTypeDescriptorAdapter = new AttributeConverterSqlTypeDescriptorAdapter(jpaAttributeConverterDefinition.getAttributeConverter(), sqlTypeDescriptor, intermediateJavaTypeDescriptor);\n    final String name = String.format(\"BasicType adapter for AttributeConverter<%s,%s>\", entityAttributeJavaType.getSimpleName(), databaseColumnJavaType.getSimpleName());\n    return new AttributeConverterTypeAdapter(name, jpaAttributeConverterDefinition.getAttributeConverter(), sqlTypeDescriptorAdapter, entityAttributeJavaTypeDescriptor);\n}"
    },
    {
      "commit": "bf168ca24ef0c328bd53d6d32e79f66b99ac56db",
      "startLine": 5,
      "endLine": 6,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprivate Type buildAttributeConverterTypeAdapter() {\n    final Class entityAttributeJavaType = jpaAttributeConverterDefinition.getEntityAttributeType();\n    final Class databaseColumnJavaType = jpaAttributeConverterDefinition.getDatabaseColumnType();\n    final JavaTypeDescriptor entityAttributeJavaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(entityAttributeJavaType);\n    final int jdbcTypeCode = JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass(databaseColumnJavaType);\n    final SqlTypeDescriptor sqlTypeDescriptor = SqlTypeDescriptorRegistry.INSTANCE.getDescriptor(jdbcTypeCode);\n    final JavaTypeDescriptor intermediateJavaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(databaseColumnJavaType);\n    final SqlTypeDescriptor sqlTypeDescriptorAdapter = new AttributeConverterSqlTypeDescriptorAdapter(jpaAttributeConverterDefinition.getAttributeConverter(), sqlTypeDescriptor, intermediateJavaTypeDescriptor);\n    final String name = \"BasicType adapter for AttributeConverter<\" + entityAttributeJavaType + \",\" + databaseColumnJavaType + \">\";\n    return new AttributeConverterTypeAdapter(sqlTypeDescriptorAdapter, entityAttributeJavaTypeDescriptor, name);\n}"
    },
    {
      "commit": "7bcf161d36d5b1e59fba1ae32e8e2d692c2fd33d",
      "startLine": 5,
      "endLine": 6,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprivate Type buildAttributeConverterTypeAdapter() {\n    final Class entityAttributeJavaType = jpaAttributeConverterDefinition.getEntityAttributeType();\n    final Class databaseColumnJavaType = jpaAttributeConverterDefinition.getDatabaseColumnType();\n    final JavaTypeDescriptor entityAttributeJavaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(entityAttributeJavaType);\n    final int jdbcTypeCode = JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass(databaseColumnJavaType);\n    final SqlTypeDescriptor sqlTypeDescriptor = SqlTypeDescriptorRegistry.INSTANCE.getDescriptor(jdbcTypeCode);\n    final JavaTypeDescriptor intermediateJavaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor(databaseColumnJavaType);\n    final SqlTypeDescriptor sqlTypeDescriptorAdapter = new AttributeConverterSqlTypeDescriptorAdapter(jpaAttributeConverterDefinition.getAttributeConverter(), sqlTypeDescriptor, intermediateJavaTypeDescriptor);\n    final String name = \"BasicType adapter for AttributeConverter<\" + entityAttributeJavaType + \",\" + databaseColumnJavaType + \">\";\n    final Type type = new AbstractSingleColumnStandardBasicType(sqlTypeDescriptorAdapter, entityAttributeJavaTypeDescriptor) {\n\n        @Override\n        public String getName() {\n            return name;\n        }\n    };\n    log.debug(\"Created : \" + name);\n    return type;\n}"
    }
  ]
}