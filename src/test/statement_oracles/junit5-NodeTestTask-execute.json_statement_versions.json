{
  "statementVersions": [
    {
      "commit": "137f831bba9d0f45085d64fad47947cbc91a30e9",
      "startLine": 3,
      "endLine": 10,
      "methodCode": "@Override\npublic void execute() {\n    throwableCollector = throwableCollectorFactory.create();\n    prepare();\n    if (throwableCollector.isEmpty()) {\n        checkWhetherSkipped();\n    }\n    if (throwableCollector.isEmpty() && !skipResult.isSkipped()) {\n        executeRecursively();\n    }\n    if (context != null) {\n        cleanUp();\n    }\n    reportCompletion();\n}"
    },
    {
      "commit": "c1d682aee5da5738fc3be071df45330c005f4cf1",
      "startLine": 3,
      "endLine": 9,
      "methodCode": "@Override\npublic void execute() {\n    prepare();\n    if (throwableCollector.isEmpty()) {\n        checkWhetherSkipped();\n    }\n    if (throwableCollector.isEmpty() && !skipResult.isSkipped()) {\n        executeRecursively();\n    }\n    if (context != null) {\n        cleanUp();\n    }\n    reportCompletion();\n}"
    },
    {
      "commit": "2f3440e0f221255a83b28c42cf77407bde92a8b4",
      "startLine": 3,
      "endLine": 9,
      "methodCode": "@Override\npublic void execute() {\n    prepare();\n    if (executionErrors.isEmpty()) {\n        checkWhetherSkipped();\n    }\n    if (executionErrors.isEmpty() && !skipResult.isSkipped()) {\n        executeRecursively();\n    }\n    if (context != null) {\n        cleanUp();\n    }\n    reportCompletion();\n}"
    },
    {
      "commit": "1092538773cba2058658bc41515a4d05cb50f19e",
      "startLine": 3,
      "endLine": 9,
      "methodCode": "void execute(C parentContext, ExecutionTracker tracker) {\n    tracker.markExecuted(testDescriptor);\n    prepare(parentContext);\n    if (executionErrors.isEmpty()) {\n        checkWhetherSkipped();\n    }\n    if (executionErrors.isEmpty() && !skipResult.isSkipped()) {\n        executeRecursively(tracker);\n    }\n    if (context != null) {\n        cleanUp();\n    }\n    reportDone();\n}"
    },
    {
      "commit": "805d4dad6d3893b8e973019b824167d7b6f2cb8c",
      "startLine": 3,
      "endLine": 9,
      "methodCode": "void execute(C parentContext, ExecutionTracker tracker) {\n    tracker.markExecuted(testDescriptor);\n    prepare(parentContext);\n    if (executionErrors.isEmpty()) {\n        checkWhetherSkipped();\n    }\n    if (executionErrors.isEmpty() && !skipResult.isSkipped()) {\n        executeRecursively(tracker);\n    }\n    cleanUp();\n    reportDone();\n}"
    },
    {
      "commit": "e0a49d10ffb6505755fc8a0308e898382e3cc1eb",
      "startLine": 5,
      "endLine": 34,
      "methodCode": "private void execute(TestDescriptor testDescriptor, C parentContext, ExecutionTracker tracker) {\n    Node<C> node = asNode(testDescriptor);\n    tracker.markExecuted(testDescriptor);\n    C preparedContext;\n    try {\n        preparedContext = node.prepare(parentContext);\n    } catch (Throwable throwable) {\n        rethrowIfBlacklisted(throwable);\n        reportAsFailed(testDescriptor, throwable);\n        return;\n    }\n    SkipResult skipResult;\n    try {\n        skipResult = node.shouldBeSkipped(preparedContext);\n    } catch (Exception exception) {\n        rethrowIfBlacklisted(exception);\n        try {\n            node.cleanUp(preparedContext);\n        } catch (Exception cleanupException) {\n            exception.addSuppressed(cleanupException);\n        } finally {\n            reportAsFailed(testDescriptor, exception);\n        }\n        return;\n    }\n    if (skipResult.isSkipped()) {\n        try {\n            node.cleanUp(preparedContext);\n            this.listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"<unknown>\"));\n        } catch (Exception exception) {\n            reportAsFailed(testDescriptor, exception);\n        }\n        return;\n    }\n    this.listener.executionStarted(testDescriptor);\n    TestExecutionResult result = singleTestExecutor.executeSafely(() -> {\n        C context = preparedContext;\n        try {\n            context = node.before(context);\n            C contextForDynamicChildren = context;\n            context = node.execute(context, dynamicTestDescriptor -> {\n                this.listener.dynamicTestRegistered(dynamicTestDescriptor);\n                execute(dynamicTestDescriptor, contextForDynamicChildren, tracker);\n            });\n            C contextForStaticChildren = context;\n            testDescriptor.getChildren().stream().filter(child -> !tracker.wasAlreadyExecuted(child)).forEach(child -> execute(child, contextForStaticChildren, tracker));\n        } finally {\n            try {\n                node.after(context);\n            } finally {\n                node.cleanUp(context);\n            }\n        }\n    });\n    this.listener.executionFinished(testDescriptor, result);\n}"
    },
    {
      "commit": "a3e4b97efb03bd7b52d18c17b9dc185d112a04e8",
      "startLine": 5,
      "endLine": 12,
      "methodCode": "private void execute(TestDescriptor testDescriptor, C parentContext, ExecutionTracker tracker) {\n    Node<C> node = asNode(testDescriptor);\n    tracker.markExecuted(testDescriptor);\n    C preparedContext;\n    try {\n        preparedContext = node.prepare(parentContext);\n        SkipResult skipResult = node.shouldBeSkipped(preparedContext);\n        if (skipResult.isSkipped()) {\n            this.listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"<unknown>\"));\n            return;\n        }\n    } catch (Throwable throwable) {\n        rethrowIfBlacklisted(throwable);\n        this.listener.executionStarted(testDescriptor);\n        this.listener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n        return;\n    }\n    this.listener.executionStarted(testDescriptor);\n    TestExecutionResult result = singleTestExecutor.executeSafely(() -> {\n        C context = preparedContext;\n        try {\n            context = node.before(context);\n            C contextForDynamicChildren = context;\n            context = node.execute(context, dynamicTestDescriptor -> {\n                this.listener.dynamicTestRegistered(dynamicTestDescriptor);\n                execute(dynamicTestDescriptor, contextForDynamicChildren, tracker);\n            });\n            C contextForStaticChildren = context;\n            testDescriptor.getChildren().stream().filter(child -> !tracker.wasAlreadyExecuted(child)).forEach(child -> execute(child, contextForStaticChildren, tracker));\n        } finally {\n            node.after(context);\n        }\n    });\n    this.listener.executionFinished(testDescriptor, result);\n}"
    },
    {
      "commit": "4b41518fa052b28a953e99b087d505603a22c175",
      "startLine": 4,
      "endLine": 16,
      "methodCode": "private void execute(TestDescriptor testDescriptor, C parentContext) {\n    Node<C> node = asNode(testDescriptor);\n    C preparedContext;\n    try {\n        preparedContext = node.prepare(parentContext);\n        SkipResult skipResult = node.shouldBeSkipped(preparedContext);\n        if (skipResult.isSkipped()) {\n            this.listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"<unknown>\"));\n            return;\n        }\n    } catch (Throwable throwable) {\n        rethrowIfBlacklisted(throwable);\n        this.listener.executionStarted(testDescriptor);\n        this.listener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n        return;\n    }\n    this.listener.executionStarted(testDescriptor);\n    TestExecutionResult result = singleTestExecutor.executeSafely(() -> {\n        C context = preparedContext;\n        try {\n            context = node.before(context);\n            C dynamicTestContext = context;\n            context = node.execute(context, dynamicTestDescriptor -> {\n                this.listener.dynamicTestRegistered(dynamicTestDescriptor);\n                execute(dynamicTestDescriptor, dynamicTestContext);\n            });\n            if (!node.isLeaf()) {\n                for (TestDescriptor child : testDescriptor.getChildren()) {\n                    execute(child, context);\n                }\n            }\n        } finally {\n            node.after(context);\n        }\n    });\n    this.listener.executionFinished(testDescriptor, result);\n}"
    },
    {
      "commit": "67f3391ab9887e5956a650c7a6b645ab04a62157",
      "startLine": 4,
      "endLine": 16,
      "methodCode": "private void execute(TestDescriptor testDescriptor, C parentContext) {\n    Node<C> node = asNode(testDescriptor);\n    C preparedContext;\n    try {\n        preparedContext = node.prepare(parentContext);\n        SkipResult skipResult = node.shouldBeSkipped(preparedContext);\n        if (skipResult.isSkipped()) {\n            this.listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"<unknown>\"));\n            return;\n        }\n    } catch (Throwable throwable) {\n        rethrowIfBlacklisted(throwable);\n        this.listener.executionStarted(testDescriptor);\n        this.listener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n        return;\n    }\n    this.listener.executionStarted(testDescriptor);\n    TestExecutionResult result = singleTestExecutor.executeSafely(() -> {\n        C context = preparedContext;\n        try {\n            context = node.before(context);\n            context = node.execute(context);\n            if (!node.isLeaf()) {\n                for (TestDescriptor child : testDescriptor.getChildren()) {\n                    execute(child, context);\n                }\n            }\n        } finally {\n            node.after(context);\n        }\n    });\n    this.listener.executionFinished(testDescriptor, result);\n}"
    },
    {
      "commit": "62c433c14ce9d70fa5b82ef385a6e15c22cc0003",
      "startLine": 4,
      "endLine": 16,
      "methodCode": "private void execute(TestDescriptor testDescriptor, C parentContext) {\n    Node<C> node = asNode(testDescriptor);\n    C preparedContext;\n    try {\n        preparedContext = node.prepare(parentContext);\n        SkipResult skipResult = node.shouldBeSkipped(preparedContext);\n        if (skipResult.isSkipped()) {\n            this.listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"<unknown>\"));\n            return;\n        }\n    } catch (Throwable throwable) {\n        rethrowIfBlacklisted(throwable);\n        this.listener.executionStarted(testDescriptor);\n        this.listener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n        return;\n    }\n    this.listener.executionStarted(testDescriptor);\n    TestExecutionResult result = singleTestExecutor.executeSafely(() -> {\n        C context = preparedContext;\n        try {\n            context = node.before(context);\n            context = node.execute(context);\n            if (!node.isLeaf()) {\n                for (TestDescriptor child : testDescriptor.getChildren()) {\n                    execute(child, context);\n                }\n            }\n        } finally {\n            node.after(context);\n        }\n    });\n    this.listener.executionFinished(testDescriptor, result);\n}"
    },
    {
      "commit": "5ca993afb2db6a2dd10e3fb4f0790cf30200a6ec",
      "startLine": 4,
      "endLine": 16,
      "methodCode": "private void execute(TestDescriptor testDescriptor, C parentContext) {\n    Node<C> node = asNode(testDescriptor);\n    C preparedContext;\n    try {\n        preparedContext = node.prepare(parentContext);\n        SkipResult skipResult = node.shouldBeSkipped(preparedContext);\n        if (skipResult.isSkipped()) {\n            this.listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"<unknown>\"));\n            return;\n        }\n    } catch (Throwable throwable) {\n        rethrowIfBlacklisted(throwable);\n        this.listener.executionStarted(testDescriptor);\n        this.listener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n        return;\n    }\n    this.listener.executionStarted(testDescriptor);\n    TestExecutionResult result = singleTestExecutor.executeSafely(() -> {\n        C context = node.before(preparedContext);\n        context = node.execute(context);\n        if (!node.isLeaf()) {\n            for (TestDescriptor child : testDescriptor.getChildren()) {\n                execute(child, context);\n            }\n        }\n        node.after(context);\n    });\n    this.listener.executionFinished(testDescriptor, result);\n}"
    },
    {
      "commit": "4972eb58d680a30e8fbd1ffb6cdc6477bef83374",
      "startLine": 4,
      "endLine": 16,
      "methodCode": "private void execute(TestDescriptor testDescriptor, C parentContext) {\n    Node<C> node = asNode(testDescriptor);\n    C preparedContext;\n    try {\n        preparedContext = node.prepare(parentContext);\n        SkipResult skipResult = node.shouldBeSkipped(preparedContext);\n        if (skipResult.isSkipped()) {\n            this.listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"<unknown>\"));\n            return;\n        }\n    } catch (Throwable throwable) {\n        rethrowIfBlacklisted(throwable);\n        this.listener.executionStarted(testDescriptor);\n        this.listener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n        return;\n    }\n    this.listener.executionStarted(testDescriptor);\n    TestExecutionResult result = singleTestExecutor.executeSafely(() -> {\n        C context = node.before(preparedContext);\n        context = node.execute(context);\n        if (!node.isLeaf()) {\n            for (TestDescriptor child : testDescriptor.getChildren()) {\n                execute(child, context);\n            }\n        }\n        node.after(context);\n    });\n    this.listener.executionFinished(testDescriptor, result);\n}"
    },
    {
      "commit": "4537bec58804c392a8bce296dced0337c8ec1a8d",
      "startLine": 4,
      "endLine": 16,
      "methodCode": "private void execute(TestDescriptor testDescriptor, C parentContext) {\n    Node<C> node = asNode(testDescriptor);\n    C preparedContext;\n    try {\n        preparedContext = node.prepare(parentContext);\n        SkipResult skipResult = node.shouldBeSkipped(preparedContext);\n        if (skipResult.isSkipped()) {\n            this.listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"<unknown>\"));\n            return;\n        }\n    } catch (Throwable throwable) {\n        rethrowIfBlacklisted(throwable);\n        this.listener.executionStarted(testDescriptor);\n        this.listener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n        return;\n    }\n    this.listener.executionStarted(testDescriptor);\n    TestExecutionResult result = singleTestExecutor.executeSafely(() -> {\n        C context = node.before(preparedContext);\n        context = node.execute(context);\n        if (!node.isLeaf()) {\n            for (TestDescriptor child : testDescriptor.getChildren()) {\n                execute(child, context);\n            }\n        }\n        node.after(context);\n    });\n    this.listener.executionFinished(testDescriptor, result);\n}"
    },
    {
      "commit": "6b46df0ee35ef56021ca5f4dc9e41ac96b19de0e",
      "startLine": 4,
      "endLine": 16,
      "methodCode": "private void execute(TestDescriptor testDescriptor, C parentContext) {\n    Node<C> node = asNode(testDescriptor);\n    C preparedContext;\n    try {\n        preparedContext = node.prepare(parentContext);\n        SkipResult skipResult = node.shouldBeSkipped(preparedContext);\n        if (skipResult.isSkipped()) {\n            this.listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"<unknown>\"));\n            return;\n        }\n    } catch (Throwable throwable) {\n        rethrowIfBlacklisted(throwable);\n        this.listener.executionStarted(testDescriptor);\n        this.listener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n        return;\n    }\n    this.listener.executionStarted(testDescriptor);\n    TestExecutionResult result = singleTestExecutor.executeSafely(() -> {\n        C context = node.before(preparedContext);\n        context = node.execute(context);\n        if (!node.isLeaf()) {\n            for (TestDescriptor child : testDescriptor.getChildren()) {\n                execute(child, context);\n            }\n        }\n        node.after(context);\n    });\n    this.listener.executionFinished(testDescriptor, result);\n}"
    },
    {
      "commit": "c8e52a7cde0579562c51c838ef1c83b68b0c31cf",
      "startLine": 4,
      "endLine": 16,
      "methodCode": "private void execute(TestDescriptor testDescriptor, C parentContext) {\n    Node<C> node = asNode(testDescriptor);\n    C preparedContext;\n    try {\n        preparedContext = node.prepare(parentContext);\n        SkipResult skipResult = node.shouldBeSkipped(preparedContext);\n        if (skipResult.isSkipped()) {\n            this.listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"<unknown>\"));\n            return;\n        }\n    } catch (Throwable throwable) {\n        rethrowIfBlacklisted(throwable);\n        this.listener.executionStarted(testDescriptor);\n        this.listener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n        return;\n    }\n    this.listener.executionStarted(testDescriptor);\n    TestExecutionResult result = singleTestExecutor.executeSafely(() -> {\n        C context = node.before(preparedContext);\n        context = node.execute(context);\n        if (!node.isLeaf()) {\n            for (TestDescriptor child : testDescriptor.getChildren()) {\n                execute(child, context);\n            }\n        }\n        node.after(context);\n    });\n    this.listener.executionFinished(testDescriptor, result);\n}"
    },
    {
      "commit": "ac7bb522519cd8a600324aa909a5c17a110cb97f",
      "startLine": 3,
      "endLine": 15,
      "methodCode": "private void executeAll(TestDescriptor testDescriptor, C parentContext) {\n    C preparedContext;\n    try {\n        preparedContext = adapter.asNode(testDescriptor).prepare(parentContext);\n        SkipResult skipResult = adapter.asNode(testDescriptor).shouldBeSkipped(preparedContext);\n        if (skipResult.isSkipped()) {\n            listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"<unknown>\"));\n            return;\n        }\n    } catch (Throwable throwable) {\n        rethrowIfBlacklisted(throwable);\n        listener.executionStarted(testDescriptor);\n        listener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n        return;\n    }\n    listener.executionStarted(testDescriptor);\n    TestExecutionResult result = singleTestExecutor.executeSafely(() -> {\n        C context = adapter.asContainer(testDescriptor).beforeAll(preparedContext);\n        context = adapter.asLeaf(testDescriptor).execute(context);\n        if (testDescriptor instanceof Container) {\n            for (TestDescriptor child : testDescriptor.getChildren()) {\n                executeAll(child, context);\n            }\n        }\n        context = adapter.asContainer(testDescriptor).afterAll(context);\n    });\n    listener.executionFinished(testDescriptor, result);\n}"
    },
    {
      "commit": "2d0b61d00defaa534532d5541cfcb818307ff0d0",
      "startLine": 3,
      "endLine": 15,
      "methodCode": "private void executeAll(TestDescriptor testDescriptor, C parentContext) {\n    C preparedContext;\n    try {\n        preparedContext = adapter.asNode(testDescriptor).prepare(parentContext);\n        SkipResult skipResult = adapter.asNode(testDescriptor).shouldBeSkipped(preparedContext);\n        if (skipResult.isSkipped()) {\n            listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"<unknown>\"));\n            return;\n        }\n    } catch (Throwable throwable) {\n        rethrowIfBlacklisted(throwable);\n        listener.executionStarted(testDescriptor);\n        listener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n        return;\n    }\n    listener.executionStarted(testDescriptor);\n    TestExecutionResult result = singleTestExecutor.executeSafely(() -> {\n        C context = adapter.asContainer(testDescriptor).beforeAll(preparedContext);\n        context = adapter.asLeaf(testDescriptor).execute(context);\n        for (TestDescriptor child : testDescriptor.getChildren()) {\n            executeAll(child, context);\n        }\n        context = adapter.asContainer(testDescriptor).afterAll(context);\n    });\n    listener.executionFinished(testDescriptor, result);\n}"
    },
    {
      "commit": "ebd537b73796d734739fa6aabb78b4e88bbdd907",
      "startLine": 3,
      "endLine": 15,
      "methodCode": "private void executeAll(TestDescriptor testDescriptor, C parentContext) {\n    C preparedContext;\n    try {\n        preparedContext = adapter.asNode(testDescriptor).prepare(parentContext);\n        SkipResult skipResult = adapter.asNode(testDescriptor).shouldBeSkipped(preparedContext);\n        if (skipResult.isSkipped()) {\n            listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"\"));\n            return;\n        }\n    } catch (Throwable throwable) {\n        rethrowIfBlacklisted(throwable);\n        listener.executionStarted(testDescriptor);\n        listener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n        return;\n    }\n    listener.executionStarted(testDescriptor);\n    TestExecutionResult result = singleTestExecutor.executeSafely(() -> {\n        C context = adapter.asContainer(testDescriptor).beforeAll(preparedContext);\n        context = adapter.asLeaf(testDescriptor).execute(context);\n        for (TestDescriptor child : testDescriptor.getChildren()) {\n            executeAll(child, context);\n        }\n        context = adapter.asContainer(testDescriptor).afterAll(context);\n    });\n    listener.executionFinished(testDescriptor, result);\n}"
    },
    {
      "commit": "0d2aa7088f7a586113524ba74448febcf6c70c51",
      "startLine": 3,
      "endLine": 15,
      "methodCode": "private void executeAll(TestDescriptor testDescriptor, C parentContext) {\n    C preparedContext;\n    try {\n        preparedContext = adapter.asNode(testDescriptor).prepare(parentContext);\n        SkipResult skipResult = adapter.asNode(testDescriptor).shouldBeSkipped(preparedContext);\n        if (skipResult.isSkipped()) {\n            listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"\"));\n            return;\n        }\n    } catch (Throwable throwable) {\n        rethrowIfBlacklisted(throwable);\n        listener.executionStarted(testDescriptor);\n        listener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n        return;\n    }\n    listener.executionStarted(testDescriptor);\n    TestExecutionResult result = singleTestExecutor.executeSafely(() -> {\n        C context = adapter.asContainer(testDescriptor).beforeAll(preparedContext);\n        context = adapter.asLeaf(testDescriptor).execute(context);\n        for (TestDescriptor child : testDescriptor.getChildren()) {\n            executeAll(child, context);\n        }\n        context = adapter.asContainer(testDescriptor).afterAll(context);\n    });\n    listener.executionFinished(testDescriptor, result);\n}"
    },
    {
      "commit": "742e38c48236556233c280ddafe8a55e570de1a2",
      "startLine": 3,
      "endLine": 15,
      "methodCode": "private void executeAll(TestDescriptor testDescriptor, C parentContext) {\n    C preparedContext;\n    try {\n        preparedContext = adapter.asNode(testDescriptor).prepare(parentContext);\n        SkipResult skipResult = adapter.asNode(testDescriptor).shouldBeSkipped(preparedContext);\n        if (skipResult.isSkipped()) {\n            listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"\"));\n            return;\n        }\n    } catch (Throwable throwable) {\n        rethrowIfBlacklisted(throwable);\n        listener.executionStarted(testDescriptor);\n        listener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n        return;\n    }\n    listener.executionStarted(testDescriptor);\n    TestExecutionResult result = singleTestExecutor.executeSafely(() -> {\n        C context = adapter.asContainer(testDescriptor).beforeAll(preparedContext);\n        context = adapter.asLeaf(testDescriptor).execute(context);\n        for (TestDescriptor child : testDescriptor.getChildren()) {\n            executeAll(child, context);\n        }\n        context = adapter.asContainer(testDescriptor).afterAll(context);\n    });\n    listener.executionFinished(testDescriptor, result);\n}"
    },
    {
      "commit": "a02c0e24af370ced24d8fa9d758b1a1db396796f",
      "startLine": 3,
      "endLine": 15,
      "methodCode": "private void executeAll(TestDescriptor testDescriptor, C parentContext) {\n    C preparedContext;\n    try {\n        preparedContext = adapter.asNode(testDescriptor).prepare(parentContext);\n        SkipResult skipResult = adapter.asNode(testDescriptor).shouldBeSkipped(preparedContext);\n        if (skipResult.isSkipped()) {\n            listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"\"));\n            return;\n        }\n    } catch (Throwable throwable) {\n        rethrowIfBlackListed(throwable);\n        listener.executionStarted(testDescriptor);\n        listener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n        return;\n    }\n    listener.executionStarted(testDescriptor);\n    TestExecutionResult result = singleTestExecutor.executeSafely(() -> {\n        C context = adapter.asContainer(testDescriptor).beforeAll(preparedContext);\n        context = adapter.asLeaf(testDescriptor).execute(context);\n        for (TestDescriptor child : testDescriptor.getChildren()) {\n            executeAll(child, context);\n        }\n        context = adapter.asContainer(testDescriptor).afterAll(context);\n    });\n    listener.executionFinished(testDescriptor, result);\n}"
    },
    {
      "commit": "c54786d16f1c5f5ac5384a68893d069eba062e39",
      "startLine": 3,
      "endLine": 14,
      "methodCode": "private void executeAll(TestDescriptor testDescriptor, C parentContext) {\n    C preparedContext;\n    try {\n        preparedContext = adapter.asNode(testDescriptor).prepare(parentContext);\n        SkipResult skipResult = adapter.asNode(testDescriptor).shouldBeSkipped(preparedContext);\n        if (skipResult.isSkipped()) {\n            listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"\"));\n            return;\n        }\n    } catch (Throwable throwable) {\n        listener.executionStarted(testDescriptor);\n        listener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n        return;\n    }\n    listener.executionStarted(testDescriptor);\n    TestExecutionResult result = singleTestExecutor.executeSafely(() -> {\n        C context = adapter.asContainer(testDescriptor).beforeAll(preparedContext);\n        context = adapter.asLeaf(testDescriptor).execute(context);\n        for (TestDescriptor child : testDescriptor.getChildren()) {\n            executeAll(child, context);\n        }\n        context = adapter.asContainer(testDescriptor).afterAll(context);\n    });\n    listener.executionFinished(testDescriptor, result);\n}"
    },
    {
      "commit": "0027ade00fd483e08714ece1021a7715bb1855da",
      "startLine": 3,
      "endLine": 12,
      "methodCode": "private void executeAll(TestDescriptor testDescriptor, C parentContext) {\n    C preparedContext;\n    try {\n        preparedContext = adapter.asNode(testDescriptor).prepare(parentContext);\n        SkipResult skipResult = adapter.asNode(testDescriptor).shouldBeSkipped(preparedContext);\n        if (skipResult.isSkipped()) {\n            listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"\"));\n            return;\n        }\n    } catch (Throwable throwable) {\n        throw new RuntimeException(throwable);\n    }\n    listener.executionStarted(testDescriptor);\n    TestExecutionResult result = singleTestExecutor.executeSafely(() -> {\n        C context = adapter.asContainer(testDescriptor).beforeAll(preparedContext);\n        context = adapter.asLeaf(testDescriptor).execute(context);\n        for (TestDescriptor child : testDescriptor.getChildren()) {\n            executeAll(child, context);\n        }\n        context = adapter.asContainer(testDescriptor).afterAll(context);\n    });\n    listener.executionFinished(testDescriptor, result);\n}"
    }
  ]
}