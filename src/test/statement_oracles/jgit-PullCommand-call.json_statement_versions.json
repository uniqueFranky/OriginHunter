{
  "statementVersions": [
    {
      "commit": "0210e0e299bed69176e0a929d0b67f3cf9fb1e37",
      "startLine": 35,
      "endLine": 52,
      "methodCode": "@Override\npublic PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, InvalidRemoteException, CanceledException, RefNotFoundException, RefNotAdvertisedException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    Config repoConfig = repo.getConfig();\n    String branchName = null;\n    try {\n        String fullBranch = repo.getFullBranch();\n        if (fullBranch != null && fullBranch.startsWith(Constants.R_HEADS)) {\n            branchName = fullBranch.substring(Constants.R_HEADS.length());\n        }\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (remoteBranchName == null && branchName != null) {\n        remoteBranchName = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    }\n    if (remoteBranchName == null) {\n        remoteBranchName = branchName;\n    }\n    if (remoteBranchName == null) {\n        throw new NoHeadException(JGitText.get().cannotCheckoutFromUnbornBranch);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    if (remote == null && branchName != null) {\n        remote = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    }\n    if (remote == null) {\n        remote = Constants.DEFAULT_REMOTE_NAME;\n    }\n    if (pullRebaseMode == null && branchName != null) {\n        pullRebaseMode = getRebaseMode(branchName, repoConfig);\n    }\n    final boolean isRemote = !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri = repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri == null) {\n            String missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch = new FetchCommand(repo).setRemote(remote).setProgressMonitor(monitor).setTagOpt(tagOption).setRecurseSubmodules(submoduleRecurseMode);\n        configure(fetch);\n        fetchRes = fetch.call();\n    } else {\n        remoteUri = JGitText.get().localRepository;\n        fetchRes = null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r = null;\n        if (fetchRes != null) {\n            r = fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r == null)\n                r = fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r == null) {\n            throw new RefNotAdvertisedException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remote, remoteBranchName));\n        } else {\n            commitToMerge = r.getObjectId();\n        }\n    } else {\n        try {\n            commitToMerge = repo.resolve(remoteBranchName);\n            if (commitToMerge == null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    String upstreamName = MessageFormat.format(JGitText.get().upstreamBranchName, Repository.shortenRefName(remoteBranchName), remoteUri);\n    PullResult result;\n    if (pullRebaseMode != BranchRebaseMode.NONE) {\n        RebaseCommand rebase = new RebaseCommand(repo);\n        RebaseResult rebaseRes = rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).setStrategy(strategy).setPreserveMerges(pullRebaseMode == BranchRebaseMode.PRESERVE).call();\n        result = new PullResult(fetchRes, remote, rebaseRes);\n    } else {\n        MergeCommand merge = new MergeCommand(repo);\n        MergeResult mergeRes = merge.include(upstreamName, commitToMerge).setStrategy(strategy).setProgressMonitor(monitor).setFastForward(getFastForwardMode()).call();\n        monitor.update(1);\n        result = new PullResult(fetchRes, remote, mergeRes);\n    }\n    monitor.endTask();\n    return result;\n}"
    },
    {
      "commit": "df638e0cfc628469eee9a91df5b2b65634e274d7",
      "startLine": 35,
      "endLine": 52,
      "methodCode": "@Override\npublic PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, InvalidRemoteException, CanceledException, RefNotFoundException, RefNotAdvertisedException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    Config repoConfig = repo.getConfig();\n    String branchName = null;\n    try {\n        String fullBranch = repo.getFullBranch();\n        if (fullBranch != null && fullBranch.startsWith(Constants.R_HEADS)) {\n            branchName = fullBranch.substring(Constants.R_HEADS.length());\n        }\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (remoteBranchName == null && branchName != null) {\n        remoteBranchName = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    }\n    if (remoteBranchName == null) {\n        remoteBranchName = branchName;\n    }\n    if (remoteBranchName == null) {\n        throw new NoHeadException(JGitText.get().cannotCheckoutFromUnbornBranch);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    if (remote == null && branchName != null) {\n        remote = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    }\n    if (remote == null) {\n        remote = Constants.DEFAULT_REMOTE_NAME;\n    }\n    if (pullRebaseMode == null && branchName != null) {\n        pullRebaseMode = getRebaseMode(branchName, repoConfig);\n    }\n    final boolean isRemote = !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri = repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri == null) {\n            String missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch = new FetchCommand(repo).setRemote(remote).setProgressMonitor(monitor).setTagOpt(tagOption).setRecurseSubmodules(submoduleRecurseMode);\n        configure(fetch);\n        fetchRes = fetch.call();\n    } else {\n        remoteUri = JGitText.get().localRepository;\n        fetchRes = null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r = null;\n        if (fetchRes != null) {\n            r = fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r == null)\n                r = fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r == null) {\n            throw new RefNotAdvertisedException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remote, remoteBranchName));\n        } else {\n            commitToMerge = r.getObjectId();\n        }\n    } else {\n        try {\n            commitToMerge = repo.resolve(remoteBranchName);\n            if (commitToMerge == null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    String upstreamName = MessageFormat.format(JGitText.get().upstreamBranchName, Repository.shortenRefName(remoteBranchName), remoteUri);\n    PullResult result;\n    if (pullRebaseMode != BranchRebaseMode.NONE) {\n        RebaseCommand rebase = new RebaseCommand(repo);\n        RebaseResult rebaseRes = rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).setStrategy(strategy).setPreserveMerges(pullRebaseMode == BranchRebaseMode.PRESERVE).call();\n        result = new PullResult(fetchRes, remote, rebaseRes);\n    } else {\n        MergeCommand merge = new MergeCommand(repo);\n        MergeResult mergeRes = merge.include(upstreamName, commitToMerge).setStrategy(strategy).setProgressMonitor(monitor).setFastForward(getFastForwardMode()).call();\n        monitor.update(1);\n        result = new PullResult(fetchRes, remote, mergeRes);\n    }\n    monitor.endTask();\n    return result;\n}"
    },
    {
      "commit": "0d447b16604d934675d2dc8e958fa043e945dfc6",
      "startLine": 35,
      "endLine": 52,
      "methodCode": "@Override\npublic PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, InvalidRemoteException, CanceledException, RefNotFoundException, RefNotAdvertisedException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    Config repoConfig = repo.getConfig();\n    String branchName = null;\n    try {\n        String fullBranch = repo.getFullBranch();\n        if (fullBranch != null && fullBranch.startsWith(Constants.R_HEADS)) {\n            branchName = fullBranch.substring(Constants.R_HEADS.length());\n        }\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (remoteBranchName == null && branchName != null) {\n        remoteBranchName = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    }\n    if (remoteBranchName == null) {\n        remoteBranchName = branchName;\n    }\n    if (remoteBranchName == null) {\n        throw new NoHeadException(JGitText.get().cannotCheckoutFromUnbornBranch);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    if (remote == null && branchName != null) {\n        remote = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    }\n    if (remote == null) {\n        remote = Constants.DEFAULT_REMOTE_NAME;\n    }\n    if (pullRebaseMode == null && branchName != null) {\n        pullRebaseMode = getRebaseMode(branchName, repoConfig);\n    }\n    final boolean isRemote = !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri = repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri == null) {\n            String missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch = new FetchCommand(repo).setRemote(remote).setProgressMonitor(monitor).setTagOpt(tagOption).setRecurseSubmodules(submoduleRecurseMode);\n        configure(fetch);\n        fetchRes = fetch.call();\n    } else {\n        remoteUri = JGitText.get().localRepository;\n        fetchRes = null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r = null;\n        if (fetchRes != null) {\n            r = fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r == null)\n                r = fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r == null) {\n            throw new RefNotAdvertisedException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remote, remoteBranchName));\n        } else {\n            commitToMerge = r.getObjectId();\n        }\n    } else {\n        try {\n            commitToMerge = repo.resolve(remoteBranchName);\n            if (commitToMerge == null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    String upstreamName = MessageFormat.format(JGitText.get().upstreamBranchName, Repository.shortenRefName(remoteBranchName), remoteUri);\n    PullResult result;\n    if (pullRebaseMode != BranchRebaseMode.NONE) {\n        RebaseCommand rebase = new RebaseCommand(repo);\n        RebaseResult rebaseRes = rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).setStrategy(strategy).setPreserveMerges(pullRebaseMode == BranchRebaseMode.PRESERVE).call();\n        result = new PullResult(fetchRes, remote, rebaseRes);\n    } else {\n        MergeCommand merge = new MergeCommand(repo);\n        merge.include(upstreamName, commitToMerge);\n        merge.setStrategy(strategy);\n        merge.setProgressMonitor(monitor);\n        merge.setFastForward(getFastForwardMode());\n        MergeResult mergeRes = merge.call();\n        monitor.update(1);\n        result = new PullResult(fetchRes, remote, mergeRes);\n    }\n    monitor.endTask();\n    return result;\n}"
    },
    {
      "commit": "5b84e25fa3afe66bbfa7eb953ea0bd332c745ecd",
      "startLine": 35,
      "endLine": 52,
      "methodCode": "@Override\npublic PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, InvalidRemoteException, CanceledException, RefNotFoundException, RefNotAdvertisedException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    Config repoConfig = repo.getConfig();\n    String branchName = null;\n    try {\n        String fullBranch = repo.getFullBranch();\n        if (fullBranch != null && fullBranch.startsWith(Constants.R_HEADS)) {\n            branchName = fullBranch.substring(Constants.R_HEADS.length());\n        }\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (remoteBranchName == null && branchName != null) {\n        remoteBranchName = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    }\n    if (remoteBranchName == null) {\n        remoteBranchName = branchName;\n    }\n    if (remoteBranchName == null) {\n        throw new NoHeadException(JGitText.get().cannotCheckoutFromUnbornBranch);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    if (remote == null && branchName != null) {\n        remote = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    }\n    if (remote == null) {\n        remote = Constants.DEFAULT_REMOTE_NAME;\n    }\n    if (pullRebaseMode == null && branchName != null) {\n        pullRebaseMode = getRebaseMode(branchName, repoConfig);\n    }\n    final boolean isRemote = !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri = repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri == null) {\n            String missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch = new FetchCommand(repo).setRemote(remote).setProgressMonitor(monitor).setTagOpt(tagOption).setRecurseSubmodules(submoduleRecurseMode);\n        configure(fetch);\n        fetchRes = fetch.call();\n    } else {\n        remoteUri = JGitText.get().localRepository;\n        fetchRes = null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r = null;\n        if (fetchRes != null) {\n            r = fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r == null)\n                r = fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r == null) {\n            throw new RefNotAdvertisedException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remote, remoteBranchName));\n        } else {\n            commitToMerge = r.getObjectId();\n        }\n    } else {\n        try {\n            commitToMerge = repo.resolve(remoteBranchName);\n            if (commitToMerge == null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    String upstreamName = MessageFormat.format(JGitText.get().upstreamBranchName, Repository.shortenRefName(remoteBranchName), remoteUri);\n    PullResult result;\n    if (pullRebaseMode != BranchRebaseMode.NONE) {\n        RebaseCommand rebase = new RebaseCommand(repo);\n        RebaseResult rebaseRes = rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).setStrategy(strategy).setPreserveMerges(pullRebaseMode == BranchRebaseMode.PRESERVE).call();\n        result = new PullResult(fetchRes, remote, rebaseRes);\n    } else {\n        MergeCommand merge = new MergeCommand(repo);\n        merge.include(upstreamName, commitToMerge);\n        merge.setStrategy(strategy);\n        merge.setProgressMonitor(monitor);\n        MergeResult mergeRes = merge.call();\n        monitor.update(1);\n        result = new PullResult(fetchRes, remote, mergeRes);\n    }\n    monitor.endTask();\n    return result;\n}"
    },
    {
      "commit": "5f902f07ccae32b82a36c05e1eca23b21a27da99",
      "startLine": 32,
      "endLine": 49,
      "methodCode": "@Override\npublic PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, RefNotAdvertisedException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch = repo.getFullBranch();\n        if (fullBranch == null)\n            throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName = fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig = repo.getConfig();\n    if (remote == null) {\n        remote = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    }\n    if (remote == null)\n        remote = Constants.DEFAULT_REMOTE_NAME;\n    if (remoteBranchName == null)\n        remoteBranchName = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    if (pullRebaseMode == null) {\n        pullRebaseMode = getRebaseMode(branchName, repoConfig);\n    }\n    if (remoteBranchName == null)\n        remoteBranchName = branchName;\n    final boolean isRemote = !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri = repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri == null) {\n            String missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch = new FetchCommand(repo).setRemote(remote).setProgressMonitor(monitor).setTagOpt(tagOption).setRecurseSubmodules(submoduleRecurseMode);\n        configure(fetch);\n        fetchRes = fetch.call();\n    } else {\n        remoteUri = JGitText.get().localRepository;\n        fetchRes = null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r = null;\n        if (fetchRes != null) {\n            r = fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r == null)\n                r = fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r == null) {\n            throw new RefNotAdvertisedException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remote, remoteBranchName));\n        } else {\n            commitToMerge = r.getObjectId();\n        }\n    } else {\n        try {\n            commitToMerge = repo.resolve(remoteBranchName);\n            if (commitToMerge == null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    String upstreamName = MessageFormat.format(JGitText.get().upstreamBranchName, Repository.shortenRefName(remoteBranchName), remoteUri);\n    PullResult result;\n    if (pullRebaseMode != BranchRebaseMode.NONE) {\n        RebaseCommand rebase = new RebaseCommand(repo);\n        RebaseResult rebaseRes = rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).setStrategy(strategy).setPreserveMerges(pullRebaseMode == BranchRebaseMode.PRESERVE).call();\n        result = new PullResult(fetchRes, remote, rebaseRes);\n    } else {\n        MergeCommand merge = new MergeCommand(repo);\n        merge.include(upstreamName, commitToMerge);\n        merge.setStrategy(strategy);\n        merge.setProgressMonitor(monitor);\n        MergeResult mergeRes = merge.call();\n        monitor.update(1);\n        result = new PullResult(fetchRes, remote, mergeRes);\n    }\n    monitor.endTask();\n    return result;\n}"
    },
    {
      "commit": "7ac182f4e427e0d5a986b8ca67a56fc22828b1a0",
      "startLine": 32,
      "endLine": 49,
      "methodCode": "@Override\npublic PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, RefNotAdvertisedException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch = repo.getFullBranch();\n        if (fullBranch == null)\n            throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName = fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig = repo.getConfig();\n    if (remote == null) {\n        remote = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    }\n    if (remote == null)\n        remote = Constants.DEFAULT_REMOTE_NAME;\n    if (remoteBranchName == null)\n        remoteBranchName = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    if (pullRebaseMode == null) {\n        pullRebaseMode = getRebaseMode(branchName, repoConfig);\n    }\n    if (remoteBranchName == null)\n        remoteBranchName = branchName;\n    final boolean isRemote = !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri = repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri == null) {\n            String missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch = new FetchCommand(repo).setRemote(remote).setProgressMonitor(monitor).setTagOpt(tagOption);\n        configure(fetch);\n        fetchRes = fetch.call();\n    } else {\n        remoteUri = JGitText.get().localRepository;\n        fetchRes = null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r = null;\n        if (fetchRes != null) {\n            r = fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r == null)\n                r = fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r == null) {\n            throw new RefNotAdvertisedException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remote, remoteBranchName));\n        } else {\n            commitToMerge = r.getObjectId();\n        }\n    } else {\n        try {\n            commitToMerge = repo.resolve(remoteBranchName);\n            if (commitToMerge == null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    String upstreamName = MessageFormat.format(JGitText.get().upstreamBranchName, Repository.shortenRefName(remoteBranchName), remoteUri);\n    PullResult result;\n    if (pullRebaseMode != BranchRebaseMode.NONE) {\n        RebaseCommand rebase = new RebaseCommand(repo);\n        RebaseResult rebaseRes = rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).setStrategy(strategy).setPreserveMerges(pullRebaseMode == BranchRebaseMode.PRESERVE).call();\n        result = new PullResult(fetchRes, remote, rebaseRes);\n    } else {\n        MergeCommand merge = new MergeCommand(repo);\n        merge.include(upstreamName, commitToMerge);\n        merge.setStrategy(strategy);\n        merge.setProgressMonitor(monitor);\n        MergeResult mergeRes = merge.call();\n        monitor.update(1);\n        result = new PullResult(fetchRes, remote, mergeRes);\n    }\n    monitor.endTask();\n    return result;\n}"
    },
    {
      "commit": "1cda4faed425286fe5230a6b2b8454c376ba79f1",
      "startLine": 31,
      "endLine": 48,
      "methodCode": "public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, RefNotAdvertisedException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch = repo.getFullBranch();\n        if (fullBranch == null)\n            throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName = fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig = repo.getConfig();\n    if (remote == null) {\n        remote = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    }\n    if (remote == null)\n        remote = Constants.DEFAULT_REMOTE_NAME;\n    if (remoteBranchName == null)\n        remoteBranchName = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    if (pullRebaseMode == null) {\n        pullRebaseMode = getRebaseMode(branchName, repoConfig);\n    }\n    if (remoteBranchName == null)\n        remoteBranchName = branchName;\n    final boolean isRemote = !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri = repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri == null) {\n            String missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch = new FetchCommand(repo).setRemote(remote).setProgressMonitor(monitor).setTagOpt(tagOption);\n        configure(fetch);\n        fetchRes = fetch.call();\n    } else {\n        remoteUri = JGitText.get().localRepository;\n        fetchRes = null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r = null;\n        if (fetchRes != null) {\n            r = fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r == null)\n                r = fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r == null) {\n            throw new RefNotAdvertisedException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remote, remoteBranchName));\n        } else {\n            commitToMerge = r.getObjectId();\n        }\n    } else {\n        try {\n            commitToMerge = repo.resolve(remoteBranchName);\n            if (commitToMerge == null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    String upstreamName = MessageFormat.format(JGitText.get().upstreamBranchName, Repository.shortenRefName(remoteBranchName), remoteUri);\n    PullResult result;\n    if (pullRebaseMode != BranchRebaseMode.NONE) {\n        RebaseCommand rebase = new RebaseCommand(repo);\n        RebaseResult rebaseRes = rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).setStrategy(strategy).setPreserveMerges(pullRebaseMode == BranchRebaseMode.PRESERVE).call();\n        result = new PullResult(fetchRes, remote, rebaseRes);\n    } else {\n        MergeCommand merge = new MergeCommand(repo);\n        merge.include(upstreamName, commitToMerge);\n        merge.setStrategy(strategy);\n        merge.setProgressMonitor(monitor);\n        MergeResult mergeRes = merge.call();\n        monitor.update(1);\n        result = new PullResult(fetchRes, remote, mergeRes);\n    }\n    monitor.endTask();\n    return result;\n}"
    },
    {
      "commit": "aadbb158e10ccc3194c4e7f2c1b3885b3c40571c",
      "startLine": 31,
      "endLine": 50,
      "methodCode": "public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, RefNotAdvertisedException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch = repo.getFullBranch();\n        if (fullBranch == null)\n            throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName = fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig = repo.getConfig();\n    if (remote == null) {\n        remote = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    }\n    if (remote == null)\n        remote = Constants.DEFAULT_REMOTE_NAME;\n    if (remoteBranchName == null)\n        remoteBranchName = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    if (pullRebaseMode == null) {\n        pullRebaseMode = getRebaseMode(branchName, repoConfig);\n    }\n    if (remoteBranchName == null)\n        remoteBranchName = branchName;\n    final boolean isRemote = !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri = repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri == null) {\n            String missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch = new FetchCommand(repo);\n        fetch.setRemote(remote);\n        fetch.setProgressMonitor(monitor);\n        configure(fetch);\n        fetchRes = fetch.call();\n    } else {\n        remoteUri = JGitText.get().localRepository;\n        fetchRes = null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r = null;\n        if (fetchRes != null) {\n            r = fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r == null)\n                r = fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r == null) {\n            throw new RefNotAdvertisedException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remote, remoteBranchName));\n        } else {\n            commitToMerge = r.getObjectId();\n        }\n    } else {\n        try {\n            commitToMerge = repo.resolve(remoteBranchName);\n            if (commitToMerge == null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    String upstreamName = MessageFormat.format(JGitText.get().upstreamBranchName, Repository.shortenRefName(remoteBranchName), remoteUri);\n    PullResult result;\n    if (pullRebaseMode != BranchRebaseMode.NONE) {\n        RebaseCommand rebase = new RebaseCommand(repo);\n        RebaseResult rebaseRes = rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).setStrategy(strategy).setPreserveMerges(pullRebaseMode == BranchRebaseMode.PRESERVE).call();\n        result = new PullResult(fetchRes, remote, rebaseRes);\n    } else {\n        MergeCommand merge = new MergeCommand(repo);\n        merge.include(upstreamName, commitToMerge);\n        merge.setStrategy(strategy);\n        merge.setProgressMonitor(monitor);\n        MergeResult mergeRes = merge.call();\n        monitor.update(1);\n        result = new PullResult(fetchRes, remote, mergeRes);\n    }\n    monitor.endTask();\n    return result;\n}"
    },
    {
      "commit": "1e1fb9fc596603a44b0fff6d19eeba2b005d659d",
      "startLine": 31,
      "endLine": 50,
      "methodCode": "public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, RefNotAdvertisedException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch = repo.getFullBranch();\n        if (fullBranch == null)\n            throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName = fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig = repo.getConfig();\n    if (remote == null) {\n        remote = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    }\n    if (remote == null)\n        remote = Constants.DEFAULT_REMOTE_NAME;\n    if (remoteBranchName == null)\n        remoteBranchName = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    if (pullRebaseMode == null) {\n        pullRebaseMode = getRebaseMode(branchName, repoConfig);\n    }\n    if (remoteBranchName == null)\n        remoteBranchName = branchName;\n    final boolean isRemote = !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri = repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri == null) {\n            String missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch = new FetchCommand(repo);\n        fetch.setRemote(remote);\n        fetch.setProgressMonitor(monitor);\n        configure(fetch);\n        fetchRes = fetch.call();\n    } else {\n        remoteUri = JGitText.get().localRepository;\n        fetchRes = null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r = null;\n        if (fetchRes != null) {\n            r = fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r == null)\n                r = fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r == null) {\n            throw new RefNotAdvertisedException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remote, remoteBranchName));\n        } else {\n            commitToMerge = r.getObjectId();\n        }\n    } else {\n        try {\n            commitToMerge = repo.resolve(remoteBranchName);\n            if (commitToMerge == null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    String upstreamName = MessageFormat.format(JGitText.get().upstreamBranchName, Repository.shortenRefName(remoteBranchName), remoteUri);\n    PullResult result;\n    if (pullRebaseMode.rebase) {\n        RebaseCommand rebase = new RebaseCommand(repo);\n        RebaseResult rebaseRes = rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).setStrategy(strategy).setPreserveMerges(pullRebaseMode.preserveMerges).call();\n        result = new PullResult(fetchRes, remote, rebaseRes);\n    } else {\n        MergeCommand merge = new MergeCommand(repo);\n        merge.include(upstreamName, commitToMerge);\n        merge.setStrategy(strategy);\n        merge.setProgressMonitor(monitor);\n        MergeResult mergeRes = merge.call();\n        monitor.update(1);\n        result = new PullResult(fetchRes, remote, mergeRes);\n    }\n    monitor.endTask();\n    return result;\n}"
    },
    {
      "commit": "efacad0fc8e98505be6f007230ab2b1cdc1684f3",
      "startLine": 31,
      "endLine": 50,
      "methodCode": "public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, RefNotAdvertisedException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch = repo.getFullBranch();\n        if (fullBranch == null)\n            throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName = fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig = repo.getConfig();\n    if (remote == null) {\n        remote = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    }\n    if (remote == null)\n        remote = Constants.DEFAULT_REMOTE_NAME;\n    if (remoteBranchName == null)\n        remoteBranchName = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    if (pullRebaseMode == null) {\n        pullRebaseMode = getRebaseMode(branchName, repoConfig);\n    }\n    if (remoteBranchName == null)\n        remoteBranchName = branchName;\n    final boolean isRemote = !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri = repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri == null) {\n            String missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch = new FetchCommand(repo);\n        fetch.setRemote(remote);\n        fetch.setProgressMonitor(monitor);\n        configure(fetch);\n        fetchRes = fetch.call();\n    } else {\n        remoteUri = JGitText.get().localRepository;\n        fetchRes = null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r = null;\n        if (fetchRes != null) {\n            r = fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r == null)\n                r = fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r == null) {\n            throw new RefNotAdvertisedException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remote, remoteBranchName));\n        } else {\n            commitToMerge = r.getObjectId();\n        }\n    } else {\n        try {\n            commitToMerge = repo.resolve(remoteBranchName);\n            if (commitToMerge == null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    String upstreamName = MessageFormat.format(JGitText.get().upstreamBranchName, Repository.shortenRefName(remoteBranchName), remoteUri);\n    PullResult result;\n    if (pullRebaseMode.rebase) {\n        RebaseCommand rebase = new RebaseCommand(repo);\n        RebaseResult rebaseRes = rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).setStrategy(strategy).setPreserveMerges(pullRebaseMode.preserveMerges).call();\n        result = new PullResult(fetchRes, remote, rebaseRes);\n    } else {\n        MergeCommand merge = new MergeCommand(repo);\n        merge.include(upstreamName, commitToMerge);\n        merge.setStrategy(strategy);\n        MergeResult mergeRes = merge.call();\n        monitor.update(1);\n        result = new PullResult(fetchRes, remote, mergeRes);\n    }\n    monitor.endTask();\n    return result;\n}"
    },
    {
      "commit": "2390531888af6dc9e4fda6cb026271dc068c40ab",
      "startLine": 31,
      "endLine": 50,
      "methodCode": "public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch = repo.getFullBranch();\n        if (fullBranch == null)\n            throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName = fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig = repo.getConfig();\n    if (remote == null) {\n        remote = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    }\n    if (remote == null)\n        remote = Constants.DEFAULT_REMOTE_NAME;\n    if (remoteBranchName == null)\n        remoteBranchName = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    if (pullRebaseMode == null) {\n        pullRebaseMode = getRebaseMode(branchName, repoConfig);\n    }\n    if (remoteBranchName == null)\n        remoteBranchName = branchName;\n    final boolean isRemote = !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri = repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri == null) {\n            String missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch = new FetchCommand(repo);\n        fetch.setRemote(remote);\n        fetch.setProgressMonitor(monitor);\n        configure(fetch);\n        fetchRes = fetch.call();\n    } else {\n        remoteUri = JGitText.get().localRepository;\n        fetchRes = null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r = null;\n        if (fetchRes != null) {\n            r = fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r == null)\n                r = fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r == null)\n            throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n        else\n            commitToMerge = r.getObjectId();\n    } else {\n        try {\n            commitToMerge = repo.resolve(remoteBranchName);\n            if (commitToMerge == null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    String upstreamName = MessageFormat.format(JGitText.get().upstreamBranchName, Repository.shortenRefName(remoteBranchName), remoteUri);\n    PullResult result;\n    if (pullRebaseMode.rebase) {\n        RebaseCommand rebase = new RebaseCommand(repo);\n        RebaseResult rebaseRes = rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).setStrategy(strategy).setPreserveMerges(pullRebaseMode.preserveMerges).call();\n        result = new PullResult(fetchRes, remote, rebaseRes);\n    } else {\n        MergeCommand merge = new MergeCommand(repo);\n        merge.include(upstreamName, commitToMerge);\n        merge.setStrategy(strategy);\n        MergeResult mergeRes = merge.call();\n        monitor.update(1);\n        result = new PullResult(fetchRes, remote, mergeRes);\n    }\n    monitor.endTask();\n    return result;\n}"
    },
    {
      "commit": "48544e27ae3808807dc1960083d8e42c05e62af3",
      "startLine": 31,
      "endLine": 50,
      "methodCode": "public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch = repo.getFullBranch();\n        if (fullBranch == null)\n            throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName = fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig = repo.getConfig();\n    if (remote == null) {\n        remote = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    }\n    if (remote == null)\n        remote = Constants.DEFAULT_REMOTE_NAME;\n    if (remoteBranchName == null)\n        remoteBranchName = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    if (pullRebaseMode == null) {\n        pullRebaseMode = getRebaseMode(branchName, repoConfig);\n    }\n    if (remoteBranchName == null)\n        remoteBranchName = branchName;\n    final boolean isRemote = !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri = repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri == null) {\n            String missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch = new FetchCommand(repo);\n        fetch.setRemote(remote);\n        fetch.setProgressMonitor(monitor);\n        configure(fetch);\n        fetchRes = fetch.call();\n    } else {\n        remoteUri = \"local repository\";\n        fetchRes = null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r = null;\n        if (fetchRes != null) {\n            r = fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r == null)\n                r = fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r == null)\n            throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n        else\n            commitToMerge = r.getObjectId();\n    } else {\n        try {\n            commitToMerge = repo.resolve(remoteBranchName);\n            if (commitToMerge == null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    String upstreamName = \"branch \\'\" + Repository.shortenRefName(remoteBranchName) + \"\\' of \" + remoteUri;\n    PullResult result;\n    if (pullRebaseMode.rebase) {\n        RebaseCommand rebase = new RebaseCommand(repo);\n        RebaseResult rebaseRes = rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).setStrategy(strategy).setPreserveMerges(pullRebaseMode.preserveMerges).call();\n        result = new PullResult(fetchRes, remote, rebaseRes);\n    } else {\n        MergeCommand merge = new MergeCommand(repo);\n        merge.include(upstreamName, commitToMerge);\n        merge.setStrategy(strategy);\n        MergeResult mergeRes = merge.call();\n        monitor.update(1);\n        result = new PullResult(fetchRes, remote, mergeRes);\n    }\n    monitor.endTask();\n    return result;\n}"
    },
    {
      "commit": "7424d58255340fa44d9191a7436fbe70d72a457c",
      "startLine": 41,
      "endLine": 60,
      "methodCode": "public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch = repo.getFullBranch();\n        if (fullBranch == null)\n            throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName = fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig = repo.getConfig();\n    if (remote == null) {\n        remote = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    }\n    if (remote == null)\n        remote = Constants.DEFAULT_REMOTE_NAME;\n    if (remoteBranchName == null)\n        remoteBranchName = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    boolean doRebase = false;\n    switch(pullRebaseMode) {\n        case REBASE:\n            doRebase = true;\n            break;\n        case NO_REBASE:\n            doRebase = false;\n            break;\n        case USE_CONFIG:\n        default:\n            doRebase = repoConfig.getBoolean(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE, false);\n            break;\n    }\n    if (remoteBranchName == null)\n        remoteBranchName = branchName;\n    final boolean isRemote = !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri = repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri == null) {\n            String missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch = new FetchCommand(repo);\n        fetch.setRemote(remote);\n        fetch.setProgressMonitor(monitor);\n        configure(fetch);\n        fetchRes = fetch.call();\n    } else {\n        remoteUri = \"local repository\";\n        fetchRes = null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r = null;\n        if (fetchRes != null) {\n            r = fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r == null)\n                r = fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r == null)\n            throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n        else\n            commitToMerge = r.getObjectId();\n    } else {\n        try {\n            commitToMerge = repo.resolve(remoteBranchName);\n            if (commitToMerge == null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    String upstreamName = \"branch \\'\" + Repository.shortenRefName(remoteBranchName) + \"\\' of \" + remoteUri;\n    PullResult result;\n    if (doRebase) {\n        RebaseCommand rebase = new RebaseCommand(repo);\n        RebaseResult rebaseRes = rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).setStrategy(strategy).call();\n        result = new PullResult(fetchRes, remote, rebaseRes);\n    } else {\n        MergeCommand merge = new MergeCommand(repo);\n        merge.include(upstreamName, commitToMerge);\n        merge.setStrategy(strategy);\n        MergeResult mergeRes = merge.call();\n        monitor.update(1);\n        result = new PullResult(fetchRes, remote, mergeRes);\n    }\n    monitor.endTask();\n    return result;\n}"
    },
    {
      "commit": "1eae309723be301a4f2fc12a3e07e7e7c9f30782",
      "startLine": 41,
      "endLine": 60,
      "methodCode": "public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch = repo.getFullBranch();\n        if (fullBranch == null)\n            throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName = fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig = repo.getConfig();\n    if (remote == null) {\n        remote = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    }\n    if (remote == null)\n        remote = Constants.DEFAULT_REMOTE_NAME;\n    if (remoteBranchName == null)\n        remoteBranchName = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    boolean doRebase = false;\n    switch(pullRebaseMode) {\n        case REBASE:\n            doRebase = true;\n            break;\n        case NO_REBASE:\n            doRebase = false;\n            break;\n        case USE_CONFIG:\n        default:\n            doRebase = repoConfig.getBoolean(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE, false);\n            break;\n    }\n    if (remoteBranchName == null)\n        remoteBranchName = branchName;\n    final boolean isRemote = !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri = repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri == null) {\n            String missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch = new FetchCommand(repo);\n        fetch.setRemote(remote);\n        fetch.setProgressMonitor(monitor);\n        configure(fetch);\n        fetchRes = fetch.call();\n    } else {\n        remoteUri = \"local repository\";\n        fetchRes = null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r = null;\n        if (fetchRes != null) {\n            r = fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r == null)\n                r = fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r == null)\n            throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n        else\n            commitToMerge = r.getObjectId();\n    } else {\n        try {\n            commitToMerge = repo.resolve(remoteBranchName);\n            if (commitToMerge == null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    String upstreamName = \"branch \\'\" + Repository.shortenRefName(remoteBranchName) + \"\\' of \" + remoteUri;\n    PullResult result;\n    if (doRebase) {\n        RebaseCommand rebase = new RebaseCommand(repo);\n        RebaseResult rebaseRes = rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n        result = new PullResult(fetchRes, remote, rebaseRes);\n    } else {\n        MergeCommand merge = new MergeCommand(repo);\n        merge.include(upstreamName, commitToMerge);\n        MergeResult mergeRes = merge.call();\n        monitor.update(1);\n        result = new PullResult(fetchRes, remote, mergeRes);\n    }\n    monitor.endTask();\n    return result;\n}"
    },
    {
      "commit": "c310fa0c802f40a774edb58641de3ac5bfad0e2c",
      "startLine": 40,
      "endLine": 59,
      "methodCode": "public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch = repo.getFullBranch();\n        if (fullBranch == null)\n            throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName = fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig = repo.getConfig();\n    String remote = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    if (remote == null)\n        remote = Constants.DEFAULT_REMOTE_NAME;\n    String remoteBranchName = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    boolean doRebase = false;\n    switch(pullRebaseMode) {\n        case REBASE:\n            doRebase = true;\n            break;\n        case NO_REBASE:\n            doRebase = false;\n            break;\n        case USE_CONFIG:\n        default:\n            doRebase = repoConfig.getBoolean(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE, false);\n            break;\n    }\n    if (remoteBranchName == null) {\n        String missingKey = ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    final boolean isRemote = !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri = repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri == null) {\n            String missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch = new FetchCommand(repo);\n        fetch.setRemote(remote);\n        fetch.setProgressMonitor(monitor);\n        configure(fetch);\n        fetchRes = fetch.call();\n    } else {\n        remoteUri = \"local repository\";\n        fetchRes = null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r = null;\n        if (fetchRes != null) {\n            r = fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r == null)\n                r = fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r == null)\n            throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n        else\n            commitToMerge = r.getObjectId();\n    } else {\n        try {\n            commitToMerge = repo.resolve(remoteBranchName);\n            if (commitToMerge == null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    String upstreamName = \"branch \\'\" + Repository.shortenRefName(remoteBranchName) + \"\\' of \" + remoteUri;\n    PullResult result;\n    if (doRebase) {\n        RebaseCommand rebase = new RebaseCommand(repo);\n        RebaseResult rebaseRes = rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n        result = new PullResult(fetchRes, remote, rebaseRes);\n    } else {\n        MergeCommand merge = new MergeCommand(repo);\n        merge.include(upstreamName, commitToMerge);\n        MergeResult mergeRes = merge.call();\n        monitor.update(1);\n        result = new PullResult(fetchRes, remote, mergeRes);\n    }\n    monitor.endTask();\n    return result;\n}"
    },
    {
      "commit": "fa5231191d530afb24810080e89990913c8e8054",
      "startLine": 40,
      "endLine": 59,
      "methodCode": "public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch = repo.getFullBranch();\n        if (fullBranch == null)\n            throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName = fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig = repo.getConfig();\n    String remote = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    if (remote == null)\n        remote = Constants.DEFAULT_REMOTE_NAME;\n    String remoteBranchName = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    boolean doRebase = false;\n    switch(pullRebaseMode) {\n        case REBASE:\n            doRebase = true;\n            break;\n        case NO_REBASE:\n            doRebase = false;\n            break;\n        case USE_CONFIG:\n        default:\n            doRebase = repoConfig.getBoolean(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE, false);\n            break;\n    }\n    if (remoteBranchName == null) {\n        String missingKey = ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    final boolean isRemote = !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri = repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri == null) {\n            String missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch = new FetchCommand(repo);\n        fetch.setRemote(remote);\n        fetch.setProgressMonitor(monitor);\n        configure(fetch);\n        fetchRes = fetch.call();\n    } else {\n        remoteUri = \"local repository\";\n        fetchRes = null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r = null;\n        if (fetchRes != null) {\n            r = fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r == null)\n                r = fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r == null)\n            throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n        else\n            commitToMerge = r.getObjectId();\n    } else {\n        try {\n            commitToMerge = repo.resolve(remoteBranchName);\n            if (commitToMerge == null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    String upstreamName = \"branch \\'\" + Repository.shortenRefName(remoteBranchName) + \"\\' of \" + remoteUri;\n    PullResult result;\n    if (doRebase) {\n        RebaseCommand rebase = new RebaseCommand(repo);\n        RebaseResult rebaseRes = rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n        result = new PullResult(fetchRes, remote, rebaseRes);\n    } else {\n        MergeCommand merge = new MergeCommand(repo);\n        merge.include(upstreamName, commitToMerge);\n        MergeResult mergeRes = merge.call();\n        monitor.update(1);\n        result = new PullResult(fetchRes, remote, mergeRes);\n    }\n    monitor.endTask();\n    return result;\n}"
    },
    {
      "commit": "5854ca091a22346e1c710ca9f875165afb3f2cc8",
      "startLine": 28,
      "endLine": 47,
      "methodCode": "public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch = repo.getFullBranch();\n        if (fullBranch == null)\n            throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName = fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig = repo.getConfig();\n    String remote = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    if (remote == null)\n        remote = Constants.DEFAULT_REMOTE_NAME;\n    String remoteBranchName = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    boolean doRebase = repoConfig.getBoolean(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE, false);\n    if (remoteBranchName == null) {\n        String missingKey = ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    final boolean isRemote = !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri = repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri == null) {\n            String missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch = new FetchCommand(repo);\n        fetch.setRemote(remote);\n        fetch.setProgressMonitor(monitor);\n        configure(fetch);\n        fetchRes = fetch.call();\n    } else {\n        remoteUri = \"local repository\";\n        fetchRes = null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r = null;\n        if (fetchRes != null) {\n            r = fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r == null)\n                r = fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r == null)\n            throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n        else\n            commitToMerge = r.getObjectId();\n    } else {\n        try {\n            commitToMerge = repo.resolve(remoteBranchName);\n            if (commitToMerge == null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    String upstreamName = \"branch \\'\" + Repository.shortenRefName(remoteBranchName) + \"\\' of \" + remoteUri;\n    PullResult result;\n    if (doRebase) {\n        RebaseCommand rebase = new RebaseCommand(repo);\n        RebaseResult rebaseRes = rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n        result = new PullResult(fetchRes, remote, rebaseRes);\n    } else {\n        MergeCommand merge = new MergeCommand(repo);\n        merge.include(upstreamName, commitToMerge);\n        MergeResult mergeRes = merge.call();\n        monitor.update(1);\n        result = new PullResult(fetchRes, remote, mergeRes);\n    }\n    monitor.endTask();\n    return result;\n}"
    },
    {
      "commit": "b61d35e848e637ef85fde4ebe95d60ced171e963",
      "startLine": 28,
      "endLine": 47,
      "methodCode": "public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch = repo.getFullBranch();\n        if (fullBranch == null)\n            throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName = fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig = repo.getConfig();\n    String remote = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    if (remote == null)\n        remote = Constants.DEFAULT_REMOTE_NAME;\n    String remoteBranchName = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    boolean doRebase = repoConfig.getBoolean(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE, false);\n    if (remoteBranchName == null) {\n        String missingKey = ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    final boolean isRemote = !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri = repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri == null) {\n            String missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch = new FetchCommand(repo);\n        fetch.setRemote(remote);\n        fetch.setProgressMonitor(monitor);\n        configure(fetch);\n        fetchRes = fetch.call();\n    } else {\n        remoteUri = \"local repository\";\n        fetchRes = null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r = null;\n        if (fetchRes != null) {\n            r = fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r == null)\n                r = fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r == null)\n            throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n        else\n            commitToMerge = r.getObjectId();\n    } else {\n        try {\n            commitToMerge = repo.resolve(remoteBranchName);\n            if (commitToMerge == null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    PullResult result;\n    if (doRebase) {\n        RebaseCommand rebase = new RebaseCommand(repo);\n        RebaseResult rebaseRes = rebase.setUpstream(commitToMerge).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n        result = new PullResult(fetchRes, remote, rebaseRes);\n    } else {\n        MergeCommand merge = new MergeCommand(repo);\n        String name = \"branch \\'\" + Repository.shortenRefName(remoteBranchName) + \"\\' of \" + remoteUri;\n        merge.include(name, commitToMerge);\n        MergeResult mergeRes = merge.call();\n        monitor.update(1);\n        result = new PullResult(fetchRes, remote, mergeRes);\n    }\n    monitor.endTask();\n    return result;\n}"
    },
    {
      "commit": "4e1454ded6e2fcf6cb789c004756883c3ea5f77e",
      "startLine": 28,
      "endLine": 47,
      "methodCode": "public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch = repo.getFullBranch();\n        if (fullBranch == null)\n            throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName = fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig = repo.getConfig();\n    String remote = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    if (remote == null)\n        remote = Constants.DEFAULT_REMOTE_NAME;\n    String remoteBranchName = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    boolean doRebase = repoConfig.getBoolean(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE, false);\n    if (remoteBranchName == null) {\n        String missingKey = ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    final boolean isRemote = !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri = repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri == null) {\n            String missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch = new FetchCommand(repo);\n        fetch.setRemote(remote);\n        fetch.setProgressMonitor(monitor);\n        configure(fetch);\n        fetchRes = fetch.call();\n    } else {\n        remoteUri = \"local repository\";\n        fetchRes = null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r = null;\n        if (fetchRes != null) {\n            r = fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r == null)\n                r = fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r == null)\n            throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n        else\n            commitToMerge = r.getObjectId();\n    } else {\n        try {\n            commitToMerge = repo.resolve(remoteBranchName);\n            if (commitToMerge == null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    PullResult result;\n    if (doRebase) {\n        RebaseCommand rebase = new RebaseCommand(repo);\n        try {\n            RebaseResult rebaseRes = rebase.setUpstream(commitToMerge).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n            result = new PullResult(fetchRes, remote, rebaseRes);\n        } catch (NoHeadException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (RefNotFoundException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (JGitInternalException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (GitAPIException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        }\n    } else {\n        MergeCommand merge = new MergeCommand(repo);\n        String name = \"branch \\'\" + Repository.shortenRefName(remoteBranchName) + \"\\' of \" + remoteUri;\n        merge.include(name, commitToMerge);\n        MergeResult mergeRes;\n        try {\n            mergeRes = merge.call();\n            monitor.update(1);\n            result = new PullResult(fetchRes, remote, mergeRes);\n        } catch (NoHeadException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (ConcurrentRefUpdateException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (CheckoutConflictException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (InvalidMergeHeadsException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (WrongRepositoryStateException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (NoMessageException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        }\n    }\n    monitor.endTask();\n    return result;\n}"
    },
    {
      "commit": "c3fe50bb18ed4e4e5e563172be4076fa5901a18a",
      "startLine": 28,
      "endLine": 47,
      "methodCode": "public PullResult call() throws WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch = repo.getFullBranch();\n        if (fullBranch == null)\n            throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName = fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig = repo.getConfig();\n    String remote = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    if (remote == null)\n        remote = Constants.DEFAULT_REMOTE_NAME;\n    String remoteBranchName = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    boolean doRebase = repoConfig.getBoolean(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE, false);\n    if (remoteBranchName == null) {\n        String missingKey = ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    final boolean isRemote = !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri = repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri == null) {\n            String missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch = new FetchCommand(repo);\n        fetch.setRemote(remote);\n        fetch.setProgressMonitor(monitor);\n        configure(fetch);\n        fetchRes = fetch.call();\n    } else {\n        remoteUri = \"local repository\";\n        fetchRes = null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r = null;\n        if (fetchRes != null) {\n            r = fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r == null)\n                r = fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r == null)\n            throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n        else\n            commitToMerge = r.getObjectId();\n    } else {\n        try {\n            commitToMerge = repo.resolve(remoteBranchName);\n            if (commitToMerge == null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    PullResult result;\n    if (doRebase) {\n        RebaseCommand rebase = new RebaseCommand(repo);\n        try {\n            RebaseResult rebaseRes = rebase.setUpstream(commitToMerge).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n            result = new PullResult(fetchRes, remote, rebaseRes);\n        } catch (NoHeadException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (RefNotFoundException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (JGitInternalException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (GitAPIException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        }\n    } else {\n        MergeCommand merge = new MergeCommand(repo);\n        String name = \"branch \\'\" + Repository.shortenRefName(remoteBranchName) + \"\\' of \" + remoteUri;\n        merge.include(name, commitToMerge);\n        MergeResult mergeRes;\n        try {\n            mergeRes = merge.call();\n            monitor.update(1);\n            result = new PullResult(fetchRes, remote, mergeRes);\n        } catch (NoHeadException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (ConcurrentRefUpdateException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (CheckoutConflictException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (InvalidMergeHeadsException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (WrongRepositoryStateException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (NoMessageException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        }\n    }\n    monitor.endTask();\n    return result;\n}"
    },
    {
      "commit": "da901c49688ef72858cd2b6904e0f8e478fa0ec3",
      "startLine": 26,
      "endLine": 45,
      "methodCode": "public PullResult call() throws WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch = repo.getFullBranch();\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName = fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig = repo.getConfig();\n    String remote = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    if (remote == null)\n        remote = Constants.DEFAULT_REMOTE_NAME;\n    String remoteBranchName = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    boolean doRebase = repoConfig.getBoolean(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE, false);\n    if (remoteBranchName == null) {\n        String missingKey = ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    final boolean isRemote = !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri = repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri == null) {\n            String missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch = new FetchCommand(repo);\n        fetch.setRemote(remote);\n        fetch.setProgressMonitor(monitor);\n        configure(fetch);\n        fetchRes = fetch.call();\n    } else {\n        remoteUri = \"local repository\";\n        fetchRes = null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r = null;\n        if (fetchRes != null) {\n            r = fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r == null)\n                r = fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r == null)\n            throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n        else\n            commitToMerge = r.getObjectId();\n    } else {\n        try {\n            commitToMerge = repo.resolve(remoteBranchName);\n            if (commitToMerge == null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    PullResult result;\n    if (doRebase) {\n        RebaseCommand rebase = new RebaseCommand(repo);\n        try {\n            RebaseResult rebaseRes = rebase.setUpstream(commitToMerge).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n            result = new PullResult(fetchRes, remote, rebaseRes);\n        } catch (NoHeadException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (RefNotFoundException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (JGitInternalException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (GitAPIException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        }\n    } else {\n        MergeCommand merge = new MergeCommand(repo);\n        String name = \"branch \\'\" + Repository.shortenRefName(remoteBranchName) + \"\\' of \" + remoteUri;\n        merge.include(name, commitToMerge);\n        MergeResult mergeRes;\n        try {\n            mergeRes = merge.call();\n            monitor.update(1);\n            result = new PullResult(fetchRes, remote, mergeRes);\n        } catch (NoHeadException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (ConcurrentRefUpdateException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (CheckoutConflictException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (InvalidMergeHeadsException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (WrongRepositoryStateException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (NoMessageException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        }\n    }\n    monitor.endTask();\n    return result;\n}"
    },
    {
      "commit": "791a9fd691e5ae101650f27f39366ec7b23f3955",
      "startLine": 26,
      "endLine": 47,
      "methodCode": "public PullResult call() throws WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch = repo.getFullBranch();\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName = fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig = repo.getConfig();\n    String remote = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    if (remote == null)\n        remote = Constants.DEFAULT_REMOTE_NAME;\n    String remoteBranchName = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    boolean doRebase = repoConfig.getBoolean(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE, false);\n    if (remoteBranchName == null) {\n        String missingKey = ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    final boolean isRemote = !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri = repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri == null) {\n            String missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch = new FetchCommand(repo);\n        fetch.setRemote(remote);\n        fetch.setProgressMonitor(monitor);\n        fetch.setTimeout(this.timeout);\n        fetch.setCredentialsProvider(credentialsProvider);\n        fetch.setTransportConfigCallback(transportConfigCallback);\n        fetchRes = fetch.call();\n    } else {\n        remoteUri = \"local repository\";\n        fetchRes = null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r = null;\n        if (fetchRes != null) {\n            r = fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r == null)\n                r = fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r == null)\n            throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n        else\n            commitToMerge = r.getObjectId();\n    } else {\n        try {\n            commitToMerge = repo.resolve(remoteBranchName);\n            if (commitToMerge == null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    PullResult result;\n    if (doRebase) {\n        RebaseCommand rebase = new RebaseCommand(repo);\n        try {\n            RebaseResult rebaseRes = rebase.setUpstream(commitToMerge).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n            result = new PullResult(fetchRes, remote, rebaseRes);\n        } catch (NoHeadException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (RefNotFoundException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (JGitInternalException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (GitAPIException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        }\n    } else {\n        MergeCommand merge = new MergeCommand(repo);\n        String name = \"branch \\'\" + Repository.shortenRefName(remoteBranchName) + \"\\' of \" + remoteUri;\n        merge.include(name, commitToMerge);\n        MergeResult mergeRes;\n        try {\n            mergeRes = merge.call();\n            monitor.update(1);\n            result = new PullResult(fetchRes, remote, mergeRes);\n        } catch (NoHeadException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (ConcurrentRefUpdateException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (CheckoutConflictException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (InvalidMergeHeadsException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (WrongRepositoryStateException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (NoMessageException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        }\n    }\n    monitor.endTask();\n    return result;\n}"
    },
    {
      "commit": "6d293c7b06e219086959e80d495b5febe8ae530d",
      "startLine": 26,
      "endLine": 46,
      "methodCode": "public PullResult call() throws WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch = repo.getFullBranch();\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName = fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig = repo.getConfig();\n    String remote = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    if (remote == null)\n        remote = Constants.DEFAULT_REMOTE_NAME;\n    String remoteBranchName = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    boolean doRebase = repoConfig.getBoolean(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE, false);\n    if (remoteBranchName == null) {\n        String missingKey = ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    final boolean isRemote = !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri = repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri == null) {\n            String missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch = new FetchCommand(repo);\n        fetch.setRemote(remote);\n        fetch.setProgressMonitor(monitor);\n        fetch.setTimeout(this.timeout);\n        fetch.setCredentialsProvider(credentialsProvider);\n        fetchRes = fetch.call();\n    } else {\n        remoteUri = \"local repository\";\n        fetchRes = null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r = null;\n        if (fetchRes != null) {\n            r = fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r == null)\n                r = fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r == null)\n            throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n        else\n            commitToMerge = r.getObjectId();\n    } else {\n        try {\n            commitToMerge = repo.resolve(remoteBranchName);\n            if (commitToMerge == null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    PullResult result;\n    if (doRebase) {\n        RebaseCommand rebase = new RebaseCommand(repo);\n        try {\n            RebaseResult rebaseRes = rebase.setUpstream(commitToMerge).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n            result = new PullResult(fetchRes, remote, rebaseRes);\n        } catch (NoHeadException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (RefNotFoundException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (JGitInternalException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (GitAPIException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        }\n    } else {\n        MergeCommand merge = new MergeCommand(repo);\n        String name = \"branch \\'\" + Repository.shortenRefName(remoteBranchName) + \"\\' of \" + remoteUri;\n        merge.include(name, commitToMerge);\n        MergeResult mergeRes;\n        try {\n            mergeRes = merge.call();\n            monitor.update(1);\n            result = new PullResult(fetchRes, remote, mergeRes);\n        } catch (NoHeadException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (ConcurrentRefUpdateException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (CheckoutConflictException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (InvalidMergeHeadsException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (WrongRepositoryStateException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (NoMessageException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        }\n    }\n    monitor.endTask();\n    return result;\n}"
    },
    {
      "commit": "770c733687d9f2f71f30822f9691427bf83b7577",
      "startLine": 26,
      "endLine": 46,
      "methodCode": "public PullResult call() throws WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch = repo.getFullBranch();\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName = fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig = repo.getConfig();\n    String remote = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    if (remote == null)\n        remote = Constants.DEFAULT_REMOTE_NAME;\n    String remoteBranchName = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    boolean doRebase = repoConfig.getBoolean(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE, false);\n    if (remoteBranchName == null) {\n        String missingKey = ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    final boolean isRemote = !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri = repoConfig.getString(\"remote\", remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri == null) {\n            String missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch = new FetchCommand(repo);\n        fetch.setRemote(remote);\n        fetch.setProgressMonitor(monitor);\n        fetch.setTimeout(this.timeout);\n        fetch.setCredentialsProvider(credentialsProvider);\n        fetchRes = fetch.call();\n    } else {\n        remoteUri = \"local repository\";\n        fetchRes = null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r = null;\n        if (fetchRes != null) {\n            r = fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r == null)\n                r = fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r == null)\n            throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n        else\n            commitToMerge = r.getObjectId();\n    } else {\n        try {\n            commitToMerge = repo.resolve(remoteBranchName);\n            if (commitToMerge == null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    PullResult result;\n    if (doRebase) {\n        RebaseCommand rebase = new RebaseCommand(repo);\n        try {\n            RebaseResult rebaseRes = rebase.setUpstream(commitToMerge).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n            result = new PullResult(fetchRes, remote, rebaseRes);\n        } catch (NoHeadException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (RefNotFoundException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (JGitInternalException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (GitAPIException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        }\n    } else {\n        MergeCommand merge = new MergeCommand(repo);\n        String name = \"branch \\'\" + Repository.shortenRefName(remoteBranchName) + \"\\' of \" + remoteUri;\n        merge.include(name, commitToMerge);\n        MergeResult mergeRes;\n        try {\n            mergeRes = merge.call();\n            monitor.update(1);\n            result = new PullResult(fetchRes, remote, mergeRes);\n        } catch (NoHeadException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (ConcurrentRefUpdateException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (CheckoutConflictException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (InvalidMergeHeadsException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (WrongRepositoryStateException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (NoMessageException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        }\n    }\n    monitor.endTask();\n    return result;\n}"
    },
    {
      "commit": "68459b646e6c8243dc5650cbe08ce1bcdb8a621d",
      "startLine": 26,
      "endLine": 46,
      "methodCode": "public PullResult call() throws WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch = repo.getFullBranch();\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName = fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig = repo.getConfig();\n    String remote = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    if (remote == null)\n        remote = Constants.DEFAULT_REMOTE_NAME;\n    String remoteBranchName = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    boolean doRebase = repoConfig.getBoolean(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE, false);\n    if (remoteBranchName == null) {\n        String missingKey = ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    final boolean isRemote = !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri = repoConfig.getString(\"remote\", remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri == null) {\n            String missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch = new FetchCommand(repo);\n        fetch.setRemote(remote);\n        fetch.setProgressMonitor(monitor);\n        fetch.setTimeout(this.timeout);\n        fetch.setCredentialsProvider(credentialsProvider);\n        fetchRes = fetch.call();\n    } else {\n        remoteUri = \"local repository\";\n        fetchRes = null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r = null;\n        if (fetchRes != null) {\n            r = fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r == null)\n                r = fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r == null)\n            throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n        else\n            commitToMerge = r.getObjectId();\n    } else {\n        try {\n            commitToMerge = repo.resolve(remoteBranchName);\n            if (commitToMerge == null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    PullResult result;\n    if (doRebase) {\n        RebaseCommand rebase = new RebaseCommand(repo);\n        try {\n            RebaseResult rebaseRes = rebase.setUpstream(commitToMerge).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n            result = new PullResult(fetchRes, remote, rebaseRes);\n        } catch (NoHeadException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (RefNotFoundException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (JGitInternalException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (GitAPIException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        }\n    } else {\n        MergeCommand merge = new MergeCommand(repo);\n        merge.include(\"branch \\'\" + remoteBranchName + \"\\' of \" + remoteUri, commitToMerge);\n        MergeResult mergeRes;\n        try {\n            mergeRes = merge.call();\n            monitor.update(1);\n            result = new PullResult(fetchRes, remote, mergeRes);\n        } catch (NoHeadException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (ConcurrentRefUpdateException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (CheckoutConflictException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (InvalidMergeHeadsException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (WrongRepositoryStateException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (NoMessageException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        }\n    }\n    monitor.endTask();\n    return result;\n}"
    },
    {
      "commit": "724af77c65c27eb24d41989bed3229910dbe063c",
      "startLine": 26,
      "endLine": 46,
      "methodCode": "public PullResult call() throws WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch = repo.getFullBranch();\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName = fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig = repo.getConfig();\n    String remote = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    if (remote == null)\n        remote = Constants.DEFAULT_REMOTE_NAME;\n    String remoteBranchName = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    boolean doRebase = repoConfig.getBoolean(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE, false);\n    if (remoteBranchName == null) {\n        String missingKey = ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    final boolean isRemote = !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri = repoConfig.getString(\"remote\", remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri == null) {\n            String missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch = new FetchCommand(repo);\n        fetch.setRemote(remote);\n        fetch.setProgressMonitor(monitor);\n        fetch.setTimeout(this.timeout);\n        fetch.setCredentialsProvider(credentialsProvider);\n        fetchRes = fetch.call();\n    } else {\n        remoteUri = \"local repository\";\n        fetchRes = null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r = null;\n        if (fetchRes != null) {\n            r = fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r == null)\n                r = fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r == null)\n            throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n        else\n            commitToMerge = r.getObjectId();\n    } else {\n        try {\n            commitToMerge = repo.resolve(remoteBranchName);\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    PullResult result;\n    if (doRebase) {\n        RebaseCommand rebase = new RebaseCommand(repo);\n        try {\n            RebaseResult rebaseRes = rebase.setUpstream(commitToMerge).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n            result = new PullResult(fetchRes, remote, rebaseRes);\n        } catch (NoHeadException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (RefNotFoundException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (JGitInternalException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (GitAPIException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        }\n    } else {\n        MergeCommand merge = new MergeCommand(repo);\n        merge.include(\"branch \\'\" + remoteBranchName + \"\\' of \" + remoteUri, commitToMerge);\n        MergeResult mergeRes;\n        try {\n            mergeRes = merge.call();\n            monitor.update(1);\n            result = new PullResult(fetchRes, remote, mergeRes);\n        } catch (NoHeadException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (ConcurrentRefUpdateException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (CheckoutConflictException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (InvalidMergeHeadsException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (WrongRepositoryStateException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (NoMessageException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        }\n    }\n    monitor.endTask();\n    return result;\n}"
    },
    {
      "commit": "b15b9d5df25b375108ca125b31338df637454865",
      "startLine": 28,
      "endLine": 48,
      "methodCode": "public PullResult call() throws WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch = repo.getFullBranch();\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName = fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig = repo.getConfig();\n    final String remote = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    if (remote == null) {\n        String missingKey = ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_REMOTE;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    String remoteBranchName = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    boolean doRebase = repoConfig.getBoolean(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE, false);\n    if (remoteBranchName == null) {\n        String missingKey = ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    final boolean isRemote = !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri = repoConfig.getString(\"remote\", remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri == null) {\n            String missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch = new FetchCommand(repo);\n        fetch.setRemote(remote);\n        fetch.setProgressMonitor(monitor);\n        fetch.setTimeout(this.timeout);\n        fetch.setCredentialsProvider(credentialsProvider);\n        fetchRes = fetch.call();\n    } else {\n        remoteUri = \"local repository\";\n        fetchRes = null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r = null;\n        if (fetchRes != null) {\n            r = fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r == null)\n                r = fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r == null)\n            throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n        else\n            commitToMerge = r.getObjectId();\n    } else {\n        try {\n            commitToMerge = repo.resolve(remoteBranchName);\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    PullResult result;\n    if (doRebase) {\n        RebaseCommand rebase = new RebaseCommand(repo);\n        try {\n            RebaseResult rebaseRes = rebase.setUpstream(commitToMerge).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n            result = new PullResult(fetchRes, remote, rebaseRes);\n        } catch (NoHeadException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (RefNotFoundException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (JGitInternalException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (GitAPIException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        }\n    } else {\n        MergeCommand merge = new MergeCommand(repo);\n        merge.include(\"branch \\'\" + remoteBranchName + \"\\' of \" + remoteUri, commitToMerge);\n        MergeResult mergeRes;\n        try {\n            mergeRes = merge.call();\n            monitor.update(1);\n            result = new PullResult(fetchRes, remote, mergeRes);\n        } catch (NoHeadException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (ConcurrentRefUpdateException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (CheckoutConflictException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (InvalidMergeHeadsException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (WrongRepositoryStateException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (NoMessageException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        }\n    }\n    monitor.endTask();\n    return result;\n}"
    },
    {
      "commit": "9fbda2239202ca9d3a20c84d7326f47c667aa920",
      "startLine": 34,
      "endLine": 54,
      "methodCode": "public PullResult call() throws WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch = repo.getFullBranch();\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName = fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig = repo.getConfig();\n    final String remote = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    if (remote == null) {\n        String missingKey = ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_REMOTE;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    String remoteBranchName = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    boolean doRebase = false;\n    if (remoteBranchName == null) {\n        remoteBranchName = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE);\n        if (remoteBranchName != null) {\n            doRebase = true;\n        }\n    }\n    if (remoteBranchName == null) {\n        String missingKey = ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    final boolean isRemote = !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri = repoConfig.getString(\"remote\", remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri == null) {\n            String missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch = new FetchCommand(repo);\n        fetch.setRemote(remote);\n        fetch.setProgressMonitor(monitor);\n        fetch.setTimeout(this.timeout);\n        fetch.setCredentialsProvider(credentialsProvider);\n        fetchRes = fetch.call();\n    } else {\n        remoteUri = \"local repository\";\n        fetchRes = null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    PullResult result;\n    if (doRebase) {\n        RebaseCommand rebase = new RebaseCommand(repo);\n        try {\n            RebaseResult rebaseRes = rebase.setUpstream(remoteBranchName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n            result = new PullResult(fetchRes, remote, rebaseRes);\n        } catch (NoHeadException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (RefNotFoundException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (JGitInternalException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (GitAPIException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        }\n    } else {\n        AnyObjectId commitToMerge;\n        if (isRemote) {\n            Ref r = null;\n            if (fetchRes != null) {\n                r = fetchRes.getAdvertisedRef(remoteBranchName);\n                if (r == null)\n                    r = fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n            }\n            if (r == null)\n                throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n            else\n                commitToMerge = r.getObjectId();\n        } else {\n            try {\n                commitToMerge = repo.resolve(remoteBranchName);\n            } catch (IOException e) {\n                throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n            }\n        }\n        MergeCommand merge = new MergeCommand(repo);\n        merge.include(\"branch \\'\" + remoteBranchName + \"\\' of \" + remoteUri, commitToMerge);\n        MergeResult mergeRes;\n        try {\n            mergeRes = merge.call();\n            monitor.update(1);\n            result = new PullResult(fetchRes, remote, mergeRes);\n        } catch (NoHeadException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (ConcurrentRefUpdateException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (CheckoutConflictException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (InvalidMergeHeadsException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (WrongRepositoryStateException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (NoMessageException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        }\n    }\n    monitor.endTask();\n    return result;\n}"
    },
    {
      "commit": "14ca80bc90ed85e3484fa28aa665fa0538096d30",
      "startLine": 34,
      "endLine": 53,
      "methodCode": "public PullResult call() throws WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch = repo.getFullBranch();\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName = fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig = repo.getConfig();\n    final String remote = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    if (remote == null) {\n        String missingKey = ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_REMOTE;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    String remoteBranchName = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    boolean doRebase = false;\n    if (remoteBranchName == null) {\n        remoteBranchName = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE);\n        if (remoteBranchName != null) {\n            doRebase = true;\n        }\n    }\n    if (remoteBranchName == null) {\n        String missingKey = ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    final boolean isRemote = !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri = repoConfig.getString(\"remote\", remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri == null) {\n            String missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch = new FetchCommand(repo);\n        fetch.setRemote(remote);\n        fetch.setProgressMonitor(monitor);\n        fetch.setTimeout(this.timeout);\n        fetchRes = fetch.call();\n    } else {\n        remoteUri = \"local repository\";\n        fetchRes = null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    PullResult result;\n    if (doRebase) {\n        RebaseCommand rebase = new RebaseCommand(repo);\n        try {\n            RebaseResult rebaseRes = rebase.setUpstream(remoteBranchName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n            result = new PullResult(fetchRes, remote, rebaseRes);\n        } catch (NoHeadException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (RefNotFoundException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (JGitInternalException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (GitAPIException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        }\n    } else {\n        AnyObjectId commitToMerge;\n        if (isRemote) {\n            Ref r = null;\n            if (fetchRes != null) {\n                r = fetchRes.getAdvertisedRef(remoteBranchName);\n                if (r == null)\n                    r = fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n            }\n            if (r == null)\n                throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n            else\n                commitToMerge = r.getObjectId();\n        } else {\n            try {\n                commitToMerge = repo.resolve(remoteBranchName);\n            } catch (IOException e) {\n                throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n            }\n        }\n        MergeCommand merge = new MergeCommand(repo);\n        merge.include(\"branch \\'\" + remoteBranchName + \"\\' of \" + remoteUri, commitToMerge);\n        MergeResult mergeRes;\n        try {\n            mergeRes = merge.call();\n            monitor.update(1);\n            result = new PullResult(fetchRes, remote, mergeRes);\n        } catch (NoHeadException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (ConcurrentRefUpdateException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (CheckoutConflictException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (InvalidMergeHeadsException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (WrongRepositoryStateException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (NoMessageException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        }\n    }\n    monitor.endTask();\n    return result;\n}"
    },
    {
      "commit": "013cb8de3824c304645a9c5db87c2e80286872d1",
      "startLine": 33,
      "endLine": 52,
      "methodCode": "public PullResult call() throws WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch = repo.getFullBranch();\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName = fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig = repo.getConfig();\n    final String remote = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    if (remote == null) {\n        String missingKey = ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_REMOTE;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    String remoteBranchName = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    if (remoteBranchName == null) {\n        remoteBranchName = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE);\n        if (remoteBranchName != null) {\n            throw new JGitInternalException(\"Pull with rebase is not yet supported\");\n        }\n    }\n    if (remoteBranchName == null) {\n        String missingKey = ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    final boolean isRemote = !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri = repoConfig.getString(\"remote\", remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri == null) {\n            String missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch = new FetchCommand(repo);\n        fetch.setRemote(remote);\n        fetch.setProgressMonitor(monitor);\n        fetch.setTimeout(this.timeout);\n        fetchRes = fetch.call();\n    } else {\n        remoteUri = \"local repository\";\n        fetchRes = null;\n    }\n    monitor.update(1);\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r = null;\n        if (fetchRes != null) {\n            r = fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r == null)\n                r = fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r == null)\n            throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n        else\n            commitToMerge = r.getObjectId();\n    } else {\n        try {\n            commitToMerge = repo.resolve(remoteBranchName);\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    MergeCommand merge = new MergeCommand(repo);\n    merge.include(\"branch \\'\" + remoteBranchName + \"\\' of \" + remoteUri, commitToMerge);\n    MergeResult mergeRes;\n    try {\n        mergeRes = merge.call();\n        monitor.update(1);\n    } catch (NoHeadException e) {\n        throw new JGitInternalException(e.getMessage(), e);\n    } catch (ConcurrentRefUpdateException e) {\n        throw new JGitInternalException(e.getMessage(), e);\n    } catch (CheckoutConflictException e) {\n        throw new JGitInternalException(e.getMessage(), e);\n    } catch (InvalidMergeHeadsException e) {\n        throw new JGitInternalException(e.getMessage(), e);\n    } catch (WrongRepositoryStateException e) {\n        throw new JGitInternalException(e.getMessage(), e);\n    } catch (NoMessageException e) {\n        throw new JGitInternalException(e.getMessage(), e);\n    }\n    monitor.endTask();\n    return new PullResult(fetchRes, remote, mergeRes);\n}"
    },
    {
      "commit": "d36c80fd048fc55d7ac31ae62eb67fbac9b12e31",
      "startLine": 33,
      "endLine": 52,
      "methodCode": "public PullResult call() throws WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch = repo.getFullBranch();\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName = fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig = repo.getConfig();\n    final String remote = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    if (remote == null) {\n        String missingKey = ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_REMOTE;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    String remoteBranchName = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    if (remoteBranchName == null) {\n        remoteBranchName = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE);\n        if (remoteBranchName != null) {\n            throw new JGitInternalException(\"Pull with rebase is not yet supported\");\n        }\n    }\n    if (remoteBranchName == null) {\n        String missingKey = ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    final boolean isRemote = !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri = repo.getConfig().getString(\"remote\", remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri == null) {\n            String missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch = new FetchCommand(repo);\n        fetch.setRemote(remote);\n        fetch.setProgressMonitor(monitor);\n        fetch.setTimeout(this.timeout);\n        fetchRes = fetch.call();\n    } else {\n        remoteUri = \"local repository\";\n        fetchRes = null;\n    }\n    monitor.update(1);\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r = null;\n        if (fetchRes != null) {\n            r = fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r == null)\n                r = fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r == null)\n            throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n        else\n            commitToMerge = r.getObjectId();\n    } else {\n        try {\n            commitToMerge = repo.resolve(remoteBranchName);\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    MergeCommand merge = new MergeCommand(repo);\n    merge.include(\"branch \\'\" + remoteBranchName + \"\\' of \" + remoteUri, commitToMerge);\n    MergeResult mergeRes;\n    try {\n        mergeRes = merge.call();\n        monitor.update(1);\n    } catch (NoHeadException e) {\n        throw new JGitInternalException(e.getMessage(), e);\n    } catch (ConcurrentRefUpdateException e) {\n        throw new JGitInternalException(e.getMessage(), e);\n    } catch (CheckoutConflictException e) {\n        throw new JGitInternalException(e.getMessage(), e);\n    } catch (InvalidMergeHeadsException e) {\n        throw new JGitInternalException(e.getMessage(), e);\n    } catch (WrongRepositoryStateException e) {\n        throw new JGitInternalException(e.getMessage(), e);\n    } catch (NoMessageException e) {\n        throw new JGitInternalException(e.getMessage(), e);\n    }\n    monitor.endTask();\n    return new PullResult(fetchRes, remote, mergeRes);\n}"
    },
    {
      "commit": "7668a462829b12e4f6a192c43157152ef63ff305",
      "startLine": 33,
      "endLine": 53,
      "methodCode": "public PullResult call() throws WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch = repo.getFullBranch();\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName = fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig = repo.getConfig();\n    final String remote = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    if (remote == null) {\n        String missingKey = ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_REMOTE;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    String remoteBranchName = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    if (remoteBranchName == null) {\n        remoteBranchName = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE);\n        if (remoteBranchName != null) {\n            throw new JGitInternalException(\"Pull with rebase is not yet supported\");\n        }\n    }\n    if (remoteBranchName == null) {\n        String missingKey = ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    final boolean isRemote = !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri = repo.getConfig().getString(\"remote\", remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri == null) {\n            String missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch = new FetchCommand(repo);\n        fetch.setRemote(remote);\n        if (monitor != null)\n            fetch.setProgressMonitor(monitor);\n        fetch.setTimeout(this.timeout);\n        fetchRes = fetch.call();\n    } else {\n        remoteUri = \"local repository\";\n        fetchRes = null;\n    }\n    monitor.update(1);\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r = null;\n        if (fetchRes != null) {\n            r = fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r == null)\n                r = fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r == null)\n            throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n        else\n            commitToMerge = r.getObjectId();\n    } else {\n        try {\n            commitToMerge = repo.resolve(remoteBranchName);\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    MergeCommand merge = new MergeCommand(repo);\n    merge.include(\"branch \\'\" + remoteBranchName + \"\\' of \" + remoteUri, commitToMerge);\n    MergeResult mergeRes;\n    try {\n        mergeRes = merge.call();\n        monitor.update(1);\n    } catch (NoHeadException e) {\n        throw new JGitInternalException(e.getMessage(), e);\n    } catch (ConcurrentRefUpdateException e) {\n        throw new JGitInternalException(e.getMessage(), e);\n    } catch (CheckoutConflictException e) {\n        throw new JGitInternalException(e.getMessage(), e);\n    } catch (InvalidMergeHeadsException e) {\n        throw new JGitInternalException(e.getMessage(), e);\n    } catch (WrongRepositoryStateException e) {\n        throw new JGitInternalException(e.getMessage(), e);\n    } catch (NoMessageException e) {\n        throw new JGitInternalException(e.getMessage(), e);\n    }\n    monitor.endTask();\n    return new PullResult(fetchRes, remote, mergeRes);\n}"
    },
    {
      "commit": "db55d13f5f4b641a9390076ced6b1775bcfcd6f6",
      "startLine": 22,
      "endLine": 22,
      "methodCode": "public PullResult call() throws WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch = repo.getFullBranch();\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName = fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig = repo.getConfig();\n    final String remote = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    if (remote == null) {\n        String missingKey = ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_REMOTE;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    final String remoteUri = repo.getConfig().getString(\"remote\", remote, ConfigConstants.CONFIG_KEY_URL);\n    if (remoteUri == null) {\n        String missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    String remoteBranchName = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    if (remoteBranchName == null) {\n        remoteBranchName = repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n        if (remoteBranchName != null) {\n            throw new JGitInternalException(\"Pull with rebase is not yet supported\");\n        }\n    }\n    if (remoteBranchName == null) {\n        String missingKey = ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    FetchCommand fetch = new FetchCommand(repo);\n    fetch.setRemote(remote);\n    if (monitor != null)\n        fetch.setProgressMonitor(monitor);\n    fetch.setTimeout(this.timeout);\n    FetchResult fetchRes = fetch.call();\n    monitor.update(1);\n    AnyObjectId commitToMerge = null;\n    Ref r = fetchRes.getAdvertisedRef(remoteBranchName);\n    if (r == null)\n        r = fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n    if (r == null) {\n        String remoteTrackingBranch = Constants.R_REMOTES + remote + '/' + branchName;\n        try {\n            commitToMerge = repo.resolve(remoteTrackingBranch);\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    } else\n        commitToMerge = r.getObjectId();\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    MergeCommand merge = new MergeCommand(repo);\n    merge.include(\"branch \\'\" + remoteBranchName + \"\\' of \" + remoteUri, commitToMerge);\n    MergeResult mergeRes;\n    try {\n        mergeRes = merge.call();\n        monitor.update(1);\n    } catch (NoHeadException e) {\n        throw new JGitInternalException(e.getMessage(), e);\n    } catch (ConcurrentRefUpdateException e) {\n        throw new JGitInternalException(e.getMessage(), e);\n    } catch (CheckoutConflictException e) {\n        throw new JGitInternalException(e.getMessage(), e);\n    } catch (InvalidMergeHeadsException e) {\n        throw new JGitInternalException(e.getMessage(), e);\n    } catch (WrongRepositoryStateException e) {\n        throw new JGitInternalException(e.getMessage(), e);\n    } catch (NoMessageException e) {\n        throw new JGitInternalException(e.getMessage(), e);\n    }\n    monitor.endTask();\n    return new PullResult(fetchRes, remote, mergeRes);\n}"
    }
  ]
}