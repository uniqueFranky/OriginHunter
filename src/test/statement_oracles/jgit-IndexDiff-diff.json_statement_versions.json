{
  "statementVersions": [
    {
      "commit": "5639639b06c004d18415f59a271319da2fb7b930",
      "startLine": 13,
      "endLine": 20,
      "methodCode": "public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n    dirCache = repository.readDirCache();\n    try (TreeWalk treeWalk = new TreeWalk(repository)) {\n        treeWalk.setOperationType(OperationType.CHECKIN_OP);\n        treeWalk.setRecursive(true);\n        if (tree != null)\n            treeWalk.addTree(tree);\n        else\n            treeWalk.addTree(new EmptyTreeIterator());\n        treeWalk.addTree(new DirCacheIterator(dirCache));\n        treeWalk.addTree(initialWorkingTreeIterator);\n        initialWorkingTreeIterator.setDirCacheIterator(treeWalk, 1);\n        Collection<TreeFilter> filters = new ArrayList<>(4);\n        if (monitor != null) {\n            if (estIndexSize == 0)\n                estIndexSize = dirCache.getEntryCount();\n            int total = Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n            monitor.beginTask(title, total);\n            filters.add(new ProgressReportingFilter(monitor, total));\n        }\n        if (filter != null)\n            filters.add(filter);\n        filters.add(new SkipWorkTreeFilter(INDEX));\n        indexDiffFilter = new IndexDiffFilter(INDEX, WORKDIR);\n        filters.add(indexDiffFilter);\n        treeWalk.setFilter(AndTreeFilter.create(filters));\n        fileModes.clear();\n        while (treeWalk.next()) {\n            AbstractTreeIterator treeIterator = treeWalk.getTree(TREE, AbstractTreeIterator.class);\n            DirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX, DirCacheIterator.class);\n            WorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n            if (dirCacheIterator != null) {\n                final DirCacheEntry dirCacheEntry = dirCacheIterator.getDirCacheEntry();\n                if (dirCacheEntry != null) {\n                    int stage = dirCacheEntry.getStage();\n                    if (stage > 0) {\n                        String path = treeWalk.getPathString();\n                        addConflict(path, stage);\n                        continue;\n                    }\n                }\n            }\n            if (treeIterator != null) {\n                if (dirCacheIterator != null) {\n                    if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() != dirCacheIterator.getEntryRawMode()) {\n                        if (!isEntryGitLink(treeIterator) || !isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                            changed.add(treeWalk.getPathString());\n                    }\n                } else {\n                    if (!isEntryGitLink(treeIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                        removed.add(treeWalk.getPathString());\n                    if (workingTreeIterator != null)\n                        untracked.add(treeWalk.getPathString());\n                }\n            } else {\n                if (dirCacheIterator != null) {\n                    if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                        added.add(treeWalk.getPathString());\n                } else {\n                    if (workingTreeIterator != null && !workingTreeIterator.isEntryIgnored()) {\n                        untracked.add(treeWalk.getPathString());\n                    }\n                }\n            }\n            if (dirCacheIterator != null) {\n                if (workingTreeIterator == null) {\n                    if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                        missing.add(treeWalk.getPathString());\n                } else {\n                    if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true, treeWalk.getObjectReader())) {\n                        if (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator) || (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL && ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY))\n                            modified.add(treeWalk.getPathString());\n                    }\n                }\n            }\n            String path = treeWalk.getPathString();\n            if (path != null) {\n                for (int i = 0; i < treeWalk.getTreeCount(); i++) {\n                    recordFileMode(path, treeWalk.getFileMode(i));\n                }\n            }\n        }\n    }\n    if (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL) {\n        IgnoreSubmoduleMode localIgnoreSubmoduleMode = ignoreSubmoduleMode;\n        SubmoduleWalk smw = SubmoduleWalk.forIndex(repository);\n        while (smw.next()) {\n            try {\n                if (localIgnoreSubmoduleMode == null)\n                    localIgnoreSubmoduleMode = smw.getModulesIgnore();\n                if (IgnoreSubmoduleMode.ALL.equals(localIgnoreSubmoduleMode))\n                    continue;\n            } catch (ConfigInvalidException e) {\n                throw new IOException(MessageFormat.format(JGitText.get().invalidIgnoreParamSubmodule, smw.getPath()), e);\n            }\n            try (Repository subRepo = smw.getRepository()) {\n                if (subRepo != null) {\n                    String subRepoPath = smw.getPath();\n                    ObjectId subHead = subRepo.resolve(\"HEAD\");\n                    if (subHead != null && !subHead.equals(smw.getObjectId())) {\n                        modified.add(subRepoPath);\n                        recordFileMode(subRepoPath, FileMode.GITLINK);\n                    } else if (ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY) {\n                        IndexDiff smid = submoduleIndexDiffs.get(smw.getPath());\n                        if (smid == null) {\n                            smid = new IndexDiff(subRepo, smw.getObjectId(), wTreeIt.getWorkingTreeIterator(subRepo));\n                            submoduleIndexDiffs.put(subRepoPath, smid);\n                        }\n                        if (smid.diff()) {\n                            if (ignoreSubmoduleMode == IgnoreSubmoduleMode.UNTRACKED && smid.getAdded().isEmpty() && smid.getChanged().isEmpty() && smid.getConflicting().isEmpty() && smid.getMissing().isEmpty() && smid.getModified().isEmpty() && smid.getRemoved().isEmpty()) {\n                                continue;\n                            }\n                            modified.add(subRepoPath);\n                            recordFileMode(subRepoPath, FileMode.GITLINK);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if (monitor != null)\n        monitor.endTask();\n    ignored = indexDiffFilter.getIgnoredPaths();\n    if (added.isEmpty() && changed.isEmpty() && removed.isEmpty() && missing.isEmpty() && modified.isEmpty() && untracked.isEmpty())\n        return false;\n    else\n        return true;\n}"
    },
    {
      "commit": "0c259eaf1db076837768512deb6c251c86e67941",
      "startLine": 13,
      "endLine": 20,
      "methodCode": "public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n    dirCache = repository.readDirCache();\n    try (TreeWalk treeWalk = new TreeWalk(repository)) {\n        treeWalk.setOperationType(OperationType.CHECKIN_OP);\n        treeWalk.setRecursive(true);\n        if (tree != null)\n            treeWalk.addTree(tree);\n        else\n            treeWalk.addTree(new EmptyTreeIterator());\n        treeWalk.addTree(new DirCacheIterator(dirCache));\n        treeWalk.addTree(initialWorkingTreeIterator);\n        initialWorkingTreeIterator.setDirCacheIterator(treeWalk, 1);\n        Collection<TreeFilter> filters = new ArrayList<>(4);\n        if (monitor != null) {\n            if (estIndexSize == 0)\n                estIndexSize = dirCache.getEntryCount();\n            int total = Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n            monitor.beginTask(title, total);\n            filters.add(new ProgressReportingFilter(monitor, total));\n        }\n        if (filter != null)\n            filters.add(filter);\n        filters.add(new SkipWorkTreeFilter(INDEX));\n        indexDiffFilter = new IndexDiffFilter(INDEX, WORKDIR);\n        filters.add(indexDiffFilter);\n        treeWalk.setFilter(AndTreeFilter.create(filters));\n        fileModes.clear();\n        while (treeWalk.next()) {\n            AbstractTreeIterator treeIterator = treeWalk.getTree(TREE, AbstractTreeIterator.class);\n            DirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX, DirCacheIterator.class);\n            WorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n            if (dirCacheIterator != null) {\n                final DirCacheEntry dirCacheEntry = dirCacheIterator.getDirCacheEntry();\n                if (dirCacheEntry != null) {\n                    int stage = dirCacheEntry.getStage();\n                    if (stage > 0) {\n                        String path = treeWalk.getPathString();\n                        addConflict(path, stage);\n                        continue;\n                    }\n                }\n            }\n            if (treeIterator != null) {\n                if (dirCacheIterator != null) {\n                    if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() != dirCacheIterator.getEntryRawMode()) {\n                        if (!isEntryGitLink(treeIterator) || !isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                            changed.add(treeWalk.getPathString());\n                    }\n                } else {\n                    if (!isEntryGitLink(treeIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                        removed.add(treeWalk.getPathString());\n                    if (workingTreeIterator != null)\n                        untracked.add(treeWalk.getPathString());\n                }\n            } else {\n                if (dirCacheIterator != null) {\n                    if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                        added.add(treeWalk.getPathString());\n                } else {\n                    if (workingTreeIterator != null && !workingTreeIterator.isEntryIgnored()) {\n                        untracked.add(treeWalk.getPathString());\n                    }\n                }\n            }\n            if (dirCacheIterator != null) {\n                if (workingTreeIterator == null) {\n                    if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                        missing.add(treeWalk.getPathString());\n                } else {\n                    if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true, treeWalk.getObjectReader())) {\n                        if (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator) || (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL && ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY))\n                            modified.add(treeWalk.getPathString());\n                    }\n                }\n            }\n            String path = treeWalk.getPathString();\n            if (path != null) {\n                for (int i = 0; i < treeWalk.getTreeCount(); i++) {\n                    recordFileMode(path, treeWalk.getFileMode(i));\n                }\n            }\n        }\n    }\n    if (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL) {\n        IgnoreSubmoduleMode localIgnoreSubmoduleMode = ignoreSubmoduleMode;\n        SubmoduleWalk smw = SubmoduleWalk.forIndex(repository);\n        while (smw.next()) {\n            try {\n                if (localIgnoreSubmoduleMode == null)\n                    localIgnoreSubmoduleMode = smw.getModulesIgnore();\n                if (IgnoreSubmoduleMode.ALL.equals(localIgnoreSubmoduleMode))\n                    continue;\n            } catch (ConfigInvalidException e) {\n                throw new IOException(MessageFormat.format(JGitText.get().invalidIgnoreParamSubmodule, smw.getPath()), e);\n            }\n            Repository subRepo = smw.getRepository();\n            if (subRepo != null) {\n                String subRepoPath = smw.getPath();\n                try {\n                    ObjectId subHead = subRepo.resolve(\"HEAD\");\n                    if (subHead != null && !subHead.equals(smw.getObjectId())) {\n                        modified.add(subRepoPath);\n                        recordFileMode(subRepoPath, FileMode.GITLINK);\n                    } else if (ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY) {\n                        IndexDiff smid = submoduleIndexDiffs.get(smw.getPath());\n                        if (smid == null) {\n                            smid = new IndexDiff(subRepo, smw.getObjectId(), wTreeIt.getWorkingTreeIterator(subRepo));\n                            submoduleIndexDiffs.put(subRepoPath, smid);\n                        }\n                        if (smid.diff()) {\n                            if (ignoreSubmoduleMode == IgnoreSubmoduleMode.UNTRACKED && smid.getAdded().isEmpty() && smid.getChanged().isEmpty() && smid.getConflicting().isEmpty() && smid.getMissing().isEmpty() && smid.getModified().isEmpty() && smid.getRemoved().isEmpty()) {\n                                continue;\n                            }\n                            modified.add(subRepoPath);\n                            recordFileMode(subRepoPath, FileMode.GITLINK);\n                        }\n                    }\n                } finally {\n                    subRepo.close();\n                }\n            }\n        }\n    }\n    if (monitor != null)\n        monitor.endTask();\n    ignored = indexDiffFilter.getIgnoredPaths();\n    if (added.isEmpty() && changed.isEmpty() && removed.isEmpty() && missing.isEmpty() && modified.isEmpty() && untracked.isEmpty())\n        return false;\n    else\n        return true;\n}"
    },
    {
      "commit": "8a6af368c4129ef35520ec72cc9f55a3f685bfb8",
      "startLine": 13,
      "endLine": 20,
      "methodCode": "public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n    dirCache = repository.readDirCache();\n    try (TreeWalk treeWalk = new TreeWalk(repository)) {\n        treeWalk.setOperationType(OperationType.CHECKIN_OP);\n        treeWalk.setRecursive(true);\n        if (tree != null)\n            treeWalk.addTree(tree);\n        else\n            treeWalk.addTree(new EmptyTreeIterator());\n        treeWalk.addTree(new DirCacheIterator(dirCache));\n        treeWalk.addTree(initialWorkingTreeIterator);\n        initialWorkingTreeIterator.setDirCacheIterator(treeWalk, 1);\n        Collection<TreeFilter> filters = new ArrayList<>(4);\n        if (monitor != null) {\n            if (estIndexSize == 0)\n                estIndexSize = dirCache.getEntryCount();\n            int total = Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n            monitor.beginTask(title, total);\n            filters.add(new ProgressReportingFilter(monitor, total));\n        }\n        if (filter != null)\n            filters.add(filter);\n        filters.add(new SkipWorkTreeFilter(INDEX));\n        indexDiffFilter = new IndexDiffFilter(INDEX, WORKDIR);\n        filters.add(indexDiffFilter);\n        treeWalk.setFilter(AndTreeFilter.create(filters));\n        fileModes.clear();\n        while (treeWalk.next()) {\n            AbstractTreeIterator treeIterator = treeWalk.getTree(TREE, AbstractTreeIterator.class);\n            DirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX, DirCacheIterator.class);\n            WorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n            if (dirCacheIterator != null) {\n                final DirCacheEntry dirCacheEntry = dirCacheIterator.getDirCacheEntry();\n                if (dirCacheEntry != null) {\n                    int stage = dirCacheEntry.getStage();\n                    if (stage > 0) {\n                        String path = treeWalk.getPathString();\n                        addConflict(path, stage);\n                        continue;\n                    }\n                }\n            }\n            if (treeIterator != null) {\n                if (dirCacheIterator != null) {\n                    if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() != dirCacheIterator.getEntryRawMode()) {\n                        if (!isEntryGitLink(treeIterator) || !isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                            changed.add(treeWalk.getPathString());\n                    }\n                } else {\n                    if (!isEntryGitLink(treeIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                        removed.add(treeWalk.getPathString());\n                    if (workingTreeIterator != null)\n                        untracked.add(treeWalk.getPathString());\n                }\n            } else {\n                if (dirCacheIterator != null) {\n                    if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                        added.add(treeWalk.getPathString());\n                } else {\n                    if (workingTreeIterator != null && !workingTreeIterator.isEntryIgnored()) {\n                        untracked.add(treeWalk.getPathString());\n                    }\n                }\n            }\n            if (dirCacheIterator != null) {\n                if (workingTreeIterator == null) {\n                    if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                        missing.add(treeWalk.getPathString());\n                } else {\n                    if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true, treeWalk.getObjectReader())) {\n                        if (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator) || (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL && ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY))\n                            modified.add(treeWalk.getPathString());\n                    }\n                }\n            }\n            String path = treeWalk.getPathString();\n            if (path != null) {\n                for (int i = 0; i < treeWalk.getTreeCount(); i++) {\n                    recordFileMode(path, treeWalk.getFileMode(i));\n                }\n            }\n        }\n    }\n    if (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL) {\n        IgnoreSubmoduleMode localIgnoreSubmoduleMode = ignoreSubmoduleMode;\n        SubmoduleWalk smw = SubmoduleWalk.forIndex(repository);\n        while (smw.next()) {\n            try {\n                if (localIgnoreSubmoduleMode == null)\n                    localIgnoreSubmoduleMode = smw.getModulesIgnore();\n                if (IgnoreSubmoduleMode.ALL.equals(localIgnoreSubmoduleMode))\n                    continue;\n            } catch (ConfigInvalidException e) {\n                IOException e1 = new IOException(MessageFormat.format(JGitText.get().invalidIgnoreParamSubmodule, smw.getPath()));\n                e1.initCause(e);\n                throw e1;\n            }\n            Repository subRepo = smw.getRepository();\n            if (subRepo != null) {\n                String subRepoPath = smw.getPath();\n                try {\n                    ObjectId subHead = subRepo.resolve(\"HEAD\");\n                    if (subHead != null && !subHead.equals(smw.getObjectId())) {\n                        modified.add(subRepoPath);\n                        recordFileMode(subRepoPath, FileMode.GITLINK);\n                    } else if (ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY) {\n                        IndexDiff smid = submoduleIndexDiffs.get(smw.getPath());\n                        if (smid == null) {\n                            smid = new IndexDiff(subRepo, smw.getObjectId(), wTreeIt.getWorkingTreeIterator(subRepo));\n                            submoduleIndexDiffs.put(subRepoPath, smid);\n                        }\n                        if (smid.diff()) {\n                            if (ignoreSubmoduleMode == IgnoreSubmoduleMode.UNTRACKED && smid.getAdded().isEmpty() && smid.getChanged().isEmpty() && smid.getConflicting().isEmpty() && smid.getMissing().isEmpty() && smid.getModified().isEmpty() && smid.getRemoved().isEmpty()) {\n                                continue;\n                            }\n                            modified.add(subRepoPath);\n                            recordFileMode(subRepoPath, FileMode.GITLINK);\n                        }\n                    }\n                } finally {\n                    subRepo.close();\n                }\n            }\n        }\n    }\n    if (monitor != null)\n        monitor.endTask();\n    ignored = indexDiffFilter.getIgnoredPaths();\n    if (added.isEmpty() && changed.isEmpty() && removed.isEmpty() && missing.isEmpty() && modified.isEmpty() && untracked.isEmpty())\n        return false;\n    else\n        return true;\n}"
    },
    {
      "commit": "df3469f6ad81dccb314bf2d5021a3cec2b184985",
      "startLine": 13,
      "endLine": 20,
      "methodCode": "public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n    dirCache = repository.readDirCache();\n    try (TreeWalk treeWalk = new TreeWalk(repository)) {\n        treeWalk.setOperationType(OperationType.CHECKIN_OP);\n        treeWalk.setRecursive(true);\n        if (tree != null)\n            treeWalk.addTree(tree);\n        else\n            treeWalk.addTree(new EmptyTreeIterator());\n        treeWalk.addTree(new DirCacheIterator(dirCache));\n        treeWalk.addTree(initialWorkingTreeIterator);\n        initialWorkingTreeIterator.setDirCacheIterator(treeWalk, 1);\n        Collection<TreeFilter> filters = new ArrayList<>(4);\n        if (monitor != null) {\n            if (estIndexSize == 0)\n                estIndexSize = dirCache.getEntryCount();\n            int total = Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n            monitor.beginTask(title, total);\n            filters.add(new ProgressReportingFilter(monitor, total));\n        }\n        if (filter != null)\n            filters.add(filter);\n        filters.add(new SkipWorkTreeFilter(INDEX));\n        indexDiffFilter = new IndexDiffFilter(INDEX, WORKDIR);\n        filters.add(indexDiffFilter);\n        treeWalk.setFilter(AndTreeFilter.create(filters));\n        fileModes.clear();\n        while (treeWalk.next()) {\n            AbstractTreeIterator treeIterator = treeWalk.getTree(TREE, AbstractTreeIterator.class);\n            DirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX, DirCacheIterator.class);\n            WorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n            if (dirCacheIterator != null) {\n                final DirCacheEntry dirCacheEntry = dirCacheIterator.getDirCacheEntry();\n                if (dirCacheEntry != null) {\n                    int stage = dirCacheEntry.getStage();\n                    if (stage > 0) {\n                        String path = treeWalk.getPathString();\n                        addConflict(path, stage);\n                        continue;\n                    }\n                }\n            }\n            if (treeIterator != null) {\n                if (dirCacheIterator != null) {\n                    if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() != dirCacheIterator.getEntryRawMode()) {\n                        if (!isEntryGitLink(treeIterator) || !isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                            changed.add(treeWalk.getPathString());\n                    }\n                } else {\n                    if (!isEntryGitLink(treeIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                        removed.add(treeWalk.getPathString());\n                    if (workingTreeIterator != null)\n                        untracked.add(treeWalk.getPathString());\n                }\n            } else {\n                if (dirCacheIterator != null) {\n                    if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                        added.add(treeWalk.getPathString());\n                } else {\n                    if (workingTreeIterator != null && !workingTreeIterator.isEntryIgnored()) {\n                        untracked.add(treeWalk.getPathString());\n                    }\n                }\n            }\n            if (dirCacheIterator != null) {\n                if (workingTreeIterator == null) {\n                    if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                        missing.add(treeWalk.getPathString());\n                } else {\n                    if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true, treeWalk.getObjectReader())) {\n                        if (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator) || (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL && ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY))\n                            modified.add(treeWalk.getPathString());\n                    }\n                }\n            }\n            String path = treeWalk.getPathString();\n            if (path != null) {\n                for (int i = 0; i < treeWalk.getTreeCount(); i++) {\n                    recordFileMode(path, treeWalk.getFileMode(i));\n                }\n            }\n        }\n    }\n    if (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL) {\n        IgnoreSubmoduleMode localIgnoreSubmoduleMode = ignoreSubmoduleMode;\n        SubmoduleWalk smw = SubmoduleWalk.forIndex(repository);\n        while (smw.next()) {\n            try {\n                if (localIgnoreSubmoduleMode == null)\n                    localIgnoreSubmoduleMode = smw.getModulesIgnore();\n                if (IgnoreSubmoduleMode.ALL.equals(localIgnoreSubmoduleMode))\n                    continue;\n            } catch (ConfigInvalidException e) {\n                IOException e1 = new IOException(MessageFormat.format(JGitText.get().invalidIgnoreParamSubmodule, smw.getPath()));\n                e1.initCause(e);\n                throw e1;\n            }\n            Repository subRepo = smw.getRepository();\n            if (subRepo != null) {\n                String subRepoPath = smw.getPath();\n                try {\n                    ObjectId subHead = subRepo.resolve(\"HEAD\");\n                    if (subHead != null && !subHead.equals(smw.getObjectId())) {\n                        modified.add(subRepoPath);\n                        recordFileMode(subRepoPath, FileMode.GITLINK);\n                    } else if (ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY) {\n                        IndexDiff smid = submoduleIndexDiffs.get(smw.getPath());\n                        if (smid == null) {\n                            smid = new IndexDiff(subRepo, smw.getObjectId(), wTreeIt.getWorkingTreeIterator(subRepo));\n                            submoduleIndexDiffs.put(subRepoPath, smid);\n                        }\n                        if (smid.diff()) {\n                            if (ignoreSubmoduleMode == IgnoreSubmoduleMode.UNTRACKED && smid.getAdded().isEmpty() && smid.getChanged().isEmpty() && smid.getConflicting().isEmpty() && smid.getMissing().isEmpty() && smid.getModified().isEmpty() && smid.getRemoved().isEmpty()) {\n                                continue;\n                            }\n                            modified.add(subRepoPath);\n                            recordFileMode(subRepoPath, FileMode.GITLINK);\n                        }\n                    }\n                } finally {\n                    subRepo.close();\n                }\n            }\n        }\n    }\n    if (monitor != null)\n        monitor.endTask();\n    ignored = indexDiffFilter.getIgnoredPaths();\n    if (added.isEmpty() && changed.isEmpty() && removed.isEmpty() && missing.isEmpty() && modified.isEmpty() && untracked.isEmpty())\n        return false;\n    else\n        return true;\n}"
    },
    {
      "commit": "3b4448637fbb9d74e0c9d44048ba76bb7c1214ce",
      "startLine": 13,
      "endLine": 20,
      "methodCode": "public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n    dirCache = repository.readDirCache();\n    try (TreeWalk treeWalk = new TreeWalk(repository)) {\n        treeWalk.setOperationType(OperationType.CHECKIN_OP);\n        treeWalk.setRecursive(true);\n        if (tree != null)\n            treeWalk.addTree(tree);\n        else\n            treeWalk.addTree(new EmptyTreeIterator());\n        treeWalk.addTree(new DirCacheIterator(dirCache));\n        treeWalk.addTree(initialWorkingTreeIterator);\n        initialWorkingTreeIterator.setDirCacheIterator(treeWalk, 1);\n        Collection<TreeFilter> filters = new ArrayList<>(4);\n        if (monitor != null) {\n            if (estIndexSize == 0)\n                estIndexSize = dirCache.getEntryCount();\n            int total = Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n            monitor.beginTask(title, total);\n            filters.add(new ProgressReportingFilter(monitor, total));\n        }\n        if (filter != null)\n            filters.add(filter);\n        filters.add(new SkipWorkTreeFilter(INDEX));\n        indexDiffFilter = new IndexDiffFilter(INDEX, WORKDIR);\n        filters.add(indexDiffFilter);\n        treeWalk.setFilter(AndTreeFilter.create(filters));\n        fileModes.clear();\n        while (treeWalk.next()) {\n            AbstractTreeIterator treeIterator = treeWalk.getTree(TREE, AbstractTreeIterator.class);\n            DirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX, DirCacheIterator.class);\n            WorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n            if (dirCacheIterator != null) {\n                final DirCacheEntry dirCacheEntry = dirCacheIterator.getDirCacheEntry();\n                if (dirCacheEntry != null) {\n                    int stage = dirCacheEntry.getStage();\n                    if (stage > 0) {\n                        String path = treeWalk.getPathString();\n                        addConflict(path, stage);\n                        continue;\n                    }\n                }\n            }\n            if (treeIterator != null) {\n                if (dirCacheIterator != null) {\n                    if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() != dirCacheIterator.getEntryRawMode()) {\n                        if (!isEntryGitLink(treeIterator) || !isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                            changed.add(treeWalk.getPathString());\n                    }\n                } else {\n                    if (!isEntryGitLink(treeIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                        removed.add(treeWalk.getPathString());\n                    if (workingTreeIterator != null)\n                        untracked.add(treeWalk.getPathString());\n                }\n            } else {\n                if (dirCacheIterator != null) {\n                    if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                        added.add(treeWalk.getPathString());\n                } else {\n                    if (workingTreeIterator != null && !workingTreeIterator.isEntryIgnored()) {\n                        untracked.add(treeWalk.getPathString());\n                    }\n                }\n            }\n            if (dirCacheIterator != null) {\n                if (workingTreeIterator == null) {\n                    if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                        missing.add(treeWalk.getPathString());\n                } else {\n                    if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true, treeWalk.getObjectReader())) {\n                        if (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator) || (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL && ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY))\n                            modified.add(treeWalk.getPathString());\n                    }\n                }\n            }\n            for (int i = 0; i < treeWalk.getTreeCount(); i++) {\n                Set<String> values = fileModes.get(treeWalk.getFileMode(i));\n                String path = treeWalk.getPathString();\n                if (path != null) {\n                    if (values == null)\n                        values = new HashSet<>();\n                    values.add(path);\n                    fileModes.put(treeWalk.getFileMode(i), values);\n                }\n            }\n        }\n    }\n    if (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL) {\n        IgnoreSubmoduleMode localIgnoreSubmoduleMode = ignoreSubmoduleMode;\n        SubmoduleWalk smw = SubmoduleWalk.forIndex(repository);\n        while (smw.next()) {\n            try {\n                if (localIgnoreSubmoduleMode == null)\n                    localIgnoreSubmoduleMode = smw.getModulesIgnore();\n                if (IgnoreSubmoduleMode.ALL.equals(localIgnoreSubmoduleMode))\n                    continue;\n            } catch (ConfigInvalidException e) {\n                IOException e1 = new IOException(MessageFormat.format(JGitText.get().invalidIgnoreParamSubmodule, smw.getPath()));\n                e1.initCause(e);\n                throw e1;\n            }\n            Repository subRepo = smw.getRepository();\n            if (subRepo != null) {\n                try {\n                    ObjectId subHead = subRepo.resolve(\"HEAD\");\n                    if (subHead != null && !subHead.equals(smw.getObjectId()))\n                        modified.add(smw.getPath());\n                    else if (ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY) {\n                        IndexDiff smid = submoduleIndexDiffs.get(smw.getPath());\n                        if (smid == null) {\n                            smid = new IndexDiff(subRepo, smw.getObjectId(), wTreeIt.getWorkingTreeIterator(subRepo));\n                            submoduleIndexDiffs.put(smw.getPath(), smid);\n                        }\n                        if (smid.diff()) {\n                            if (ignoreSubmoduleMode == IgnoreSubmoduleMode.UNTRACKED && smid.getAdded().isEmpty() && smid.getChanged().isEmpty() && smid.getConflicting().isEmpty() && smid.getMissing().isEmpty() && smid.getModified().isEmpty() && smid.getRemoved().isEmpty()) {\n                                continue;\n                            }\n                            modified.add(smw.getPath());\n                        }\n                    }\n                } finally {\n                    subRepo.close();\n                }\n            }\n        }\n    }\n    if (monitor != null)\n        monitor.endTask();\n    ignored = indexDiffFilter.getIgnoredPaths();\n    if (added.isEmpty() && changed.isEmpty() && removed.isEmpty() && missing.isEmpty() && modified.isEmpty() && untracked.isEmpty())\n        return false;\n    else\n        return true;\n}"
    },
    {
      "commit": "5d9f595eb87fba31c2253051102116fc7876e6c0",
      "startLine": 13,
      "endLine": 20,
      "methodCode": "public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n    dirCache = repository.readDirCache();\n    try (TreeWalk treeWalk = new TreeWalk(repository)) {\n        treeWalk.setOperationType(OperationType.CHECKIN_OP);\n        treeWalk.setRecursive(true);\n        if (tree != null)\n            treeWalk.addTree(tree);\n        else\n            treeWalk.addTree(new EmptyTreeIterator());\n        treeWalk.addTree(new DirCacheIterator(dirCache));\n        treeWalk.addTree(initialWorkingTreeIterator);\n        initialWorkingTreeIterator.setDirCacheIterator(treeWalk, 1);\n        Collection<TreeFilter> filters = new ArrayList<TreeFilter>(4);\n        if (monitor != null) {\n            if (estIndexSize == 0)\n                estIndexSize = dirCache.getEntryCount();\n            int total = Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n            monitor.beginTask(title, total);\n            filters.add(new ProgressReportingFilter(monitor, total));\n        }\n        if (filter != null)\n            filters.add(filter);\n        filters.add(new SkipWorkTreeFilter(INDEX));\n        indexDiffFilter = new IndexDiffFilter(INDEX, WORKDIR);\n        filters.add(indexDiffFilter);\n        treeWalk.setFilter(AndTreeFilter.create(filters));\n        fileModes.clear();\n        while (treeWalk.next()) {\n            AbstractTreeIterator treeIterator = treeWalk.getTree(TREE, AbstractTreeIterator.class);\n            DirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX, DirCacheIterator.class);\n            WorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n            if (dirCacheIterator != null) {\n                final DirCacheEntry dirCacheEntry = dirCacheIterator.getDirCacheEntry();\n                if (dirCacheEntry != null) {\n                    int stage = dirCacheEntry.getStage();\n                    if (stage > 0) {\n                        String path = treeWalk.getPathString();\n                        addConflict(path, stage);\n                        continue;\n                    }\n                }\n            }\n            if (treeIterator != null) {\n                if (dirCacheIterator != null) {\n                    if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() != dirCacheIterator.getEntryRawMode()) {\n                        if (!isEntryGitLink(treeIterator) || !isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                            changed.add(treeWalk.getPathString());\n                    }\n                } else {\n                    if (!isEntryGitLink(treeIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                        removed.add(treeWalk.getPathString());\n                    if (workingTreeIterator != null)\n                        untracked.add(treeWalk.getPathString());\n                }\n            } else {\n                if (dirCacheIterator != null) {\n                    if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                        added.add(treeWalk.getPathString());\n                } else {\n                    if (workingTreeIterator != null && !workingTreeIterator.isEntryIgnored()) {\n                        untracked.add(treeWalk.getPathString());\n                    }\n                }\n            }\n            if (dirCacheIterator != null) {\n                if (workingTreeIterator == null) {\n                    if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                        missing.add(treeWalk.getPathString());\n                } else {\n                    if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true, treeWalk.getObjectReader())) {\n                        if (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator) || (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL && ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY))\n                            modified.add(treeWalk.getPathString());\n                    }\n                }\n            }\n            for (int i = 0; i < treeWalk.getTreeCount(); i++) {\n                Set<String> values = fileModes.get(treeWalk.getFileMode(i));\n                String path = treeWalk.getPathString();\n                if (path != null) {\n                    if (values == null)\n                        values = new HashSet<String>();\n                    values.add(path);\n                    fileModes.put(treeWalk.getFileMode(i), values);\n                }\n            }\n        }\n    }\n    if (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL) {\n        IgnoreSubmoduleMode localIgnoreSubmoduleMode = ignoreSubmoduleMode;\n        SubmoduleWalk smw = SubmoduleWalk.forIndex(repository);\n        while (smw.next()) {\n            try {\n                if (localIgnoreSubmoduleMode == null)\n                    localIgnoreSubmoduleMode = smw.getModulesIgnore();\n                if (IgnoreSubmoduleMode.ALL.equals(localIgnoreSubmoduleMode))\n                    continue;\n            } catch (ConfigInvalidException e) {\n                IOException e1 = new IOException(MessageFormat.format(JGitText.get().invalidIgnoreParamSubmodule, smw.getPath()));\n                e1.initCause(e);\n                throw e1;\n            }\n            Repository subRepo = smw.getRepository();\n            if (subRepo != null) {\n                try {\n                    ObjectId subHead = subRepo.resolve(\"HEAD\");\n                    if (subHead != null && !subHead.equals(smw.getObjectId()))\n                        modified.add(smw.getPath());\n                    else if (ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY) {\n                        IndexDiff smid = submoduleIndexDiffs.get(smw.getPath());\n                        if (smid == null) {\n                            smid = new IndexDiff(subRepo, smw.getObjectId(), wTreeIt.getWorkingTreeIterator(subRepo));\n                            submoduleIndexDiffs.put(smw.getPath(), smid);\n                        }\n                        if (smid.diff()) {\n                            if (ignoreSubmoduleMode == IgnoreSubmoduleMode.UNTRACKED && smid.getAdded().isEmpty() && smid.getChanged().isEmpty() && smid.getConflicting().isEmpty() && smid.getMissing().isEmpty() && smid.getModified().isEmpty() && smid.getRemoved().isEmpty()) {\n                                continue;\n                            }\n                            modified.add(smw.getPath());\n                        }\n                    }\n                } finally {\n                    subRepo.close();\n                }\n            }\n        }\n    }\n    if (monitor != null)\n        monitor.endTask();\n    ignored = indexDiffFilter.getIgnoredPaths();\n    if (added.isEmpty() && changed.isEmpty() && removed.isEmpty() && missing.isEmpty() && modified.isEmpty() && untracked.isEmpty())\n        return false;\n    else\n        return true;\n}"
    },
    {
      "commit": "12280c02dbb8e4ac10893fbbd415be757afab4c1",
      "startLine": 12,
      "endLine": 19,
      "methodCode": "public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n    dirCache = repository.readDirCache();\n    try (TreeWalk treeWalk = new TreeWalk(repository)) {\n        treeWalk.setOperationType(OperationType.CHECKIN_OP);\n        treeWalk.setRecursive(true);\n        if (tree != null)\n            treeWalk.addTree(tree);\n        else\n            treeWalk.addTree(new EmptyTreeIterator());\n        treeWalk.addTree(new DirCacheIterator(dirCache));\n        treeWalk.addTree(initialWorkingTreeIterator);\n        Collection<TreeFilter> filters = new ArrayList<TreeFilter>(4);\n        if (monitor != null) {\n            if (estIndexSize == 0)\n                estIndexSize = dirCache.getEntryCount();\n            int total = Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n            monitor.beginTask(title, total);\n            filters.add(new ProgressReportingFilter(monitor, total));\n        }\n        if (filter != null)\n            filters.add(filter);\n        filters.add(new SkipWorkTreeFilter(INDEX));\n        indexDiffFilter = new IndexDiffFilter(INDEX, WORKDIR);\n        filters.add(indexDiffFilter);\n        treeWalk.setFilter(AndTreeFilter.create(filters));\n        fileModes.clear();\n        while (treeWalk.next()) {\n            AbstractTreeIterator treeIterator = treeWalk.getTree(TREE, AbstractTreeIterator.class);\n            DirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX, DirCacheIterator.class);\n            WorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n            if (dirCacheIterator != null) {\n                final DirCacheEntry dirCacheEntry = dirCacheIterator.getDirCacheEntry();\n                if (dirCacheEntry != null) {\n                    int stage = dirCacheEntry.getStage();\n                    if (stage > 0) {\n                        String path = treeWalk.getPathString();\n                        addConflict(path, stage);\n                        continue;\n                    }\n                }\n            }\n            if (treeIterator != null) {\n                if (dirCacheIterator != null) {\n                    if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() != dirCacheIterator.getEntryRawMode()) {\n                        if (!isEntryGitLink(treeIterator) || !isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                            changed.add(treeWalk.getPathString());\n                    }\n                } else {\n                    if (!isEntryGitLink(treeIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                        removed.add(treeWalk.getPathString());\n                    if (workingTreeIterator != null)\n                        untracked.add(treeWalk.getPathString());\n                }\n            } else {\n                if (dirCacheIterator != null) {\n                    if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                        added.add(treeWalk.getPathString());\n                } else {\n                    if (workingTreeIterator != null && !workingTreeIterator.isEntryIgnored()) {\n                        untracked.add(treeWalk.getPathString());\n                    }\n                }\n            }\n            if (dirCacheIterator != null) {\n                if (workingTreeIterator == null) {\n                    if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                        missing.add(treeWalk.getPathString());\n                } else {\n                    if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true, treeWalk.getObjectReader())) {\n                        if (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator) || (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL && ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY))\n                            modified.add(treeWalk.getPathString());\n                    }\n                }\n            }\n            for (int i = 0; i < treeWalk.getTreeCount(); i++) {\n                Set<String> values = fileModes.get(treeWalk.getFileMode(i));\n                String path = treeWalk.getPathString();\n                if (path != null) {\n                    if (values == null)\n                        values = new HashSet<String>();\n                    values.add(path);\n                    fileModes.put(treeWalk.getFileMode(i), values);\n                }\n            }\n        }\n    }\n    if (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL) {\n        IgnoreSubmoduleMode localIgnoreSubmoduleMode = ignoreSubmoduleMode;\n        SubmoduleWalk smw = SubmoduleWalk.forIndex(repository);\n        while (smw.next()) {\n            try {\n                if (localIgnoreSubmoduleMode == null)\n                    localIgnoreSubmoduleMode = smw.getModulesIgnore();\n                if (IgnoreSubmoduleMode.ALL.equals(localIgnoreSubmoduleMode))\n                    continue;\n            } catch (ConfigInvalidException e) {\n                IOException e1 = new IOException(MessageFormat.format(JGitText.get().invalidIgnoreParamSubmodule, smw.getPath()));\n                e1.initCause(e);\n                throw e1;\n            }\n            Repository subRepo = smw.getRepository();\n            if (subRepo != null) {\n                try {\n                    ObjectId subHead = subRepo.resolve(\"HEAD\");\n                    if (subHead != null && !subHead.equals(smw.getObjectId()))\n                        modified.add(smw.getPath());\n                    else if (ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY) {\n                        IndexDiff smid = submoduleIndexDiffs.get(smw.getPath());\n                        if (smid == null) {\n                            smid = new IndexDiff(subRepo, smw.getObjectId(), wTreeIt.getWorkingTreeIterator(subRepo));\n                            submoduleIndexDiffs.put(smw.getPath(), smid);\n                        }\n                        if (smid.diff()) {\n                            if (ignoreSubmoduleMode == IgnoreSubmoduleMode.UNTRACKED && smid.getAdded().isEmpty() && smid.getChanged().isEmpty() && smid.getConflicting().isEmpty() && smid.getMissing().isEmpty() && smid.getModified().isEmpty() && smid.getRemoved().isEmpty()) {\n                                continue;\n                            }\n                            modified.add(smw.getPath());\n                        }\n                    }\n                } finally {\n                    subRepo.close();\n                }\n            }\n        }\n    }\n    if (monitor != null)\n        monitor.endTask();\n    ignored = indexDiffFilter.getIgnoredPaths();\n    if (added.isEmpty() && changed.isEmpty() && removed.isEmpty() && missing.isEmpty() && modified.isEmpty() && untracked.isEmpty())\n        return false;\n    else\n        return true;\n}"
    },
    {
      "commit": "2390531888af6dc9e4fda6cb026271dc068c40ab",
      "startLine": 11,
      "endLine": 18,
      "methodCode": "public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n    dirCache = repository.readDirCache();\n    try (TreeWalk treeWalk = new TreeWalk(repository)) {\n        treeWalk.setRecursive(true);\n        if (tree != null)\n            treeWalk.addTree(tree);\n        else\n            treeWalk.addTree(new EmptyTreeIterator());\n        treeWalk.addTree(new DirCacheIterator(dirCache));\n        treeWalk.addTree(initialWorkingTreeIterator);\n        Collection<TreeFilter> filters = new ArrayList<TreeFilter>(4);\n        if (monitor != null) {\n            if (estIndexSize == 0)\n                estIndexSize = dirCache.getEntryCount();\n            int total = Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n            monitor.beginTask(title, total);\n            filters.add(new ProgressReportingFilter(monitor, total));\n        }\n        if (filter != null)\n            filters.add(filter);\n        filters.add(new SkipWorkTreeFilter(INDEX));\n        indexDiffFilter = new IndexDiffFilter(INDEX, WORKDIR);\n        filters.add(indexDiffFilter);\n        treeWalk.setFilter(AndTreeFilter.create(filters));\n        fileModes.clear();\n        while (treeWalk.next()) {\n            AbstractTreeIterator treeIterator = treeWalk.getTree(TREE, AbstractTreeIterator.class);\n            DirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX, DirCacheIterator.class);\n            WorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n            if (dirCacheIterator != null) {\n                final DirCacheEntry dirCacheEntry = dirCacheIterator.getDirCacheEntry();\n                if (dirCacheEntry != null) {\n                    int stage = dirCacheEntry.getStage();\n                    if (stage > 0) {\n                        String path = treeWalk.getPathString();\n                        addConflict(path, stage);\n                        continue;\n                    }\n                }\n            }\n            if (treeIterator != null) {\n                if (dirCacheIterator != null) {\n                    if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() != dirCacheIterator.getEntryRawMode()) {\n                        if (!isEntryGitLink(treeIterator) || !isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                            changed.add(treeWalk.getPathString());\n                    }\n                } else {\n                    if (!isEntryGitLink(treeIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                        removed.add(treeWalk.getPathString());\n                    if (workingTreeIterator != null)\n                        untracked.add(treeWalk.getPathString());\n                }\n            } else {\n                if (dirCacheIterator != null) {\n                    if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                        added.add(treeWalk.getPathString());\n                } else {\n                    if (workingTreeIterator != null && !workingTreeIterator.isEntryIgnored()) {\n                        untracked.add(treeWalk.getPathString());\n                    }\n                }\n            }\n            if (dirCacheIterator != null) {\n                if (workingTreeIterator == null) {\n                    if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                        missing.add(treeWalk.getPathString());\n                } else {\n                    if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true, treeWalk.getObjectReader())) {\n                        if (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator) || (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL && ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY))\n                            modified.add(treeWalk.getPathString());\n                    }\n                }\n            }\n            for (int i = 0; i < treeWalk.getTreeCount(); i++) {\n                Set<String> values = fileModes.get(treeWalk.getFileMode(i));\n                String path = treeWalk.getPathString();\n                if (path != null) {\n                    if (values == null)\n                        values = new HashSet<String>();\n                    values.add(path);\n                    fileModes.put(treeWalk.getFileMode(i), values);\n                }\n            }\n        }\n    }\n    if (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL) {\n        IgnoreSubmoduleMode localIgnoreSubmoduleMode = ignoreSubmoduleMode;\n        SubmoduleWalk smw = SubmoduleWalk.forIndex(repository);\n        while (smw.next()) {\n            try {\n                if (localIgnoreSubmoduleMode == null)\n                    localIgnoreSubmoduleMode = smw.getModulesIgnore();\n                if (IgnoreSubmoduleMode.ALL.equals(localIgnoreSubmoduleMode))\n                    continue;\n            } catch (ConfigInvalidException e) {\n                IOException e1 = new IOException(MessageFormat.format(JGitText.get().invalidIgnoreParamSubmodule, smw.getPath()));\n                e1.initCause(e);\n                throw e1;\n            }\n            Repository subRepo = smw.getRepository();\n            if (subRepo != null) {\n                try {\n                    ObjectId subHead = subRepo.resolve(\"HEAD\");\n                    if (subHead != null && !subHead.equals(smw.getObjectId()))\n                        modified.add(smw.getPath());\n                    else if (ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY) {\n                        IndexDiff smid = submoduleIndexDiffs.get(smw.getPath());\n                        if (smid == null) {\n                            smid = new IndexDiff(subRepo, smw.getObjectId(), wTreeIt.getWorkingTreeIterator(subRepo));\n                            submoduleIndexDiffs.put(smw.getPath(), smid);\n                        }\n                        if (smid.diff()) {\n                            if (ignoreSubmoduleMode == IgnoreSubmoduleMode.UNTRACKED && smid.getAdded().isEmpty() && smid.getChanged().isEmpty() && smid.getConflicting().isEmpty() && smid.getMissing().isEmpty() && smid.getModified().isEmpty() && smid.getRemoved().isEmpty()) {\n                                continue;\n                            }\n                            modified.add(smw.getPath());\n                        }\n                    }\n                } finally {\n                    subRepo.close();\n                }\n            }\n        }\n    }\n    if (monitor != null)\n        monitor.endTask();\n    ignored = indexDiffFilter.getIgnoredPaths();\n    if (added.isEmpty() && changed.isEmpty() && removed.isEmpty() && missing.isEmpty() && modified.isEmpty() && untracked.isEmpty())\n        return false;\n    else\n        return true;\n}"
    },
    {
      "commit": "0e73d395061d1bfee365acaa2f79c392175d13bf",
      "startLine": 11,
      "endLine": 18,
      "methodCode": "public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n    dirCache = repository.readDirCache();\n    try (TreeWalk treeWalk = new TreeWalk(repository)) {\n        treeWalk.setRecursive(true);\n        if (tree != null)\n            treeWalk.addTree(tree);\n        else\n            treeWalk.addTree(new EmptyTreeIterator());\n        treeWalk.addTree(new DirCacheIterator(dirCache));\n        treeWalk.addTree(initialWorkingTreeIterator);\n        Collection<TreeFilter> filters = new ArrayList<TreeFilter>(4);\n        if (monitor != null) {\n            if (estIndexSize == 0)\n                estIndexSize = dirCache.getEntryCount();\n            int total = Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n            monitor.beginTask(title, total);\n            filters.add(new ProgressReportingFilter(monitor, total));\n        }\n        if (filter != null)\n            filters.add(filter);\n        filters.add(new SkipWorkTreeFilter(INDEX));\n        indexDiffFilter = new IndexDiffFilter(INDEX, WORKDIR);\n        filters.add(indexDiffFilter);\n        treeWalk.setFilter(AndTreeFilter.create(filters));\n        fileModes.clear();\n        while (treeWalk.next()) {\n            AbstractTreeIterator treeIterator = treeWalk.getTree(TREE, AbstractTreeIterator.class);\n            DirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX, DirCacheIterator.class);\n            WorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n            if (dirCacheIterator != null) {\n                final DirCacheEntry dirCacheEntry = dirCacheIterator.getDirCacheEntry();\n                if (dirCacheEntry != null) {\n                    int stage = dirCacheEntry.getStage();\n                    if (stage > 0) {\n                        String path = treeWalk.getPathString();\n                        addConflict(path, stage);\n                        continue;\n                    }\n                }\n            }\n            if (treeIterator != null) {\n                if (dirCacheIterator != null) {\n                    if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() != dirCacheIterator.getEntryRawMode()) {\n                        if (!isEntryGitLink(treeIterator) || !isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                            changed.add(treeWalk.getPathString());\n                    }\n                } else {\n                    if (!isEntryGitLink(treeIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                        removed.add(treeWalk.getPathString());\n                    if (workingTreeIterator != null)\n                        untracked.add(treeWalk.getPathString());\n                }\n            } else {\n                if (dirCacheIterator != null) {\n                    if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                        added.add(treeWalk.getPathString());\n                } else {\n                    if (workingTreeIterator != null && !workingTreeIterator.isEntryIgnored()) {\n                        untracked.add(treeWalk.getPathString());\n                    }\n                }\n            }\n            if (dirCacheIterator != null) {\n                if (workingTreeIterator == null) {\n                    if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                        missing.add(treeWalk.getPathString());\n                } else {\n                    if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true, treeWalk.getObjectReader())) {\n                        if (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator) || (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL && ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY))\n                            modified.add(treeWalk.getPathString());\n                    }\n                }\n            }\n            for (int i = 0; i < treeWalk.getTreeCount(); i++) {\n                Set<String> values = fileModes.get(treeWalk.getFileMode(i));\n                String path = treeWalk.getPathString();\n                if (path != null) {\n                    if (values == null)\n                        values = new HashSet<String>();\n                    values.add(path);\n                    fileModes.put(treeWalk.getFileMode(i), values);\n                }\n            }\n        }\n    }\n    if (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL) {\n        IgnoreSubmoduleMode localIgnoreSubmoduleMode = ignoreSubmoduleMode;\n        SubmoduleWalk smw = SubmoduleWalk.forIndex(repository);\n        while (smw.next()) {\n            try {\n                if (localIgnoreSubmoduleMode == null)\n                    localIgnoreSubmoduleMode = smw.getModulesIgnore();\n                if (IgnoreSubmoduleMode.ALL.equals(localIgnoreSubmoduleMode))\n                    continue;\n            } catch (ConfigInvalidException e) {\n                IOException e1 = new IOException(\"Found invalid ignore param for submodule \" + smw.getPath());\n                e1.initCause(e);\n                throw e1;\n            }\n            Repository subRepo = smw.getRepository();\n            if (subRepo != null) {\n                try {\n                    ObjectId subHead = subRepo.resolve(\"HEAD\");\n                    if (subHead != null && !subHead.equals(smw.getObjectId()))\n                        modified.add(smw.getPath());\n                    else if (ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY) {\n                        IndexDiff smid = submoduleIndexDiffs.get(smw.getPath());\n                        if (smid == null) {\n                            smid = new IndexDiff(subRepo, smw.getObjectId(), wTreeIt.getWorkingTreeIterator(subRepo));\n                            submoduleIndexDiffs.put(smw.getPath(), smid);\n                        }\n                        if (smid.diff()) {\n                            if (ignoreSubmoduleMode == IgnoreSubmoduleMode.UNTRACKED && smid.getAdded().isEmpty() && smid.getChanged().isEmpty() && smid.getConflicting().isEmpty() && smid.getMissing().isEmpty() && smid.getModified().isEmpty() && smid.getRemoved().isEmpty()) {\n                                continue;\n                            }\n                            modified.add(smw.getPath());\n                        }\n                    }\n                } finally {\n                    subRepo.close();\n                }\n            }\n        }\n    }\n    if (monitor != null)\n        monitor.endTask();\n    ignored = indexDiffFilter.getIgnoredPaths();\n    if (added.isEmpty() && changed.isEmpty() && removed.isEmpty() && missing.isEmpty() && modified.isEmpty() && untracked.isEmpty())\n        return false;\n    else\n        return true;\n}"
    },
    {
      "commit": "da595f093e5547a7da583fa0459400e47a2638c6",
      "startLine": 11,
      "endLine": 18,
      "methodCode": "public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n    dirCache = repository.readDirCache();\n    TreeWalk treeWalk = new TreeWalk(repository);\n    treeWalk.setRecursive(true);\n    if (tree != null)\n        treeWalk.addTree(tree);\n    else\n        treeWalk.addTree(new EmptyTreeIterator());\n    treeWalk.addTree(new DirCacheIterator(dirCache));\n    treeWalk.addTree(initialWorkingTreeIterator);\n    Collection<TreeFilter> filters = new ArrayList<TreeFilter>(4);\n    if (monitor != null) {\n        if (estIndexSize == 0)\n            estIndexSize = dirCache.getEntryCount();\n        int total = Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n        monitor.beginTask(title, total);\n        filters.add(new ProgressReportingFilter(monitor, total));\n    }\n    if (filter != null)\n        filters.add(filter);\n    filters.add(new SkipWorkTreeFilter(INDEX));\n    indexDiffFilter = new IndexDiffFilter(INDEX, WORKDIR);\n    filters.add(indexDiffFilter);\n    treeWalk.setFilter(AndTreeFilter.create(filters));\n    fileModes.clear();\n    while (treeWalk.next()) {\n        AbstractTreeIterator treeIterator = treeWalk.getTree(TREE, AbstractTreeIterator.class);\n        DirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX, DirCacheIterator.class);\n        WorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n        if (dirCacheIterator != null) {\n            final DirCacheEntry dirCacheEntry = dirCacheIterator.getDirCacheEntry();\n            if (dirCacheEntry != null) {\n                int stage = dirCacheEntry.getStage();\n                if (stage > 0) {\n                    String path = treeWalk.getPathString();\n                    addConflict(path, stage);\n                    continue;\n                }\n            }\n        }\n        if (treeIterator != null) {\n            if (dirCacheIterator != null) {\n                if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() != dirCacheIterator.getEntryRawMode()) {\n                    if (!isEntryGitLink(treeIterator) || !isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                        changed.add(treeWalk.getPathString());\n                }\n            } else {\n                if (!isEntryGitLink(treeIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                    removed.add(treeWalk.getPathString());\n                if (workingTreeIterator != null)\n                    untracked.add(treeWalk.getPathString());\n            }\n        } else {\n            if (dirCacheIterator != null) {\n                if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                    added.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator != null && !workingTreeIterator.isEntryIgnored()) {\n                    untracked.add(treeWalk.getPathString());\n                }\n            }\n        }\n        if (dirCacheIterator != null) {\n            if (workingTreeIterator == null) {\n                if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                    missing.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true, treeWalk.getObjectReader())) {\n                    if (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator) || (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL && ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY))\n                        modified.add(treeWalk.getPathString());\n                }\n            }\n        }\n        for (int i = 0; i < treeWalk.getTreeCount(); i++) {\n            Set<String> values = fileModes.get(treeWalk.getFileMode(i));\n            String path = treeWalk.getPathString();\n            if (path != null) {\n                if (values == null)\n                    values = new HashSet<String>();\n                values.add(path);\n                fileModes.put(treeWalk.getFileMode(i), values);\n            }\n        }\n    }\n    if (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL) {\n        IgnoreSubmoduleMode localIgnoreSubmoduleMode = ignoreSubmoduleMode;\n        SubmoduleWalk smw = SubmoduleWalk.forIndex(repository);\n        while (smw.next()) {\n            try {\n                if (localIgnoreSubmoduleMode == null)\n                    localIgnoreSubmoduleMode = smw.getModulesIgnore();\n                if (IgnoreSubmoduleMode.ALL.equals(localIgnoreSubmoduleMode))\n                    continue;\n            } catch (ConfigInvalidException e) {\n                IOException e1 = new IOException(\"Found invalid ignore param for submodule \" + smw.getPath());\n                e1.initCause(e);\n                throw e1;\n            }\n            Repository subRepo = smw.getRepository();\n            if (subRepo != null) {\n                try {\n                    ObjectId subHead = subRepo.resolve(\"HEAD\");\n                    if (subHead != null && !subHead.equals(smw.getObjectId()))\n                        modified.add(smw.getPath());\n                    else if (ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY) {\n                        IndexDiff smid = submoduleIndexDiffs.get(smw.getPath());\n                        if (smid == null) {\n                            smid = new IndexDiff(subRepo, smw.getObjectId(), wTreeIt.getWorkingTreeIterator(subRepo));\n                            submoduleIndexDiffs.put(smw.getPath(), smid);\n                        }\n                        if (smid.diff()) {\n                            if (ignoreSubmoduleMode == IgnoreSubmoduleMode.UNTRACKED && smid.getAdded().isEmpty() && smid.getChanged().isEmpty() && smid.getConflicting().isEmpty() && smid.getMissing().isEmpty() && smid.getModified().isEmpty() && smid.getRemoved().isEmpty()) {\n                                continue;\n                            }\n                            modified.add(smw.getPath());\n                        }\n                    }\n                } finally {\n                    subRepo.close();\n                }\n            }\n        }\n    }\n    if (monitor != null)\n        monitor.endTask();\n    ignored = indexDiffFilter.getIgnoredPaths();\n    if (added.isEmpty() && changed.isEmpty() && removed.isEmpty() && missing.isEmpty() && modified.isEmpty() && untracked.isEmpty())\n        return false;\n    else\n        return true;\n}"
    },
    {
      "commit": "9597c41ea9db20d769f7b8c54eafa207824e5bd6",
      "startLine": 11,
      "endLine": 18,
      "methodCode": "public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n    dirCache = repository.readDirCache();\n    TreeWalk treeWalk = new TreeWalk(repository);\n    treeWalk.setRecursive(true);\n    if (tree != null)\n        treeWalk.addTree(tree);\n    else\n        treeWalk.addTree(new EmptyTreeIterator());\n    treeWalk.addTree(new DirCacheIterator(dirCache));\n    treeWalk.addTree(initialWorkingTreeIterator);\n    Collection<TreeFilter> filters = new ArrayList<TreeFilter>(4);\n    if (monitor != null) {\n        if (estIndexSize == 0)\n            estIndexSize = dirCache.getEntryCount();\n        int total = Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n        monitor.beginTask(title, total);\n        filters.add(new ProgressReportingFilter(monitor, total));\n    }\n    if (filter != null)\n        filters.add(filter);\n    filters.add(new SkipWorkTreeFilter(INDEX));\n    indexDiffFilter = new IndexDiffFilter(INDEX, WORKDIR);\n    filters.add(indexDiffFilter);\n    treeWalk.setFilter(AndTreeFilter.create(filters));\n    fileModes.clear();\n    while (treeWalk.next()) {\n        AbstractTreeIterator treeIterator = treeWalk.getTree(TREE, AbstractTreeIterator.class);\n        DirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX, DirCacheIterator.class);\n        WorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n        if (dirCacheIterator != null) {\n            final DirCacheEntry dirCacheEntry = dirCacheIterator.getDirCacheEntry();\n            if (dirCacheEntry != null) {\n                int stage = dirCacheEntry.getStage();\n                if (stage > 0) {\n                    String path = treeWalk.getPathString();\n                    addConflict(path, stage);\n                    continue;\n                }\n            }\n        }\n        if (treeIterator != null) {\n            if (dirCacheIterator != null) {\n                if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() != dirCacheIterator.getEntryRawMode()) {\n                    if (!isEntryGitLink(treeIterator) || !isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                        changed.add(treeWalk.getPathString());\n                }\n            } else {\n                if (!isEntryGitLink(treeIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                    removed.add(treeWalk.getPathString());\n                if (workingTreeIterator != null)\n                    untracked.add(treeWalk.getPathString());\n            }\n        } else {\n            if (dirCacheIterator != null) {\n                if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                    added.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator != null && !workingTreeIterator.isEntryIgnored()) {\n                    untracked.add(treeWalk.getPathString());\n                }\n            }\n        }\n        if (dirCacheIterator != null) {\n            if (workingTreeIterator == null) {\n                if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                    missing.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true, treeWalk.getObjectReader())) {\n                    if (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator) || (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL && ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY))\n                        modified.add(treeWalk.getPathString());\n                }\n            }\n        }\n        for (int i = 0; i < treeWalk.getTreeCount(); i++) {\n            Set<String> values = fileModes.get(treeWalk.getFileMode(i));\n            String path = treeWalk.getPathString();\n            if (path != null) {\n                if (values == null)\n                    values = new HashSet<String>();\n                values.add(path);\n                fileModes.put(treeWalk.getFileMode(i), values);\n            }\n        }\n    }\n    if (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL) {\n        IgnoreSubmoduleMode localIgnoreSubmoduleMode = ignoreSubmoduleMode;\n        SubmoduleWalk smw = SubmoduleWalk.forIndex(repository);\n        while (smw.next()) {\n            try {\n                if (localIgnoreSubmoduleMode == null)\n                    localIgnoreSubmoduleMode = smw.getModulesIgnore();\n                if (IgnoreSubmoduleMode.ALL.equals(localIgnoreSubmoduleMode))\n                    continue;\n            } catch (ConfigInvalidException e) {\n                IOException e1 = new IOException(\"Found invalid ignore param for submodule \" + smw.getPath());\n                e1.initCause(e);\n                throw e1;\n            }\n            Repository subRepo = smw.getRepository();\n            if (subRepo != null) {\n                ObjectId subHead = subRepo.resolve(\"HEAD\");\n                if (subHead != null && !subHead.equals(smw.getObjectId()))\n                    modified.add(smw.getPath());\n                else if (ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY) {\n                    IndexDiff smid = submoduleIndexDiffs.get(smw.getPath());\n                    if (smid == null) {\n                        smid = new IndexDiff(subRepo, smw.getObjectId(), wTreeIt.getWorkingTreeIterator(subRepo));\n                        submoduleIndexDiffs.put(smw.getPath(), smid);\n                    }\n                    if (smid.diff()) {\n                        if (ignoreSubmoduleMode == IgnoreSubmoduleMode.UNTRACKED && smid.getAdded().isEmpty() && smid.getChanged().isEmpty() && smid.getConflicting().isEmpty() && smid.getMissing().isEmpty() && smid.getModified().isEmpty() && smid.getRemoved().isEmpty()) {\n                            continue;\n                        }\n                        modified.add(smw.getPath());\n                    }\n                }\n            }\n        }\n    }\n    if (monitor != null)\n        monitor.endTask();\n    ignored = indexDiffFilter.getIgnoredPaths();\n    if (added.isEmpty() && changed.isEmpty() && removed.isEmpty() && missing.isEmpty() && modified.isEmpty() && untracked.isEmpty())\n        return false;\n    else\n        return true;\n}"
    },
    {
      "commit": "abb57e6b5674b7251bd94b7238e5d995ad9c30c5",
      "startLine": 11,
      "endLine": 18,
      "methodCode": "public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n    dirCache = repository.readDirCache();\n    TreeWalk treeWalk = new TreeWalk(repository);\n    treeWalk.setRecursive(true);\n    if (tree != null)\n        treeWalk.addTree(tree);\n    else\n        treeWalk.addTree(new EmptyTreeIterator());\n    treeWalk.addTree(new DirCacheIterator(dirCache));\n    treeWalk.addTree(initialWorkingTreeIterator);\n    Collection<TreeFilter> filters = new ArrayList<TreeFilter>(4);\n    if (monitor != null) {\n        if (estIndexSize == 0)\n            estIndexSize = dirCache.getEntryCount();\n        int total = Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n        monitor.beginTask(title, total);\n        filters.add(new ProgressReportingFilter(monitor, total));\n    }\n    if (filter != null)\n        filters.add(filter);\n    filters.add(new SkipWorkTreeFilter(INDEX));\n    indexDiffFilter = new IndexDiffFilter(INDEX, WORKDIR);\n    filters.add(indexDiffFilter);\n    treeWalk.setFilter(AndTreeFilter.create(filters));\n    fileModes.clear();\n    while (treeWalk.next()) {\n        AbstractTreeIterator treeIterator = treeWalk.getTree(TREE, AbstractTreeIterator.class);\n        DirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX, DirCacheIterator.class);\n        WorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n        if (dirCacheIterator != null) {\n            final DirCacheEntry dirCacheEntry = dirCacheIterator.getDirCacheEntry();\n            if (dirCacheEntry != null) {\n                int stage = dirCacheEntry.getStage();\n                if (stage > 0) {\n                    String path = treeWalk.getPathString();\n                    addConflict(path, stage);\n                    continue;\n                }\n            }\n        }\n        if (treeIterator != null) {\n            if (dirCacheIterator != null) {\n                if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() != dirCacheIterator.getEntryRawMode()) {\n                    if (!isEntryGitLink(treeIterator) || !isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                        changed.add(treeWalk.getPathString());\n                }\n            } else {\n                if (!isEntryGitLink(treeIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                    removed.add(treeWalk.getPathString());\n                if (workingTreeIterator != null)\n                    untracked.add(treeWalk.getPathString());\n            }\n        } else {\n            if (dirCacheIterator != null) {\n                if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                    added.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator != null && !workingTreeIterator.isEntryIgnored()) {\n                    untracked.add(treeWalk.getPathString());\n                }\n            }\n        }\n        if (dirCacheIterator != null) {\n            if (workingTreeIterator == null) {\n                if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                    missing.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true, treeWalk.getObjectReader())) {\n                    if (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator) || (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL && ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY))\n                        modified.add(treeWalk.getPathString());\n                }\n            }\n        }\n        for (int i = 0; i < treeWalk.getTreeCount(); i++) {\n            Set<String> values = fileModes.get(treeWalk.getFileMode(i));\n            String path = treeWalk.getPathString();\n            if (path != null) {\n                if (values == null)\n                    values = new HashSet<String>();\n                values.add(path);\n                fileModes.put(treeWalk.getFileMode(i), values);\n            }\n        }\n    }\n    if (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL) {\n        IgnoreSubmoduleMode localIgnoreSubmoduleMode = ignoreSubmoduleMode;\n        SubmoduleWalk smw = SubmoduleWalk.forIndex(repository);\n        while (smw.next()) {\n            try {\n                if (localIgnoreSubmoduleMode == null)\n                    localIgnoreSubmoduleMode = smw.getModulesIgnore();\n                if (IgnoreSubmoduleMode.ALL.equals(localIgnoreSubmoduleMode))\n                    continue;\n            } catch (ConfigInvalidException e) {\n                IOException e1 = new IOException(\"Found invalid ignore param for submodule \" + smw.getPath());\n                e1.initCause(e);\n                throw e1;\n            }\n            Repository subRepo = smw.getRepository();\n            ObjectId subHead = subRepo.resolve(\"HEAD\");\n            if (subHead != null && !subHead.equals(smw.getObjectId()))\n                modified.add(smw.getPath());\n            else if (ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY) {\n                IndexDiff smid = submoduleIndexDiffs.get(smw.getPath());\n                if (smid == null) {\n                    smid = new IndexDiff(subRepo, smw.getObjectId(), wTreeIt.getWorkingTreeIterator(subRepo));\n                    submoduleIndexDiffs.put(smw.getPath(), smid);\n                }\n                if (smid.diff()) {\n                    if (ignoreSubmoduleMode == IgnoreSubmoduleMode.UNTRACKED && smid.getAdded().isEmpty() && smid.getChanged().isEmpty() && smid.getConflicting().isEmpty() && smid.getMissing().isEmpty() && smid.getModified().isEmpty() && smid.getRemoved().isEmpty()) {\n                        continue;\n                    }\n                    modified.add(smw.getPath());\n                }\n            }\n        }\n    }\n    if (monitor != null)\n        monitor.endTask();\n    ignored = indexDiffFilter.getIgnoredPaths();\n    if (added.isEmpty() && changed.isEmpty() && removed.isEmpty() && missing.isEmpty() && modified.isEmpty() && untracked.isEmpty())\n        return false;\n    else\n        return true;\n}"
    },
    {
      "commit": "d8fcc964a85b255aac431c14ac35624f0634620b",
      "startLine": 11,
      "endLine": 18,
      "methodCode": "public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n    dirCache = repository.readDirCache();\n    TreeWalk treeWalk = new TreeWalk(repository);\n    treeWalk.setRecursive(true);\n    if (tree != null)\n        treeWalk.addTree(tree);\n    else\n        treeWalk.addTree(new EmptyTreeIterator());\n    treeWalk.addTree(new DirCacheIterator(dirCache));\n    treeWalk.addTree(initialWorkingTreeIterator);\n    Collection<TreeFilter> filters = new ArrayList<TreeFilter>(4);\n    if (monitor != null) {\n        if (estIndexSize == 0)\n            estIndexSize = dirCache.getEntryCount();\n        int total = Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n        monitor.beginTask(title, total);\n        filters.add(new ProgressReportingFilter(monitor, total));\n    }\n    if (filter != null)\n        filters.add(filter);\n    filters.add(new SkipWorkTreeFilter(INDEX));\n    indexDiffFilter = new IndexDiffFilter(INDEX, WORKDIR);\n    filters.add(indexDiffFilter);\n    treeWalk.setFilter(AndTreeFilter.create(filters));\n    fileModes.clear();\n    while (treeWalk.next()) {\n        AbstractTreeIterator treeIterator = treeWalk.getTree(TREE, AbstractTreeIterator.class);\n        DirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX, DirCacheIterator.class);\n        WorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n        if (dirCacheIterator != null) {\n            final DirCacheEntry dirCacheEntry = dirCacheIterator.getDirCacheEntry();\n            if (dirCacheEntry != null) {\n                int stage = dirCacheEntry.getStage();\n                if (stage > 0) {\n                    String path = treeWalk.getPathString();\n                    addConflict(path, stage);\n                    continue;\n                }\n            }\n        }\n        if (treeIterator != null) {\n            if (dirCacheIterator != null) {\n                if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() != dirCacheIterator.getEntryRawMode()) {\n                    if (!isEntryGitLink(treeIterator) || !isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                        changed.add(treeWalk.getPathString());\n                }\n            } else {\n                if (!isEntryGitLink(treeIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                    removed.add(treeWalk.getPathString());\n                if (workingTreeIterator != null)\n                    untracked.add(treeWalk.getPathString());\n            }\n        } else {\n            if (dirCacheIterator != null) {\n                if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                    added.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator != null && !workingTreeIterator.isEntryIgnored()) {\n                    untracked.add(treeWalk.getPathString());\n                }\n            }\n        }\n        if (dirCacheIterator != null) {\n            if (workingTreeIterator == null) {\n                if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                    missing.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true, treeWalk.getObjectReader())) {\n                    if (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator) || (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL && ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY))\n                        modified.add(treeWalk.getPathString());\n                }\n            }\n        }\n        for (int i = 0; i < treeWalk.getTreeCount(); i++) {\n            Set<String> values = fileModes.get(treeWalk.getFileMode(i));\n            String path = treeWalk.getPathString();\n            if (path != null) {\n                if (values == null)\n                    values = new HashSet<String>();\n                values.add(path);\n                fileModes.put(treeWalk.getFileMode(i), values);\n            }\n        }\n    }\n    if (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL) {\n        IgnoreSubmoduleMode localIgnoreSubmoduleMode = ignoreSubmoduleMode;\n        SubmoduleWalk smw = SubmoduleWalk.forIndex(repository);\n        while (smw.next()) {\n            try {\n                if (localIgnoreSubmoduleMode == null)\n                    localIgnoreSubmoduleMode = smw.getModulesIgnore();\n                if (IgnoreSubmoduleMode.ALL.equals(localIgnoreSubmoduleMode))\n                    continue;\n            } catch (ConfigInvalidException e) {\n                throw new IOException(\"Found invalid ignore param for submodule \" + smw.getPath());\n            }\n            Repository subRepo = smw.getRepository();\n            ObjectId subHead = subRepo.resolve(\"HEAD\");\n            if (subHead != null && !subHead.equals(smw.getObjectId()))\n                modified.add(smw.getPath());\n            else if (ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY) {\n                IndexDiff smid = submoduleIndexDiffs.get(smw.getPath());\n                if (smid == null) {\n                    smid = new IndexDiff(subRepo, smw.getObjectId(), wTreeIt.getWorkingTreeIterator(subRepo));\n                    submoduleIndexDiffs.put(smw.getPath(), smid);\n                }\n                if (smid.diff()) {\n                    if (ignoreSubmoduleMode == IgnoreSubmoduleMode.UNTRACKED && smid.getAdded().isEmpty() && smid.getChanged().isEmpty() && smid.getConflicting().isEmpty() && smid.getMissing().isEmpty() && smid.getModified().isEmpty() && smid.getRemoved().isEmpty()) {\n                        continue;\n                    }\n                    modified.add(smw.getPath());\n                }\n            }\n        }\n    }\n    if (monitor != null)\n        monitor.endTask();\n    ignored = indexDiffFilter.getIgnoredPaths();\n    if (added.isEmpty() && changed.isEmpty() && removed.isEmpty() && missing.isEmpty() && modified.isEmpty() && untracked.isEmpty())\n        return false;\n    else\n        return true;\n}"
    },
    {
      "commit": "5328c8c9164414a63ce7f1323d8194b84b6f1e49",
      "startLine": 11,
      "endLine": 18,
      "methodCode": "public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n    dirCache = repository.readDirCache();\n    TreeWalk treeWalk = new TreeWalk(repository);\n    treeWalk.setRecursive(true);\n    if (tree != null)\n        treeWalk.addTree(tree);\n    else\n        treeWalk.addTree(new EmptyTreeIterator());\n    treeWalk.addTree(new DirCacheIterator(dirCache));\n    treeWalk.addTree(initialWorkingTreeIterator);\n    Collection<TreeFilter> filters = new ArrayList<TreeFilter>(4);\n    if (monitor != null) {\n        if (estIndexSize == 0)\n            estIndexSize = dirCache.getEntryCount();\n        int total = Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n        monitor.beginTask(title, total);\n        filters.add(new ProgressReportingFilter(monitor, total));\n    }\n    if (filter != null)\n        filters.add(filter);\n    filters.add(new SkipWorkTreeFilter(INDEX));\n    indexDiffFilter = new IndexDiffFilter(INDEX, WORKDIR);\n    filters.add(indexDiffFilter);\n    treeWalk.setFilter(AndTreeFilter.create(filters));\n    fileModes.clear();\n    while (treeWalk.next()) {\n        AbstractTreeIterator treeIterator = treeWalk.getTree(TREE, AbstractTreeIterator.class);\n        DirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX, DirCacheIterator.class);\n        WorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n        if (dirCacheIterator != null) {\n            final DirCacheEntry dirCacheEntry = dirCacheIterator.getDirCacheEntry();\n            if (dirCacheEntry != null) {\n                int stage = dirCacheEntry.getStage();\n                if (stage > 0) {\n                    String path = treeWalk.getPathString();\n                    addConflict(path, stage);\n                    continue;\n                }\n            }\n        }\n        if (treeIterator != null) {\n            if (dirCacheIterator != null) {\n                if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() != dirCacheIterator.getEntryRawMode()) {\n                    if (!isEntryGitLink(treeIterator) || !isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                        changed.add(treeWalk.getPathString());\n                }\n            } else {\n                if (!isEntryGitLink(treeIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                    removed.add(treeWalk.getPathString());\n                if (workingTreeIterator != null)\n                    untracked.add(treeWalk.getPathString());\n            }\n        } else {\n            if (dirCacheIterator != null) {\n                if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                    added.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator != null && !workingTreeIterator.isEntryIgnored()) {\n                    untracked.add(treeWalk.getPathString());\n                }\n            }\n        }\n        if (dirCacheIterator != null) {\n            if (workingTreeIterator == null) {\n                if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                    missing.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true, treeWalk.getObjectReader())) {\n                    if (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator) || (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL && ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY))\n                        modified.add(treeWalk.getPathString());\n                }\n            }\n        }\n        for (int i = 0; i < treeWalk.getTreeCount(); i++) {\n            Set<String> values = fileModes.get(treeWalk.getFileMode(i));\n            String path = treeWalk.getPathString();\n            if (path != null) {\n                if (values == null)\n                    values = new HashSet<String>();\n                values.add(path);\n                fileModes.put(treeWalk.getFileMode(i), values);\n            }\n        }\n    }\n    if (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL) {\n        IgnoreSubmoduleMode localIgnoreSubmoduleMode = ignoreSubmoduleMode;\n        SubmoduleWalk smw = SubmoduleWalk.forIndex(repository);\n        while (smw.next()) {\n            try {\n                if (localIgnoreSubmoduleMode == null)\n                    localIgnoreSubmoduleMode = smw.getModulesIgnore();\n                if (IgnoreSubmoduleMode.ALL.equals(localIgnoreSubmoduleMode))\n                    continue;\n            } catch (ConfigInvalidException e) {\n                throw new IOException(\"Found invalid ignore param for submodule \" + smw.getPath());\n            }\n            Repository subRepo = smw.getRepository();\n            ObjectId subHead = subRepo.resolve(\"HEAD\");\n            if (subHead != null && !subHead.equals(smw.getObjectId()))\n                modified.add(smw.getPath());\n            else if (ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY) {\n                IndexDiff smid = submoduleIndexDiffs.get(smw.getPath());\n                if (smid == null) {\n                    smid = new IndexDiff(subRepo, smw.getObjectId(), wTreeIt.getWorkingTreeIterator(subRepo));\n                    submoduleIndexDiffs.put(smw.getPath(), smid);\n                }\n                if (smid.diff()) {\n                    if (ignoreSubmoduleMode == IgnoreSubmoduleMode.UNTRACKED && smid.getAdded().isEmpty() && smid.getChanged().isEmpty() && smid.getConflicting().isEmpty() && smid.getMissing().isEmpty() && smid.getModified().isEmpty() && smid.getRemoved().isEmpty()) {\n                        continue;\n                    }\n                    modified.add(smw.getPath());\n                }\n            }\n        }\n    }\n    if (monitor != null)\n        monitor.endTask();\n    ignored = indexDiffFilter.getIgnoredPaths();\n    if (added.isEmpty() && changed.isEmpty() && removed.isEmpty() && missing.isEmpty() && modified.isEmpty() && untracked.isEmpty())\n        return false;\n    else\n        return true;\n}"
    },
    {
      "commit": "95172dea173425697814e3ba0b4eb823301bf7d0",
      "startLine": 11,
      "endLine": 18,
      "methodCode": "public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n    dirCache = repository.readDirCache();\n    TreeWalk treeWalk = new TreeWalk(repository);\n    treeWalk.setRecursive(true);\n    if (tree != null)\n        treeWalk.addTree(tree);\n    else\n        treeWalk.addTree(new EmptyTreeIterator());\n    treeWalk.addTree(new DirCacheIterator(dirCache));\n    treeWalk.addTree(initialWorkingTreeIterator);\n    Collection<TreeFilter> filters = new ArrayList<TreeFilter>(4);\n    if (monitor != null) {\n        if (estIndexSize == 0)\n            estIndexSize = dirCache.getEntryCount();\n        int total = Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n        monitor.beginTask(title, total);\n        filters.add(new ProgressReportingFilter(monitor, total));\n    }\n    if (filter != null)\n        filters.add(filter);\n    filters.add(new SkipWorkTreeFilter(INDEX));\n    indexDiffFilter = new IndexDiffFilter(INDEX, WORKDIR);\n    filters.add(indexDiffFilter);\n    treeWalk.setFilter(AndTreeFilter.create(filters));\n    while (treeWalk.next()) {\n        AbstractTreeIterator treeIterator = treeWalk.getTree(TREE, AbstractTreeIterator.class);\n        DirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX, DirCacheIterator.class);\n        WorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n        if (dirCacheIterator != null) {\n            final DirCacheEntry dirCacheEntry = dirCacheIterator.getDirCacheEntry();\n            if (dirCacheEntry != null) {\n                int stage = dirCacheEntry.getStage();\n                if (stage > 0) {\n                    String path = treeWalk.getPathString();\n                    addConflict(path, stage);\n                    continue;\n                }\n            }\n        }\n        if (treeIterator != null) {\n            if (dirCacheIterator != null) {\n                if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() != dirCacheIterator.getEntryRawMode()) {\n                    if (!isEntryGitLink(treeIterator) || !isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                        changed.add(treeWalk.getPathString());\n                }\n            } else {\n                if (!isEntryGitLink(treeIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                    removed.add(treeWalk.getPathString());\n                if (workingTreeIterator != null)\n                    untracked.add(treeWalk.getPathString());\n            }\n        } else {\n            if (dirCacheIterator != null) {\n                if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                    added.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator != null && !workingTreeIterator.isEntryIgnored()) {\n                    untracked.add(treeWalk.getPathString());\n                }\n            }\n        }\n        if (dirCacheIterator != null) {\n            if (workingTreeIterator == null) {\n                if (!isEntryGitLink(dirCacheIterator) || ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n                    missing.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true, treeWalk.getObjectReader())) {\n                    if (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator) || (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL && ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY))\n                        modified.add(treeWalk.getPathString());\n                }\n            }\n        }\n    }\n    if (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL) {\n        IgnoreSubmoduleMode localIgnoreSubmoduleMode = ignoreSubmoduleMode;\n        SubmoduleWalk smw = SubmoduleWalk.forIndex(repository);\n        while (smw.next()) {\n            try {\n                if (localIgnoreSubmoduleMode == null)\n                    localIgnoreSubmoduleMode = smw.getModulesIgnore();\n                if (IgnoreSubmoduleMode.ALL.equals(localIgnoreSubmoduleMode))\n                    continue;\n            } catch (ConfigInvalidException e) {\n                throw new IOException(\"Found invalid ignore param for submodule \" + smw.getPath());\n            }\n            Repository subRepo = smw.getRepository();\n            ObjectId subHead = subRepo.resolve(\"HEAD\");\n            if (subHead != null && !subHead.equals(smw.getObjectId()))\n                modified.add(smw.getPath());\n            else if (ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY) {\n                IndexDiff smid = submoduleIndexDiffs.get(smw.getPath());\n                if (smid == null) {\n                    smid = new IndexDiff(subRepo, smw.getObjectId(), wTreeIt.getWorkingTreeIterator(subRepo));\n                    submoduleIndexDiffs.put(smw.getPath(), smid);\n                }\n                if (smid.diff()) {\n                    if (ignoreSubmoduleMode == IgnoreSubmoduleMode.UNTRACKED && smid.getAdded().isEmpty() && smid.getChanged().isEmpty() && smid.getConflicting().isEmpty() && smid.getMissing().isEmpty() && smid.getModified().isEmpty() && smid.getRemoved().isEmpty()) {\n                        continue;\n                    }\n                    modified.add(smw.getPath());\n                }\n            }\n        }\n    }\n    if (monitor != null)\n        monitor.endTask();\n    ignored = indexDiffFilter.getIgnoredPaths();\n    if (added.isEmpty() && changed.isEmpty() && removed.isEmpty() && missing.isEmpty() && modified.isEmpty() && untracked.isEmpty())\n        return false;\n    else\n        return true;\n}"
    },
    {
      "commit": "5404e70dc64201786cd6a21efb41310912860122",
      "startLine": 11,
      "endLine": 18,
      "methodCode": "public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n    dirCache = repository.readDirCache();\n    TreeWalk treeWalk = new TreeWalk(repository);\n    treeWalk.setRecursive(true);\n    if (tree != null)\n        treeWalk.addTree(tree);\n    else\n        treeWalk.addTree(new EmptyTreeIterator());\n    treeWalk.addTree(new DirCacheIterator(dirCache));\n    treeWalk.addTree(initialWorkingTreeIterator);\n    Collection<TreeFilter> filters = new ArrayList<TreeFilter>(4);\n    if (monitor != null) {\n        if (estIndexSize == 0)\n            estIndexSize = dirCache.getEntryCount();\n        int total = Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n        monitor.beginTask(title, total);\n        filters.add(new ProgressReportingFilter(monitor, total));\n    }\n    if (filter != null)\n        filters.add(filter);\n    filters.add(new SkipWorkTreeFilter(INDEX));\n    indexDiffFilter = new IndexDiffFilter(INDEX, WORKDIR);\n    filters.add(indexDiffFilter);\n    treeWalk.setFilter(AndTreeFilter.create(filters));\n    while (treeWalk.next()) {\n        AbstractTreeIterator treeIterator = treeWalk.getTree(TREE, AbstractTreeIterator.class);\n        DirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX, DirCacheIterator.class);\n        WorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n        if (dirCacheIterator != null) {\n            final DirCacheEntry dirCacheEntry = dirCacheIterator.getDirCacheEntry();\n            if (dirCacheEntry != null) {\n                int stage = dirCacheEntry.getStage();\n                if (stage > 0) {\n                    String path = treeWalk.getPathString();\n                    addConflict(path, stage);\n                    continue;\n                }\n            }\n        }\n        if (treeIterator != null) {\n            if (dirCacheIterator != null) {\n                if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() != dirCacheIterator.getEntryRawMode()) {\n                    changed.add(treeWalk.getPathString());\n                }\n            } else {\n                removed.add(treeWalk.getPathString());\n                if (workingTreeIterator != null)\n                    untracked.add(treeWalk.getPathString());\n            }\n        } else {\n            if (dirCacheIterator != null) {\n                added.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator != null && !workingTreeIterator.isEntryIgnored()) {\n                    untracked.add(treeWalk.getPathString());\n                }\n            }\n        }\n        if (dirCacheIterator != null) {\n            if (workingTreeIterator == null) {\n                missing.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true, treeWalk.getObjectReader())) {\n                    modified.add(treeWalk.getPathString());\n                }\n            }\n        }\n    }\n    if (monitor != null)\n        monitor.endTask();\n    ignored = indexDiffFilter.getIgnoredPaths();\n    if (added.isEmpty() && changed.isEmpty() && removed.isEmpty() && missing.isEmpty() && modified.isEmpty() && untracked.isEmpty())\n        return false;\n    else\n        return true;\n}"
    },
    {
      "commit": "1080cc5a0d67012c0ef08d9468fbbc9d90b0c238",
      "startLine": 11,
      "endLine": 18,
      "methodCode": "public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n    dirCache = repository.readDirCache();\n    TreeWalk treeWalk = new TreeWalk(repository);\n    treeWalk.setRecursive(true);\n    if (tree != null)\n        treeWalk.addTree(tree);\n    else\n        treeWalk.addTree(new EmptyTreeIterator());\n    treeWalk.addTree(new DirCacheIterator(dirCache));\n    treeWalk.addTree(initialWorkingTreeIterator);\n    Collection<TreeFilter> filters = new ArrayList<TreeFilter>(4);\n    if (monitor != null) {\n        if (estIndexSize == 0)\n            estIndexSize = dirCache.getEntryCount();\n        int total = Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n        monitor.beginTask(title, total);\n        filters.add(new ProgressReportingFilter(monitor, total));\n    }\n    if (filter != null)\n        filters.add(filter);\n    filters.add(new SkipWorkTreeFilter(INDEX));\n    indexDiffFilter = new IndexDiffFilter(INDEX, WORKDIR);\n    filters.add(indexDiffFilter);\n    treeWalk.setFilter(AndTreeFilter.create(filters));\n    while (treeWalk.next()) {\n        AbstractTreeIterator treeIterator = treeWalk.getTree(TREE, AbstractTreeIterator.class);\n        DirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX, DirCacheIterator.class);\n        WorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n        if (dirCacheIterator != null) {\n            final DirCacheEntry dirCacheEntry = dirCacheIterator.getDirCacheEntry();\n            if (dirCacheEntry != null) {\n                int stage = dirCacheEntry.getStage();\n                if (stage > 0) {\n                    String path = treeWalk.getPathString();\n                    addConflict(path, stage);\n                    continue;\n                }\n            }\n        }\n        if (treeIterator != null) {\n            if (dirCacheIterator != null) {\n                if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() != dirCacheIterator.getEntryRawMode()) {\n                    changed.add(treeWalk.getPathString());\n                }\n            } else {\n                removed.add(treeWalk.getPathString());\n                if (workingTreeIterator != null)\n                    untracked.add(treeWalk.getPathString());\n            }\n        } else {\n            if (dirCacheIterator != null) {\n                added.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator != null && !workingTreeIterator.isEntryIgnored()) {\n                    untracked.add(treeWalk.getPathString());\n                }\n            }\n        }\n        if (dirCacheIterator != null) {\n            if (workingTreeIterator == null) {\n                missing.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true)) {\n                    modified.add(treeWalk.getPathString());\n                }\n            }\n        }\n    }\n    if (monitor != null)\n        monitor.endTask();\n    ignored = indexDiffFilter.getIgnoredPaths();\n    if (added.isEmpty() && changed.isEmpty() && removed.isEmpty() && missing.isEmpty() && modified.isEmpty() && untracked.isEmpty())\n        return false;\n    else\n        return true;\n}"
    },
    {
      "commit": "53ef3e51145adb4b060110e262d7c064be0d5fc5",
      "startLine": 11,
      "endLine": 18,
      "methodCode": "public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n    dirCache = repository.readDirCache();\n    TreeWalk treeWalk = new TreeWalk(repository);\n    treeWalk.setRecursive(true);\n    if (tree != null)\n        treeWalk.addTree(tree);\n    else\n        treeWalk.addTree(new EmptyTreeIterator());\n    treeWalk.addTree(new DirCacheIterator(dirCache));\n    treeWalk.addTree(initialWorkingTreeIterator);\n    Collection<TreeFilter> filters = new ArrayList<TreeFilter>(4);\n    if (monitor != null) {\n        if (estIndexSize == 0)\n            estIndexSize = dirCache.getEntryCount();\n        int total = Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n        monitor.beginTask(title, total);\n        filters.add(new ProgressReportingFilter(monitor, total));\n    }\n    if (filter != null)\n        filters.add(filter);\n    filters.add(new SkipWorkTreeFilter(INDEX));\n    indexDiffFilter = new IndexDiffFilter(INDEX, WORKDIR);\n    filters.add(indexDiffFilter);\n    treeWalk.setFilter(AndTreeFilter.create(filters));\n    while (treeWalk.next()) {\n        AbstractTreeIterator treeIterator = treeWalk.getTree(TREE, AbstractTreeIterator.class);\n        DirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX, DirCacheIterator.class);\n        WorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n        if (dirCacheIterator != null) {\n            final DirCacheEntry dirCacheEntry = dirCacheIterator.getDirCacheEntry();\n            if (dirCacheEntry != null && dirCacheEntry.getStage() > 0) {\n                conflicts.add(treeWalk.getPathString());\n                continue;\n            }\n        }\n        if (treeIterator != null) {\n            if (dirCacheIterator != null) {\n                if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() != dirCacheIterator.getEntryRawMode()) {\n                    changed.add(treeWalk.getPathString());\n                }\n            } else {\n                removed.add(treeWalk.getPathString());\n                if (workingTreeIterator != null)\n                    untracked.add(treeWalk.getPathString());\n            }\n        } else {\n            if (dirCacheIterator != null) {\n                added.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator != null && !workingTreeIterator.isEntryIgnored()) {\n                    untracked.add(treeWalk.getPathString());\n                }\n            }\n        }\n        if (dirCacheIterator != null) {\n            if (workingTreeIterator == null) {\n                missing.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true)) {\n                    modified.add(treeWalk.getPathString());\n                }\n            }\n        }\n    }\n    if (monitor != null)\n        monitor.endTask();\n    ignored = indexDiffFilter.getIgnoredPaths();\n    if (added.isEmpty() && changed.isEmpty() && removed.isEmpty() && missing.isEmpty() && modified.isEmpty() && untracked.isEmpty())\n        return false;\n    else\n        return true;\n}"
    },
    {
      "commit": "6befabcb1584118fb02188f602f7ca34b9a7efc5",
      "startLine": 11,
      "endLine": 18,
      "methodCode": "public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n    dirCache = repository.readDirCache();\n    TreeWalk treeWalk = new TreeWalk(repository);\n    treeWalk.setRecursive(true);\n    if (tree != null)\n        treeWalk.addTree(tree);\n    else\n        treeWalk.addTree(new EmptyTreeIterator());\n    treeWalk.addTree(new DirCacheIterator(dirCache));\n    treeWalk.addTree(initialWorkingTreeIterator);\n    Collection<TreeFilter> filters = new ArrayList<TreeFilter>(4);\n    if (monitor != null) {\n        if (estIndexSize == 0)\n            estIndexSize = dirCache.getEntryCount();\n        int total = Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n        monitor.beginTask(title, total);\n        filters.add(new ProgressReportingFilter(monitor, total));\n    }\n    if (filter != null)\n        filters.add(filter);\n    filters.add(new SkipWorkTreeFilter(INDEX));\n    IndexDiffFilter indexDiffFilter = new IndexDiffFilter(INDEX, WORKDIR);\n    filters.add(indexDiffFilter);\n    treeWalk.setFilter(AndTreeFilter.create(filters));\n    while (treeWalk.next()) {\n        AbstractTreeIterator treeIterator = treeWalk.getTree(TREE, AbstractTreeIterator.class);\n        DirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX, DirCacheIterator.class);\n        WorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n        if (dirCacheIterator != null) {\n            final DirCacheEntry dirCacheEntry = dirCacheIterator.getDirCacheEntry();\n            if (dirCacheEntry != null && dirCacheEntry.getStage() > 0) {\n                conflicts.add(treeWalk.getPathString());\n                continue;\n            }\n        }\n        if (treeIterator != null) {\n            if (dirCacheIterator != null) {\n                if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() != dirCacheIterator.getEntryRawMode()) {\n                    changed.add(treeWalk.getPathString());\n                }\n            } else {\n                removed.add(treeWalk.getPathString());\n                if (workingTreeIterator != null)\n                    untracked.add(treeWalk.getPathString());\n            }\n        } else {\n            if (dirCacheIterator != null) {\n                added.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator != null && !workingTreeIterator.isEntryIgnored()) {\n                    untracked.add(treeWalk.getPathString());\n                }\n            }\n        }\n        if (dirCacheIterator != null) {\n            if (workingTreeIterator == null) {\n                missing.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true)) {\n                    modified.add(treeWalk.getPathString());\n                }\n            }\n        }\n    }\n    if (monitor != null)\n        monitor.endTask();\n    ignored = indexDiffFilter.getIgnoredPaths();\n    if (added.isEmpty() && changed.isEmpty() && removed.isEmpty() && missing.isEmpty() && modified.isEmpty() && untracked.isEmpty())\n        return false;\n    else\n        return true;\n}"
    },
    {
      "commit": "298486a7c320629de12f9506e0133686a7382b01",
      "startLine": 11,
      "endLine": 18,
      "methodCode": "public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n    dirCache = repository.readDirCache();\n    TreeWalk treeWalk = new TreeWalk(repository);\n    treeWalk.setRecursive(true);\n    if (tree != null)\n        treeWalk.addTree(tree);\n    else\n        treeWalk.addTree(new EmptyTreeIterator());\n    treeWalk.addTree(new DirCacheIterator(dirCache));\n    treeWalk.addTree(initialWorkingTreeIterator);\n    Collection<TreeFilter> filters = new ArrayList<TreeFilter>(4);\n    if (monitor != null) {\n        if (estIndexSize == 0)\n            estIndexSize = dirCache.getEntryCount();\n        int total = Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n        monitor.beginTask(title, total);\n        filters.add(new ProgressReportingFilter(monitor, total));\n    }\n    if (filter != null)\n        filters.add(filter);\n    filters.add(new SkipWorkTreeFilter(INDEX));\n    filters.add(new IndexDiffFilter(INDEX, WORKDIR));\n    treeWalk.setFilter(AndTreeFilter.create(filters));\n    while (treeWalk.next()) {\n        AbstractTreeIterator treeIterator = treeWalk.getTree(TREE, AbstractTreeIterator.class);\n        DirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX, DirCacheIterator.class);\n        WorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n        if (dirCacheIterator != null) {\n            final DirCacheEntry dirCacheEntry = dirCacheIterator.getDirCacheEntry();\n            if (dirCacheEntry != null && dirCacheEntry.getStage() > 0) {\n                conflicts.add(treeWalk.getPathString());\n                continue;\n            }\n        }\n        if (treeIterator != null) {\n            if (dirCacheIterator != null) {\n                if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() != dirCacheIterator.getEntryRawMode()) {\n                    changed.add(treeWalk.getPathString());\n                }\n            } else {\n                removed.add(treeWalk.getPathString());\n                if (workingTreeIterator != null)\n                    untracked.add(treeWalk.getPathString());\n            }\n        } else {\n            if (dirCacheIterator != null) {\n                added.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator != null && !workingTreeIterator.isEntryIgnored()) {\n                    untracked.add(treeWalk.getPathString());\n                }\n            }\n        }\n        if (dirCacheIterator != null) {\n            if (workingTreeIterator == null) {\n                missing.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true)) {\n                    modified.add(treeWalk.getPathString());\n                }\n            }\n        }\n    }\n    if (monitor != null)\n        monitor.endTask();\n    if (added.isEmpty() && changed.isEmpty() && removed.isEmpty() && missing.isEmpty() && modified.isEmpty() && untracked.isEmpty())\n        return false;\n    else\n        return true;\n}"
    },
    {
      "commit": "1a867d10b974cab4d43d77f5b392f4f07807ebd8",
      "startLine": 11,
      "endLine": 18,
      "methodCode": "public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n    dirCache = repository.readDirCache();\n    TreeWalk treeWalk = new TreeWalk(repository);\n    treeWalk.setRecursive(true);\n    if (tree != null)\n        treeWalk.addTree(tree);\n    else\n        treeWalk.addTree(new EmptyTreeIterator());\n    treeWalk.addTree(new DirCacheIterator(dirCache));\n    treeWalk.addTree(initialWorkingTreeIterator);\n    Collection<TreeFilter> filters = new ArrayList<TreeFilter>(4);\n    if (monitor != null) {\n        if (estIndexSize == 0)\n            estIndexSize = dirCache.getEntryCount();\n        int total = Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n        monitor.beginTask(title, total);\n        filters.add(new ProgressReportingFilter(monitor, total));\n    }\n    if (filter != null)\n        filters.add(filter);\n    filters.add(new SkipWorkTreeFilter(INDEX));\n    filters.add(new IndexDiffFilter(INDEX, WORKDIR));\n    treeWalk.setFilter(AndTreeFilter.create(filters));\n    while (treeWalk.next()) {\n        AbstractTreeIterator treeIterator = treeWalk.getTree(TREE, AbstractTreeIterator.class);\n        DirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX, DirCacheIterator.class);\n        WorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n        if (treeIterator != null) {\n            if (dirCacheIterator != null) {\n                if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() != dirCacheIterator.getEntryRawMode()) {\n                    changed.add(treeWalk.getPathString());\n                }\n            } else {\n                removed.add(treeWalk.getPathString());\n                if (workingTreeIterator != null)\n                    untracked.add(treeWalk.getPathString());\n            }\n        } else {\n            if (dirCacheIterator != null) {\n                added.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator != null && !workingTreeIterator.isEntryIgnored()) {\n                    untracked.add(treeWalk.getPathString());\n                }\n            }\n        }\n        if (dirCacheIterator != null) {\n            if (workingTreeIterator == null) {\n                missing.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true)) {\n                    modified.add(treeWalk.getPathString());\n                }\n            }\n            final DirCacheEntry dirCacheEntry = dirCacheIterator.getDirCacheEntry();\n            if (dirCacheEntry != null && dirCacheEntry.getStage() > 0) {\n                conflicts.add(treeWalk.getPathString());\n            }\n        }\n    }\n    if (monitor != null)\n        monitor.endTask();\n    if (added.isEmpty() && changed.isEmpty() && removed.isEmpty() && missing.isEmpty() && modified.isEmpty() && untracked.isEmpty())\n        return false;\n    else\n        return true;\n}"
    },
    {
      "commit": "5e2e3819a690b739eba773415899d20db88a452e",
      "startLine": 11,
      "endLine": 18,
      "methodCode": "public boolean diff(final ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, final String title) throws IOException {\n    dirCache = repository.readDirCache();\n    TreeWalk treeWalk = new TreeWalk(repository);\n    treeWalk.setRecursive(true);\n    if (tree != null)\n        treeWalk.addTree(tree);\n    else\n        treeWalk.addTree(new EmptyTreeIterator());\n    treeWalk.addTree(new DirCacheIterator(dirCache));\n    treeWalk.addTree(initialWorkingTreeIterator);\n    Collection<TreeFilter> filters = new ArrayList<TreeFilter>(4);\n    if (monitor != null) {\n        if (estIndexSize == 0)\n            estIndexSize = dirCache.getEntryCount();\n        int total = Math.max(estIndexSize * 10 / 9, estWorkTreeSize * 10 / 9);\n        monitor.beginTask(title, total);\n        filters.add(new ProgressReportingFilter(monitor, total));\n    }\n    if (filter != null)\n        filters.add(filter);\n    filters.add(new SkipWorkTreeFilter(INDEX));\n    filters.add(new IndexDiffFilter(INDEX, WORKDIR));\n    treeWalk.setFilter(AndTreeFilter.create(filters));\n    while (treeWalk.next()) {\n        AbstractTreeIterator treeIterator = treeWalk.getTree(TREE, AbstractTreeIterator.class);\n        DirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX, DirCacheIterator.class);\n        WorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n        if (treeIterator != null) {\n            if (dirCacheIterator != null) {\n                if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() != dirCacheIterator.getEntryRawMode()) {\n                    changed.add(treeWalk.getPathString());\n                }\n            } else {\n                removed.add(treeWalk.getPathString());\n                if (workingTreeIterator != null)\n                    untracked.add(treeWalk.getPathString());\n            }\n        } else {\n            if (dirCacheIterator != null) {\n                added.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator != null && !workingTreeIterator.isEntryIgnored()) {\n                    untracked.add(treeWalk.getPathString());\n                }\n            }\n        }\n        if (dirCacheIterator != null) {\n            if (workingTreeIterator == null) {\n                missing.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true)) {\n                    modified.add(treeWalk.getPathString());\n                }\n            }\n        }\n    }\n    if (monitor != null)\n        monitor.endTask();\n    if (added.isEmpty() && changed.isEmpty() && removed.isEmpty() && missing.isEmpty() && modified.isEmpty() && untracked.isEmpty())\n        return false;\n    else\n        return true;\n}"
    },
    {
      "commit": "1783749e169c57cef7131e1749a01ee269b89df8",
      "startLine": 11,
      "endLine": 11,
      "methodCode": "public boolean diff() throws IOException {\n    dirCache = repository.readDirCache();\n    TreeWalk treeWalk = new TreeWalk(repository);\n    treeWalk.setRecursive(true);\n    if (tree != null)\n        treeWalk.addTree(tree);\n    else\n        treeWalk.addTree(new EmptyTreeIterator());\n    treeWalk.addTree(new DirCacheIterator(dirCache));\n    treeWalk.addTree(initialWorkingTreeIterator);\n    Collection<TreeFilter> filters = new ArrayList<TreeFilter>(4);\n    if (filter != null)\n        filters.add(filter);\n    filters.add(new SkipWorkTreeFilter(INDEX));\n    filters.add(new IndexDiffFilter(INDEX, WORKDIR));\n    treeWalk.setFilter(AndTreeFilter.create(filters));\n    while (treeWalk.next()) {\n        AbstractTreeIterator treeIterator = treeWalk.getTree(TREE, AbstractTreeIterator.class);\n        DirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX, DirCacheIterator.class);\n        WorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n        if (treeIterator != null) {\n            if (dirCacheIterator != null) {\n                if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() != dirCacheIterator.getEntryRawMode()) {\n                    changed.add(treeWalk.getPathString());\n                }\n            } else {\n                removed.add(treeWalk.getPathString());\n                if (workingTreeIterator != null)\n                    untracked.add(treeWalk.getPathString());\n            }\n        } else {\n            if (dirCacheIterator != null) {\n                added.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator != null && !workingTreeIterator.isEntryIgnored()) {\n                    untracked.add(treeWalk.getPathString());\n                }\n            }\n        }\n        if (dirCacheIterator != null) {\n            if (workingTreeIterator == null) {\n                missing.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true)) {\n                    modified.add(treeWalk.getPathString());\n                }\n            }\n        }\n    }\n    if (added.isEmpty() && changed.isEmpty() && removed.isEmpty() && missing.isEmpty() && modified.isEmpty() && untracked.isEmpty())\n        return false;\n    else\n        return true;\n}"
    },
    {
      "commit": "18abb8195a67a0502a71e2420078dd95563e18c6",
      "startLine": 11,
      "endLine": 11,
      "methodCode": "public boolean diff() throws IOException {\n    dirCache = repository.readDirCache();\n    TreeWalk treeWalk = new TreeWalk(repository);\n    treeWalk.setRecursive(true);\n    if (tree != null)\n        treeWalk.addTree(tree);\n    else\n        treeWalk.addTree(new EmptyTreeIterator());\n    treeWalk.addTree(new DirCacheIterator(dirCache));\n    treeWalk.addTree(initialWorkingTreeIterator);\n    Collection<TreeFilter> filters = new ArrayList<TreeFilter>(4);\n    if (filter != null)\n        filters.add(filter);\n    filters.add(new NotIgnoredFilter(WORKDIR));\n    filters.add(new SkipWorkTreeFilter(INDEX));\n    filters.add(TreeFilter.ANY_DIFF);\n    treeWalk.setFilter(AndTreeFilter.create(filters));\n    while (treeWalk.next()) {\n        AbstractTreeIterator treeIterator = treeWalk.getTree(TREE, AbstractTreeIterator.class);\n        DirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX, DirCacheIterator.class);\n        WorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n        if (treeIterator != null) {\n            if (dirCacheIterator != null) {\n                if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() != dirCacheIterator.getEntryRawMode()) {\n                    changed.add(treeWalk.getPathString());\n                }\n            } else {\n                removed.add(treeWalk.getPathString());\n                if (workingTreeIterator != null)\n                    untracked.add(treeWalk.getPathString());\n            }\n        } else {\n            if (dirCacheIterator != null) {\n                added.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator != null && !workingTreeIterator.isEntryIgnored()) {\n                    untracked.add(treeWalk.getPathString());\n                }\n            }\n        }\n        if (dirCacheIterator != null) {\n            if (workingTreeIterator == null) {\n                missing.add(treeWalk.getPathString());\n            } else {\n                if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true)) {\n                    modified.add(treeWalk.getPathString());\n                }\n            }\n        }\n    }\n    if (added.isEmpty() && changed.isEmpty() && removed.isEmpty() && missing.isEmpty() && modified.isEmpty() && untracked.isEmpty())\n        return false;\n    else\n        return true;\n}"
    },
    {
      "commit": "a66a7d90fd4c3ec3587d2f314e785ab5bba71b6f",
      "startLine": 12,
      "endLine": 12,
      "methodCode": "public boolean diff() throws IOException {\n    boolean changesExist = false;\n    dirCache = repository.readDirCache();\n    TreeWalk treeWalk = new TreeWalk(repository);\n    treeWalk.setRecursive(true);\n    if (tree != null)\n        treeWalk.addTree(tree);\n    else\n        treeWalk.addTree(new EmptyTreeIterator());\n    treeWalk.addTree(new DirCacheIterator(dirCache));\n    treeWalk.addTree(initialWorkingTreeIterator);\n    Collection<TreeFilter> filters = new ArrayList<TreeFilter>(4);\n    if (filter != null)\n        filters.add(filter);\n    filters.add(new NotIgnoredFilter(WORKDIR));\n    filters.add(new SkipWorkTreeFilter(INDEX));\n    filters.add(TreeFilter.ANY_DIFF);\n    treeWalk.setFilter(AndTreeFilter.create(filters));\n    while (treeWalk.next()) {\n        AbstractTreeIterator treeIterator = treeWalk.getTree(TREE, AbstractTreeIterator.class);\n        DirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX, DirCacheIterator.class);\n        WorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n        if (treeIterator != null) {\n            if (dirCacheIterator != null) {\n                if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() != dirCacheIterator.getEntryRawMode()) {\n                    changed.add(treeWalk.getPathString());\n                    changesExist = true;\n                }\n            } else {\n                removed.add(treeWalk.getPathString());\n                changesExist = true;\n                if (workingTreeIterator != null)\n                    untracked.add(treeWalk.getPathString());\n            }\n        } else {\n            if (dirCacheIterator != null) {\n                added.add(treeWalk.getPathString());\n                changesExist = true;\n            } else {\n                if (workingTreeIterator != null && !workingTreeIterator.isEntryIgnored()) {\n                    untracked.add(treeWalk.getPathString());\n                    changesExist = true;\n                }\n            }\n        }\n        if (dirCacheIterator != null) {\n            if (workingTreeIterator == null) {\n                missing.add(treeWalk.getPathString());\n                changesExist = true;\n            } else {\n                if (workingTreeIterator.isModified(dirCacheIterator.getDirCacheEntry(), true)) {\n                    modified.add(treeWalk.getPathString());\n                    changesExist = true;\n                }\n            }\n        }\n    }\n    return changesExist;\n}"
    },
    {
      "commit": "d4bbb2e4497335993f4d24f539111dc5d3f8bbcd",
      "startLine": 12,
      "endLine": 12,
      "methodCode": "public boolean diff() throws IOException {\n    boolean changesExist = false;\n    dirCache = repository.readDirCache();\n    TreeWalk treeWalk = new TreeWalk(repository);\n    treeWalk.setRecursive(true);\n    if (tree != null)\n        treeWalk.addTree(tree);\n    else\n        treeWalk.addTree(new EmptyTreeIterator());\n    treeWalk.addTree(new DirCacheIterator(dirCache));\n    treeWalk.addTree(initialWorkingTreeIterator);\n    Collection<TreeFilter> filters = new ArrayList<TreeFilter>(4);\n    if (filter != null)\n        filters.add(filter);\n    filters.add(new NotIgnoredFilter(WORKDIR));\n    filters.add(new SkipWorkTreeFilter(INDEX));\n    filters.add(TreeFilter.ANY_DIFF);\n    treeWalk.setFilter(AndTreeFilter.create(filters));\n    while (treeWalk.next()) {\n        AbstractTreeIterator treeIterator = treeWalk.getTree(TREE, AbstractTreeIterator.class);\n        DirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX, DirCacheIterator.class);\n        WorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n        if (treeIterator != null) {\n            if (dirCacheIterator != null) {\n                if (!treeIterator.idEqual(dirCacheIterator) || treeIterator.getEntryRawMode() != dirCacheIterator.getEntryRawMode()) {\n                    changed.add(treeWalk.getPathString());\n                    changesExist = true;\n                }\n            } else {\n                removed.add(treeWalk.getPathString());\n                changesExist = true;\n                if (workingTreeIterator != null)\n                    untracked.add(treeWalk.getPathString());\n            }\n        } else {\n            if (dirCacheIterator != null) {\n                added.add(treeWalk.getPathString());\n                changesExist = true;\n            } else {\n                if (workingTreeIterator != null && !workingTreeIterator.isEntryIgnored()) {\n                    untracked.add(treeWalk.getPathString());\n                    changesExist = true;\n                }\n            }\n        }\n        if (dirCacheIterator != null) {\n            if (workingTreeIterator == null) {\n                missing.add(treeWalk.getPathString());\n                changesExist = true;\n            } else {\n                if (!dirCacheIterator.idEqual(workingTreeIterator)) {\n                    modified.add(treeWalk.getPathString());\n                    changesExist = true;\n                }\n            }\n        }\n    }\n    return changesExist;\n}"
    },
    {
      "commit": "e6c39227640536ac1c2e41d8970aeca84b3c6268",
      "startLine": 12,
      "endLine": 12,
      "methodCode": "public boolean diff() throws IOException {\n    boolean changesExist = false;\n    dirCache = repository.readDirCache();\n    TreeWalk treeWalk = new TreeWalk(repository);\n    treeWalk.setRecursive(true);\n    if (tree != null)\n        treeWalk.addTree(tree);\n    else\n        treeWalk.addTree(new EmptyTreeIterator());\n    treeWalk.addTree(new DirCacheIterator(dirCache));\n    treeWalk.addTree(initialWorkingTreeIterator);\n    Collection<TreeFilter> filters = new ArrayList<TreeFilter>(4);\n    if (filter != null)\n        filters.add(filter);\n    filters.add(new NotIgnoredFilter(WORKDIR));\n    filters.add(new SkipWorkTreeFilter(INDEX));\n    filters.add(TreeFilter.ANY_DIFF);\n    treeWalk.setFilter(AndTreeFilter.create(filters));\n    while (treeWalk.next()) {\n        AbstractTreeIterator treeIterator = treeWalk.getTree(TREE, AbstractTreeIterator.class);\n        DirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX, DirCacheIterator.class);\n        WorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n        if (treeIterator != null) {\n            if (dirCacheIterator != null) {\n                if (!treeIterator.getEntryObjectId().equals(dirCacheIterator.getEntryObjectId())) {\n                    changed.add(treeWalk.getPathString());\n                    changesExist = true;\n                }\n            } else {\n                removed.add(treeWalk.getPathString());\n                changesExist = true;\n                if (workingTreeIterator != null)\n                    untracked.add(treeWalk.getPathString());\n            }\n        } else {\n            if (dirCacheIterator != null) {\n                added.add(treeWalk.getPathString());\n                changesExist = true;\n            } else {\n                if (workingTreeIterator != null && !workingTreeIterator.isEntryIgnored()) {\n                    untracked.add(treeWalk.getPathString());\n                    changesExist = true;\n                }\n            }\n        }\n        if (dirCacheIterator != null) {\n            if (workingTreeIterator == null) {\n                missing.add(treeWalk.getPathString());\n                changesExist = true;\n            } else {\n                if (!dirCacheIterator.idEqual(workingTreeIterator)) {\n                    modified.add(treeWalk.getPathString());\n                    changesExist = true;\n                }\n            }\n        }\n    }\n    return changesExist;\n}"
    },
    {
      "commit": "48e80698cf7b19422cb7a62a34170cc3c7a3f7a2",
      "startLine": 12,
      "endLine": 12,
      "methodCode": "public boolean diff() throws IOException {\n    boolean changesExist = false;\n    DirCache dirCache = repository.readDirCache();\n    TreeWalk treeWalk = new TreeWalk(repository);\n    treeWalk.setRecursive(true);\n    if (tree != null)\n        treeWalk.addTree(tree);\n    else\n        treeWalk.addTree(new EmptyTreeIterator());\n    treeWalk.addTree(new DirCacheIterator(dirCache));\n    treeWalk.addTree(initialWorkingTreeIterator);\n    Collection<TreeFilter> filters = new ArrayList<TreeFilter>(4);\n    if (filter != null)\n        filters.add(filter);\n    filters.add(new NotIgnoredFilter(WORKDIR));\n    filters.add(new SkipWorkTreeFilter(INDEX));\n    filters.add(TreeFilter.ANY_DIFF);\n    treeWalk.setFilter(AndTreeFilter.create(filters));\n    while (treeWalk.next()) {\n        AbstractTreeIterator treeIterator = treeWalk.getTree(TREE, AbstractTreeIterator.class);\n        DirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX, DirCacheIterator.class);\n        WorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n        if (dirCacheIterator != null) {\n            if (dirCacheIterator.getDirCacheEntry().isAssumeValid())\n                assumeUnchanged.add(treeWalk.getPathString());\n        }\n        if (treeIterator != null) {\n            if (dirCacheIterator != null) {\n                if (!treeIterator.getEntryObjectId().equals(dirCacheIterator.getEntryObjectId())) {\n                    changed.add(treeWalk.getPathString());\n                    changesExist = true;\n                }\n            } else {\n                removed.add(treeWalk.getPathString());\n                changesExist = true;\n                if (workingTreeIterator != null)\n                    untracked.add(treeWalk.getPathString());\n            }\n        } else {\n            if (dirCacheIterator != null) {\n                added.add(treeWalk.getPathString());\n                changesExist = true;\n            } else {\n                if (workingTreeIterator != null && !workingTreeIterator.isEntryIgnored()) {\n                    untracked.add(treeWalk.getPathString());\n                    changesExist = true;\n                }\n            }\n        }\n        if (dirCacheIterator != null) {\n            if (workingTreeIterator == null) {\n                missing.add(treeWalk.getPathString());\n                changesExist = true;\n            } else {\n                if (!dirCacheIterator.idEqual(workingTreeIterator)) {\n                    modified.add(treeWalk.getPathString());\n                    changesExist = true;\n                }\n            }\n        }\n    }\n    return changesExist;\n}"
    },
    {
      "commit": "ca9baa0ee2d86edf1c1e29ba3c35ba45fcf32b8c",
      "startLine": 12,
      "endLine": 12,
      "methodCode": "public boolean diff() throws IOException {\n    boolean changesExist = false;\n    DirCache dirCache = repository.readDirCache();\n    TreeWalk treeWalk = new TreeWalk(repository);\n    treeWalk.setRecursive(true);\n    if (tree != null)\n        treeWalk.addTree(tree);\n    else\n        treeWalk.addTree(new EmptyTreeIterator());\n    treeWalk.addTree(new DirCacheIterator(dirCache));\n    treeWalk.addTree(initialWorkingTreeIterator);\n    Collection<TreeFilter> filters = new ArrayList<TreeFilter>(4);\n    if (filter != null)\n        filters.add(filter);\n    filters.add(new NotIgnoredFilter(WORKDIR));\n    filters.add(new SkipWorkTreeFilter(INDEX));\n    filters.add(TreeFilter.ANY_DIFF);\n    treeWalk.setFilter(AndTreeFilter.create(filters));\n    while (treeWalk.next()) {\n        AbstractTreeIterator treeIterator = treeWalk.getTree(TREE, AbstractTreeIterator.class);\n        DirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX, DirCacheIterator.class);\n        WorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n        FileMode fileModeTree = treeWalk.getFileMode(TREE);\n        if (dirCacheIterator != null) {\n            if (dirCacheIterator.getDirCacheEntry().isAssumeValid())\n                assumeUnchanged.add(treeWalk.getPathString());\n        }\n        if (treeIterator != null) {\n            if (dirCacheIterator != null) {\n                if (!treeIterator.getEntryObjectId().equals(dirCacheIterator.getEntryObjectId())) {\n                    changed.add(treeWalk.getPathString());\n                    changesExist = true;\n                }\n            } else {\n                if (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n                    removed.add(treeWalk.getPathString());\n                    changesExist = true;\n                    if (workingTreeIterator != null)\n                        untracked.add(treeWalk.getPathString());\n                }\n            }\n        } else {\n            if (dirCacheIterator != null) {\n                added.add(treeWalk.getPathString());\n                changesExist = true;\n            } else {\n                if (workingTreeIterator != null && !workingTreeIterator.isEntryIgnored()) {\n                    untracked.add(treeWalk.getPathString());\n                    changesExist = true;\n                }\n            }\n        }\n        if (dirCacheIterator != null) {\n            if (workingTreeIterator == null) {\n                missing.add(treeWalk.getPathString());\n                changesExist = true;\n            } else {\n                if (!dirCacheIterator.idEqual(workingTreeIterator)) {\n                    modified.add(treeWalk.getPathString());\n                    changesExist = true;\n                }\n            }\n        }\n    }\n    return changesExist;\n}"
    },
    {
      "commit": "f4e9c8890cc625ba57b5a3cd078ca14cbcc86f8b",
      "startLine": 12,
      "endLine": 12,
      "methodCode": "public boolean diff() throws IOException {\n    boolean changesExist = false;\n    DirCache dirCache = repository.readDirCache();\n    TreeWalk treeWalk = new TreeWalk(repository);\n    treeWalk.setRecursive(true);\n    if (tree != null)\n        treeWalk.addTree(tree);\n    else\n        treeWalk.addTree(new EmptyTreeIterator());\n    treeWalk.addTree(new DirCacheIterator(dirCache));\n    treeWalk.addTree(initialWorkingTreeIterator);\n    Collection<TreeFilter> filters = new ArrayList<TreeFilter>(4);\n    if (filter != null)\n        filters.add(filter);\n    filters.add(new NotIgnoredFilter(WORKDIR));\n    filters.add(new SkipWorkTreeFilter(INDEX));\n    filters.add(TreeFilter.ANY_DIFF);\n    treeWalk.setFilter(AndTreeFilter.create(filters));\n    while (treeWalk.next()) {\n        AbstractTreeIterator treeIterator = treeWalk.getTree(TREE, AbstractTreeIterator.class);\n        DirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX, DirCacheIterator.class);\n        WorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n        FileMode fileModeTree = treeWalk.getFileMode(TREE);\n        if (dirCacheIterator != null) {\n            if (dirCacheIterator.getDirCacheEntry().isAssumeValid())\n                assumeUnchanged.add(dirCacheIterator.getEntryPathString());\n        }\n        if (treeIterator != null) {\n            if (dirCacheIterator != null) {\n                if (!treeIterator.getEntryObjectId().equals(dirCacheIterator.getEntryObjectId())) {\n                    changed.add(dirCacheIterator.getEntryPathString());\n                    changesExist = true;\n                }\n            } else {\n                if (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n                    removed.add(treeIterator.getEntryPathString());\n                    changesExist = true;\n                    if (workingTreeIterator != null)\n                        untracked.add(workingTreeIterator.getEntryPathString());\n                }\n            }\n        } else {\n            if (dirCacheIterator != null) {\n                added.add(dirCacheIterator.getEntryPathString());\n                changesExist = true;\n            } else {\n                if (workingTreeIterator != null && !workingTreeIterator.isEntryIgnored()) {\n                    untracked.add(workingTreeIterator.getEntryPathString());\n                    changesExist = true;\n                }\n            }\n        }\n        if (dirCacheIterator != null) {\n            if (workingTreeIterator == null) {\n                missing.add(dirCacheIterator.getEntryPathString());\n                changesExist = true;\n            } else {\n                if (!dirCacheIterator.idEqual(workingTreeIterator)) {\n                    modified.add(dirCacheIterator.getEntryPathString());\n                    changesExist = true;\n                }\n            }\n        }\n    }\n    return changesExist;\n}"
    },
    {
      "commit": "a02be9725c9f83f0a0280a9a1f00e8d484825885",
      "startLine": 12,
      "endLine": 12,
      "methodCode": "public boolean diff() throws IOException {\n    boolean changesExist = false;\n    DirCache dirCache = repository.readDirCache();\n    TreeWalk treeWalk = new TreeWalk(repository);\n    treeWalk.setRecursive(true);\n    if (tree != null)\n        treeWalk.addTree(tree);\n    else\n        treeWalk.addTree(new EmptyTreeIterator());\n    treeWalk.addTree(new DirCacheIterator(dirCache));\n    treeWalk.addTree(initialWorkingTreeIterator);\n    Collection<TreeFilter> filters = new ArrayList<TreeFilter>(filter == null ? 3 : 4);\n    if (filter != null)\n        filters.add(filter);\n    filters.add(new NotIgnoredFilter(WORKDIR));\n    filters.add(new SkipWorkTreeFilter(INDEX));\n    filters.add(TreeFilter.ANY_DIFF);\n    treeWalk.setFilter(AndTreeFilter.create(filters));\n    while (treeWalk.next()) {\n        AbstractTreeIterator treeIterator = treeWalk.getTree(TREE, AbstractTreeIterator.class);\n        DirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX, DirCacheIterator.class);\n        WorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n        FileMode fileModeTree = treeWalk.getFileMode(TREE);\n        if (dirCacheIterator != null) {\n            if (dirCacheIterator.getDirCacheEntry().isAssumeValid())\n                assumeUnchanged.add(dirCacheIterator.getEntryPathString());\n        }\n        if (treeIterator != null) {\n            if (dirCacheIterator != null) {\n                if (!treeIterator.getEntryObjectId().equals(dirCacheIterator.getEntryObjectId())) {\n                    changed.add(dirCacheIterator.getEntryPathString());\n                    changesExist = true;\n                }\n            } else {\n                if (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n                    removed.add(treeIterator.getEntryPathString());\n                    changesExist = true;\n                    if (workingTreeIterator != null)\n                        untracked.add(workingTreeIterator.getEntryPathString());\n                }\n            }\n        } else {\n            if (dirCacheIterator != null) {\n                added.add(dirCacheIterator.getEntryPathString());\n                changesExist = true;\n            } else {\n                if (workingTreeIterator != null && !workingTreeIterator.isEntryIgnored()) {\n                    untracked.add(workingTreeIterator.getEntryPathString());\n                    changesExist = true;\n                }\n            }\n        }\n        if (dirCacheIterator != null) {\n            if (workingTreeIterator == null) {\n                missing.add(dirCacheIterator.getEntryPathString());\n                changesExist = true;\n            } else {\n                if (!dirCacheIterator.idEqual(workingTreeIterator)) {\n                    modified.add(dirCacheIterator.getEntryPathString());\n                    changesExist = true;\n                }\n            }\n        }\n    }\n    return changesExist;\n}"
    },
    {
      "commit": "b4359cb8294de1e80147f00caabad9ebd6b7bce1",
      "startLine": 13,
      "endLine": 13,
      "methodCode": "public boolean diff() throws IOException {\n    boolean changesExist = false;\n    DirCache dirCache = repository.readDirCache();\n    TreeWalk treeWalk = new TreeWalk(repository);\n    treeWalk.reset();\n    treeWalk.setRecursive(true);\n    if (tree != null)\n        treeWalk.addTree(tree);\n    else\n        treeWalk.addTree(new EmptyTreeIterator());\n    treeWalk.addTree(new DirCacheIterator(dirCache));\n    treeWalk.addTree(initialWorkingTreeIterator);\n    Collection<TreeFilter> filters = new ArrayList<TreeFilter>(filter == null ? 3 : 4);\n    if (filter != null)\n        filters.add(filter);\n    filters.add(new NotIgnoredFilter(WORKDIR));\n    filters.add(new SkipWorkTreeFilter(INDEX));\n    filters.add(TreeFilter.ANY_DIFF);\n    treeWalk.setFilter(AndTreeFilter.create(filters));\n    while (treeWalk.next()) {\n        AbstractTreeIterator treeIterator = treeWalk.getTree(TREE, AbstractTreeIterator.class);\n        DirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX, DirCacheIterator.class);\n        WorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n        FileMode fileModeTree = treeWalk.getFileMode(TREE);\n        if (dirCacheIterator != null) {\n            if (dirCacheIterator.getDirCacheEntry().isAssumeValid())\n                assumeUnchanged.add(dirCacheIterator.getEntryPathString());\n        }\n        if (treeIterator != null) {\n            if (dirCacheIterator != null) {\n                if (!treeIterator.getEntryObjectId().equals(dirCacheIterator.getEntryObjectId())) {\n                    changed.add(dirCacheIterator.getEntryPathString());\n                    changesExist = true;\n                }\n            } else {\n                if (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n                    removed.add(treeIterator.getEntryPathString());\n                    changesExist = true;\n                    if (workingTreeIterator != null)\n                        untracked.add(workingTreeIterator.getEntryPathString());\n                }\n            }\n        } else {\n            if (dirCacheIterator != null) {\n                added.add(dirCacheIterator.getEntryPathString());\n                changesExist = true;\n            } else {\n                if (workingTreeIterator != null && !workingTreeIterator.isEntryIgnored()) {\n                    untracked.add(workingTreeIterator.getEntryPathString());\n                    changesExist = true;\n                }\n            }\n        }\n        if (dirCacheIterator != null) {\n            if (workingTreeIterator == null) {\n                missing.add(dirCacheIterator.getEntryPathString());\n                changesExist = true;\n            } else {\n                if (!dirCacheIterator.idEqual(workingTreeIterator)) {\n                    modified.add(dirCacheIterator.getEntryPathString());\n                    changesExist = true;\n                }\n            }\n        }\n    }\n    return changesExist;\n}"
    },
    {
      "commit": "2dc2dd8b1b4c98b255b3f2dec655a3f0b197ce07",
      "startLine": 13,
      "endLine": 13,
      "methodCode": "public boolean diff() throws IOException {\n    boolean changesExist = false;\n    DirCache dirCache = repository.readDirCache();\n    TreeWalk treeWalk = new TreeWalk(repository);\n    treeWalk.reset();\n    treeWalk.setRecursive(true);\n    if (tree != null)\n        treeWalk.addTree(tree);\n    else\n        treeWalk.addTree(new EmptyTreeIterator());\n    treeWalk.addTree(new DirCacheIterator(dirCache));\n    treeWalk.addTree(initialWorkingTreeIterator);\n    Collection<TreeFilter> filters = new ArrayList<TreeFilter>(filter == null ? 3 : 4);\n    if (filter != null)\n        filters.add(filter);\n    filters.add(new NotIgnoredFilter(WORKDIR));\n    filters.add(new SkipWorkTreeFilter(INDEX));\n    filters.add(TreeFilter.ANY_DIFF);\n    treeWalk.setFilter(AndTreeFilter.create(filters));\n    while (treeWalk.next()) {\n        AbstractTreeIterator treeIterator = treeWalk.getTree(TREE, AbstractTreeIterator.class);\n        DirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX, DirCacheIterator.class);\n        WorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n        FileMode fileModeTree = treeWalk.getFileMode(TREE);\n        if (treeIterator != null) {\n            if (dirCacheIterator != null) {\n                if (!treeIterator.getEntryObjectId().equals(dirCacheIterator.getEntryObjectId())) {\n                    changed.add(dirCacheIterator.getEntryPathString());\n                    changesExist = true;\n                }\n            } else {\n                if (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n                    removed.add(treeIterator.getEntryPathString());\n                    changesExist = true;\n                    if (workingTreeIterator != null)\n                        untracked.add(workingTreeIterator.getEntryPathString());\n                }\n            }\n        } else {\n            if (dirCacheIterator != null) {\n                added.add(dirCacheIterator.getEntryPathString());\n                changesExist = true;\n            } else {\n                if (workingTreeIterator != null && !workingTreeIterator.isEntryIgnored()) {\n                    untracked.add(workingTreeIterator.getEntryPathString());\n                    changesExist = true;\n                }\n            }\n        }\n        if (dirCacheIterator != null) {\n            if (workingTreeIterator == null) {\n                missing.add(dirCacheIterator.getEntryPathString());\n                changesExist = true;\n            } else {\n                if (!dirCacheIterator.idEqual(workingTreeIterator)) {\n                    modified.add(dirCacheIterator.getEntryPathString());\n                    changesExist = true;\n                }\n            }\n        }\n    }\n    return changesExist;\n}"
    },
    {
      "commit": "6f3b089188ef4937ab4e9970b0987b061000831e",
      "startLine": 13,
      "endLine": 13,
      "methodCode": "public boolean diff() throws IOException {\n    boolean changesExist = false;\n    DirCache dirCache = repository.readDirCache();\n    TreeWalk treeWalk = new TreeWalk(repository);\n    treeWalk.reset();\n    treeWalk.setRecursive(true);\n    if (tree != null)\n        treeWalk.addTree(tree);\n    else\n        treeWalk.addTree(new EmptyTreeIterator());\n    treeWalk.addTree(new DirCacheIterator(dirCache));\n    treeWalk.addTree(initialWorkingTreeIterator);\n    Collection<TreeFilter> filters = new ArrayList<TreeFilter>(filter == null ? 3 : 4);\n    if (filter != null)\n        filters.add(filter);\n    filters.add(new NotIgnoredFilter(WORKDIR));\n    filters.add(new SkipWorkTreeFilter(INDEX));\n    filters.add(TreeFilter.ANY_DIFF);\n    treeWalk.setFilter(AndTreeFilter.create(filters));\n    while (treeWalk.next()) {\n        AbstractTreeIterator treeIterator = treeWalk.getTree(TREE, AbstractTreeIterator.class);\n        DirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX, DirCacheIterator.class);\n        WorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR, WorkingTreeIterator.class);\n        FileMode fileModeTree = treeWalk.getFileMode(TREE);\n        if (treeIterator != null) {\n            if (dirCacheIterator != null) {\n                if (!treeIterator.getEntryObjectId().equals(dirCacheIterator.getEntryObjectId())) {\n                    changed.add(dirCacheIterator.getEntryPathString());\n                    changesExist = true;\n                }\n            } else {\n                if (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n                    removed.add(treeIterator.getEntryPathString());\n                    changesExist = true;\n                }\n            }\n        } else {\n            if (dirCacheIterator != null) {\n                added.add(dirCacheIterator.getEntryPathString());\n                changesExist = true;\n            } else {\n                if (workingTreeIterator != null && !workingTreeIterator.isEntryIgnored()) {\n                    untracked.add(workingTreeIterator.getEntryPathString());\n                    changesExist = true;\n                }\n            }\n        }\n        if (dirCacheIterator != null) {\n            if (workingTreeIterator == null) {\n                missing.add(dirCacheIterator.getEntryPathString());\n                changesExist = true;\n            } else {\n                if (!dirCacheIterator.idEqual(workingTreeIterator)) {\n                    modified.add(dirCacheIterator.getEntryPathString());\n                    changesExist = true;\n                }\n            }\n        }\n    }\n    return changesExist;\n}"
    }
  ]
}