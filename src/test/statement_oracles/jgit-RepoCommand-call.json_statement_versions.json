{
  "statementVersions": [
    {
      "commit": "6658f367682932c0a77061a5aa37c06e480a0c62",
      "startLine": 124,
      "endLine": 136,
      "methodCode": "@Override\npublic RevCommit call() throws GitAPIException {\n    checkCallable();\n    if (baseUri == null) {\n        baseUri = \"\";\n    }\n    if (inputStream == null) {\n        if (manifestPath == null || manifestPath.length() == 0)\n            throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n        try {\n            inputStream = new FileInputStream(manifestPath);\n        } catch (IOException e) {\n            throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n        }\n    }\n    List<RepoProject> filteredProjects;\n    try {\n        ManifestParser parser = new ManifestParser(includedReader, manifestPath, branch, baseUri, groupsParam, repo);\n        parser.read(inputStream);\n        filteredProjects = parser.getFilteredProjects();\n    } catch (IOException e) {\n        throw new ManifestErrorException(e);\n    } finally {\n        try {\n            inputStream.close();\n        } catch (IOException e) {\n        }\n    }\n    if (repo.isBare()) {\n        if (author == null)\n            author = new PersonIdent(repo);\n        if (callback == null)\n            callback = new DefaultRemoteReader();\n        List<RepoProject> renamedProjects = renameProjects(filteredProjects);\n        DirCache index = DirCache.newInCore();\n        DirCacheBuilder builder = index.builder();\n        ObjectInserter inserter = repo.newObjectInserter();\n        try (RevWalk rw = new RevWalk(repo)) {\n            Config cfg = new Config();\n            StringBuilder attributes = new StringBuilder();\n            for (RepoProject proj : renamedProjects) {\n                String name = proj.getName();\n                String path = proj.getPath();\n                String url = proj.getUrl();\n                ObjectId objectId;\n                if (ObjectId.isId(proj.getRevision())) {\n                    objectId = ObjectId.fromString(proj.getRevision());\n                } else {\n                    objectId = callback.sha1(url, proj.getRevision());\n                    if (objectId == null && !ignoreRemoteFailures) {\n                        throw new RemoteUnavailableException(url);\n                    }\n                    if (recordRemoteBranch) {\n                        cfg.setString(\"submodule\", name, \"branch\", proj.getRevision());\n                    }\n                    if (recordShallowSubmodules && proj.getRecommendShallow() != null) {\n                        cfg.setBoolean(\"submodule\", name, \"shallow\", true);\n                    }\n                }\n                if (recordSubmoduleLabels) {\n                    StringBuilder rec = new StringBuilder();\n                    rec.append(\"/\");\n                    rec.append(path);\n                    for (String group : proj.getGroups()) {\n                        rec.append(\" \");\n                        rec.append(group);\n                    }\n                    rec.append(\"\\n\");\n                    attributes.append(rec.toString());\n                }\n                URI submodUrl = URI.create(url);\n                if (targetUri != null) {\n                    submodUrl = relativize(targetUri, submodUrl);\n                }\n                cfg.setString(\"submodule\", name, \"path\", path);\n                cfg.setString(\"submodule\", name, \"url\", submodUrl.toString());\n                if (objectId != null) {\n                    DirCacheEntry dcEntry = new DirCacheEntry(path);\n                    dcEntry.setObjectId(objectId);\n                    dcEntry.setFileMode(FileMode.GITLINK);\n                    builder.add(dcEntry);\n                    for (CopyFile copyfile : proj.getCopyFiles()) {\n                        byte[] src = callback.readFile(url, proj.getRevision(), copyfile.src);\n                        objectId = inserter.insert(Constants.OBJ_BLOB, src);\n                        dcEntry = new DirCacheEntry(copyfile.dest);\n                        dcEntry.setObjectId(objectId);\n                        dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                        builder.add(dcEntry);\n                    }\n                    for (LinkFile linkfile : proj.getLinkFiles()) {\n                        String link;\n                        if (linkfile.dest.contains(\"/\")) {\n                            link = FileUtils.relativizeGitPath(linkfile.dest.substring(0, linkfile.dest.lastIndexOf('/')), proj.getPath() + \"/\" + linkfile.src);\n                        } else {\n                            link = proj.getPath() + \"/\" + linkfile.src;\n                        }\n                        objectId = inserter.insert(Constants.OBJ_BLOB, link.getBytes(Constants.CHARACTER_ENCODING));\n                        dcEntry = new DirCacheEntry(linkfile.dest);\n                        dcEntry.setObjectId(objectId);\n                        dcEntry.setFileMode(FileMode.SYMLINK);\n                        builder.add(dcEntry);\n                    }\n                }\n            }\n            String content = cfg.toText();\n            final DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);\n            ObjectId objectId = inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n            dcEntry.setObjectId(objectId);\n            dcEntry.setFileMode(FileMode.REGULAR_FILE);\n            builder.add(dcEntry);\n            if (recordSubmoduleLabels) {\n                final DirCacheEntry dcEntryAttr = new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n                ObjectId attrId = inserter.insert(Constants.OBJ_BLOB, attributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n                dcEntryAttr.setObjectId(attrId);\n                dcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n                builder.add(dcEntryAttr);\n            }\n            builder.finish();\n            ObjectId treeId = index.writeTree(inserter);\n            ObjectId headId = repo.resolve(targetBranch + \"^{commit}\");\n            if (headId != null && rw.parseCommit(headId).getTree().getId().equals(treeId)) {\n                return rw.parseCommit(headId);\n            }\n            CommitBuilder commit = new CommitBuilder();\n            commit.setTreeId(treeId);\n            if (headId != null)\n                commit.setParentIds(headId);\n            commit.setAuthor(author);\n            commit.setCommitter(author);\n            commit.setMessage(RepoText.get().repoCommitMessage);\n            ObjectId commitId = inserter.insert(commit);\n            inserter.flush();\n            RefUpdate ru = repo.updateRef(targetBranch);\n            ru.setNewObjectId(commitId);\n            ru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());\n            Result rc = ru.update(rw);\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    break;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetBranch), ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetBranch, commitId.name(), rc));\n            }\n            return rw.parseCommit(commitId);\n        } catch (GitAPIException | IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } else {\n        try (Git git = new Git(repo)) {\n            for (RepoProject proj : filteredProjects) {\n                addSubmodule(proj.getName(), proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles(), proj.getLinkFiles(), git);\n            }\n            return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n        } catch (GitAPIException | IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    }\n}"
    },
    {
      "commit": "3214171decf596f003c154685638b01faba31ff3",
      "startLine": 126,
      "endLine": 138,
      "methodCode": "@Override\npublic RevCommit call() throws GitAPIException {\n    checkCallable();\n    if (baseUri == null) {\n        baseUri = \"\";\n    }\n    if (inputStream == null) {\n        if (manifestPath == null || manifestPath.length() == 0)\n            throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n        try {\n            inputStream = new FileInputStream(manifestPath);\n        } catch (IOException e) {\n            throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n        }\n    }\n    List<RepoProject> filteredProjects;\n    try {\n        ManifestParser parser = new ManifestParser(includedReader, manifestPath, branch, baseUri, groupsParam, repo);\n        parser.read(inputStream);\n        filteredProjects = parser.getFilteredProjects();\n    } catch (IOException e) {\n        throw new ManifestErrorException(e);\n    } finally {\n        try {\n            inputStream.close();\n        } catch (IOException e) {\n        }\n    }\n    if (repo.isBare()) {\n        bareProjects = new ArrayList<>();\n        if (author == null)\n            author = new PersonIdent(repo);\n        if (callback == null)\n            callback = new DefaultRemoteReader();\n        for (RepoProject proj : filteredProjects) {\n            addSubmoduleBare(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles(), proj.getLinkFiles(), proj.getGroups(), proj.getRecommendShallow());\n        }\n        DirCache index = DirCache.newInCore();\n        DirCacheBuilder builder = index.builder();\n        ObjectInserter inserter = repo.newObjectInserter();\n        try (RevWalk rw = new RevWalk(repo)) {\n            Config cfg = new Config();\n            StringBuilder attributes = new StringBuilder();\n            for (RepoProject proj : bareProjects) {\n                String path = proj.getPath();\n                String nameUri = proj.getName();\n                ObjectId objectId;\n                if (ObjectId.isId(proj.getRevision())) {\n                    objectId = ObjectId.fromString(proj.getRevision());\n                } else {\n                    objectId = callback.sha1(nameUri, proj.getRevision());\n                    if (objectId == null && !ignoreRemoteFailures) {\n                        throw new RemoteUnavailableException(nameUri);\n                    }\n                    if (recordRemoteBranch) {\n                        cfg.setString(\"submodule\", path, \"branch\", proj.getRevision());\n                    }\n                    if (recordShallowSubmodules && proj.getRecommendShallow() != null) {\n                        cfg.setBoolean(\"submodule\", path, \"shallow\", true);\n                    }\n                }\n                if (recordSubmoduleLabels) {\n                    StringBuilder rec = new StringBuilder();\n                    rec.append(\"/\");\n                    rec.append(path);\n                    for (String group : proj.getGroups()) {\n                        rec.append(\" \");\n                        rec.append(group);\n                    }\n                    rec.append(\"\\n\");\n                    attributes.append(rec.toString());\n                }\n                URI submodUrl = URI.create(nameUri);\n                if (targetUri != null) {\n                    submodUrl = relativize(targetUri, submodUrl);\n                }\n                cfg.setString(\"submodule\", path, \"path\", path);\n                cfg.setString(\"submodule\", path, \"url\", submodUrl.toString());\n                if (objectId != null) {\n                    DirCacheEntry dcEntry = new DirCacheEntry(path);\n                    dcEntry.setObjectId(objectId);\n                    dcEntry.setFileMode(FileMode.GITLINK);\n                    builder.add(dcEntry);\n                    for (CopyFile copyfile : proj.getCopyFiles()) {\n                        byte[] src = callback.readFile(nameUri, proj.getRevision(), copyfile.src);\n                        objectId = inserter.insert(Constants.OBJ_BLOB, src);\n                        dcEntry = new DirCacheEntry(copyfile.dest);\n                        dcEntry.setObjectId(objectId);\n                        dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                        builder.add(dcEntry);\n                    }\n                    for (LinkFile linkfile : proj.getLinkFiles()) {\n                        String link;\n                        if (linkfile.dest.contains(\"/\")) {\n                            link = FileUtils.relativizeGitPath(linkfile.dest.substring(0, linkfile.dest.lastIndexOf('/')), proj.getPath() + \"/\" + linkfile.src);\n                        } else {\n                            link = proj.getPath() + \"/\" + linkfile.src;\n                        }\n                        objectId = inserter.insert(Constants.OBJ_BLOB, link.getBytes(Constants.CHARACTER_ENCODING));\n                        dcEntry = new DirCacheEntry(linkfile.dest);\n                        dcEntry.setObjectId(objectId);\n                        dcEntry.setFileMode(FileMode.SYMLINK);\n                        builder.add(dcEntry);\n                    }\n                }\n            }\n            String content = cfg.toText();\n            final DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);\n            ObjectId objectId = inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n            dcEntry.setObjectId(objectId);\n            dcEntry.setFileMode(FileMode.REGULAR_FILE);\n            builder.add(dcEntry);\n            if (recordSubmoduleLabels) {\n                final DirCacheEntry dcEntryAttr = new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n                ObjectId attrId = inserter.insert(Constants.OBJ_BLOB, attributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n                dcEntryAttr.setObjectId(attrId);\n                dcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n                builder.add(dcEntryAttr);\n            }\n            builder.finish();\n            ObjectId treeId = index.writeTree(inserter);\n            ObjectId headId = repo.resolve(targetBranch + \"^{commit}\");\n            if (headId != null && rw.parseCommit(headId).getTree().getId().equals(treeId)) {\n                return rw.parseCommit(headId);\n            }\n            CommitBuilder commit = new CommitBuilder();\n            commit.setTreeId(treeId);\n            if (headId != null)\n                commit.setParentIds(headId);\n            commit.setAuthor(author);\n            commit.setCommitter(author);\n            commit.setMessage(RepoText.get().repoCommitMessage);\n            ObjectId commitId = inserter.insert(commit);\n            inserter.flush();\n            RefUpdate ru = repo.updateRef(targetBranch);\n            ru.setNewObjectId(commitId);\n            ru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());\n            Result rc = ru.update(rw);\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    break;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetBranch), ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetBranch, commitId.name(), rc));\n            }\n            return rw.parseCommit(commitId);\n        } catch (GitAPIException | IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } else {\n        try (Git git = new Git(repo)) {\n            for (RepoProject proj : filteredProjects) {\n                addSubmodule(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles(), proj.getLinkFiles(), git);\n            }\n            return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n        } catch (GitAPIException | IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    }\n}"
    },
    {
      "commit": "446a7096ef01c0e3bb56736403d91b125b2ee6ba",
      "startLine": 123,
      "endLine": 135,
      "methodCode": "@Override\npublic RevCommit call() throws GitAPIException {\n    checkCallable();\n    if (baseUri == null) {\n        baseUri = \"\";\n    }\n    if (inputStream == null) {\n        if (manifestPath == null || manifestPath.length() == 0)\n            throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n        try {\n            inputStream = new FileInputStream(manifestPath);\n        } catch (IOException e) {\n            throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n        }\n    }\n    List<RepoProject> filteredProjects;\n    try {\n        ManifestParser parser = new ManifestParser(includedReader, manifestPath, branch, baseUri, groupsParam, repo);\n        parser.read(inputStream);\n        filteredProjects = parser.getFilteredProjects();\n    } catch (IOException e) {\n        throw new ManifestErrorException(e);\n    } finally {\n        try {\n            inputStream.close();\n        } catch (IOException e) {\n        }\n    }\n    if (repo.isBare()) {\n        bareProjects = new ArrayList<>();\n        if (author == null)\n            author = new PersonIdent(repo);\n        if (callback == null)\n            callback = new DefaultRemoteReader();\n        for (RepoProject proj : filteredProjects) {\n            addSubmoduleBare(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles(), proj.getLinkFiles(), proj.getGroups(), proj.getRecommendShallow());\n        }\n        DirCache index = DirCache.newInCore();\n        DirCacheBuilder builder = index.builder();\n        ObjectInserter inserter = repo.newObjectInserter();\n        try (RevWalk rw = new RevWalk(repo)) {\n            Config cfg = new Config();\n            StringBuilder attributes = new StringBuilder();\n            for (RepoProject proj : bareProjects) {\n                String path = proj.getPath();\n                String nameUri = proj.getName();\n                ObjectId objectId;\n                if (ObjectId.isId(proj.getRevision())) {\n                    objectId = ObjectId.fromString(proj.getRevision());\n                } else {\n                    objectId = callback.sha1(nameUri, proj.getRevision());\n                    if (objectId == null && !ignoreRemoteFailures) {\n                        throw new RemoteUnavailableException(nameUri);\n                    }\n                    if (recordRemoteBranch) {\n                        cfg.setString(\"submodule\", path, \"branch\", proj.getRevision());\n                    }\n                    if (recordShallowSubmodules && proj.getRecommendShallow() != null) {\n                        cfg.setBoolean(\"submodule\", path, \"shallow\", true);\n                    }\n                }\n                if (recordSubmoduleLabels) {\n                    StringBuilder rec = new StringBuilder();\n                    rec.append(\"/\");\n                    rec.append(path);\n                    for (String group : proj.getGroups()) {\n                        rec.append(\" \");\n                        rec.append(group);\n                    }\n                    rec.append(\"\\n\");\n                    attributes.append(rec.toString());\n                }\n                URI submodUrl = URI.create(nameUri);\n                if (targetUri != null) {\n                    submodUrl = relativize(targetUri, submodUrl);\n                }\n                cfg.setString(\"submodule\", path, \"path\", path);\n                cfg.setString(\"submodule\", path, \"url\", submodUrl.toString());\n                if (objectId != null) {\n                    DirCacheEntry dcEntry = new DirCacheEntry(path);\n                    dcEntry.setObjectId(objectId);\n                    dcEntry.setFileMode(FileMode.GITLINK);\n                    builder.add(dcEntry);\n                    for (CopyFile copyfile : proj.getCopyFiles()) {\n                        byte[] src = callback.readFile(nameUri, proj.getRevision(), copyfile.src);\n                        objectId = inserter.insert(Constants.OBJ_BLOB, src);\n                        dcEntry = new DirCacheEntry(copyfile.dest);\n                        dcEntry.setObjectId(objectId);\n                        dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                        builder.add(dcEntry);\n                    }\n                    for (LinkFile linkfile : proj.getLinkFiles()) {\n                        String link;\n                        if (linkfile.dest.contains(\"/\")) {\n                            link = FileUtils.relativizeGitPath(linkfile.dest.substring(0, linkfile.dest.lastIndexOf('/')), proj.getPath() + \"/\" + linkfile.src);\n                        } else {\n                            link = proj.getPath() + \"/\" + linkfile.src;\n                        }\n                        objectId = inserter.insert(Constants.OBJ_BLOB, link.getBytes(Constants.CHARACTER_ENCODING));\n                        dcEntry = new DirCacheEntry(linkfile.dest);\n                        dcEntry.setObjectId(objectId);\n                        dcEntry.setFileMode(FileMode.SYMLINK);\n                        builder.add(dcEntry);\n                    }\n                }\n            }\n            String content = cfg.toText();\n            final DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);\n            ObjectId objectId = inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n            dcEntry.setObjectId(objectId);\n            dcEntry.setFileMode(FileMode.REGULAR_FILE);\n            builder.add(dcEntry);\n            if (recordSubmoduleLabels) {\n                final DirCacheEntry dcEntryAttr = new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n                ObjectId attrId = inserter.insert(Constants.OBJ_BLOB, attributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n                dcEntryAttr.setObjectId(attrId);\n                dcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n                builder.add(dcEntryAttr);\n            }\n            builder.finish();\n            ObjectId treeId = index.writeTree(inserter);\n            ObjectId headId = repo.resolve(targetBranch + \"^{commit}\");\n            CommitBuilder commit = new CommitBuilder();\n            commit.setTreeId(treeId);\n            if (headId != null)\n                commit.setParentIds(headId);\n            commit.setAuthor(author);\n            commit.setCommitter(author);\n            commit.setMessage(RepoText.get().repoCommitMessage);\n            ObjectId commitId = inserter.insert(commit);\n            inserter.flush();\n            RefUpdate ru = repo.updateRef(targetBranch);\n            ru.setNewObjectId(commitId);\n            ru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());\n            Result rc = ru.update(rw);\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    break;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetBranch), ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetBranch, commitId.name(), rc));\n            }\n            return rw.parseCommit(commitId);\n        } catch (GitAPIException | IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } else {\n        try (Git git = new Git(repo)) {\n            for (RepoProject proj : filteredProjects) {\n                addSubmodule(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles(), proj.getLinkFiles(), git);\n            }\n            return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n        } catch (GitAPIException | IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    }\n}"
    },
    {
      "commit": "9bebb1eae78401e1d3289dc3d84006c10d10c0ef",
      "startLine": 124,
      "endLine": 136,
      "methodCode": "@Override\npublic RevCommit call() throws GitAPIException {\n    checkCallable();\n    if (baseUri == null) {\n        baseUri = \"\";\n    }\n    if (inputStream == null) {\n        if (manifestPath == null || manifestPath.length() == 0)\n            throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n        try {\n            inputStream = new FileInputStream(manifestPath);\n        } catch (IOException e) {\n            throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n        }\n    }\n    List<RepoProject> filteredProjects;\n    try {\n        ManifestParser parser = new ManifestParser(includedReader, manifestPath, branch, baseUri, groupsParam, repo);\n        parser.read(inputStream);\n        filteredProjects = parser.getFilteredProjects();\n    } catch (IOException e) {\n        throw new ManifestErrorException(e);\n    } finally {\n        try {\n            inputStream.close();\n        } catch (IOException e) {\n        }\n    }\n    if (repo.isBare()) {\n        bareProjects = new ArrayList<>();\n        if (author == null)\n            author = new PersonIdent(repo);\n        if (callback == null)\n            callback = new DefaultRemoteReader();\n        for (RepoProject proj : filteredProjects) {\n            addSubmoduleBare(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles(), proj.getLinkFiles(), proj.getGroups(), proj.getRecommendShallow());\n        }\n        DirCache index = DirCache.newInCore();\n        DirCacheBuilder builder = index.builder();\n        ObjectInserter inserter = repo.newObjectInserter();\n        try (RevWalk rw = new RevWalk(repo)) {\n            Config cfg = new Config();\n            StringBuilder attributes = new StringBuilder();\n            for (RepoProject proj : bareProjects) {\n                String path = proj.getPath();\n                String nameUri = proj.getName();\n                ObjectId objectId;\n                if (ObjectId.isId(proj.getRevision())) {\n                    objectId = ObjectId.fromString(proj.getRevision());\n                } else {\n                    objectId = callback.sha1(nameUri, proj.getRevision());\n                    if (objectId == null) {\n                        if (ignoreRemoteFailures) {\n                            continue;\n                        }\n                        throw new RemoteUnavailableException(nameUri);\n                    }\n                    if (recordRemoteBranch) {\n                        cfg.setString(\"submodule\", path, \"branch\", proj.getRevision());\n                    }\n                    if (recordShallowSubmodules && proj.getRecommendShallow() != null) {\n                        cfg.setBoolean(\"submodule\", path, \"shallow\", true);\n                    }\n                }\n                if (recordSubmoduleLabels) {\n                    StringBuilder rec = new StringBuilder();\n                    rec.append(\"/\");\n                    rec.append(path);\n                    for (String group : proj.getGroups()) {\n                        rec.append(\" \");\n                        rec.append(group);\n                    }\n                    rec.append(\"\\n\");\n                    attributes.append(rec.toString());\n                }\n                URI submodUrl = URI.create(nameUri);\n                if (targetUri != null) {\n                    submodUrl = relativize(targetUri, submodUrl);\n                }\n                cfg.setString(\"submodule\", path, \"path\", path);\n                cfg.setString(\"submodule\", path, \"url\", submodUrl.toString());\n                DirCacheEntry dcEntry = new DirCacheEntry(path);\n                dcEntry.setObjectId(objectId);\n                dcEntry.setFileMode(FileMode.GITLINK);\n                builder.add(dcEntry);\n                for (CopyFile copyfile : proj.getCopyFiles()) {\n                    byte[] src = callback.readFile(nameUri, proj.getRevision(), copyfile.src);\n                    objectId = inserter.insert(Constants.OBJ_BLOB, src);\n                    dcEntry = new DirCacheEntry(copyfile.dest);\n                    dcEntry.setObjectId(objectId);\n                    dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                    builder.add(dcEntry);\n                }\n                for (LinkFile linkfile : proj.getLinkFiles()) {\n                    String link;\n                    if (linkfile.dest.contains(\"/\")) {\n                        link = FileUtils.relativizeGitPath(linkfile.dest.substring(0, linkfile.dest.lastIndexOf('/')), proj.getPath() + \"/\" + linkfile.src);\n                    } else {\n                        link = proj.getPath() + \"/\" + linkfile.src;\n                    }\n                    objectId = inserter.insert(Constants.OBJ_BLOB, link.getBytes(Constants.CHARACTER_ENCODING));\n                    dcEntry = new DirCacheEntry(linkfile.dest);\n                    dcEntry.setObjectId(objectId);\n                    dcEntry.setFileMode(FileMode.SYMLINK);\n                    builder.add(dcEntry);\n                }\n            }\n            String content = cfg.toText();\n            final DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);\n            ObjectId objectId = inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n            dcEntry.setObjectId(objectId);\n            dcEntry.setFileMode(FileMode.REGULAR_FILE);\n            builder.add(dcEntry);\n            if (recordSubmoduleLabels) {\n                final DirCacheEntry dcEntryAttr = new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n                ObjectId attrId = inserter.insert(Constants.OBJ_BLOB, attributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n                dcEntryAttr.setObjectId(attrId);\n                dcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n                builder.add(dcEntryAttr);\n            }\n            builder.finish();\n            ObjectId treeId = index.writeTree(inserter);\n            ObjectId headId = repo.resolve(targetBranch + \"^{commit}\");\n            CommitBuilder commit = new CommitBuilder();\n            commit.setTreeId(treeId);\n            if (headId != null)\n                commit.setParentIds(headId);\n            commit.setAuthor(author);\n            commit.setCommitter(author);\n            commit.setMessage(RepoText.get().repoCommitMessage);\n            ObjectId commitId = inserter.insert(commit);\n            inserter.flush();\n            RefUpdate ru = repo.updateRef(targetBranch);\n            ru.setNewObjectId(commitId);\n            ru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());\n            Result rc = ru.update(rw);\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    break;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetBranch), ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetBranch, commitId.name(), rc));\n            }\n            return rw.parseCommit(commitId);\n        } catch (GitAPIException | IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } else {\n        try (Git git = new Git(repo)) {\n            for (RepoProject proj : filteredProjects) {\n                addSubmodule(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles(), proj.getLinkFiles(), git);\n            }\n            return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n        } catch (GitAPIException | IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    }\n}"
    },
    {
      "commit": "5e2e111280898e47959996a1a1e016e9fcb21179",
      "startLine": 128,
      "endLine": 140,
      "methodCode": "@Override\npublic RevCommit call() throws GitAPIException {\n    try {\n        checkCallable();\n        if (baseUri == null) {\n            baseUri = \"\";\n        }\n        if (inputStream == null) {\n            if (manifestPath == null || manifestPath.length() == 0)\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            try {\n                inputStream = new FileInputStream(manifestPath);\n            } catch (IOException e) {\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            }\n        }\n        if (repo.isBare()) {\n            bareProjects = new ArrayList<>();\n            if (author == null)\n                author = new PersonIdent(repo);\n            if (callback == null)\n                callback = new DefaultRemoteReader();\n        } else\n            git = new Git(repo);\n        ManifestParser parser = new ManifestParser(includedReader, manifestPath, branch, baseUri, groupsParam, repo);\n        try {\n            parser.read(inputStream);\n            for (RepoProject proj : parser.getFilteredProjects()) {\n                addSubmodule(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles(), proj.getLinkFiles(), proj.getGroups(), proj.getRecommendShallow());\n            }\n        } catch (GitAPIException | IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } finally {\n        try {\n            if (inputStream != null)\n                inputStream.close();\n        } catch (IOException e) {\n        }\n    }\n    if (repo.isBare()) {\n        DirCache index = DirCache.newInCore();\n        DirCacheBuilder builder = index.builder();\n        ObjectInserter inserter = repo.newObjectInserter();\n        try (RevWalk rw = new RevWalk(repo)) {\n            Config cfg = new Config();\n            StringBuilder attributes = new StringBuilder();\n            for (RepoProject proj : bareProjects) {\n                String path = proj.getPath();\n                String nameUri = proj.getName();\n                ObjectId objectId;\n                if (ObjectId.isId(proj.getRevision())) {\n                    objectId = ObjectId.fromString(proj.getRevision());\n                } else {\n                    objectId = callback.sha1(nameUri, proj.getRevision());\n                    if (objectId == null) {\n                        if (ignoreRemoteFailures) {\n                            continue;\n                        }\n                        throw new RemoteUnavailableException(nameUri);\n                    }\n                    if (recordRemoteBranch) {\n                        cfg.setString(\"submodule\", path, \"branch\", proj.getRevision());\n                    }\n                    if (recordShallowSubmodules && proj.getRecommendShallow() != null) {\n                        cfg.setBoolean(\"submodule\", path, \"shallow\", true);\n                    }\n                }\n                if (recordSubmoduleLabels) {\n                    StringBuilder rec = new StringBuilder();\n                    rec.append(\"/\");\n                    rec.append(path);\n                    for (String group : proj.getGroups()) {\n                        rec.append(\" \");\n                        rec.append(group);\n                    }\n                    rec.append(\"\\n\");\n                    attributes.append(rec.toString());\n                }\n                URI submodUrl = URI.create(nameUri);\n                if (targetUri != null) {\n                    submodUrl = relativize(targetUri, submodUrl);\n                }\n                cfg.setString(\"submodule\", path, \"path\", path);\n                cfg.setString(\"submodule\", path, \"url\", submodUrl.toString());\n                DirCacheEntry dcEntry = new DirCacheEntry(path);\n                dcEntry.setObjectId(objectId);\n                dcEntry.setFileMode(FileMode.GITLINK);\n                builder.add(dcEntry);\n                for (CopyFile copyfile : proj.getCopyFiles()) {\n                    byte[] src = callback.readFile(nameUri, proj.getRevision(), copyfile.src);\n                    objectId = inserter.insert(Constants.OBJ_BLOB, src);\n                    dcEntry = new DirCacheEntry(copyfile.dest);\n                    dcEntry.setObjectId(objectId);\n                    dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                    builder.add(dcEntry);\n                }\n                for (LinkFile linkfile : proj.getLinkFiles()) {\n                    String link;\n                    if (linkfile.dest.contains(\"/\")) {\n                        link = FileUtils.relativizeGitPath(linkfile.dest.substring(0, linkfile.dest.lastIndexOf('/')), proj.getPath() + \"/\" + linkfile.src);\n                    } else {\n                        link = proj.getPath() + \"/\" + linkfile.src;\n                    }\n                    objectId = inserter.insert(Constants.OBJ_BLOB, link.getBytes(Constants.CHARACTER_ENCODING));\n                    dcEntry = new DirCacheEntry(linkfile.dest);\n                    dcEntry.setObjectId(objectId);\n                    dcEntry.setFileMode(FileMode.SYMLINK);\n                    builder.add(dcEntry);\n                }\n            }\n            String content = cfg.toText();\n            final DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);\n            ObjectId objectId = inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n            dcEntry.setObjectId(objectId);\n            dcEntry.setFileMode(FileMode.REGULAR_FILE);\n            builder.add(dcEntry);\n            if (recordSubmoduleLabels) {\n                final DirCacheEntry dcEntryAttr = new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n                ObjectId attrId = inserter.insert(Constants.OBJ_BLOB, attributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n                dcEntryAttr.setObjectId(attrId);\n                dcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n                builder.add(dcEntryAttr);\n            }\n            builder.finish();\n            ObjectId treeId = index.writeTree(inserter);\n            ObjectId headId = repo.resolve(targetBranch + \"^{commit}\");\n            CommitBuilder commit = new CommitBuilder();\n            commit.setTreeId(treeId);\n            if (headId != null)\n                commit.setParentIds(headId);\n            commit.setAuthor(author);\n            commit.setCommitter(author);\n            commit.setMessage(RepoText.get().repoCommitMessage);\n            ObjectId commitId = inserter.insert(commit);\n            inserter.flush();\n            RefUpdate ru = repo.updateRef(targetBranch);\n            ru.setNewObjectId(commitId);\n            ru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());\n            Result rc = ru.update(rw);\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    break;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetBranch), ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetBranch, commitId.name(), rc));\n            }\n            return rw.parseCommit(commitId);\n        } catch (IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } else {\n        return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n    }\n}"
    },
    {
      "commit": "04b8168beb5fb9c7d4e9768cc99a82d0e6176dc2",
      "startLine": 128,
      "endLine": 140,
      "methodCode": "@Override\npublic RevCommit call() throws GitAPIException {\n    try {\n        checkCallable();\n        if (baseUri == null) {\n            baseUri = \"\";\n        }\n        if (inputStream == null) {\n            if (manifestPath == null || manifestPath.length() == 0)\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            try {\n                inputStream = new FileInputStream(manifestPath);\n            } catch (IOException e) {\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            }\n        }\n        if (repo.isBare()) {\n            bareProjects = new ArrayList<>();\n            if (author == null)\n                author = new PersonIdent(repo);\n            if (callback == null)\n                callback = new DefaultRemoteReader();\n        } else\n            git = new Git(repo);\n        ManifestParser parser = new ManifestParser(includedReader, manifestPath, branch, baseUri, groupsParam, repo);\n        try {\n            parser.read(inputStream);\n            for (RepoProject proj : parser.getFilteredProjects()) {\n                addSubmodule(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles(), proj.getLinkFiles(), proj.getGroups(), proj.getRecommendShallow());\n            }\n        } catch (GitAPIException | IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } finally {\n        try {\n            if (inputStream != null)\n                inputStream.close();\n        } catch (IOException e) {\n        }\n    }\n    if (repo.isBare()) {\n        DirCache index = DirCache.newInCore();\n        DirCacheBuilder builder = index.builder();\n        ObjectInserter inserter = repo.newObjectInserter();\n        try (RevWalk rw = new RevWalk(repo)) {\n            Config cfg = new Config();\n            StringBuilder attributes = new StringBuilder();\n            for (RepoProject proj : bareProjects) {\n                String path = proj.getPath();\n                String nameUri = proj.getName();\n                ObjectId objectId;\n                if (ObjectId.isId(proj.getRevision())) {\n                    objectId = ObjectId.fromString(proj.getRevision());\n                } else {\n                    objectId = callback.sha1(nameUri, proj.getRevision());\n                    if (objectId == null) {\n                        if (ignoreRemoteFailures) {\n                            continue;\n                        }\n                        throw new RemoteUnavailableException(nameUri);\n                    }\n                    if (recordRemoteBranch) {\n                        cfg.setString(\"submodule\", path, \"branch\", proj.getRevision());\n                    }\n                    if (recordShallowSubmodules && proj.getRecommendShallow() != null) {\n                        cfg.setBoolean(\"submodule\", path, \"shallow\", true);\n                    }\n                }\n                if (recordSubmoduleLabels) {\n                    StringBuilder rec = new StringBuilder();\n                    rec.append(\"/\");\n                    rec.append(path);\n                    for (String group : proj.getGroups()) {\n                        rec.append(\" \");\n                        rec.append(group);\n                    }\n                    rec.append(\"\\n\");\n                    attributes.append(rec.toString());\n                }\n                URI submodUrl = URI.create(nameUri);\n                if (targetUri != null) {\n                    submodUrl = relativize(targetUri, submodUrl);\n                }\n                cfg.setString(\"submodule\", path, \"path\", path);\n                cfg.setString(\"submodule\", path, \"url\", submodUrl.toString());\n                DirCacheEntry dcEntry = new DirCacheEntry(path);\n                dcEntry.setObjectId(objectId);\n                dcEntry.setFileMode(FileMode.GITLINK);\n                builder.add(dcEntry);\n                for (CopyFile copyfile : proj.getCopyFiles()) {\n                    byte[] src = callback.readFile(nameUri, proj.getRevision(), copyfile.src);\n                    objectId = inserter.insert(Constants.OBJ_BLOB, src);\n                    dcEntry = new DirCacheEntry(copyfile.dest);\n                    dcEntry.setObjectId(objectId);\n                    dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                    builder.add(dcEntry);\n                }\n                for (LinkFile linkfile : proj.getLinkFiles()) {\n                    String link;\n                    if (linkfile.dest.contains(\"/\")) {\n                        link = FileUtils.relativizeGitPath(linkfile.dest.substring(0, linkfile.dest.lastIndexOf('/')), proj.getPath() + \"/\" + linkfile.src);\n                    } else {\n                        link = proj.getPath() + \"/\" + linkfile.src;\n                    }\n                    objectId = inserter.insert(Constants.OBJ_BLOB, link.getBytes(Constants.CHARACTER_ENCODING));\n                    dcEntry = new DirCacheEntry(linkfile.dest);\n                    dcEntry.setObjectId(objectId);\n                    dcEntry.setFileMode(FileMode.SYMLINK);\n                    builder.add(dcEntry);\n                }\n            }\n            String content = cfg.toText();\n            final DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);\n            ObjectId objectId = inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n            dcEntry.setObjectId(objectId);\n            dcEntry.setFileMode(FileMode.REGULAR_FILE);\n            builder.add(dcEntry);\n            if (recordSubmoduleLabels) {\n                final DirCacheEntry dcEntryAttr = new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n                ObjectId attrId = inserter.insert(Constants.OBJ_BLOB, attributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n                dcEntryAttr.setObjectId(attrId);\n                dcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n                builder.add(dcEntryAttr);\n            }\n            builder.finish();\n            ObjectId treeId = index.writeTree(inserter);\n            ObjectId headId = repo.resolve(targetBranch + \"^{commit}\");\n            CommitBuilder commit = new CommitBuilder();\n            commit.setTreeId(treeId);\n            if (headId != null)\n                commit.setParentIds(headId);\n            commit.setAuthor(author);\n            commit.setCommitter(author);\n            commit.setMessage(RepoText.get().repoCommitMessage);\n            ObjectId commitId = inserter.insert(commit);\n            inserter.flush();\n            RefUpdate ru = repo.updateRef(targetBranch);\n            ru.setNewObjectId(commitId);\n            ru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());\n            Result rc = ru.update(rw);\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    break;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetBranch), ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetBranch, commitId.name(), rc));\n            }\n            return rw.parseCommit(commitId);\n        } catch (IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } else {\n        return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n    }\n}"
    },
    {
      "commit": "b6fc8e2f3cb1af6f7cbc624acfac01bec002baf8",
      "startLine": 128,
      "endLine": 140,
      "methodCode": "@Override\npublic RevCommit call() throws GitAPIException {\n    try {\n        checkCallable();\n        if (baseUri == null) {\n            baseUri = \"\";\n        }\n        if (inputStream == null) {\n            if (manifestPath == null || manifestPath.length() == 0)\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            try {\n                inputStream = new FileInputStream(manifestPath);\n            } catch (IOException e) {\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            }\n        }\n        if (repo.isBare()) {\n            bareProjects = new ArrayList<>();\n            if (author == null)\n                author = new PersonIdent(repo);\n            if (callback == null)\n                callback = new DefaultRemoteReader();\n        } else\n            git = new Git(repo);\n        ManifestParser parser = new ManifestParser(includedReader, manifestPath, branch, baseUri, groupsParam, repo);\n        try {\n            parser.read(inputStream);\n            for (RepoProject proj : parser.getFilteredProjects()) {\n                addSubmodule(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles(), proj.getLinkFiles(), proj.getGroups(), proj.getRecommendShallow());\n            }\n        } catch (GitAPIException | IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } finally {\n        try {\n            if (inputStream != null)\n                inputStream.close();\n        } catch (IOException e) {\n        }\n    }\n    if (repo.isBare()) {\n        DirCache index = DirCache.newInCore();\n        DirCacheBuilder builder = index.builder();\n        ObjectInserter inserter = repo.newObjectInserter();\n        try (RevWalk rw = new RevWalk(repo)) {\n            Config cfg = new Config();\n            StringBuilder attributes = new StringBuilder();\n            for (RepoProject proj : bareProjects) {\n                String path = proj.getPath();\n                String nameUri = proj.getName();\n                ObjectId objectId;\n                if (ObjectId.isId(proj.getRevision()) && !ignoreRemoteFailures) {\n                    objectId = ObjectId.fromString(proj.getRevision());\n                } else {\n                    objectId = callback.sha1(nameUri, proj.getRevision());\n                    if (objectId == null) {\n                        if (ignoreRemoteFailures) {\n                            continue;\n                        }\n                        throw new RemoteUnavailableException(nameUri);\n                    }\n                    if (recordRemoteBranch) {\n                        cfg.setString(\"submodule\", path, \"branch\", proj.getRevision());\n                    }\n                    if (recordShallowSubmodules && proj.getRecommendShallow() != null) {\n                        cfg.setBoolean(\"submodule\", path, \"shallow\", true);\n                    }\n                }\n                if (recordSubmoduleLabels) {\n                    StringBuilder rec = new StringBuilder();\n                    rec.append(\"/\");\n                    rec.append(path);\n                    for (String group : proj.getGroups()) {\n                        rec.append(\" \");\n                        rec.append(group);\n                    }\n                    rec.append(\"\\n\");\n                    attributes.append(rec.toString());\n                }\n                URI submodUrl = URI.create(nameUri);\n                if (targetUri != null) {\n                    submodUrl = relativize(targetUri, submodUrl);\n                }\n                cfg.setString(\"submodule\", path, \"path\", path);\n                cfg.setString(\"submodule\", path, \"url\", submodUrl.toString());\n                DirCacheEntry dcEntry = new DirCacheEntry(path);\n                dcEntry.setObjectId(objectId);\n                dcEntry.setFileMode(FileMode.GITLINK);\n                builder.add(dcEntry);\n                for (CopyFile copyfile : proj.getCopyFiles()) {\n                    byte[] src = callback.readFile(nameUri, proj.getRevision(), copyfile.src);\n                    objectId = inserter.insert(Constants.OBJ_BLOB, src);\n                    dcEntry = new DirCacheEntry(copyfile.dest);\n                    dcEntry.setObjectId(objectId);\n                    dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                    builder.add(dcEntry);\n                }\n                for (LinkFile linkfile : proj.getLinkFiles()) {\n                    String link;\n                    if (linkfile.dest.contains(\"/\")) {\n                        link = FileUtils.relativizeGitPath(linkfile.dest.substring(0, linkfile.dest.lastIndexOf('/')), proj.getPath() + \"/\" + linkfile.src);\n                    } else {\n                        link = proj.getPath() + \"/\" + linkfile.src;\n                    }\n                    objectId = inserter.insert(Constants.OBJ_BLOB, link.getBytes(Constants.CHARACTER_ENCODING));\n                    dcEntry = new DirCacheEntry(linkfile.dest);\n                    dcEntry.setObjectId(objectId);\n                    dcEntry.setFileMode(FileMode.SYMLINK);\n                    builder.add(dcEntry);\n                }\n            }\n            String content = cfg.toText();\n            final DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);\n            ObjectId objectId = inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n            dcEntry.setObjectId(objectId);\n            dcEntry.setFileMode(FileMode.REGULAR_FILE);\n            builder.add(dcEntry);\n            if (recordSubmoduleLabels) {\n                final DirCacheEntry dcEntryAttr = new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n                ObjectId attrId = inserter.insert(Constants.OBJ_BLOB, attributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n                dcEntryAttr.setObjectId(attrId);\n                dcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n                builder.add(dcEntryAttr);\n            }\n            builder.finish();\n            ObjectId treeId = index.writeTree(inserter);\n            ObjectId headId = repo.resolve(targetBranch + \"^{commit}\");\n            CommitBuilder commit = new CommitBuilder();\n            commit.setTreeId(treeId);\n            if (headId != null)\n                commit.setParentIds(headId);\n            commit.setAuthor(author);\n            commit.setCommitter(author);\n            commit.setMessage(RepoText.get().repoCommitMessage);\n            ObjectId commitId = inserter.insert(commit);\n            inserter.flush();\n            RefUpdate ru = repo.updateRef(targetBranch);\n            ru.setNewObjectId(commitId);\n            ru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());\n            Result rc = ru.update(rw);\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    break;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetBranch), ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetBranch, commitId.name(), rc));\n            }\n            return rw.parseCommit(commitId);\n        } catch (IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } else {\n        return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n    }\n}"
    },
    {
      "commit": "fe5437e96b91222e30d9105e7bab490fd68c2d52",
      "startLine": 115,
      "endLine": 127,
      "methodCode": "@Override\npublic RevCommit call() throws GitAPIException {\n    try {\n        checkCallable();\n        if (baseUri == null) {\n            baseUri = \"\";\n        }\n        if (inputStream == null) {\n            if (manifestPath == null || manifestPath.length() == 0)\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            try {\n                inputStream = new FileInputStream(manifestPath);\n            } catch (IOException e) {\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            }\n        }\n        if (repo.isBare()) {\n            bareProjects = new ArrayList<>();\n            if (author == null)\n                author = new PersonIdent(repo);\n            if (callback == null)\n                callback = new DefaultRemoteReader();\n        } else\n            git = new Git(repo);\n        ManifestParser parser = new ManifestParser(includedReader, manifestPath, branch, baseUri, groupsParam, repo);\n        try {\n            parser.read(inputStream);\n            for (RepoProject proj : parser.getFilteredProjects()) {\n                addSubmodule(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles(), proj.getGroups(), proj.getRecommendShallow());\n            }\n        } catch (GitAPIException | IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } finally {\n        try {\n            if (inputStream != null)\n                inputStream.close();\n        } catch (IOException e) {\n        }\n    }\n    if (repo.isBare()) {\n        DirCache index = DirCache.newInCore();\n        DirCacheBuilder builder = index.builder();\n        ObjectInserter inserter = repo.newObjectInserter();\n        try (RevWalk rw = new RevWalk(repo)) {\n            Config cfg = new Config();\n            StringBuilder attributes = new StringBuilder();\n            for (RepoProject proj : bareProjects) {\n                String path = proj.getPath();\n                String nameUri = proj.getName();\n                ObjectId objectId;\n                if (ObjectId.isId(proj.getRevision()) && !ignoreRemoteFailures) {\n                    objectId = ObjectId.fromString(proj.getRevision());\n                } else {\n                    objectId = callback.sha1(nameUri, proj.getRevision());\n                    if (objectId == null) {\n                        if (ignoreRemoteFailures) {\n                            continue;\n                        }\n                        throw new RemoteUnavailableException(nameUri);\n                    }\n                    if (recordRemoteBranch) {\n                        cfg.setString(\"submodule\", path, \"branch\", proj.getRevision());\n                    }\n                    if (recordShallowSubmodules && proj.getRecommendShallow() != null) {\n                        cfg.setBoolean(\"submodule\", path, \"shallow\", true);\n                    }\n                }\n                if (recordSubmoduleLabels) {\n                    StringBuilder rec = new StringBuilder();\n                    rec.append(\"/\");\n                    rec.append(path);\n                    for (String group : proj.getGroups()) {\n                        rec.append(\" \");\n                        rec.append(group);\n                    }\n                    rec.append(\"\\n\");\n                    attributes.append(rec.toString());\n                }\n                URI submodUrl = URI.create(nameUri);\n                if (targetUri != null) {\n                    submodUrl = relativize(targetUri, submodUrl);\n                }\n                cfg.setString(\"submodule\", path, \"path\", path);\n                cfg.setString(\"submodule\", path, \"url\", submodUrl.toString());\n                DirCacheEntry dcEntry = new DirCacheEntry(path);\n                dcEntry.setObjectId(objectId);\n                dcEntry.setFileMode(FileMode.GITLINK);\n                builder.add(dcEntry);\n                for (CopyFile copyfile : proj.getCopyFiles()) {\n                    byte[] src = callback.readFile(nameUri, proj.getRevision(), copyfile.src);\n                    objectId = inserter.insert(Constants.OBJ_BLOB, src);\n                    dcEntry = new DirCacheEntry(copyfile.dest);\n                    dcEntry.setObjectId(objectId);\n                    dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                    builder.add(dcEntry);\n                }\n            }\n            String content = cfg.toText();\n            final DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);\n            ObjectId objectId = inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n            dcEntry.setObjectId(objectId);\n            dcEntry.setFileMode(FileMode.REGULAR_FILE);\n            builder.add(dcEntry);\n            if (recordSubmoduleLabels) {\n                final DirCacheEntry dcEntryAttr = new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n                ObjectId attrId = inserter.insert(Constants.OBJ_BLOB, attributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n                dcEntryAttr.setObjectId(attrId);\n                dcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n                builder.add(dcEntryAttr);\n            }\n            builder.finish();\n            ObjectId treeId = index.writeTree(inserter);\n            ObjectId headId = repo.resolve(targetBranch + \"^{commit}\");\n            CommitBuilder commit = new CommitBuilder();\n            commit.setTreeId(treeId);\n            if (headId != null)\n                commit.setParentIds(headId);\n            commit.setAuthor(author);\n            commit.setCommitter(author);\n            commit.setMessage(RepoText.get().repoCommitMessage);\n            ObjectId commitId = inserter.insert(commit);\n            inserter.flush();\n            RefUpdate ru = repo.updateRef(targetBranch);\n            ru.setNewObjectId(commitId);\n            ru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());\n            Result rc = ru.update(rw);\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    break;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetBranch), ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetBranch, commitId.name(), rc));\n            }\n            return rw.parseCommit(commitId);\n        } catch (IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } else {\n        return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n    }\n}"
    },
    {
      "commit": "f32d65759c9afdcbec28eb3051ed9138b8e03271",
      "startLine": 111,
      "endLine": 123,
      "methodCode": "@Override\npublic RevCommit call() throws GitAPIException {\n    try {\n        checkCallable();\n        if (uri == null || uri.length() == 0) {\n            throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n        }\n        if (inputStream == null) {\n            if (manifestPath == null || manifestPath.length() == 0)\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            try {\n                inputStream = new FileInputStream(manifestPath);\n            } catch (IOException e) {\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            }\n        }\n        if (repo.isBare()) {\n            bareProjects = new ArrayList<>();\n            if (author == null)\n                author = new PersonIdent(repo);\n            if (callback == null)\n                callback = new DefaultRemoteReader();\n        } else\n            git = new Git(repo);\n        ManifestParser parser = new ManifestParser(includedReader, manifestPath, branch, uri, groupsParam, repo);\n        try {\n            parser.read(inputStream);\n            for (RepoProject proj : parser.getFilteredProjects()) {\n                addSubmodule(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles(), proj.getGroups(), proj.getRecommendShallow());\n            }\n        } catch (GitAPIException | IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } finally {\n        try {\n            if (inputStream != null)\n                inputStream.close();\n        } catch (IOException e) {\n        }\n    }\n    if (repo.isBare()) {\n        DirCache index = DirCache.newInCore();\n        DirCacheBuilder builder = index.builder();\n        ObjectInserter inserter = repo.newObjectInserter();\n        try (RevWalk rw = new RevWalk(repo)) {\n            Config cfg = new Config();\n            StringBuilder attributes = new StringBuilder();\n            for (RepoProject proj : bareProjects) {\n                String path = proj.getPath();\n                String nameUri = proj.getName();\n                ObjectId objectId;\n                if (ObjectId.isId(proj.getRevision()) && !ignoreRemoteFailures) {\n                    objectId = ObjectId.fromString(proj.getRevision());\n                } else {\n                    objectId = callback.sha1(nameUri, proj.getRevision());\n                    if (objectId == null) {\n                        if (ignoreRemoteFailures) {\n                            continue;\n                        }\n                        throw new RemoteUnavailableException(nameUri);\n                    }\n                    if (recordRemoteBranch) {\n                        cfg.setString(\"submodule\", path, \"branch\", proj.getRevision());\n                    }\n                    if (recordShallowSubmodules && proj.getRecommendShallow() != null) {\n                        cfg.setBoolean(\"submodule\", path, \"shallow\", true);\n                    }\n                }\n                if (recordSubmoduleLabels) {\n                    StringBuilder rec = new StringBuilder();\n                    rec.append(\"/\");\n                    rec.append(path);\n                    for (String group : proj.getGroups()) {\n                        rec.append(\" \");\n                        rec.append(group);\n                    }\n                    rec.append(\"\\n\");\n                    attributes.append(rec.toString());\n                }\n                cfg.setString(\"submodule\", path, \"path\", path);\n                cfg.setString(\"submodule\", path, \"url\", nameUri);\n                DirCacheEntry dcEntry = new DirCacheEntry(path);\n                dcEntry.setObjectId(objectId);\n                dcEntry.setFileMode(FileMode.GITLINK);\n                builder.add(dcEntry);\n                for (CopyFile copyfile : proj.getCopyFiles()) {\n                    byte[] src = callback.readFile(nameUri, proj.getRevision(), copyfile.src);\n                    objectId = inserter.insert(Constants.OBJ_BLOB, src);\n                    dcEntry = new DirCacheEntry(copyfile.dest);\n                    dcEntry.setObjectId(objectId);\n                    dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                    builder.add(dcEntry);\n                }\n            }\n            String content = cfg.toText();\n            final DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);\n            ObjectId objectId = inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n            dcEntry.setObjectId(objectId);\n            dcEntry.setFileMode(FileMode.REGULAR_FILE);\n            builder.add(dcEntry);\n            if (recordSubmoduleLabels) {\n                final DirCacheEntry dcEntryAttr = new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n                ObjectId attrId = inserter.insert(Constants.OBJ_BLOB, attributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n                dcEntryAttr.setObjectId(attrId);\n                dcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n                builder.add(dcEntryAttr);\n            }\n            builder.finish();\n            ObjectId treeId = index.writeTree(inserter);\n            ObjectId headId = repo.resolve(targetBranch + \"^{commit}\");\n            CommitBuilder commit = new CommitBuilder();\n            commit.setTreeId(treeId);\n            if (headId != null)\n                commit.setParentIds(headId);\n            commit.setAuthor(author);\n            commit.setCommitter(author);\n            commit.setMessage(RepoText.get().repoCommitMessage);\n            ObjectId commitId = inserter.insert(commit);\n            inserter.flush();\n            RefUpdate ru = repo.updateRef(targetBranch);\n            ru.setNewObjectId(commitId);\n            ru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());\n            Result rc = ru.update(rw);\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    break;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetBranch), ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetBranch, commitId.name(), rc));\n            }\n            return rw.parseCommit(commitId);\n        } catch (IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } else {\n        return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n    }\n}"
    },
    {
      "commit": "27b05c7d719754427a97c141b44bec7de3acb8db",
      "startLine": 110,
      "endLine": 122,
      "methodCode": "@Override\npublic RevCommit call() throws GitAPIException {\n    try {\n        checkCallable();\n        if (uri == null || uri.length() == 0)\n            throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n        if (inputStream == null) {\n            if (manifestPath == null || manifestPath.length() == 0)\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            try {\n                inputStream = new FileInputStream(manifestPath);\n            } catch (IOException e) {\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            }\n        }\n        if (repo.isBare()) {\n            bareProjects = new ArrayList<>();\n            if (author == null)\n                author = new PersonIdent(repo);\n            if (callback == null)\n                callback = new DefaultRemoteReader();\n        } else\n            git = new Git(repo);\n        ManifestParser parser = new ManifestParser(includedReader, manifestPath, branch, uri, groupsParam, repo);\n        try {\n            parser.read(inputStream);\n            for (RepoProject proj : parser.getFilteredProjects()) {\n                addSubmodule(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles(), proj.getGroups(), proj.getRecommendShallow());\n            }\n        } catch (GitAPIException | IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } finally {\n        try {\n            if (inputStream != null)\n                inputStream.close();\n        } catch (IOException e) {\n        }\n    }\n    if (repo.isBare()) {\n        DirCache index = DirCache.newInCore();\n        DirCacheBuilder builder = index.builder();\n        ObjectInserter inserter = repo.newObjectInserter();\n        try (RevWalk rw = new RevWalk(repo)) {\n            Config cfg = new Config();\n            StringBuilder attributes = new StringBuilder();\n            for (RepoProject proj : bareProjects) {\n                String path = proj.getPath();\n                String nameUri = proj.getName();\n                ObjectId objectId;\n                if (ObjectId.isId(proj.getRevision()) && !ignoreRemoteFailures) {\n                    objectId = ObjectId.fromString(proj.getRevision());\n                } else {\n                    objectId = callback.sha1(nameUri, proj.getRevision());\n                    if (objectId == null) {\n                        if (ignoreRemoteFailures) {\n                            continue;\n                        }\n                        throw new RemoteUnavailableException(nameUri);\n                    }\n                    if (recordRemoteBranch) {\n                        cfg.setString(\"submodule\", path, \"branch\", proj.getRevision());\n                    }\n                    if (recordShallowSubmodules && proj.getRecommendShallow() != null) {\n                        cfg.setBoolean(\"submodule\", path, \"shallow\", true);\n                    }\n                }\n                if (recordSubmoduleLabels) {\n                    StringBuilder rec = new StringBuilder();\n                    rec.append(\"/\");\n                    rec.append(path);\n                    for (String group : proj.getGroups()) {\n                        rec.append(\" \");\n                        rec.append(group);\n                    }\n                    rec.append(\"\\n\");\n                    attributes.append(rec.toString());\n                }\n                cfg.setString(\"submodule\", path, \"path\", path);\n                cfg.setString(\"submodule\", path, \"url\", nameUri);\n                DirCacheEntry dcEntry = new DirCacheEntry(path);\n                dcEntry.setObjectId(objectId);\n                dcEntry.setFileMode(FileMode.GITLINK);\n                builder.add(dcEntry);\n                for (CopyFile copyfile : proj.getCopyFiles()) {\n                    byte[] src = callback.readFile(nameUri, proj.getRevision(), copyfile.src);\n                    objectId = inserter.insert(Constants.OBJ_BLOB, src);\n                    dcEntry = new DirCacheEntry(copyfile.dest);\n                    dcEntry.setObjectId(objectId);\n                    dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                    builder.add(dcEntry);\n                }\n            }\n            String content = cfg.toText();\n            final DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);\n            ObjectId objectId = inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n            dcEntry.setObjectId(objectId);\n            dcEntry.setFileMode(FileMode.REGULAR_FILE);\n            builder.add(dcEntry);\n            if (recordSubmoduleLabels) {\n                final DirCacheEntry dcEntryAttr = new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n                ObjectId attrId = inserter.insert(Constants.OBJ_BLOB, attributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n                dcEntryAttr.setObjectId(attrId);\n                dcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n                builder.add(dcEntryAttr);\n            }\n            builder.finish();\n            ObjectId treeId = index.writeTree(inserter);\n            ObjectId headId = repo.resolve(targetBranch + \"^{commit}\");\n            CommitBuilder commit = new CommitBuilder();\n            commit.setTreeId(treeId);\n            if (headId != null)\n                commit.setParentIds(headId);\n            commit.setAuthor(author);\n            commit.setCommitter(author);\n            commit.setMessage(RepoText.get().repoCommitMessage);\n            ObjectId commitId = inserter.insert(commit);\n            inserter.flush();\n            RefUpdate ru = repo.updateRef(targetBranch);\n            ru.setNewObjectId(commitId);\n            ru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());\n            Result rc = ru.update(rw);\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    break;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetBranch), ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetBranch, commitId.name(), rc));\n            }\n            return rw.parseCommit(commitId);\n        } catch (IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } else {\n        return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n    }\n}"
    },
    {
      "commit": "3b4448637fbb9d74e0c9d44048ba76bb7c1214ce",
      "startLine": 110,
      "endLine": 122,
      "methodCode": "@Override\npublic RevCommit call() throws GitAPIException {\n    try {\n        checkCallable();\n        if (uri == null || uri.length() == 0)\n            throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n        if (inputStream == null) {\n            if (path == null || path.length() == 0)\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            try {\n                inputStream = new FileInputStream(path);\n            } catch (IOException e) {\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            }\n        }\n        if (repo.isBare()) {\n            bareProjects = new ArrayList<>();\n            if (author == null)\n                author = new PersonIdent(repo);\n            if (callback == null)\n                callback = new DefaultRemoteReader();\n        } else\n            git = new Git(repo);\n        ManifestParser parser = new ManifestParser(includedReader, path, branch, uri, groupsParam, repo);\n        try {\n            parser.read(inputStream);\n            for (RepoProject proj : parser.getFilteredProjects()) {\n                addSubmodule(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles(), proj.getGroups(), proj.getRecommendShallow());\n            }\n        } catch (GitAPIException | IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } finally {\n        try {\n            if (inputStream != null)\n                inputStream.close();\n        } catch (IOException e) {\n        }\n    }\n    if (repo.isBare()) {\n        DirCache index = DirCache.newInCore();\n        DirCacheBuilder builder = index.builder();\n        ObjectInserter inserter = repo.newObjectInserter();\n        try (RevWalk rw = new RevWalk(repo)) {\n            Config cfg = new Config();\n            StringBuilder attributes = new StringBuilder();\n            for (RepoProject proj : bareProjects) {\n                String name = proj.getPath();\n                String nameUri = proj.getName();\n                ObjectId objectId;\n                if (ObjectId.isId(proj.getRevision()) && !ignoreRemoteFailures) {\n                    objectId = ObjectId.fromString(proj.getRevision());\n                } else {\n                    objectId = callback.sha1(nameUri, proj.getRevision());\n                    if (objectId == null) {\n                        if (ignoreRemoteFailures) {\n                            continue;\n                        }\n                        throw new RemoteUnavailableException(nameUri);\n                    }\n                    if (recordRemoteBranch) {\n                        cfg.setString(\"submodule\", name, \"branch\", proj.getRevision());\n                    }\n                    if (recordShallowSubmodules && proj.getRecommendShallow() != null) {\n                        cfg.setBoolean(\"submodule\", name, \"shallow\", true);\n                    }\n                }\n                if (recordSubmoduleLabels) {\n                    StringBuilder rec = new StringBuilder();\n                    rec.append(\"/\");\n                    rec.append(name);\n                    for (String group : proj.getGroups()) {\n                        rec.append(\" \");\n                        rec.append(group);\n                    }\n                    rec.append(\"\\n\");\n                    attributes.append(rec.toString());\n                }\n                cfg.setString(\"submodule\", name, \"path\", name);\n                cfg.setString(\"submodule\", name, \"url\", nameUri);\n                DirCacheEntry dcEntry = new DirCacheEntry(name);\n                dcEntry.setObjectId(objectId);\n                dcEntry.setFileMode(FileMode.GITLINK);\n                builder.add(dcEntry);\n                for (CopyFile copyfile : proj.getCopyFiles()) {\n                    byte[] src = callback.readFile(nameUri, proj.getRevision(), copyfile.src);\n                    objectId = inserter.insert(Constants.OBJ_BLOB, src);\n                    dcEntry = new DirCacheEntry(copyfile.dest);\n                    dcEntry.setObjectId(objectId);\n                    dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                    builder.add(dcEntry);\n                }\n            }\n            String content = cfg.toText();\n            final DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);\n            ObjectId objectId = inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n            dcEntry.setObjectId(objectId);\n            dcEntry.setFileMode(FileMode.REGULAR_FILE);\n            builder.add(dcEntry);\n            if (recordSubmoduleLabels) {\n                final DirCacheEntry dcEntryAttr = new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n                ObjectId attrId = inserter.insert(Constants.OBJ_BLOB, attributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n                dcEntryAttr.setObjectId(attrId);\n                dcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n                builder.add(dcEntryAttr);\n            }\n            builder.finish();\n            ObjectId treeId = index.writeTree(inserter);\n            ObjectId headId = repo.resolve(targetBranch + \"^{commit}\");\n            CommitBuilder commit = new CommitBuilder();\n            commit.setTreeId(treeId);\n            if (headId != null)\n                commit.setParentIds(headId);\n            commit.setAuthor(author);\n            commit.setCommitter(author);\n            commit.setMessage(RepoText.get().repoCommitMessage);\n            ObjectId commitId = inserter.insert(commit);\n            inserter.flush();\n            RefUpdate ru = repo.updateRef(targetBranch);\n            ru.setNewObjectId(commitId);\n            ru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());\n            Result rc = ru.update(rw);\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    break;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetBranch), ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetBranch, commitId.name(), rc));\n            }\n            return rw.parseCommit(commitId);\n        } catch (IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } else {\n        return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n    }\n}"
    },
    {
      "commit": "a9b87de97090b4f7d25ace0525edc1268cfa737f",
      "startLine": 110,
      "endLine": 122,
      "methodCode": "@Override\npublic RevCommit call() throws GitAPIException {\n    try {\n        checkCallable();\n        if (uri == null || uri.length() == 0)\n            throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n        if (inputStream == null) {\n            if (path == null || path.length() == 0)\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            try {\n                inputStream = new FileInputStream(path);\n            } catch (IOException e) {\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            }\n        }\n        if (repo.isBare()) {\n            bareProjects = new ArrayList<RepoProject>();\n            if (author == null)\n                author = new PersonIdent(repo);\n            if (callback == null)\n                callback = new DefaultRemoteReader();\n        } else\n            git = new Git(repo);\n        ManifestParser parser = new ManifestParser(includedReader, path, branch, uri, groupsParam, repo);\n        try {\n            parser.read(inputStream);\n            for (RepoProject proj : parser.getFilteredProjects()) {\n                addSubmodule(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles(), proj.getGroups(), proj.getRecommendShallow());\n            }\n        } catch (GitAPIException | IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } finally {\n        try {\n            if (inputStream != null)\n                inputStream.close();\n        } catch (IOException e) {\n        }\n    }\n    if (repo.isBare()) {\n        DirCache index = DirCache.newInCore();\n        DirCacheBuilder builder = index.builder();\n        ObjectInserter inserter = repo.newObjectInserter();\n        try (RevWalk rw = new RevWalk(repo)) {\n            Config cfg = new Config();\n            StringBuilder attributes = new StringBuilder();\n            for (RepoProject proj : bareProjects) {\n                String name = proj.getPath();\n                String nameUri = proj.getName();\n                ObjectId objectId;\n                if (ObjectId.isId(proj.getRevision()) && !ignoreRemoteFailures) {\n                    objectId = ObjectId.fromString(proj.getRevision());\n                } else {\n                    objectId = callback.sha1(nameUri, proj.getRevision());\n                    if (objectId == null) {\n                        if (ignoreRemoteFailures) {\n                            continue;\n                        }\n                        throw new RemoteUnavailableException(nameUri);\n                    }\n                    if (recordRemoteBranch) {\n                        cfg.setString(\"submodule\", name, \"branch\", proj.getRevision());\n                    }\n                    if (recordShallowSubmodules && proj.getRecommendShallow() != null) {\n                        cfg.setBoolean(\"submodule\", name, \"shallow\", true);\n                    }\n                }\n                if (recordSubmoduleLabels) {\n                    StringBuilder rec = new StringBuilder();\n                    rec.append(\"/\");\n                    rec.append(name);\n                    for (String group : proj.getGroups()) {\n                        rec.append(\" \");\n                        rec.append(group);\n                    }\n                    rec.append(\"\\n\");\n                    attributes.append(rec.toString());\n                }\n                cfg.setString(\"submodule\", name, \"path\", name);\n                cfg.setString(\"submodule\", name, \"url\", nameUri);\n                DirCacheEntry dcEntry = new DirCacheEntry(name);\n                dcEntry.setObjectId(objectId);\n                dcEntry.setFileMode(FileMode.GITLINK);\n                builder.add(dcEntry);\n                for (CopyFile copyfile : proj.getCopyFiles()) {\n                    byte[] src = callback.readFile(nameUri, proj.getRevision(), copyfile.src);\n                    objectId = inserter.insert(Constants.OBJ_BLOB, src);\n                    dcEntry = new DirCacheEntry(copyfile.dest);\n                    dcEntry.setObjectId(objectId);\n                    dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                    builder.add(dcEntry);\n                }\n            }\n            String content = cfg.toText();\n            final DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);\n            ObjectId objectId = inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n            dcEntry.setObjectId(objectId);\n            dcEntry.setFileMode(FileMode.REGULAR_FILE);\n            builder.add(dcEntry);\n            if (recordSubmoduleLabels) {\n                final DirCacheEntry dcEntryAttr = new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n                ObjectId attrId = inserter.insert(Constants.OBJ_BLOB, attributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n                dcEntryAttr.setObjectId(attrId);\n                dcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n                builder.add(dcEntryAttr);\n            }\n            builder.finish();\n            ObjectId treeId = index.writeTree(inserter);\n            ObjectId headId = repo.resolve(targetBranch + \"^{commit}\");\n            CommitBuilder commit = new CommitBuilder();\n            commit.setTreeId(treeId);\n            if (headId != null)\n                commit.setParentIds(headId);\n            commit.setAuthor(author);\n            commit.setCommitter(author);\n            commit.setMessage(RepoText.get().repoCommitMessage);\n            ObjectId commitId = inserter.insert(commit);\n            inserter.flush();\n            RefUpdate ru = repo.updateRef(targetBranch);\n            ru.setNewObjectId(commitId);\n            ru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());\n            Result rc = ru.update(rw);\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    break;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetBranch), ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetBranch, commitId.name(), rc));\n            }\n            return rw.parseCommit(commitId);\n        } catch (IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } else {\n        return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n    }\n}"
    },
    {
      "commit": "6ae4ed0f7da996bde2ba5cdc26daff979c9f6866",
      "startLine": 110,
      "endLine": 122,
      "methodCode": "@Override\npublic RevCommit call() throws GitAPIException {\n    try {\n        checkCallable();\n        if (uri == null || uri.length() == 0)\n            throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n        if (inputStream == null) {\n            if (path == null || path.length() == 0)\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            try {\n                inputStream = new FileInputStream(path);\n            } catch (IOException e) {\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            }\n        }\n        if (repo.isBare()) {\n            bareProjects = new ArrayList<RepoProject>();\n            if (author == null)\n                author = new PersonIdent(repo);\n            if (callback == null)\n                callback = new DefaultRemoteReader();\n        } else\n            git = new Git(repo);\n        ManifestParser parser = new ManifestParser(includedReader, path, branch, uri, groups, repo);\n        try {\n            parser.read(inputStream);\n            for (RepoProject proj : parser.getFilteredProjects()) {\n                addSubmodule(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles(), proj.getGroups(), proj.getRecommendShallow());\n            }\n        } catch (GitAPIException | IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } finally {\n        try {\n            if (inputStream != null)\n                inputStream.close();\n        } catch (IOException e) {\n        }\n    }\n    if (repo.isBare()) {\n        DirCache index = DirCache.newInCore();\n        DirCacheBuilder builder = index.builder();\n        ObjectInserter inserter = repo.newObjectInserter();\n        try (RevWalk rw = new RevWalk(repo)) {\n            Config cfg = new Config();\n            StringBuilder attributes = new StringBuilder();\n            for (RepoProject proj : bareProjects) {\n                String name = proj.getPath();\n                String nameUri = proj.getName();\n                ObjectId objectId;\n                if (ObjectId.isId(proj.getRevision()) && !ignoreRemoteFailures) {\n                    objectId = ObjectId.fromString(proj.getRevision());\n                } else {\n                    objectId = callback.sha1(nameUri, proj.getRevision());\n                    if (objectId == null) {\n                        if (ignoreRemoteFailures) {\n                            continue;\n                        }\n                        throw new RemoteUnavailableException(nameUri);\n                    }\n                    if (recordRemoteBranch) {\n                        cfg.setString(\"submodule\", name, \"branch\", proj.getRevision());\n                    }\n                    if (recordShallowSubmodules && proj.getRecommendShallow() != null) {\n                        cfg.setBoolean(\"submodule\", name, \"shallow\", true);\n                    }\n                }\n                if (recordSubmoduleLabels) {\n                    StringBuilder rec = new StringBuilder();\n                    rec.append(\"/\");\n                    rec.append(name);\n                    for (String group : proj.getGroups()) {\n                        rec.append(\" \");\n                        rec.append(group);\n                    }\n                    rec.append(\"\\n\");\n                    attributes.append(rec.toString());\n                }\n                cfg.setString(\"submodule\", name, \"path\", name);\n                cfg.setString(\"submodule\", name, \"url\", nameUri);\n                DirCacheEntry dcEntry = new DirCacheEntry(name);\n                dcEntry.setObjectId(objectId);\n                dcEntry.setFileMode(FileMode.GITLINK);\n                builder.add(dcEntry);\n                for (CopyFile copyfile : proj.getCopyFiles()) {\n                    byte[] src = callback.readFile(nameUri, proj.getRevision(), copyfile.src);\n                    objectId = inserter.insert(Constants.OBJ_BLOB, src);\n                    dcEntry = new DirCacheEntry(copyfile.dest);\n                    dcEntry.setObjectId(objectId);\n                    dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                    builder.add(dcEntry);\n                }\n            }\n            String content = cfg.toText();\n            final DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);\n            ObjectId objectId = inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n            dcEntry.setObjectId(objectId);\n            dcEntry.setFileMode(FileMode.REGULAR_FILE);\n            builder.add(dcEntry);\n            if (recordSubmoduleLabels) {\n                final DirCacheEntry dcEntryAttr = new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n                ObjectId attrId = inserter.insert(Constants.OBJ_BLOB, attributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n                dcEntryAttr.setObjectId(attrId);\n                dcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n                builder.add(dcEntryAttr);\n            }\n            builder.finish();\n            ObjectId treeId = index.writeTree(inserter);\n            ObjectId headId = repo.resolve(targetBranch + \"^{commit}\");\n            CommitBuilder commit = new CommitBuilder();\n            commit.setTreeId(treeId);\n            if (headId != null)\n                commit.setParentIds(headId);\n            commit.setAuthor(author);\n            commit.setCommitter(author);\n            commit.setMessage(RepoText.get().repoCommitMessage);\n            ObjectId commitId = inserter.insert(commit);\n            inserter.flush();\n            RefUpdate ru = repo.updateRef(targetBranch);\n            ru.setNewObjectId(commitId);\n            ru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());\n            Result rc = ru.update(rw);\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    break;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetBranch), ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetBranch, commitId.name(), rc));\n            }\n            return rw.parseCommit(commitId);\n        } catch (IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } else {\n        return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n    }\n}"
    },
    {
      "commit": "ddd0fe257bc78dc9646407e7121769d0c03e0d94",
      "startLine": 107,
      "endLine": 119,
      "methodCode": "@Override\npublic RevCommit call() throws GitAPIException {\n    try {\n        checkCallable();\n        if (uri == null || uri.length() == 0)\n            throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n        if (inputStream == null) {\n            if (path == null || path.length() == 0)\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            try {\n                inputStream = new FileInputStream(path);\n            } catch (IOException e) {\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            }\n        }\n        if (repo.isBare()) {\n            bareProjects = new ArrayList<RepoProject>();\n            if (author == null)\n                author = new PersonIdent(repo);\n            if (callback == null)\n                callback = new DefaultRemoteReader();\n        } else\n            git = new Git(repo);\n        ManifestParser parser = new ManifestParser(includedReader, path, branch, uri, groups, repo);\n        try {\n            parser.read(inputStream);\n            for (RepoProject proj : parser.getFilteredProjects()) {\n                addSubmodule(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles(), proj.getGroups());\n            }\n        } catch (GitAPIException | IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } finally {\n        try {\n            if (inputStream != null)\n                inputStream.close();\n        } catch (IOException e) {\n        }\n    }\n    if (repo.isBare()) {\n        DirCache index = DirCache.newInCore();\n        DirCacheBuilder builder = index.builder();\n        ObjectInserter inserter = repo.newObjectInserter();\n        try (RevWalk rw = new RevWalk(repo)) {\n            Config cfg = new Config();\n            StringBuilder attributes = new StringBuilder();\n            for (RepoProject proj : bareProjects) {\n                String name = proj.getPath();\n                String nameUri = proj.getName();\n                ObjectId objectId;\n                if (ObjectId.isId(proj.getRevision()) && !ignoreRemoteFailures) {\n                    objectId = ObjectId.fromString(proj.getRevision());\n                } else {\n                    objectId = callback.sha1(nameUri, proj.getRevision());\n                    if (objectId == null) {\n                        if (ignoreRemoteFailures) {\n                            continue;\n                        }\n                        throw new RemoteUnavailableException(nameUri);\n                    }\n                    if (recordRemoteBranch) {\n                        cfg.setString(\"submodule\", name, \"branch\", proj.getRevision());\n                    }\n                }\n                if (recordSubmoduleLabels) {\n                    StringBuilder rec = new StringBuilder();\n                    rec.append(\"/\");\n                    rec.append(name);\n                    for (String group : proj.getGroups()) {\n                        rec.append(\" \");\n                        rec.append(group);\n                    }\n                    rec.append(\"\\n\");\n                    attributes.append(rec.toString());\n                }\n                cfg.setString(\"submodule\", name, \"path\", name);\n                cfg.setString(\"submodule\", name, \"url\", nameUri);\n                DirCacheEntry dcEntry = new DirCacheEntry(name);\n                dcEntry.setObjectId(objectId);\n                dcEntry.setFileMode(FileMode.GITLINK);\n                builder.add(dcEntry);\n                for (CopyFile copyfile : proj.getCopyFiles()) {\n                    byte[] src = callback.readFile(nameUri, proj.getRevision(), copyfile.src);\n                    objectId = inserter.insert(Constants.OBJ_BLOB, src);\n                    dcEntry = new DirCacheEntry(copyfile.dest);\n                    dcEntry.setObjectId(objectId);\n                    dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                    builder.add(dcEntry);\n                }\n            }\n            String content = cfg.toText();\n            final DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);\n            ObjectId objectId = inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n            dcEntry.setObjectId(objectId);\n            dcEntry.setFileMode(FileMode.REGULAR_FILE);\n            builder.add(dcEntry);\n            if (recordSubmoduleLabels) {\n                final DirCacheEntry dcEntryAttr = new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n                ObjectId attrId = inserter.insert(Constants.OBJ_BLOB, attributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n                dcEntryAttr.setObjectId(attrId);\n                dcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n                builder.add(dcEntryAttr);\n            }\n            builder.finish();\n            ObjectId treeId = index.writeTree(inserter);\n            ObjectId headId = repo.resolve(targetBranch + \"^{commit}\");\n            CommitBuilder commit = new CommitBuilder();\n            commit.setTreeId(treeId);\n            if (headId != null)\n                commit.setParentIds(headId);\n            commit.setAuthor(author);\n            commit.setCommitter(author);\n            commit.setMessage(RepoText.get().repoCommitMessage);\n            ObjectId commitId = inserter.insert(commit);\n            inserter.flush();\n            RefUpdate ru = repo.updateRef(targetBranch);\n            ru.setNewObjectId(commitId);\n            ru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());\n            Result rc = ru.update(rw);\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    break;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetBranch), ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetBranch, commitId.name(), rc));\n            }\n            return rw.parseCommit(commitId);\n        } catch (IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } else {\n        return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n    }\n}"
    },
    {
      "commit": "0ecb016d7db42ab83584cab3c1554d4d28cc5062",
      "startLine": 88,
      "endLine": 100,
      "methodCode": "@Override\npublic RevCommit call() throws GitAPIException {\n    try {\n        checkCallable();\n        if (uri == null || uri.length() == 0)\n            throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n        if (inputStream == null) {\n            if (path == null || path.length() == 0)\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            try {\n                inputStream = new FileInputStream(path);\n            } catch (IOException e) {\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            }\n        }\n        if (repo.isBare()) {\n            bareProjects = new ArrayList<RepoProject>();\n            if (author == null)\n                author = new PersonIdent(repo);\n            if (callback == null)\n                callback = new DefaultRemoteReader();\n        } else\n            git = new Git(repo);\n        ManifestParser parser = new ManifestParser(includedReader, path, branch, uri, groups, repo);\n        try {\n            parser.read(inputStream);\n            for (RepoProject proj : parser.getFilteredProjects()) {\n                addSubmodule(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles());\n            }\n        } catch (GitAPIException | IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } finally {\n        try {\n            if (inputStream != null)\n                inputStream.close();\n        } catch (IOException e) {\n        }\n    }\n    if (repo.isBare()) {\n        DirCache index = DirCache.newInCore();\n        DirCacheBuilder builder = index.builder();\n        ObjectInserter inserter = repo.newObjectInserter();\n        try (RevWalk rw = new RevWalk(repo)) {\n            Config cfg = new Config();\n            for (RepoProject proj : bareProjects) {\n                String name = proj.getPath();\n                String nameUri = proj.getName();\n                ObjectId objectId;\n                if (ObjectId.isId(proj.getRevision()) && !ignoreRemoteFailures) {\n                    objectId = ObjectId.fromString(proj.getRevision());\n                } else {\n                    objectId = callback.sha1(nameUri, proj.getRevision());\n                    if (objectId == null) {\n                        if (ignoreRemoteFailures) {\n                            continue;\n                        }\n                        throw new RemoteUnavailableException(nameUri);\n                    }\n                    if (recordRemoteBranch) {\n                        cfg.setString(\"submodule\", name, \"branch\", proj.getRevision());\n                    }\n                }\n                cfg.setString(\"submodule\", name, \"path\", name);\n                cfg.setString(\"submodule\", name, \"url\", nameUri);\n                DirCacheEntry dcEntry = new DirCacheEntry(name);\n                dcEntry.setObjectId(objectId);\n                dcEntry.setFileMode(FileMode.GITLINK);\n                builder.add(dcEntry);\n                for (CopyFile copyfile : proj.getCopyFiles()) {\n                    byte[] src = callback.readFile(nameUri, proj.getRevision(), copyfile.src);\n                    objectId = inserter.insert(Constants.OBJ_BLOB, src);\n                    dcEntry = new DirCacheEntry(copyfile.dest);\n                    dcEntry.setObjectId(objectId);\n                    dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                    builder.add(dcEntry);\n                }\n            }\n            String content = cfg.toText();\n            final DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);\n            ObjectId objectId = inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n            dcEntry.setObjectId(objectId);\n            dcEntry.setFileMode(FileMode.REGULAR_FILE);\n            builder.add(dcEntry);\n            builder.finish();\n            ObjectId treeId = index.writeTree(inserter);\n            ObjectId headId = repo.resolve(targetBranch + \"^{commit}\");\n            CommitBuilder commit = new CommitBuilder();\n            commit.setTreeId(treeId);\n            if (headId != null)\n                commit.setParentIds(headId);\n            commit.setAuthor(author);\n            commit.setCommitter(author);\n            commit.setMessage(RepoText.get().repoCommitMessage);\n            ObjectId commitId = inserter.insert(commit);\n            inserter.flush();\n            RefUpdate ru = repo.updateRef(targetBranch);\n            ru.setNewObjectId(commitId);\n            ru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());\n            Result rc = ru.update(rw);\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    break;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetBranch), ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetBranch, commitId.name(), rc));\n            }\n            return rw.parseCommit(commitId);\n        } catch (IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } else {\n        return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n    }\n}"
    },
    {
      "commit": "cdd7c23446a0030e5b521d91cbb2d3a9c522ccc2",
      "startLine": 83,
      "endLine": 95,
      "methodCode": "@Override\npublic RevCommit call() throws GitAPIException {\n    try {\n        checkCallable();\n        if (uri == null || uri.length() == 0)\n            throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n        if (inputStream == null) {\n            if (path == null || path.length() == 0)\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            try {\n                inputStream = new FileInputStream(path);\n            } catch (IOException e) {\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            }\n        }\n        if (repo.isBare()) {\n            bareProjects = new ArrayList<RepoProject>();\n            if (author == null)\n                author = new PersonIdent(repo);\n            if (callback == null)\n                callback = new DefaultRemoteReader();\n        } else\n            git = new Git(repo);\n        ManifestParser parser = new ManifestParser(includedReader, path, branch, uri, groups, repo);\n        try {\n            parser.read(inputStream);\n            for (RepoProject proj : parser.getFilteredProjects()) {\n                addSubmodule(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles());\n            }\n        } catch (GitAPIException | IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } finally {\n        try {\n            if (inputStream != null)\n                inputStream.close();\n        } catch (IOException e) {\n        }\n    }\n    if (repo.isBare()) {\n        DirCache index = DirCache.newInCore();\n        DirCacheBuilder builder = index.builder();\n        ObjectInserter inserter = repo.newObjectInserter();\n        try (RevWalk rw = new RevWalk(repo)) {\n            Config cfg = new Config();\n            for (RepoProject proj : bareProjects) {\n                String name = proj.getPath();\n                String nameUri = proj.getName();\n                cfg.setString(\"submodule\", name, \"path\", name);\n                cfg.setString(\"submodule\", name, \"url\", nameUri);\n                DirCacheEntry dcEntry = new DirCacheEntry(name);\n                ObjectId objectId;\n                if (ObjectId.isId(proj.getRevision())) {\n                    objectId = ObjectId.fromString(proj.getRevision());\n                } else {\n                    objectId = callback.sha1(nameUri, proj.getRevision());\n                    if (recordRemoteBranch)\n                        cfg.setString(\"submodule\", name, \"branch\", proj.getRevision());\n                }\n                if (objectId == null)\n                    throw new RemoteUnavailableException(nameUri);\n                dcEntry.setObjectId(objectId);\n                dcEntry.setFileMode(FileMode.GITLINK);\n                builder.add(dcEntry);\n                for (CopyFile copyfile : proj.getCopyFiles()) {\n                    byte[] src = callback.readFile(nameUri, proj.getRevision(), copyfile.src);\n                    objectId = inserter.insert(Constants.OBJ_BLOB, src);\n                    dcEntry = new DirCacheEntry(copyfile.dest);\n                    dcEntry.setObjectId(objectId);\n                    dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                    builder.add(dcEntry);\n                }\n            }\n            String content = cfg.toText();\n            final DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);\n            ObjectId objectId = inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n            dcEntry.setObjectId(objectId);\n            dcEntry.setFileMode(FileMode.REGULAR_FILE);\n            builder.add(dcEntry);\n            builder.finish();\n            ObjectId treeId = index.writeTree(inserter);\n            ObjectId headId = repo.resolve(targetBranch + \"^{commit}\");\n            CommitBuilder commit = new CommitBuilder();\n            commit.setTreeId(treeId);\n            if (headId != null)\n                commit.setParentIds(headId);\n            commit.setAuthor(author);\n            commit.setCommitter(author);\n            commit.setMessage(RepoText.get().repoCommitMessage);\n            ObjectId commitId = inserter.insert(commit);\n            inserter.flush();\n            RefUpdate ru = repo.updateRef(targetBranch);\n            ru.setNewObjectId(commitId);\n            ru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());\n            Result rc = ru.update(rw);\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    break;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetBranch), ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetBranch, commitId.name(), rc));\n            }\n            return rw.parseCommit(commitId);\n        } catch (IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } else {\n        return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n    }\n}"
    },
    {
      "commit": "217b2a7cc5366491be5317d20f3f3c1b6e3475bf",
      "startLine": 81,
      "endLine": 93,
      "methodCode": "@Override\npublic RevCommit call() throws GitAPIException {\n    try {\n        checkCallable();\n        if (uri == null || uri.length() == 0)\n            throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n        if (inputStream == null) {\n            if (path == null || path.length() == 0)\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            try {\n                inputStream = new FileInputStream(path);\n            } catch (IOException e) {\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            }\n        }\n        if (repo.isBare()) {\n            bareProjects = new ArrayList<RepoProject>();\n            if (author == null)\n                author = new PersonIdent(repo);\n            if (callback == null)\n                callback = new DefaultRemoteReader();\n        } else\n            git = new Git(repo);\n        ManifestParser parser = new ManifestParser(includedReader, path, branch, uri, groups, repo);\n        try {\n            parser.read(inputStream);\n            for (RepoProject proj : parser.getFilteredProjects()) {\n                addSubmodule(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles());\n            }\n        } catch (GitAPIException | IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } finally {\n        try {\n            if (inputStream != null)\n                inputStream.close();\n        } catch (IOException e) {\n        }\n    }\n    if (repo.isBare()) {\n        DirCache index = DirCache.newInCore();\n        DirCacheBuilder builder = index.builder();\n        ObjectInserter inserter = repo.newObjectInserter();\n        try (RevWalk rw = new RevWalk(repo)) {\n            Config cfg = new Config();\n            for (RepoProject proj : bareProjects) {\n                String name = proj.getPath();\n                String nameUri = proj.getName();\n                cfg.setString(\"submodule\", name, \"path\", name);\n                cfg.setString(\"submodule\", name, \"url\", nameUri);\n                DirCacheEntry dcEntry = new DirCacheEntry(name);\n                ObjectId objectId;\n                if (ObjectId.isId(proj.getRevision()))\n                    objectId = ObjectId.fromString(proj.getRevision());\n                else {\n                    objectId = callback.sha1(nameUri, proj.getRevision());\n                }\n                if (objectId == null)\n                    throw new RemoteUnavailableException(nameUri);\n                dcEntry.setObjectId(objectId);\n                dcEntry.setFileMode(FileMode.GITLINK);\n                builder.add(dcEntry);\n                for (CopyFile copyfile : proj.getCopyFiles()) {\n                    byte[] src = callback.readFile(nameUri, proj.getRevision(), copyfile.src);\n                    objectId = inserter.insert(Constants.OBJ_BLOB, src);\n                    dcEntry = new DirCacheEntry(copyfile.dest);\n                    dcEntry.setObjectId(objectId);\n                    dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                    builder.add(dcEntry);\n                }\n            }\n            String content = cfg.toText();\n            final DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);\n            ObjectId objectId = inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n            dcEntry.setObjectId(objectId);\n            dcEntry.setFileMode(FileMode.REGULAR_FILE);\n            builder.add(dcEntry);\n            builder.finish();\n            ObjectId treeId = index.writeTree(inserter);\n            ObjectId headId = repo.resolve(targetBranch + \"^{commit}\");\n            CommitBuilder commit = new CommitBuilder();\n            commit.setTreeId(treeId);\n            if (headId != null)\n                commit.setParentIds(headId);\n            commit.setAuthor(author);\n            commit.setCommitter(author);\n            commit.setMessage(RepoText.get().repoCommitMessage);\n            ObjectId commitId = inserter.insert(commit);\n            inserter.flush();\n            RefUpdate ru = repo.updateRef(targetBranch);\n            ru.setNewObjectId(commitId);\n            ru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());\n            Result rc = ru.update(rw);\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    break;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetBranch), ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetBranch, commitId.name(), rc));\n            }\n            return rw.parseCommit(commitId);\n        } catch (IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } else {\n        return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n    }\n}"
    },
    {
      "commit": "744c370c1be8044d1ccaaf84cd164324961fea1a",
      "startLine": 81,
      "endLine": 93,
      "methodCode": "@Override\npublic RevCommit call() throws GitAPIException {\n    try {\n        checkCallable();\n        if (uri == null || uri.length() == 0)\n            throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n        if (inputStream == null) {\n            if (path == null || path.length() == 0)\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            try {\n                inputStream = new FileInputStream(path);\n            } catch (IOException e) {\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            }\n        }\n        if (repo.isBare()) {\n            bareProjects = new ArrayList<RepoProject>();\n            if (author == null)\n                author = new PersonIdent(repo);\n            if (callback == null)\n                callback = new DefaultRemoteReader();\n        } else\n            git = new Git(repo);\n        ManifestParser parser = new ManifestParser(includedReader, path, branch, uri, groups, repo);\n        try {\n            parser.read(inputStream);\n            for (RepoProject proj : parser.getFilteredProjects()) {\n                addSubmodule(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles());\n            }\n        } catch (GitAPIException | IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } finally {\n        try {\n            if (inputStream != null)\n                inputStream.close();\n        } catch (IOException e) {\n        }\n    }\n    if (repo.isBare()) {\n        DirCache index = DirCache.newInCore();\n        DirCacheBuilder builder = index.builder();\n        ObjectInserter inserter = repo.newObjectInserter();\n        try (RevWalk rw = new RevWalk(repo)) {\n            Config cfg = new Config();\n            for (RepoProject proj : bareProjects) {\n                String name = proj.getPath();\n                String nameUri = proj.getName();\n                cfg.setString(\"submodule\", name, \"path\", name);\n                cfg.setString(\"submodule\", name, \"url\", nameUri);\n                DirCacheEntry dcEntry = new DirCacheEntry(name);\n                ObjectId objectId;\n                if (ObjectId.isId(proj.getRevision()))\n                    objectId = ObjectId.fromString(proj.getRevision());\n                else {\n                    objectId = callback.sha1(nameUri, proj.getRevision());\n                }\n                if (objectId == null)\n                    throw new RemoteUnavailableException(nameUri);\n                dcEntry.setObjectId(objectId);\n                dcEntry.setFileMode(FileMode.GITLINK);\n                builder.add(dcEntry);\n                for (CopyFile copyfile : proj.getCopyFiles()) {\n                    byte[] src = callback.readFile(nameUri, proj.getRevision(), copyfile.src);\n                    objectId = inserter.insert(Constants.OBJ_BLOB, src);\n                    dcEntry = new DirCacheEntry(copyfile.dest);\n                    dcEntry.setObjectId(objectId);\n                    dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                    builder.add(dcEntry);\n                }\n            }\n            String content = cfg.toText();\n            final DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);\n            ObjectId objectId = inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n            dcEntry.setObjectId(objectId);\n            dcEntry.setFileMode(FileMode.REGULAR_FILE);\n            builder.add(dcEntry);\n            builder.finish();\n            ObjectId treeId = index.writeTree(inserter);\n            ObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n            CommitBuilder commit = new CommitBuilder();\n            commit.setTreeId(treeId);\n            if (headId != null)\n                commit.setParentIds(headId);\n            commit.setAuthor(author);\n            commit.setCommitter(author);\n            commit.setMessage(RepoText.get().repoCommitMessage);\n            ObjectId commitId = inserter.insert(commit);\n            inserter.flush();\n            RefUpdate ru = repo.updateRef(Constants.HEAD);\n            ru.setNewObjectId(commitId);\n            ru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());\n            Result rc = ru.update(rw);\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    break;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.name(), rc));\n            }\n            return rw.parseCommit(commitId);\n        } catch (IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } else {\n        return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n    }\n}"
    },
    {
      "commit": "d3348e5623a2abf7b2f1356ea077d6eb9bf7760c",
      "startLine": 81,
      "endLine": 93,
      "methodCode": "@Override\npublic RevCommit call() throws GitAPIException {\n    try {\n        checkCallable();\n        if (uri == null || uri.length() == 0)\n            throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n        if (inputStream == null) {\n            if (path == null || path.length() == 0)\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            try {\n                inputStream = new FileInputStream(path);\n            } catch (IOException e) {\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            }\n        }\n        if (repo.isBare()) {\n            bareProjects = new ArrayList<RepoProject>();\n            if (author == null)\n                author = new PersonIdent(repo);\n            if (callback == null)\n                callback = new DefaultRemoteReader();\n        } else\n            git = new Git(repo);\n        ManifestParser parser = new ManifestParser(includedReader, path, branch, uri, groups, repo);\n        try {\n            parser.read(inputStream);\n            for (RepoProject proj : parser.getFilteredProjects()) {\n                addSubmodule(proj.url, proj.path, proj.getRevision(), proj.copyfiles);\n            }\n        } catch (GitAPIException | IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } finally {\n        try {\n            if (inputStream != null)\n                inputStream.close();\n        } catch (IOException e) {\n        }\n    }\n    if (repo.isBare()) {\n        DirCache index = DirCache.newInCore();\n        DirCacheBuilder builder = index.builder();\n        ObjectInserter inserter = repo.newObjectInserter();\n        try (RevWalk rw = new RevWalk(repo)) {\n            Config cfg = new Config();\n            for (RepoProject proj : bareProjects) {\n                String name = proj.path;\n                String nameUri = proj.name;\n                cfg.setString(\"submodule\", name, \"path\", name);\n                cfg.setString(\"submodule\", name, \"url\", nameUri);\n                DirCacheEntry dcEntry = new DirCacheEntry(name);\n                ObjectId objectId;\n                if (ObjectId.isId(proj.revision))\n                    objectId = ObjectId.fromString(proj.revision);\n                else {\n                    objectId = callback.sha1(nameUri, proj.revision);\n                }\n                if (objectId == null)\n                    throw new RemoteUnavailableException(nameUri);\n                dcEntry.setObjectId(objectId);\n                dcEntry.setFileMode(FileMode.GITLINK);\n                builder.add(dcEntry);\n                for (CopyFile copyfile : proj.copyfiles) {\n                    byte[] src = callback.readFile(nameUri, proj.revision, copyfile.src);\n                    objectId = inserter.insert(Constants.OBJ_BLOB, src);\n                    dcEntry = new DirCacheEntry(copyfile.dest);\n                    dcEntry.setObjectId(objectId);\n                    dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                    builder.add(dcEntry);\n                }\n            }\n            String content = cfg.toText();\n            final DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);\n            ObjectId objectId = inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n            dcEntry.setObjectId(objectId);\n            dcEntry.setFileMode(FileMode.REGULAR_FILE);\n            builder.add(dcEntry);\n            builder.finish();\n            ObjectId treeId = index.writeTree(inserter);\n            ObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n            CommitBuilder commit = new CommitBuilder();\n            commit.setTreeId(treeId);\n            if (headId != null)\n                commit.setParentIds(headId);\n            commit.setAuthor(author);\n            commit.setCommitter(author);\n            commit.setMessage(RepoText.get().repoCommitMessage);\n            ObjectId commitId = inserter.insert(commit);\n            inserter.flush();\n            RefUpdate ru = repo.updateRef(Constants.HEAD);\n            ru.setNewObjectId(commitId);\n            ru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());\n            Result rc = ru.update(rw);\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    break;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.name(), rc));\n            }\n            return rw.parseCommit(commitId);\n        } catch (IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } else {\n        return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n    }\n}"
    },
    {
      "commit": "0e73d395061d1bfee365acaa2f79c392175d13bf",
      "startLine": 78,
      "endLine": 90,
      "methodCode": "@Override\npublic RevCommit call() throws GitAPIException {\n    try {\n        checkCallable();\n        if (uri == null || uri.length() == 0)\n            throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n        if (inputStream == null) {\n            if (path == null || path.length() == 0)\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            try {\n                inputStream = new FileInputStream(path);\n            } catch (IOException e) {\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            }\n        }\n        if (repo.isBare()) {\n            bareProjects = new ArrayList<Project>();\n            if (author == null)\n                author = new PersonIdent(repo);\n            if (callback == null)\n                callback = new DefaultRemoteReader();\n        } else\n            git = new Git(repo);\n        XmlManifest manifest = new XmlManifest(this, includedReader, path, uri, groups);\n        try {\n            manifest.read(inputStream);\n        } catch (IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } finally {\n        try {\n            if (inputStream != null)\n                inputStream.close();\n        } catch (IOException e) {\n        }\n    }\n    if (repo.isBare()) {\n        DirCache index = DirCache.newInCore();\n        DirCacheBuilder builder = index.builder();\n        ObjectInserter inserter = repo.newObjectInserter();\n        try (RevWalk rw = new RevWalk(repo)) {\n            Config cfg = new Config();\n            for (Project proj : bareProjects) {\n                String name = proj.path;\n                String nameUri = proj.name;\n                cfg.setString(\"submodule\", name, \"path\", name);\n                cfg.setString(\"submodule\", name, \"url\", nameUri);\n                DirCacheEntry dcEntry = new DirCacheEntry(name);\n                ObjectId objectId;\n                if (ObjectId.isId(proj.revision))\n                    objectId = ObjectId.fromString(proj.revision);\n                else {\n                    objectId = callback.sha1(nameUri, proj.revision);\n                }\n                if (objectId == null)\n                    throw new RemoteUnavailableException(nameUri);\n                dcEntry.setObjectId(objectId);\n                dcEntry.setFileMode(FileMode.GITLINK);\n                builder.add(dcEntry);\n                for (CopyFile copyfile : proj.copyfiles) {\n                    byte[] src = callback.readFile(nameUri, proj.revision, copyfile.src);\n                    objectId = inserter.insert(Constants.OBJ_BLOB, src);\n                    dcEntry = new DirCacheEntry(copyfile.dest);\n                    dcEntry.setObjectId(objectId);\n                    dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                    builder.add(dcEntry);\n                }\n            }\n            String content = cfg.toText();\n            final DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);\n            ObjectId objectId = inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n            dcEntry.setObjectId(objectId);\n            dcEntry.setFileMode(FileMode.REGULAR_FILE);\n            builder.add(dcEntry);\n            builder.finish();\n            ObjectId treeId = index.writeTree(inserter);\n            ObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n            CommitBuilder commit = new CommitBuilder();\n            commit.setTreeId(treeId);\n            if (headId != null)\n                commit.setParentIds(headId);\n            commit.setAuthor(author);\n            commit.setCommitter(author);\n            commit.setMessage(RepoText.get().repoCommitMessage);\n            ObjectId commitId = inserter.insert(commit);\n            inserter.flush();\n            RefUpdate ru = repo.updateRef(Constants.HEAD);\n            ru.setNewObjectId(commitId);\n            ru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());\n            Result rc = ru.update(rw);\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    break;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.name(), rc));\n            }\n            return rw.parseCommit(commitId);\n        } catch (IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } else {\n        return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n    }\n}"
    },
    {
      "commit": "2f6372337cfd5944e2179f5ec5e2dbe0cbc96386",
      "startLine": 79,
      "endLine": 91,
      "methodCode": "@Override\npublic RevCommit call() throws GitAPIException {\n    try {\n        checkCallable();\n        if (uri == null || uri.length() == 0)\n            throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n        if (inputStream == null) {\n            if (path == null || path.length() == 0)\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            try {\n                inputStream = new FileInputStream(path);\n            } catch (IOException e) {\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            }\n        }\n        if (repo.isBare()) {\n            bareProjects = new ArrayList<Project>();\n            if (author == null)\n                author = new PersonIdent(repo);\n            if (callback == null)\n                callback = new DefaultRemoteReader();\n        } else\n            git = new Git(repo);\n        XmlManifest manifest = new XmlManifest(this, includedReader, path, uri, groups);\n        try {\n            manifest.read(inputStream);\n        } catch (IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } finally {\n        try {\n            if (inputStream != null)\n                inputStream.close();\n        } catch (IOException e) {\n        }\n    }\n    if (repo.isBare()) {\n        DirCache index = DirCache.newInCore();\n        DirCacheBuilder builder = index.builder();\n        ObjectInserter inserter = repo.newObjectInserter();\n        RevWalk rw = new RevWalk(repo);\n        try {\n            Config cfg = new Config();\n            for (Project proj : bareProjects) {\n                String name = proj.path;\n                String nameUri = proj.name;\n                cfg.setString(\"submodule\", name, \"path\", name);\n                cfg.setString(\"submodule\", name, \"url\", nameUri);\n                DirCacheEntry dcEntry = new DirCacheEntry(name);\n                ObjectId objectId;\n                if (ObjectId.isId(proj.revision))\n                    objectId = ObjectId.fromString(proj.revision);\n                else {\n                    objectId = callback.sha1(nameUri, proj.revision);\n                }\n                if (objectId == null)\n                    throw new RemoteUnavailableException(nameUri);\n                dcEntry.setObjectId(objectId);\n                dcEntry.setFileMode(FileMode.GITLINK);\n                builder.add(dcEntry);\n                for (CopyFile copyfile : proj.copyfiles) {\n                    byte[] src = callback.readFile(nameUri, proj.revision, copyfile.src);\n                    objectId = inserter.insert(Constants.OBJ_BLOB, src);\n                    dcEntry = new DirCacheEntry(copyfile.dest);\n                    dcEntry.setObjectId(objectId);\n                    dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                    builder.add(dcEntry);\n                }\n            }\n            String content = cfg.toText();\n            final DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);\n            ObjectId objectId = inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n            dcEntry.setObjectId(objectId);\n            dcEntry.setFileMode(FileMode.REGULAR_FILE);\n            builder.add(dcEntry);\n            builder.finish();\n            ObjectId treeId = index.writeTree(inserter);\n            ObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n            CommitBuilder commit = new CommitBuilder();\n            commit.setTreeId(treeId);\n            if (headId != null)\n                commit.setParentIds(headId);\n            commit.setAuthor(author);\n            commit.setCommitter(author);\n            commit.setMessage(RepoText.get().repoCommitMessage);\n            ObjectId commitId = inserter.insert(commit);\n            inserter.flush();\n            RefUpdate ru = repo.updateRef(Constants.HEAD);\n            ru.setNewObjectId(commitId);\n            ru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());\n            Result rc = ru.update(rw);\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    break;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.name(), rc));\n            }\n            return rw.parseCommit(commitId);\n        } catch (IOException e) {\n            throw new ManifestErrorException(e);\n        } finally {\n            rw.release();\n        }\n    } else {\n        return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n    }\n}"
    },
    {
      "commit": "34dd64f6fe36ace1a90b0b503e2e37d877b7c621",
      "startLine": 79,
      "endLine": 91,
      "methodCode": "@Override\npublic RevCommit call() throws GitAPIException {\n    try {\n        checkCallable();\n        if (uri == null || uri.length() == 0)\n            throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n        if (inputStream == null) {\n            if (path == null || path.length() == 0)\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            try {\n                inputStream = new FileInputStream(path);\n            } catch (IOException e) {\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            }\n        }\n        if (repo.isBare()) {\n            bareProjects = new ArrayList<Project>();\n            if (author == null)\n                author = new PersonIdent(repo);\n            if (callback == null)\n                callback = new DefaultRemoteReader();\n        } else\n            git = new Git(repo);\n        XmlManifest manifest = new XmlManifest(this, includedReader, path, uri, groups);\n        try {\n            manifest.read(inputStream);\n        } catch (IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } finally {\n        try {\n            if (inputStream != null)\n                inputStream.close();\n        } catch (IOException e) {\n        }\n    }\n    if (repo.isBare()) {\n        DirCache index = DirCache.newInCore();\n        DirCacheBuilder builder = index.builder();\n        ObjectInserter inserter = repo.newObjectInserter();\n        RevWalk rw = new RevWalk(repo);\n        try {\n            Config cfg = new Config();\n            for (Project proj : bareProjects) {\n                String name = proj.path;\n                String uri = proj.name;\n                cfg.setString(\"submodule\", name, \"path\", name);\n                cfg.setString(\"submodule\", name, \"url\", uri);\n                DirCacheEntry dcEntry = new DirCacheEntry(name);\n                ObjectId objectId;\n                if (ObjectId.isId(proj.revision))\n                    objectId = ObjectId.fromString(proj.revision);\n                else {\n                    objectId = callback.sha1(uri, proj.revision);\n                }\n                if (objectId == null)\n                    throw new RemoteUnavailableException(uri);\n                dcEntry.setObjectId(objectId);\n                dcEntry.setFileMode(FileMode.GITLINK);\n                builder.add(dcEntry);\n                for (CopyFile copyfile : proj.copyfiles) {\n                    byte[] src = callback.readFile(uri, proj.revision, copyfile.src);\n                    objectId = inserter.insert(Constants.OBJ_BLOB, src);\n                    dcEntry = new DirCacheEntry(copyfile.dest);\n                    dcEntry.setObjectId(objectId);\n                    dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                    builder.add(dcEntry);\n                }\n            }\n            String content = cfg.toText();\n            final DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);\n            ObjectId objectId = inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n            dcEntry.setObjectId(objectId);\n            dcEntry.setFileMode(FileMode.REGULAR_FILE);\n            builder.add(dcEntry);\n            builder.finish();\n            ObjectId treeId = index.writeTree(inserter);\n            ObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n            CommitBuilder commit = new CommitBuilder();\n            commit.setTreeId(treeId);\n            if (headId != null)\n                commit.setParentIds(headId);\n            commit.setAuthor(author);\n            commit.setCommitter(author);\n            commit.setMessage(RepoText.get().repoCommitMessage);\n            ObjectId commitId = inserter.insert(commit);\n            inserter.flush();\n            RefUpdate ru = repo.updateRef(Constants.HEAD);\n            ru.setNewObjectId(commitId);\n            ru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());\n            Result rc = ru.update(rw);\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    break;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.name(), rc));\n            }\n            return rw.parseCommit(commitId);\n        } catch (IOException e) {\n            throw new ManifestErrorException(e);\n        } finally {\n            rw.release();\n        }\n    } else {\n        return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n    }\n}"
    },
    {
      "commit": "acd7ed52692bb7155333efea6dead712b7156ab9",
      "startLine": 79,
      "endLine": 91,
      "methodCode": "@Override\npublic RevCommit call() throws GitAPIException {\n    try {\n        checkCallable();\n        if (uri == null || uri.length() == 0)\n            throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n        if (inputStream == null) {\n            if (path == null || path.length() == 0)\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            try {\n                inputStream = new FileInputStream(path);\n            } catch (IOException e) {\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            }\n        }\n        if (repo.isBare()) {\n            bareProjects = new ArrayList<Project>();\n            if (author == null)\n                author = new PersonIdent(repo);\n            if (callback == null)\n                callback = new DefaultRemoteReader();\n        } else\n            git = new Git(repo);\n        XmlManifest manifest = new XmlManifest(this, inputStream, path, uri, groups);\n        try {\n            manifest.read();\n        } catch (IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } finally {\n        try {\n            if (inputStream != null)\n                inputStream.close();\n        } catch (IOException e) {\n        }\n    }\n    if (repo.isBare()) {\n        DirCache index = DirCache.newInCore();\n        DirCacheBuilder builder = index.builder();\n        ObjectInserter inserter = repo.newObjectInserter();\n        RevWalk rw = new RevWalk(repo);\n        try {\n            Config cfg = new Config();\n            for (Project proj : bareProjects) {\n                String name = proj.path;\n                String uri = proj.name;\n                cfg.setString(\"submodule\", name, \"path\", name);\n                cfg.setString(\"submodule\", name, \"url\", uri);\n                DirCacheEntry dcEntry = new DirCacheEntry(name);\n                ObjectId objectId;\n                if (ObjectId.isId(proj.revision))\n                    objectId = ObjectId.fromString(proj.revision);\n                else {\n                    objectId = callback.sha1(uri, proj.revision);\n                }\n                if (objectId == null)\n                    throw new RemoteUnavailableException(uri);\n                dcEntry.setObjectId(objectId);\n                dcEntry.setFileMode(FileMode.GITLINK);\n                builder.add(dcEntry);\n                for (CopyFile copyfile : proj.copyfiles) {\n                    byte[] src = callback.readFile(uri, proj.revision, copyfile.src);\n                    objectId = inserter.insert(Constants.OBJ_BLOB, src);\n                    dcEntry = new DirCacheEntry(copyfile.dest);\n                    dcEntry.setObjectId(objectId);\n                    dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                    builder.add(dcEntry);\n                }\n            }\n            String content = cfg.toText();\n            final DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);\n            ObjectId objectId = inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n            dcEntry.setObjectId(objectId);\n            dcEntry.setFileMode(FileMode.REGULAR_FILE);\n            builder.add(dcEntry);\n            builder.finish();\n            ObjectId treeId = index.writeTree(inserter);\n            ObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n            CommitBuilder commit = new CommitBuilder();\n            commit.setTreeId(treeId);\n            if (headId != null)\n                commit.setParentIds(headId);\n            commit.setAuthor(author);\n            commit.setCommitter(author);\n            commit.setMessage(RepoText.get().repoCommitMessage);\n            ObjectId commitId = inserter.insert(commit);\n            inserter.flush();\n            RefUpdate ru = repo.updateRef(Constants.HEAD);\n            ru.setNewObjectId(commitId);\n            ru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());\n            Result rc = ru.update(rw);\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    break;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.name(), rc));\n            }\n            return rw.parseCommit(commitId);\n        } catch (IOException e) {\n            throw new ManifestErrorException(e);\n        } finally {\n            rw.release();\n        }\n    } else {\n        return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n    }\n}"
    },
    {
      "commit": "0b15b48f741f87277e0d1c7d29637430b880dbde",
      "startLine": 64,
      "endLine": 76,
      "methodCode": "@Override\npublic RevCommit call() throws GitAPIException {\n    checkCallable();\n    if (path == null || path.length() == 0)\n        throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n    if (uri == null || uri.length() == 0)\n        throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n    if (repo.isBare()) {\n        bareProjects = new ArrayList<Project>();\n        if (author == null)\n            author = new PersonIdent(repo);\n        if (callback == null)\n            callback = new DefaultRemoteReader();\n    } else\n        git = new Git(repo);\n    XmlManifest manifest = new XmlManifest(this, path, uri, groups);\n    try {\n        manifest.read();\n    } catch (IOException e) {\n        throw new ManifestErrorException(e);\n    }\n    if (repo.isBare()) {\n        DirCache index = DirCache.newInCore();\n        DirCacheBuilder builder = index.builder();\n        ObjectInserter inserter = repo.newObjectInserter();\n        RevWalk rw = new RevWalk(repo);\n        try {\n            Config cfg = new Config();\n            for (Project proj : bareProjects) {\n                String name = proj.path;\n                String uri = proj.name;\n                cfg.setString(\"submodule\", name, \"path\", name);\n                cfg.setString(\"submodule\", name, \"url\", uri);\n                DirCacheEntry dcEntry = new DirCacheEntry(name);\n                ObjectId objectId;\n                if (ObjectId.isId(proj.revision))\n                    objectId = ObjectId.fromString(proj.revision);\n                else {\n                    objectId = callback.sha1(uri, proj.revision);\n                }\n                if (objectId == null)\n                    throw new RemoteUnavailableException(uri);\n                dcEntry.setObjectId(objectId);\n                dcEntry.setFileMode(FileMode.GITLINK);\n                builder.add(dcEntry);\n                for (CopyFile copyfile : proj.copyfiles) {\n                    byte[] src = callback.readFile(uri, proj.revision, copyfile.src);\n                    objectId = inserter.insert(Constants.OBJ_BLOB, src);\n                    dcEntry = new DirCacheEntry(copyfile.dest);\n                    dcEntry.setObjectId(objectId);\n                    dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                    builder.add(dcEntry);\n                }\n            }\n            String content = cfg.toText();\n            final DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);\n            ObjectId objectId = inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n            dcEntry.setObjectId(objectId);\n            dcEntry.setFileMode(FileMode.REGULAR_FILE);\n            builder.add(dcEntry);\n            builder.finish();\n            ObjectId treeId = index.writeTree(inserter);\n            ObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n            CommitBuilder commit = new CommitBuilder();\n            commit.setTreeId(treeId);\n            if (headId != null)\n                commit.setParentIds(headId);\n            commit.setAuthor(author);\n            commit.setCommitter(author);\n            commit.setMessage(RepoText.get().repoCommitMessage);\n            ObjectId commitId = inserter.insert(commit);\n            inserter.flush();\n            RefUpdate ru = repo.updateRef(Constants.HEAD);\n            ru.setNewObjectId(commitId);\n            ru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());\n            Result rc = ru.update(rw);\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    break;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.name(), rc));\n            }\n            return rw.parseCommit(commitId);\n        } catch (IOException e) {\n            throw new ManifestErrorException(e);\n        } finally {\n            rw.release();\n        }\n    } else {\n        return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n    }\n}"
    },
    {
      "commit": "d998bc938a21cb3871b442a3bb54b5807b6e4ed2",
      "startLine": 56,
      "endLine": 68,
      "methodCode": "@Override\npublic RevCommit call() throws GitAPIException {\n    checkCallable();\n    if (path == null || path.length() == 0)\n        throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n    if (uri == null || uri.length() == 0)\n        throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n    if (repo.isBare()) {\n        bareProjects = new ArrayList<Project>();\n        if (author == null)\n            author = new PersonIdent(repo);\n        if (callback == null)\n            callback = new DefaultRemoteReader();\n    } else\n        git = new Git(repo);\n    XmlManifest manifest = new XmlManifest(this, path, uri, groups);\n    try {\n        manifest.read();\n    } catch (IOException e) {\n        throw new ManifestErrorException(e);\n    }\n    if (repo.isBare()) {\n        DirCache index = DirCache.newInCore();\n        DirCacheBuilder builder = index.builder();\n        ObjectInserter inserter = repo.newObjectInserter();\n        RevWalk rw = new RevWalk(repo);\n        try {\n            Config cfg = new Config();\n            for (Project proj : bareProjects) {\n                String name = proj.path;\n                String uri = proj.name;\n                cfg.setString(\"submodule\", name, \"path\", name);\n                cfg.setString(\"submodule\", name, \"url\", uri);\n                final DirCacheEntry dcEntry = new DirCacheEntry(name);\n                ObjectId objectId;\n                if (ObjectId.isId(proj.revision))\n                    objectId = ObjectId.fromString(proj.revision);\n                else {\n                    objectId = callback.sha1(uri, proj.revision);\n                }\n                if (objectId == null)\n                    throw new RemoteUnavailableException(uri);\n                dcEntry.setObjectId(objectId);\n                dcEntry.setFileMode(FileMode.GITLINK);\n                builder.add(dcEntry);\n            }\n            String content = cfg.toText();\n            final DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);\n            ObjectId objectId = inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n            dcEntry.setObjectId(objectId);\n            dcEntry.setFileMode(FileMode.REGULAR_FILE);\n            builder.add(dcEntry);\n            builder.finish();\n            ObjectId treeId = index.writeTree(inserter);\n            ObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n            CommitBuilder commit = new CommitBuilder();\n            commit.setTreeId(treeId);\n            if (headId != null)\n                commit.setParentIds(headId);\n            commit.setAuthor(author);\n            commit.setCommitter(author);\n            commit.setMessage(RepoText.get().repoCommitMessage);\n            ObjectId commitId = inserter.insert(commit);\n            inserter.flush();\n            RefUpdate ru = repo.updateRef(Constants.HEAD);\n            ru.setNewObjectId(commitId);\n            ru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());\n            Result rc = ru.update(rw);\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    break;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.name(), rc));\n            }\n            return rw.parseCommit(commitId);\n        } catch (IOException e) {\n            throw new ManifestErrorException(e);\n        } finally {\n            rw.release();\n        }\n    } else {\n        return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n    }\n}"
    },
    {
      "commit": "056135a1482a9d56ee5055d6bc2df5bea032b5e5",
      "startLine": 58,
      "endLine": 70,
      "methodCode": "@Override\npublic RevCommit call() throws GitAPIException {\n    checkCallable();\n    if (path == null || path.length() == 0)\n        throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n    if (uri == null || uri.length() == 0)\n        throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n    if (repo.isBare()) {\n        bareProjects = new ArrayList<Project>();\n        if (author == null)\n            author = new PersonIdent(repo);\n        if (callback == null)\n            callback = new DefaultRemoteReader();\n    } else\n        git = new Git(repo);\n    XmlManifest manifest = new XmlManifest(this, path, uri, groups);\n    try {\n        manifest.read();\n    } catch (IOException e) {\n        throw new ManifestErrorException(e);\n    }\n    if (repo.isBare()) {\n        DirCache index = DirCache.newInCore();\n        DirCacheBuilder builder = index.builder();\n        ObjectInserter inserter = repo.newObjectInserter();\n        RevWalk rw = new RevWalk(repo);\n        try {\n            Config cfg = new Config();\n            for (Project proj : bareProjects) {\n                String name = proj.path;\n                String uri = proj.name;\n                cfg.setString(\"submodule\", name, \"path\", name);\n                cfg.setString(\"submodule\", name, \"url\", uri);\n                final DirCacheEntry dcEntry = new DirCacheEntry(name);\n                ObjectId objectId;\n                try {\n                    objectId = callback.sha1(uri);\n                } catch (GitAPIException e) {\n                    throw new RemoteUnavailableException(uri, e);\n                } catch (IllegalArgumentException e) {\n                    throw new ManifestErrorException(e);\n                }\n                if (objectId == null)\n                    throw new RemoteUnavailableException(uri, null);\n                dcEntry.setObjectId(objectId);\n                dcEntry.setFileMode(FileMode.GITLINK);\n                builder.add(dcEntry);\n            }\n            String content = cfg.toText();\n            final DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);\n            ObjectId objectId = inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n            dcEntry.setObjectId(objectId);\n            dcEntry.setFileMode(FileMode.REGULAR_FILE);\n            builder.add(dcEntry);\n            builder.finish();\n            ObjectId treeId = index.writeTree(inserter);\n            ObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n            CommitBuilder commit = new CommitBuilder();\n            commit.setTreeId(treeId);\n            if (headId != null)\n                commit.setParentIds(headId);\n            commit.setAuthor(author);\n            commit.setCommitter(author);\n            commit.setMessage(RepoText.get().repoCommitMessage);\n            ObjectId commitId = inserter.insert(commit);\n            inserter.flush();\n            RefUpdate ru = repo.updateRef(Constants.HEAD);\n            ru.setNewObjectId(commitId);\n            ru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());\n            Result rc = ru.update(rw);\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    break;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.name(), rc));\n            }\n            return rw.parseCommit(commitId);\n        } catch (IOException e) {\n            throw new ManifestErrorException(e);\n        } finally {\n            rw.release();\n        }\n    } else {\n        return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n    }\n}"
    }
  ]
}