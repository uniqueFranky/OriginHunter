{
  "statementVersions": [
    {
      "commit": "9a43d2ec208d2e8cd0866431acf26af3529f8677",
      "startLine": 27,
      "endLine": 35,
      "methodCode": "@Nullable\nprotected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n        if (this.environment instanceof ConfigurableEnvironment) {\n            processPropertySource(propertySource);\n        } else {\n            logger.info(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() + \"]. Reason: Environment must implement ConfigurableEnvironment\");\n        }\n    }\n    Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);\n    if (!componentScans.isEmpty() && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n        for (AnnotationAttributes componentScan : componentScans) {\n            Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();\n                if (bdCand == null) {\n                    bdCand = holder.getBeanDefinition();\n                }\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {\n                    parse(bdCand.getBeanClassName(), holder.getBeanName());\n                }\n            }\n        }\n    }\n    processImports(configClass, sourceClass, getImports(sourceClass), true);\n    AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n    if (importResource != null) {\n        String[] resources = importResource.getStringArray(\"locations\");\n        Class<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n            configClass.addImportedResource(resolvedResource, readerClass);\n        }\n    }\n    Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass);\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    processInterfaces(configClass, sourceClass);\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass = sourceClass.getMetadata().getSuperClassName();\n        if (superclass != null && !superclass.startsWith(\"java\") && !this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            return sourceClass.getSuperClass();\n        }\n    }\n    return null;\n}"
    },
    {
      "commit": "c8b6233bd03d43c8a91ec197e9cf1ea15bba478c",
      "startLine": 27,
      "endLine": 35,
      "methodCode": "@Nullable\nprotected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n        if (this.environment instanceof ConfigurableEnvironment) {\n            processPropertySource(propertySource);\n        } else {\n            logger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() + \"]. Reason: Environment must implement ConfigurableEnvironment\");\n        }\n    }\n    Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);\n    if (!componentScans.isEmpty() && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n        for (AnnotationAttributes componentScan : componentScans) {\n            Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();\n                if (bdCand == null) {\n                    bdCand = holder.getBeanDefinition();\n                }\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {\n                    parse(bdCand.getBeanClassName(), holder.getBeanName());\n                }\n            }\n        }\n    }\n    processImports(configClass, sourceClass, getImports(sourceClass), true);\n    AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n    if (importResource != null) {\n        String[] resources = importResource.getStringArray(\"locations\");\n        Class<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n            configClass.addImportedResource(resolvedResource, readerClass);\n        }\n    }\n    Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass);\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    processInterfaces(configClass, sourceClass);\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass = sourceClass.getMetadata().getSuperClassName();\n        if (superclass != null && !superclass.startsWith(\"java\") && !this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            return sourceClass.getSuperClass();\n        }\n    }\n    return null;\n}"
    },
    {
      "commit": "f813712f5b413b354560cd7cc006352e9defa9a3",
      "startLine": 23,
      "endLine": 31,
      "methodCode": "@Nullable\nprotected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n        if (this.environment instanceof ConfigurableEnvironment) {\n            processPropertySource(propertySource);\n        } else {\n            logger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() + \"]. Reason: Environment must implement ConfigurableEnvironment\");\n        }\n    }\n    Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);\n    if (!componentScans.isEmpty() && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n        for (AnnotationAttributes componentScan : componentScans) {\n            Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                    parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                }\n            }\n        }\n    }\n    processImports(configClass, sourceClass, getImports(sourceClass), true);\n    AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n    if (importResource != null) {\n        String[] resources = importResource.getStringArray(\"locations\");\n        Class<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n            configClass.addImportedResource(resolvedResource, readerClass);\n        }\n    }\n    Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass);\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    processInterfaces(configClass, sourceClass);\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass = sourceClass.getMetadata().getSuperClassName();\n        if (superclass != null && !superclass.startsWith(\"java\") && !this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            return sourceClass.getSuperClass();\n        }\n    }\n    return null;\n}"
    },
    {
      "commit": "87598f48e41d483745aba56cbf4e998c6f6d680c",
      "startLine": 23,
      "endLine": 31,
      "methodCode": "@Nullable\nprotected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n        if (this.environment instanceof ConfigurableEnvironment) {\n            processPropertySource(propertySource);\n        } else {\n            logger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() + \"]. Reason: Environment must implement ConfigurableEnvironment\");\n        }\n    }\n    Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);\n    if (!componentScans.isEmpty() && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n        for (AnnotationAttributes componentScan : componentScans) {\n            Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                    parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                }\n            }\n        }\n    }\n    processImports(configClass, sourceClass, getImports(sourceClass), true);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources = importResource.getStringArray(\"locations\");\n        Class<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n            configClass.addImportedResource(resolvedResource, readerClass);\n        }\n    }\n    Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass);\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    processInterfaces(configClass, sourceClass);\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass = sourceClass.getMetadata().getSuperClassName();\n        if (!superclass.startsWith(\"java\") && !this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            return sourceClass.getSuperClass();\n        }\n    }\n    return null;\n}"
    },
    {
      "commit": "91df0653fe5e22477ec2ed6dbe7e44b835c99038",
      "startLine": 22,
      "endLine": 30,
      "methodCode": "protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n        if (this.environment instanceof ConfigurableEnvironment) {\n            processPropertySource(propertySource);\n        } else {\n            logger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() + \"]. Reason: Environment must implement ConfigurableEnvironment\");\n        }\n    }\n    Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);\n    if (!componentScans.isEmpty() && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n        for (AnnotationAttributes componentScan : componentScans) {\n            Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                    parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                }\n            }\n        }\n    }\n    processImports(configClass, sourceClass, getImports(sourceClass), true);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources = importResource.getStringArray(\"locations\");\n        Class<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n            configClass.addImportedResource(resolvedResource, readerClass);\n        }\n    }\n    Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass);\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    processInterfaces(configClass, sourceClass);\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass = sourceClass.getMetadata().getSuperClassName();\n        if (!superclass.startsWith(\"java\") && !this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            return sourceClass.getSuperClass();\n        }\n    }\n    return null;\n}"
    },
    {
      "commit": "3295a4e6ef43c3e3053f41404ccf7da6ab53f310",
      "startLine": 22,
      "endLine": 30,
      "methodCode": "protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n        if (this.environment instanceof ConfigurableEnvironment) {\n            processPropertySource(propertySource);\n        } else {\n            logger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() + \"]. Reason: Environment must implement ConfigurableEnvironment\");\n        }\n    }\n    Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);\n    if (!componentScans.isEmpty() && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n        for (AnnotationAttributes componentScan : componentScans) {\n            Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                    parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                }\n            }\n        }\n    }\n    processImports(configClass, sourceClass, getImports(sourceClass), true);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources = importResource.getStringArray(\"locations\");\n        Class<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n            configClass.addImportedResource(resolvedResource, readerClass);\n        }\n    }\n    Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass);\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    processInterfaces(configClass, sourceClass);\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass = sourceClass.getMetadata().getSuperClassName();\n        if (!superclass.startsWith(\"java\") && !this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            return sourceClass.getSuperClass();\n        }\n    }\n    return null;\n}"
    },
    {
      "commit": "d96a66ae8fc01cb480132e909b320a6c6addbfde",
      "startLine": 22,
      "endLine": 30,
      "methodCode": "protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n        if (this.environment instanceof ConfigurableEnvironment) {\n            processPropertySource(propertySource);\n        } else {\n            logger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() + \"]. Reason: Environment must implement ConfigurableEnvironment\");\n        }\n    }\n    Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);\n    if (!componentScans.isEmpty() && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n        for (AnnotationAttributes componentScan : componentScans) {\n            Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                    parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                }\n            }\n        }\n    }\n    processImports(configClass, sourceClass, getImports(sourceClass), true);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources = importResource.getStringArray(\"locations\");\n        Class<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n            configClass.addImportedResource(resolvedResource, readerClass);\n        }\n    }\n    Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    processInterfaces(configClass, sourceClass);\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass = sourceClass.getMetadata().getSuperClassName();\n        if (!superclass.startsWith(\"java\") && !this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            return sourceClass.getSuperClass();\n        }\n    }\n    return null;\n}"
    },
    {
      "commit": "316244d2bdcb288ef4e6ff58daef6da0511fe765",
      "startLine": 28,
      "endLine": 36,
      "methodCode": "protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n        if (this.environment instanceof ConfigurableEnvironment) {\n            processPropertySource(propertySource);\n        } else {\n            logger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() + \"]. Reason: Environment must implement ConfigurableEnvironment\");\n        }\n    }\n    Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);\n    if (!componentScans.isEmpty() && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n        for (AnnotationAttributes componentScan : componentScans) {\n            Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                    ImportStack previousStack = this.importStack;\n                    this.importStack = new ImportStack();\n                    try {\n                        parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                    } finally {\n                        this.importStack = previousStack;\n                    }\n                }\n            }\n        }\n    }\n    processImports(configClass, sourceClass, getImports(sourceClass), true);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources = importResource.getStringArray(\"locations\");\n        Class<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n            configClass.addImportedResource(resolvedResource, readerClass);\n        }\n    }\n    Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    processInterfaces(configClass, sourceClass);\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass = sourceClass.getMetadata().getSuperClassName();\n        if (!superclass.startsWith(\"java\") && !this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            return sourceClass.getSuperClass();\n        }\n    }\n    return null;\n}"
    },
    {
      "commit": "3d3407c78992bbb504ae96a8f3eb17dbca07bcc7",
      "startLine": 22,
      "endLine": 30,
      "methodCode": "protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n        if (this.environment instanceof ConfigurableEnvironment) {\n            processPropertySource(propertySource);\n        } else {\n            logger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() + \"]. Reason: Environment must implement ConfigurableEnvironment\");\n        }\n    }\n    Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);\n    if (!componentScans.isEmpty() && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n        for (AnnotationAttributes componentScan : componentScans) {\n            Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                    parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                }\n            }\n        }\n    }\n    processImports(configClass, sourceClass, getImports(sourceClass), true);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources = importResource.getStringArray(\"locations\");\n        Class<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n            configClass.addImportedResource(resolvedResource, readerClass);\n        }\n    }\n    Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    processInterfaces(configClass, sourceClass);\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass = sourceClass.getMetadata().getSuperClassName();\n        if (!superclass.startsWith(\"java\") && !this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            return sourceClass.getSuperClass();\n        }\n    }\n    return null;\n}"
    },
    {
      "commit": "03affa02dbb3d629d12228b1622a1d2c8cd37931",
      "startLine": 22,
      "endLine": 30,
      "methodCode": "protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n        if (this.environment instanceof ConfigurableEnvironment) {\n            processPropertySource(propertySource);\n        } else {\n            logger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() + \"]. Reason: Environment must implement ConfigurableEnvironment\");\n        }\n    }\n    Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);\n    if (!componentScans.isEmpty() && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n        for (AnnotationAttributes componentScan : componentScans) {\n            Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                    parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                }\n            }\n        }\n    }\n    processImports(configClass, sourceClass, getImports(sourceClass), true);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources = importResource.getAliasedStringArray(\"locations\", ImportResource.class, sourceClass);\n        Class<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n            configClass.addImportedResource(resolvedResource, readerClass);\n        }\n    }\n    Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    processInterfaces(configClass, sourceClass);\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass = sourceClass.getMetadata().getSuperClassName();\n        if (!superclass.startsWith(\"java\") && !this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            return sourceClass.getSuperClass();\n        }\n    }\n    return null;\n}"
    },
    {
      "commit": "388bd87ef03b3c080f1c351855d01af1df033a94",
      "startLine": 22,
      "endLine": 30,
      "methodCode": "protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n        if (this.environment instanceof ConfigurableEnvironment) {\n            processPropertySource(propertySource);\n        } else {\n            logger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() + \"]. Reason: Environment must implement ConfigurableEnvironment\");\n        }\n    }\n    Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);\n    if (!componentScans.isEmpty() && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n        for (AnnotationAttributes componentScan : componentScans) {\n            Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                    parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                }\n            }\n        }\n    }\n    processImports(configClass, sourceClass, getImports(sourceClass), true);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources = importResource.getAliasedStringArray(\"locations\", ImportResource.class, sourceClass);\n        Class<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n            configClass.addImportedResource(resolvedResource, readerClass);\n        }\n    }\n    Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    for (SourceClass ifc : sourceClass.getInterfaces()) {\n        beanMethods = ifc.getMetadata().getAnnotatedMethods(Bean.class.getName());\n        for (MethodMetadata methodMetadata : beanMethods) {\n            if (!methodMetadata.isAbstract()) {\n                configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n            }\n        }\n    }\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass = sourceClass.getMetadata().getSuperClassName();\n        if (!superclass.startsWith(\"java\") && !this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            return sourceClass.getSuperClass();\n        }\n    }\n    return null;\n}"
    },
    {
      "commit": "d3b5aeb768b89d960302b471bd4b3e913dd2df27",
      "startLine": 20,
      "endLine": 28,
      "methodCode": "protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n        if (this.environment instanceof ConfigurableEnvironment) {\n            processPropertySource(propertySource);\n        } else {\n            logger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() + \"]. Reason: Environment must implement ConfigurableEnvironment\");\n        }\n    }\n    AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n    if (componentScan != null && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n        Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n        for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n            if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n            }\n        }\n    }\n    processImports(configClass, sourceClass, getImports(sourceClass), true);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources = importResource.getAliasedStringArray(\"locations\", ImportResource.class, sourceClass);\n        Class<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n            configClass.addImportedResource(resolvedResource, readerClass);\n        }\n    }\n    Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    for (SourceClass ifc : sourceClass.getInterfaces()) {\n        beanMethods = ifc.getMetadata().getAnnotatedMethods(Bean.class.getName());\n        for (MethodMetadata methodMetadata : beanMethods) {\n            if (!methodMetadata.isAbstract()) {\n                configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n            }\n        }\n    }\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass = sourceClass.getMetadata().getSuperClassName();\n        if (!superclass.startsWith(\"java\") && !this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            return sourceClass.getSuperClass();\n        }\n    }\n    return null;\n}"
    },
    {
      "commit": "1a8c6fa5ee9e70ed880cd2e9afefc4fe38283f1e",
      "startLine": 20,
      "endLine": 28,
      "methodCode": "protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n        if (this.environment instanceof ConfigurableEnvironment) {\n            processPropertySource(propertySource);\n        } else {\n            logger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() + \"]. Reason: Environment must implement ConfigurableEnvironment\");\n        }\n    }\n    AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n    if (componentScan != null && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n        Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n        for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n            if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n            }\n        }\n    }\n    processImports(configClass, sourceClass, getImports(sourceClass), true);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources = importResource.getStringArray(\"value\");\n        Class<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n            configClass.addImportedResource(resolvedResource, readerClass);\n        }\n    }\n    Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    for (SourceClass ifc : sourceClass.getInterfaces()) {\n        beanMethods = ifc.getMetadata().getAnnotatedMethods(Bean.class.getName());\n        for (MethodMetadata methodMetadata : beanMethods) {\n            if (!methodMetadata.isAbstract()) {\n                configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n            }\n        }\n    }\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass = sourceClass.getMetadata().getSuperClassName();\n        if (!superclass.startsWith(\"java\") && !this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            return sourceClass.getSuperClass();\n        }\n    }\n    return null;\n}"
    },
    {
      "commit": "192462902ef3d97c0b6684d467c7d2023ecd5be1",
      "startLine": 20,
      "endLine": 28,
      "methodCode": "protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n        if (this.environment instanceof ConfigurableEnvironment) {\n            processPropertySource(propertySource);\n        } else {\n            logger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() + \"]. Reason: Environment must implement ConfigurableEnvironment\");\n        }\n    }\n    AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n    if (componentScan != null && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n        Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n        for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n            if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n            }\n        }\n    }\n    processImports(configClass, sourceClass, getImports(sourceClass), true, false);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources = importResource.getStringArray(\"value\");\n        Class<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n            configClass.addImportedResource(resolvedResource, readerClass);\n        }\n    }\n    Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    for (SourceClass ifc : sourceClass.getInterfaces()) {\n        beanMethods = ifc.getMetadata().getAnnotatedMethods(Bean.class.getName());\n        for (MethodMetadata methodMetadata : beanMethods) {\n            if (!methodMetadata.isAbstract()) {\n                configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n            }\n        }\n    }\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass = sourceClass.getMetadata().getSuperClassName();\n        if (!superclass.startsWith(\"java\") && !this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            return sourceClass.getSuperClass();\n        }\n    }\n    return null;\n}"
    },
    {
      "commit": "078f23d6e65c7c377b7e20681214e2c7fcf5f2b4",
      "startLine": 20,
      "endLine": 28,
      "methodCode": "protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n        if (this.environment instanceof ConfigurableEnvironment) {\n            processPropertySource(propertySource);\n        } else {\n            logger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() + \"]. Reason: Environment must implement ConfigurableEnvironment\");\n        }\n    }\n    AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n    if (componentScan != null && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n        Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n        for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n            if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n            }\n        }\n    }\n    processImports(configClass, sourceClass, getImports(sourceClass), true, false);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources = importResource.getStringArray(\"value\");\n        Class<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n            configClass.addImportedResource(resolvedResource, readerClass);\n        }\n    }\n    Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass = sourceClass.getMetadata().getSuperClassName();\n        if (!superclass.startsWith(\"java\") && !this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            return sourceClass.getSuperClass();\n        }\n    }\n    return null;\n}"
    },
    {
      "commit": "9dfbc5326b17ab48a0335efa4d82e15e6df0dfae",
      "startLine": 22,
      "endLine": 30,
      "methodCode": "protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n        if (this.environment instanceof ConfigurableEnvironment) {\n            processPropertySource(propertySource);\n        } else {\n            logger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() + \"]. Reason: Environment must implement ConfigurableEnvironment\");\n        }\n    }\n    AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n    if (componentScan != null) {\n        if (!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n            Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                    parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                }\n            }\n        }\n    }\n    processImports(configClass, sourceClass, getImports(sourceClass), true, false);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources = importResource.getStringArray(\"value\");\n        Class<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n            configClass.addImportedResource(resolvedResource, readerClass);\n        }\n    }\n    Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass = sourceClass.getMetadata().getSuperClassName();\n        if (!superclass.startsWith(\"java\") && !this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            return sourceClass.getSuperClass();\n        }\n    }\n    return null;\n}"
    },
    {
      "commit": "84564a0c7b6c34cec4beede6ee75078a6073abb9",
      "startLine": 22,
      "endLine": 30,
      "methodCode": "protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n        if (!(this.environment instanceof ConfigurableEnvironment)) {\n            logger.warn(\"Ignoring @PropertySource annotation on \" + sourceClass.getMetadata().getClassName() + \"Reason: Environment must implement ConfigurableEnvironment\");\n        } else {\n            processPropertySource(propertySource);\n        }\n    }\n    AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n    if (componentScan != null) {\n        if (!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n            Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                    parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                }\n            }\n        }\n    }\n    processImports(configClass, sourceClass, getImports(sourceClass), true, false);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources = importResource.getStringArray(\"value\");\n        Class<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n            configClass.addImportedResource(resolvedResource, readerClass);\n        }\n    }\n    Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass = sourceClass.getMetadata().getSuperClassName();\n        if (!superclass.startsWith(\"java\") && !this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            return sourceClass.getSuperClass();\n        }\n    }\n    return null;\n}"
    },
    {
      "commit": "7c6088861f9e59f4e29c7f9d47a2cf467c4e8cd6",
      "startLine": 19,
      "endLine": 27,
      "methodCode": "protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n        processPropertySource(propertySource);\n    }\n    registerPropertySources();\n    AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n    if (componentScan != null) {\n        if (!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n            Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                    parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                }\n            }\n        }\n    }\n    processImports(configClass, sourceClass, getImports(sourceClass), true, false);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources = importResource.getStringArray(\"value\");\n        Class<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n            configClass.addImportedResource(resolvedResource, readerClass);\n        }\n    }\n    Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass = sourceClass.getMetadata().getSuperClassName();\n        if (!superclass.startsWith(\"java\") && !this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            return sourceClass.getSuperClass();\n        }\n    }\n    return null;\n}"
    },
    {
      "commit": "bbf58008314bd42dd20c92602c1133287423dc7f",
      "startLine": 18,
      "endLine": 26,
      "methodCode": "protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n        processPropertySource(propertySource);\n    }\n    AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n    if (componentScan != null) {\n        if (!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n            Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                    parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                }\n            }\n        }\n    }\n    processImports(configClass, sourceClass, getImports(sourceClass), true, false);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources = importResource.getStringArray(\"value\");\n        Class<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n            configClass.addImportedResource(resolvedResource, readerClass);\n        }\n    }\n    Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass = sourceClass.getMetadata().getSuperClassName();\n        if (!superclass.startsWith(\"java\") && !this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            return sourceClass.getSuperClass();\n        }\n    }\n    return null;\n}"
    },
    {
      "commit": "ce1954da1edd64f1280ead0435c7b3923e33f6da",
      "startLine": 18,
      "endLine": 26,
      "methodCode": "protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n        processPropertySource(propertySource);\n    }\n    AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n    if (componentScan != null) {\n        if (!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n            Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                    parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                }\n            }\n        }\n    }\n    processImports(configClass, sourceClass, getImports(sourceClass), true);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources = importResource.getStringArray(\"value\");\n        Class<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n            configClass.addImportedResource(resolvedResource, readerClass);\n        }\n    }\n    Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass = sourceClass.getMetadata().getSuperClassName();\n        if (!superclass.startsWith(\"java\") && !this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            try {\n                return sourceClass.getSuperClass();\n            } catch (ClassNotFoundException ex) {\n                throw new IllegalStateException(ex);\n            }\n        }\n    }\n    return null;\n}"
    },
    {
      "commit": "e8dead247c7d421074caf171456e0653d63780f7",
      "startLine": 18,
      "endLine": 26,
      "methodCode": "protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n        processPropertySource(propertySource);\n    }\n    AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n    if (componentScan != null) {\n        if (!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n            Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                    parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                }\n            }\n        }\n    }\n    processImports(configClass, sourceClass, getImports(sourceClass), true);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources = importResource.getStringArray(\"value\");\n        Class<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n            configClass.addImportedResource(resolvedResource, readerClass);\n        }\n    }\n    Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass = sourceClass.getMetadata().getSuperClassName();\n        if (!this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            try {\n                return sourceClass.getSuperClass();\n            } catch (ClassNotFoundException ex) {\n                throw new IllegalStateException(ex);\n            }\n        }\n    }\n    return null;\n}"
    },
    {
      "commit": "e95bd9e25086bf1dad37f8d08293c948621faf6b",
      "startLine": 18,
      "endLine": 26,
      "methodCode": "protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n        processPropertySource(propertySource);\n    }\n    AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n    if (componentScan != null) {\n        if (!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n            Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                    parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                }\n            }\n        }\n    }\n    processImports(configClass, getImports(sourceClass), true);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources = importResource.getStringArray(\"value\");\n        Class<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n            configClass.addImportedResource(resolvedResource, readerClass);\n        }\n    }\n    Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass = sourceClass.getMetadata().getSuperClassName();\n        if (!this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            try {\n                return sourceClass.getSuperClass();\n            } catch (ClassNotFoundException ex) {\n                throw new IllegalStateException(ex);\n            }\n        }\n    }\n    return null;\n}"
    },
    {
      "commit": "d87838fc6d0923659465ca5b75d8e0ba628afb77",
      "startLine": 19,
      "endLine": 27,
      "methodCode": "protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    AnnotationAttributes propertySource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class);\n    if (propertySource != null) {\n        processPropertySource(propertySource);\n    }\n    AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n    if (componentScan != null) {\n        if (!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n            Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                    parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                }\n            }\n        }\n    }\n    processImports(configClass, getImports(sourceClass), true);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources = importResource.getStringArray(\"value\");\n        Class<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n            configClass.addImportedResource(resolvedResource, readerClass);\n        }\n    }\n    Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass = sourceClass.getMetadata().getSuperClassName();\n        if (!this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            try {\n                return sourceClass.getSuperClass();\n            } catch (ClassNotFoundException ex) {\n                throw new IllegalStateException(ex);\n            }\n        }\n    }\n    return null;\n}"
    },
    {
      "commit": "ced5ea2f93a474646e9554354ca09c0c12e967e8",
      "startLine": 19,
      "endLine": 27,
      "methodCode": "protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    AnnotationAttributes propertySource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class);\n    if (propertySource != null) {\n        processPropertySource(propertySource);\n    }\n    AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n    if (componentScan != null) {\n        if (!conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n            Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                    parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                }\n            }\n        }\n    }\n    processImports(configClass, getImports(sourceClass), true);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources = importResource.getStringArray(\"value\");\n        Class<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n            configClass.addImportedResource(resolvedResource, readerClass);\n        }\n    }\n    Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass = sourceClass.getMetadata().getSuperClassName();\n        if (!this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            try {\n                return sourceClass.getSuperClass();\n            } catch (ClassNotFoundException ex) {\n                throw new IllegalStateException(ex);\n            }\n        }\n    }\n    return null;\n}"
    },
    {
      "commit": "620c16f5c7bb543b18f71b2848f90461f8646237",
      "startLine": 19,
      "endLine": 27,
      "methodCode": "protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    AnnotationAttributes propertySource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class);\n    if (propertySource != null) {\n        processPropertySource(propertySource);\n    }\n    AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n    if (componentScan != null) {\n        if (!shouldSkip(sourceClass, ConfigurationPhase.REGISTER_BEAN)) {\n            Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                    parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                }\n            }\n        }\n    }\n    processImports(configClass, getImports(sourceClass), true);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources = importResource.getStringArray(\"value\");\n        Class<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n            configClass.addImportedResource(resolvedResource, readerClass);\n        }\n    }\n    Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass = sourceClass.getMetadata().getSuperClassName();\n        if (!this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            return sourceClass.getSuperClass();\n        }\n    }\n    return null;\n}"
    },
    {
      "commit": "c9771012e98afe1679cd1c3ebf5ab6c1a018fd65",
      "startLine": 19,
      "endLine": 27,
      "methodCode": "protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    AnnotationAttributes propertySource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class);\n    if (propertySource != null) {\n        processPropertySource(propertySource);\n    }\n    AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n    if (componentScan != null) {\n        if (!conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n            Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                    parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                }\n            }\n        }\n    }\n    processImports(configClass, getImports(sourceClass), true);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources = importResource.getStringArray(\"value\");\n        Class<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n            configClass.addImportedResource(resolvedResource, readerClass);\n        }\n    }\n    Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass = sourceClass.getMetadata().getSuperClassName();\n        if (!this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            try {\n                return sourceClass.getSuperClass();\n            } catch (ClassNotFoundException ex) {\n                throw new IllegalStateException(ex);\n            }\n        }\n    }\n    return null;\n}"
    },
    {
      "commit": "1a8f0d6a9e37d12b31a2fe7bc1fbc2c91700a08e",
      "startLine": 19,
      "endLine": 27,
      "methodCode": "protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    AnnotationAttributes propertySource = attributesFor(sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class);\n    if (propertySource != null) {\n        processPropertySource(propertySource);\n    }\n    AnnotationAttributes componentScan = attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n    if (componentScan != null) {\n        if (!conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n            Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                    parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                }\n            }\n        }\n    }\n    processImports(configClass, getImports(sourceClass), true);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource = attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources = importResource.getStringArray(\"value\");\n        Class<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n            configClass.addImportedResource(resolvedResource, readerClass);\n        }\n    }\n    Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass = sourceClass.getMetadata().getSuperClassName();\n        if (!this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            try {\n                return sourceClass.getSuperClass();\n            } catch (ClassNotFoundException ex) {\n                throw new IllegalStateException(ex);\n            }\n        }\n    }\n    return null;\n}"
    },
    {
      "commit": "2e2e9b8dd0ecb113c86ec3a5d0cf87d4f6f72fd6",
      "startLine": 19,
      "endLine": 26,
      "methodCode": "protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    AnnotationAttributes propertySource = attributesFor(sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class);\n    if (propertySource != null) {\n        processPropertySource(propertySource);\n    }\n    AnnotationAttributes componentScan = attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n    if (componentScan != null) {\n        if (!conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n            Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                    parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                }\n            }\n        }\n    }\n    processImports(configClass, getImports(sourceClass), true);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource = attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources = importResource.getStringArray(\"value\");\n        Class<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass = sourceClass.getMetadata().getSuperClassName();\n        if (!this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            try {\n                return sourceClass.getSuperClass();\n            } catch (ClassNotFoundException ex) {\n                throw new IllegalStateException(ex);\n            }\n        }\n    }\n    return null;\n}"
    },
    {
      "commit": "e10e16cd6b2a2342a6b7d169878117046b6c5e16",
      "startLine": 19,
      "endLine": 26,
      "methodCode": "protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    AnnotationAttributes propertySource = attributesFor(sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class);\n    if (propertySource != null) {\n        processPropertySource(propertySource);\n    }\n    AnnotationAttributes componentScan = attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n    if (componentScan != null) {\n        if (!ConditionEvaluator.get(configClass.getMetadata(), false).shouldSkip(this.registry, this.environment)) {\n            Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                    this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                }\n            }\n        }\n    }\n    processImports(configClass, getImports(sourceClass), true);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource = attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources = importResource.getStringArray(\"value\");\n        Class<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass = sourceClass.getMetadata().getSuperClassName();\n        if (!this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            try {\n                return sourceClass.getSuperClass();\n            } catch (ClassNotFoundException ex) {\n                throw new IllegalStateException(ex);\n            }\n        }\n    }\n    return null;\n}"
    },
    {
      "commit": "239ce1466ce118294f5c7b8e842a80815fd813de",
      "startLine": 24,
      "endLine": 31,
      "methodCode": "protected AnnotationMetadata doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    processMemberClasses(configClass, metadata);\n    AnnotationAttributes propertySource = attributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n    if (propertySource != null) {\n        processPropertySource(propertySource);\n    }\n    AnnotationAttributes componentScan = attributesFor(metadata, ComponentScan.class);\n    if (componentScan != null) {\n        if (!ConditionEvaluator.get(configClass.getMetadata(), false).shouldSkip(this.registry, this.environment)) {\n            Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan, metadata.getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                    this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                }\n            }\n        }\n    }\n    Set<Object> imports = new LinkedHashSet<Object>();\n    Set<Object> visited = new LinkedHashSet<Object>();\n    collectImports(metadata, imports, visited);\n    if (!imports.isEmpty()) {\n        processImport(configClass, imports, true);\n    }\n    if (metadata.isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource = attributesFor(metadata, ImportResource.class);\n        String[] resources = importResource.getStringArray(\"value\");\n        Class<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (metadata.hasSuperClass()) {\n        String superclass = metadata.getSuperClassName();\n        if (!this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            if (metadata instanceof StandardAnnotationMetadata) {\n                Class<?> clazz = ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n                return new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n            } else if (superclass.startsWith(\"java\")) {\n                try {\n                    return new StandardAnnotationMetadata(this.resourceLoader.getClassLoader().loadClass(superclass), true);\n                } catch (ClassNotFoundException ex) {\n                    throw new IllegalStateException(ex);\n                }\n            } else {\n                MetadataReader reader = this.metadataReaderFactory.getMetadataReader(superclass);\n                return reader.getAnnotationMetadata();\n            }\n        }\n    }\n    return null;\n}"
    },
    {
      "commit": "3f7007f73a3b8d660e9ff0224f1d87483650d2c2",
      "startLine": 22,
      "endLine": 29,
      "methodCode": "protected AnnotationMetadata doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    processMemberClasses(configClass, metadata);\n    AnnotationAttributes propertySource = attributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n    if (propertySource != null) {\n        processPropertySource(propertySource);\n    }\n    AnnotationAttributes componentScan = attributesFor(metadata, ComponentScan.class);\n    if (componentScan != null) {\n        Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan, metadata.getClassName());\n        for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n            if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n            }\n        }\n    }\n    Set<Object> imports = new LinkedHashSet<Object>();\n    Set<Object> visited = new LinkedHashSet<Object>();\n    collectImports(metadata, imports, visited);\n    if (!imports.isEmpty()) {\n        processImport(configClass, imports, true);\n    }\n    if (metadata.isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource = attributesFor(metadata, ImportResource.class);\n        String[] resources = importResource.getStringArray(\"value\");\n        Class<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (metadata.hasSuperClass()) {\n        String superclass = metadata.getSuperClassName();\n        if (!this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            if (metadata instanceof StandardAnnotationMetadata) {\n                Class<?> clazz = ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n                return new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n            } else if (superclass.startsWith(\"java\")) {\n                try {\n                    return new StandardAnnotationMetadata(this.resourceLoader.getClassLoader().loadClass(superclass), true);\n                } catch (ClassNotFoundException ex) {\n                    throw new IllegalStateException(ex);\n                }\n            } else {\n                MetadataReader reader = this.metadataReaderFactory.getMetadataReader(superclass);\n                return reader.getAnnotationMetadata();\n            }\n        }\n    }\n    return null;\n}"
    },
    {
      "commit": "b257253a2b6890ef532f27a662c441fc4fd21f3b",
      "startLine": 22,
      "endLine": 29,
      "methodCode": "protected AnnotationMetadata doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    processMemberClasses(configClass, metadata);\n    AnnotationAttributes propertySource = attributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n    if (propertySource != null) {\n        processPropertySource(propertySource);\n    }\n    AnnotationAttributes componentScan = attributesFor(metadata, ComponentScan.class);\n    if (componentScan != null) {\n        Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan, metadata.getClassName());\n        for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n            if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n            }\n        }\n    }\n    Set<Object> imports = new LinkedHashSet<Object>();\n    Set<Object> visited = new LinkedHashSet<Object>();\n    collectImports(metadata, imports, visited);\n    if (!imports.isEmpty()) {\n        processImport(configClass, imports, true);\n    }\n    if (metadata.isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource = attributesFor(metadata, ImportResource.class);\n        String[] resources = importResource.getStringArray(\"value\");\n        Class<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (metadata.hasSuperClass()) {\n        String superclass = metadata.getSuperClassName();\n        if (this.knownSuperclasses.add(superclass)) {\n            if (metadata instanceof StandardAnnotationMetadata) {\n                Class<?> clazz = ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n                return new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n            } else if (superclass.startsWith(\"java\")) {\n                try {\n                    return new StandardAnnotationMetadata(this.resourceLoader.getClassLoader().loadClass(superclass), true);\n                } catch (ClassNotFoundException ex) {\n                    throw new IllegalStateException(ex);\n                }\n            } else {\n                MetadataReader reader = this.metadataReaderFactory.getMetadataReader(superclass);\n                return reader.getAnnotationMetadata();\n            }\n        }\n    }\n    return null;\n}"
    },
    {
      "commit": "d3a406876834b91a4cf3b1e840855caeb0446d28",
      "startLine": 22,
      "endLine": 29,
      "methodCode": "protected AnnotationMetadata doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    processMemberClasses(metadata);\n    AnnotationAttributes propertySource = attributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n    if (propertySource != null) {\n        processPropertySource(propertySource);\n    }\n    AnnotationAttributes componentScan = attributesFor(metadata, ComponentScan.class);\n    if (componentScan != null) {\n        Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan, metadata.getClassName());\n        for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n            if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n            }\n        }\n    }\n    Set<Object> imports = new LinkedHashSet<Object>();\n    Set<Object> visited = new LinkedHashSet<Object>();\n    collectImports(metadata, imports, visited);\n    if (!imports.isEmpty()) {\n        processImport(configClass, imports, true);\n    }\n    if (metadata.isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource = attributesFor(metadata, ImportResource.class);\n        String[] resources = importResource.getStringArray(\"value\");\n        Class<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (metadata.hasSuperClass()) {\n        String superclass = metadata.getSuperClassName();\n        if (this.knownSuperclasses.add(superclass)) {\n            if (metadata instanceof StandardAnnotationMetadata) {\n                Class<?> clazz = ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n                return new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n            } else if (superclass.startsWith(\"java\")) {\n                try {\n                    return new StandardAnnotationMetadata(this.resourceLoader.getClassLoader().loadClass(superclass), true);\n                } catch (ClassNotFoundException ex) {\n                    throw new IllegalStateException(ex);\n                }\n            } else {\n                MetadataReader reader = this.metadataReaderFactory.getMetadataReader(superclass);\n                return reader.getAnnotationMetadata();\n            }\n        }\n    }\n    return null;\n}"
    },
    {
      "commit": "6d77f1cf3b3f060ead70d49079bc87d75e0b105c",
      "startLine": 50,
      "endLine": 57,
      "methodCode": "protected AnnotationMetadata doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    for (String memberClassName : metadata.getMemberClassNames()) {\n        MetadataReader reader = this.metadataReaderFactory.getMetadataReader(memberClassName);\n        AnnotationMetadata memberClassMetadata = reader.getAnnotationMetadata();\n        if (ConfigurationClassUtils.isConfigurationCandidate(memberClassMetadata)) {\n            processConfigurationClass(new ConfigurationClass(reader, true));\n        }\n    }\n    AnnotationAttributes propertySource = attributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n    if (propertySource != null) {\n        String name = propertySource.getString(\"name\");\n        String[] locations = propertySource.getStringArray(\"value\");\n        int nLocations = locations.length;\n        if (nLocations == 0) {\n            throw new IllegalArgumentException(\"At least one @PropertySource(value) location is required\");\n        }\n        for (int i = 0; i < nLocations; i++) {\n            locations[i] = this.environment.resolveRequiredPlaceholders(locations[i]);\n        }\n        ClassLoader classLoader = this.resourceLoader.getClassLoader();\n        if (!StringUtils.hasText(name)) {\n            for (String location : locations) {\n                this.propertySources.push(new ResourcePropertySource(location, classLoader));\n            }\n        } else {\n            if (nLocations == 1) {\n                this.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader));\n            } else {\n                CompositePropertySource ps = new CompositePropertySource(name);\n                for (String location : locations) {\n                    ps.addPropertySource(new ResourcePropertySource(location, classLoader));\n                }\n                this.propertySources.push(ps);\n            }\n        }\n    }\n    AnnotationAttributes componentScan = attributesFor(metadata, ComponentScan.class);\n    if (componentScan != null) {\n        Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan, metadata.getClassName());\n        for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n            if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n            }\n        }\n    }\n    Set<String> imports = getImports(metadata.getClassName(), null, new HashSet<String>());\n    if (!CollectionUtils.isEmpty(imports)) {\n        processImport(configClass, imports.toArray(new String[imports.size()]), true);\n    }\n    if (metadata.isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource = attributesFor(metadata, ImportResource.class);\n        String[] resources = importResource.getStringArray(\"value\");\n        Class<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (metadata.hasSuperClass()) {\n        String superclass = metadata.getSuperClassName();\n        if (this.knownSuperclasses.add(superclass)) {\n            if (metadata instanceof StandardAnnotationMetadata) {\n                Class<?> clazz = ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n                return new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n            } else if (superclass.startsWith(\"java\")) {\n                try {\n                    return new StandardAnnotationMetadata(this.resourceLoader.getClassLoader().loadClass(superclass), true);\n                } catch (ClassNotFoundException ex) {\n                    throw new IllegalStateException(ex);\n                }\n            } else {\n                MetadataReader reader = this.metadataReaderFactory.getMetadataReader(superclass);\n                return reader.getAnnotationMetadata();\n            }\n        }\n    }\n    return null;\n}"
    },
    {
      "commit": "a92f7dd474406a02844ec635fde6c22eb8ef8456",
      "startLine": 50,
      "endLine": 57,
      "methodCode": "protected AnnotationMetadata doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    for (String memberClassName : metadata.getMemberClassNames()) {\n        MetadataReader reader = this.metadataReaderFactory.getMetadataReader(memberClassName);\n        AnnotationMetadata memberClassMetadata = reader.getAnnotationMetadata();\n        if (ConfigurationClassUtils.isConfigurationCandidate(memberClassMetadata)) {\n            processConfigurationClass(new ConfigurationClass(reader, true));\n        }\n    }\n    AnnotationAttributes propertySource = attributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n    if (propertySource != null) {\n        String name = propertySource.getString(\"name\");\n        String[] locations = propertySource.getStringArray(\"value\");\n        int nLocations = locations.length;\n        if (nLocations == 0) {\n            throw new IllegalArgumentException(\"At least one @PropertySource(value) location is required\");\n        }\n        for (int i = 0; i < nLocations; i++) {\n            locations[i] = this.environment.resolveRequiredPlaceholders(locations[i]);\n        }\n        ClassLoader classLoader = this.resourceLoader.getClassLoader();\n        if (!StringUtils.hasText(name)) {\n            for (String location : locations) {\n                this.propertySources.push(new ResourcePropertySource(location, classLoader));\n            }\n        } else {\n            if (nLocations == 1) {\n                this.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader));\n            } else {\n                CompositePropertySource ps = new CompositePropertySource(name);\n                for (String location : locations) {\n                    ps.addPropertySource(new ResourcePropertySource(location, classLoader));\n                }\n                this.propertySources.push(ps);\n            }\n        }\n    }\n    AnnotationAttributes componentScan = attributesFor(metadata, ComponentScan.class);\n    if (componentScan != null) {\n        Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan, metadata.getClassName());\n        for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n            if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n            }\n        }\n    }\n    Set<String> imports = getImports(metadata.getClassName(), null, new HashSet<String>());\n    if (imports != null && !imports.isEmpty()) {\n        processImport(configClass, imports.toArray(new String[imports.size()]), true);\n    }\n    if (metadata.isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource = attributesFor(metadata, ImportResource.class);\n        String[] resources = importResource.getStringArray(\"value\");\n        Class<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (metadata.hasSuperClass()) {\n        String superclass = metadata.getSuperClassName();\n        if (this.knownSuperclasses.add(superclass)) {\n            if (metadata instanceof StandardAnnotationMetadata) {\n                Class<?> clazz = ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n                return new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n            } else if (superclass.startsWith(\"java\")) {\n                try {\n                    return new StandardAnnotationMetadata(this.resourceLoader.getClassLoader().loadClass(superclass), true);\n                } catch (ClassNotFoundException ex) {\n                    throw new IllegalStateException(ex);\n                }\n            } else {\n                MetadataReader reader = this.metadataReaderFactory.getMetadataReader(superclass);\n                return reader.getAnnotationMetadata();\n            }\n        }\n    }\n    return null;\n}"
    },
    {
      "commit": "4cdf46f83c775c5101bc664c819fd5c0bb0682f7",
      "startLine": 50,
      "endLine": 57,
      "methodCode": "protected AnnotationMetadata doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    for (String memberClassName : metadata.getMemberClassNames()) {\n        MetadataReader reader = this.metadataReaderFactory.getMetadataReader(memberClassName);\n        AnnotationMetadata memberClassMetadata = reader.getAnnotationMetadata();\n        if (ConfigurationClassUtils.isConfigurationCandidate(memberClassMetadata)) {\n            processConfigurationClass(new ConfigurationClass(reader, true));\n        }\n    }\n    AnnotationAttributes propertySource = attributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n    if (propertySource != null) {\n        String name = propertySource.getString(\"name\");\n        String[] locations = propertySource.getStringArray(\"value\");\n        int nLocations = locations.length;\n        if (nLocations == 0) {\n            throw new IllegalArgumentException(\"At least one @PropertySource(value) location is required\");\n        }\n        for (int i = 0; i < nLocations; i++) {\n            locations[i] = this.environment.resolveRequiredPlaceholders(locations[i]);\n        }\n        ClassLoader classLoader = this.resourceLoader.getClassLoader();\n        if (!StringUtils.hasText(name)) {\n            for (String location : locations) {\n                this.propertySources.push(new ResourcePropertySource(location, classLoader));\n            }\n        } else {\n            if (nLocations == 1) {\n                this.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader));\n            } else {\n                CompositePropertySource ps = new CompositePropertySource(name);\n                for (String location : locations) {\n                    ps.addPropertySource(new ResourcePropertySource(location, classLoader));\n                }\n                this.propertySources.push(ps);\n            }\n        }\n    }\n    AnnotationAttributes componentScan = attributesFor(metadata, ComponentScan.class);\n    if (componentScan != null) {\n        Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan, metadata.getClassName());\n        for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n            if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n            }\n        }\n    }\n    Set<String> imports = getImports(metadata.getClassName(), null, new HashSet<String>());\n    if (imports != null && !imports.isEmpty()) {\n        processImport(configClass, imports.toArray(new String[imports.size()]), true);\n    }\n    if (metadata.isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource = attributesFor(metadata, ImportResource.class);\n        String[] resources = importResource.getStringArray(\"value\");\n        Class<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (metadata.hasSuperClass()) {\n        String superclass = metadata.getSuperClassName();\n        if (this.knownSuperclasses.add(superclass)) {\n            if (metadata instanceof StandardAnnotationMetadata) {\n                Class<?> clazz = ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n                return new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n            } else {\n                MetadataReader reader = this.metadataReaderFactory.getMetadataReader(superclass);\n                return reader.getAnnotationMetadata();\n            }\n        }\n    }\n    return null;\n}"
    },
    {
      "commit": "3416e058a01d80d22c52c8c6fb720454be4c4290",
      "startLine": 47,
      "endLine": 54,
      "methodCode": "protected AnnotationMetadata doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    for (String memberClassName : metadata.getMemberClassNames()) {\n        MetadataReader reader = this.metadataReaderFactory.getMetadataReader(memberClassName);\n        AnnotationMetadata memberClassMetadata = reader.getAnnotationMetadata();\n        if (ConfigurationClassUtils.isConfigurationCandidate(memberClassMetadata)) {\n            processConfigurationClass(new ConfigurationClass(reader, true));\n        }\n    }\n    AnnotationAttributes propertySource = attributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n    if (propertySource != null) {\n        String name = propertySource.getString(\"name\");\n        String[] locations = propertySource.getStringArray(\"value\");\n        int nLocations = locations.length;\n        if (nLocations == 0) {\n            throw new IllegalArgumentException(\"At least one @PropertySource(value) location is required\");\n        }\n        for (int i = 0; i < nLocations; i++) {\n            locations[i] = this.environment.resolveRequiredPlaceholders(locations[i]);\n        }\n        ClassLoader classLoader = this.resourceLoader.getClassLoader();\n        if (!StringUtils.hasText(name)) {\n            for (String location : locations) {\n                this.propertySources.push(new ResourcePropertySource(location, classLoader));\n            }\n        } else {\n            if (nLocations == 1) {\n                this.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader));\n            } else {\n                CompositePropertySource ps = new CompositePropertySource(name);\n                for (String location : locations) {\n                    ps.addPropertySource(new ResourcePropertySource(location, classLoader));\n                }\n                this.propertySources.push(ps);\n            }\n        }\n    }\n    AnnotationAttributes componentScan = attributesFor(metadata, ComponentScan.class);\n    if (componentScan != null) {\n        Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan, metadata.getClassName());\n        for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n            if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n            }\n        }\n    }\n    processImport(configClass, getImports(metadata.getClassName()), true);\n    if (metadata.isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource = attributesFor(metadata, ImportResource.class);\n        String[] resources = importResource.getStringArray(\"value\");\n        Class<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (metadata.hasSuperClass()) {\n        String superclass = metadata.getSuperClassName();\n        if (this.knownSuperclasses.add(superclass)) {\n            if (metadata instanceof StandardAnnotationMetadata) {\n                Class<?> clazz = ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n                return new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n            } else {\n                MetadataReader reader = this.metadataReaderFactory.getMetadataReader(superclass);\n                return reader.getAnnotationMetadata();\n            }\n        }\n    }\n    return null;\n}"
    },
    {
      "commit": "6d8b37d8bbce8c6e6cb4890291469c80742132f7",
      "startLine": 50,
      "endLine": 57,
      "methodCode": "protected AnnotationMetadata doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    for (String memberClassName : metadata.getMemberClassNames()) {\n        MetadataReader reader = this.metadataReaderFactory.getMetadataReader(memberClassName);\n        AnnotationMetadata memberClassMetadata = reader.getAnnotationMetadata();\n        if (ConfigurationClassUtils.isConfigurationCandidate(memberClassMetadata)) {\n            processConfigurationClass(new ConfigurationClass(reader, true));\n        }\n    }\n    AnnotationAttributes propertySource = attributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n    if (propertySource != null) {\n        String name = propertySource.getString(\"name\");\n        String[] locations = propertySource.getStringArray(\"value\");\n        int nLocations = locations.length;\n        if (nLocations == 0) {\n            throw new IllegalArgumentException(\"At least one @PropertySource(value) location is required\");\n        }\n        for (int i = 0; i < nLocations; i++) {\n            locations[i] = this.environment.resolveRequiredPlaceholders(locations[i]);\n        }\n        ClassLoader classLoader = this.resourceLoader.getClassLoader();\n        if (!StringUtils.hasText(name)) {\n            for (String location : locations) {\n                this.propertySources.push(new ResourcePropertySource(location, classLoader));\n            }\n        } else {\n            if (nLocations == 1) {\n                this.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader));\n            } else {\n                CompositePropertySource ps = new CompositePropertySource(name);\n                for (String location : locations) {\n                    ps.addPropertySource(new ResourcePropertySource(location, classLoader));\n                }\n                this.propertySources.push(ps);\n            }\n        }\n    }\n    AnnotationAttributes componentScan = attributesFor(metadata, ComponentScan.class);\n    if (componentScan != null) {\n        Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan, metadata.getClassName());\n        for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n            if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n            }\n        }\n    }\n    Set<String> imports = getImports(metadata.getClassName(), null, new HashSet<String>());\n    if (imports != null && !imports.isEmpty()) {\n        processImport(configClass, imports.toArray(new String[imports.size()]), true);\n    }\n    if (metadata.isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource = attributesFor(metadata, ImportResource.class);\n        String[] resources = importResource.getStringArray(\"value\");\n        Class<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (metadata.hasSuperClass()) {\n        String superclass = metadata.getSuperClassName();\n        if (this.knownSuperclasses.add(superclass)) {\n            if (metadata instanceof StandardAnnotationMetadata) {\n                Class<?> clazz = ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n                return new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n            } else {\n                MetadataReader reader = this.metadataReaderFactory.getMetadataReader(superclass);\n                return reader.getAnnotationMetadata();\n            }\n        }\n    }\n    return null;\n}"
    },
    {
      "commit": "73832f8c6e51eb305b88dfc11815801d18b4d567",
      "startLine": 50,
      "endLine": 57,
      "methodCode": "protected AnnotationMetadata doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    for (String memberClassName : metadata.getMemberClassNames()) {\n        MetadataReader reader = this.metadataReaderFactory.getMetadataReader(memberClassName);\n        AnnotationMetadata memberClassMetadata = reader.getAnnotationMetadata();\n        if (ConfigurationClassUtils.isConfigurationCandidate(memberClassMetadata)) {\n            processConfigurationClass(new ConfigurationClass(reader, true));\n        }\n    }\n    AnnotationAttributes propertySource = attributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n    if (propertySource != null) {\n        String name = propertySource.getString(\"name\");\n        String[] locations = propertySource.getStringArray(\"value\");\n        int nLocations = locations.length;\n        if (nLocations == 0) {\n            throw new IllegalArgumentException(\"At least one @PropertySource(value) location is required\");\n        }\n        for (int i = 0; i < nLocations; i++) {\n            locations[i] = this.environment.resolveRequiredPlaceholders(locations[i]);\n        }\n        ClassLoader classLoader = this.resourceLoader.getClassLoader();\n        if (!StringUtils.hasText(name)) {\n            for (String location : locations) {\n                this.propertySources.push(new ResourcePropertySource(location, classLoader));\n            }\n        } else {\n            if (nLocations == 1) {\n                this.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader));\n            } else {\n                CompositePropertySource ps = new CompositePropertySource(name);\n                for (String location : locations) {\n                    ps.addPropertySource(new ResourcePropertySource(location, classLoader));\n                }\n                this.propertySources.push(ps);\n            }\n        }\n    }\n    AnnotationAttributes componentScan = attributesFor(metadata, ComponentScan.class);\n    if (componentScan != null) {\n        Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan, metadata.getClassName());\n        for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n            if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n            }\n        }\n    }\n    List<AnnotationAttributes> imports = findAllAnnotationAttributes(Import.class, metadata.getClassName(), true);\n    for (AnnotationAttributes importAnno : imports) {\n        processImport(configClass, importAnno.getStringArray(\"value\"), true);\n    }\n    if (metadata.isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource = attributesFor(metadata, ImportResource.class);\n        String[] resources = importResource.getStringArray(\"value\");\n        Class<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (metadata.hasSuperClass()) {\n        String superclass = metadata.getSuperClassName();\n        if (this.knownSuperclasses.add(superclass)) {\n            if (metadata instanceof StandardAnnotationMetadata) {\n                Class<?> clazz = ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n                return new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n            } else {\n                MetadataReader reader = this.metadataReaderFactory.getMetadataReader(superclass);\n                return reader.getAnnotationMetadata();\n            }\n        }\n    }\n    return null;\n}"
    },
    {
      "commit": "4df2a14b13ac41d71f8034fa68e1b7e54e3f7a48",
      "startLine": 50,
      "endLine": 57,
      "methodCode": "protected AnnotationMetadata doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    for (String memberClassName : metadata.getMemberClassNames()) {\n        MetadataReader reader = this.metadataReaderFactory.getMetadataReader(memberClassName);\n        AnnotationMetadata memberClassMetadata = reader.getAnnotationMetadata();\n        if (ConfigurationClassUtils.isConfigurationCandidate(memberClassMetadata)) {\n            processConfigurationClass(new ConfigurationClass(reader, true));\n        }\n    }\n    AnnotationAttributes propertySource = attributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n    if (propertySource != null) {\n        String name = propertySource.getString(\"name\");\n        String[] locations = propertySource.getStringArray(\"value\");\n        int nLocations = locations.length;\n        if (nLocations == 0) {\n            throw new IllegalArgumentException(\"At least one @PropertySource(value) location is required\");\n        }\n        for (int i = 0; i < nLocations; i++) {\n            locations[i] = this.environment.resolveRequiredPlaceholders(locations[i]);\n        }\n        ClassLoader classLoader = this.resourceLoader.getClassLoader();\n        if (!StringUtils.hasText(name)) {\n            for (String location : locations) {\n                this.propertySources.push(new ResourcePropertySource(location, classLoader));\n            }\n        } else {\n            if (nLocations == 1) {\n                this.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader));\n            } else {\n                CompositePropertySource ps = new CompositePropertySource(name);\n                for (String location : locations) {\n                    ps.addPropertySource(new ResourcePropertySource(location, classLoader));\n                }\n                this.propertySources.push(ps);\n            }\n        }\n    }\n    AnnotationAttributes componentScan = attributesFor(metadata, ComponentScan.class);\n    if (componentScan != null) {\n        Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan);\n        for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n            if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n            }\n        }\n    }\n    List<AnnotationAttributes> imports = findAllAnnotationAttributes(Import.class, metadata.getClassName(), true);\n    for (AnnotationAttributes importAnno : imports) {\n        processImport(configClass, importAnno.getStringArray(\"value\"), true);\n    }\n    if (metadata.isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource = attributesFor(metadata, ImportResource.class);\n        String[] resources = importResource.getStringArray(\"value\");\n        Class<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (metadata.hasSuperClass()) {\n        String superclass = metadata.getSuperClassName();\n        if (this.knownSuperclasses.add(superclass)) {\n            if (metadata instanceof StandardAnnotationMetadata) {\n                Class<?> clazz = ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n                return new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n            } else {\n                MetadataReader reader = this.metadataReaderFactory.getMetadataReader(superclass);\n                return reader.getAnnotationMetadata();\n            }\n        }\n    }\n    return null;\n}"
    },
    {
      "commit": "02a4473c62d8240837bec297f0a1f3cb67ef8a7b",
      "startLine": 33,
      "endLine": 42,
      "methodCode": "protected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    for (String memberClassName : metadata.getMemberClassNames()) {\n        MetadataReader reader = this.metadataReaderFactory.getMetadataReader(memberClassName);\n        AnnotationMetadata memberClassMetadata = reader.getAnnotationMetadata();\n        if (ConfigurationClassUtils.isConfigurationCandidate(memberClassMetadata)) {\n            processConfigurationClass(new ConfigurationClass(reader, null));\n        }\n    }\n    Map<String, Object> propertySourceAttributes = metadata.getAnnotationAttributes(org.springframework.context.annotation.PropertySource.class.getName());\n    if (propertySourceAttributes != null) {\n        String name = (String) propertySourceAttributes.get(\"name\");\n        String[] locations = (String[]) propertySourceAttributes.get(\"value\");\n        ClassLoader classLoader = this.resourceLoader.getClassLoader();\n        for (String location : locations) {\n            location = this.environment.resolveRequiredPlaceholders(location);\n            ResourcePropertySource ps = StringUtils.hasText(name) ? new ResourcePropertySource(name, location, classLoader) : new ResourcePropertySource(location, classLoader);\n            this.propertySources.push(ps);\n        }\n    }\n    Map<String, Object> componentScanAttributes = metadata.getAnnotationAttributes(ComponentScan.class.getName());\n    if (componentScanAttributes != null) {\n        Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScanAttributes);\n        for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n            if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), metadataReaderFactory)) {\n                this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n            }\n        }\n    }\n    List<Map<String, Object>> allImportAttribs = findAllAnnotationAttributes(Import.class, metadata.getClassName(), true);\n    for (Map<String, Object> importAttribs : allImportAttribs) {\n        processImport(configClass, (String[]) importAttribs.get(\"value\"), true);\n    }\n    if (metadata.isAnnotated(ImportResource.class.getName())) {\n        String[] resources = (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n        Class<?> readerClass = (Class<?>) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n        if (readerClass == null) {\n            throw new IllegalStateException(\"No reader class associated with imported resources: \" + StringUtils.arrayToCommaDelimitedString(resources));\n        }\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n}"
    },
    {
      "commit": "d6d169ac5614ca10aa7d5bade5a695f599823d8a",
      "startLine": 33,
      "endLine": 42,
      "methodCode": "protected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    for (String memberClassName : metadata.getMemberClassNames()) {\n        MetadataReader reader = this.metadataReaderFactory.getMetadataReader(memberClassName);\n        AnnotationMetadata memberClassMetadata = reader.getAnnotationMetadata();\n        if (ConfigurationClassUtils.isConfigurationCandidate(memberClassMetadata)) {\n            processConfigurationClass(new ConfigurationClass(reader, null));\n        }\n    }\n    Map<String, Object> propertySourceAttributes = metadata.getAnnotationAttributes(org.springframework.context.annotation.PropertySource.class.getName());\n    if (propertySourceAttributes != null) {\n        String name = (String) propertySourceAttributes.get(\"name\");\n        String[] locations = (String[]) propertySourceAttributes.get(\"value\");\n        ClassLoader classLoader = this.resourceLoader.getClassLoader();\n        for (String location : locations) {\n            location = this.environment.resolveRequiredPlaceholders(location);\n            ResourcePropertySource ps = StringUtils.hasText(name) ? new ResourcePropertySource(name, location, classLoader) : new ResourcePropertySource(location, classLoader);\n            this.propertySources.push(ps);\n        }\n    }\n    Map<String, Object> componentScanAttributes = metadata.getAnnotationAttributes(ComponentScan.class.getName());\n    if (componentScanAttributes != null) {\n        Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScanAttributes);\n        for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n            if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), metadataReaderFactory)) {\n                this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n            }\n        }\n    }\n    List<Map<String, Object>> allImportAttribs = findAllAnnotationAttributes(Import.class, metadata.getClassName(), true);\n    for (Map<String, Object> importAttribs : allImportAttribs) {\n        processImport(configClass, (String[]) importAttribs.get(\"value\"), true);\n    }\n    if (metadata.isAnnotated(ImportResource.class.getName())) {\n        String[] resources = (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n        Class<?> readerClass = (Class<?>) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n        if (readerClass == null) {\n            throw new IllegalStateException(\"No reader class associated with imported resources: \" + StringUtils.arrayToCommaDelimitedString(resources));\n        }\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n}"
    },
    {
      "commit": "6991cd9cdf610f94ace3cd8072634106830b439f",
      "startLine": 33,
      "endLine": 42,
      "methodCode": "protected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    for (String memberClassName : metadata.getMemberClassNames()) {\n        MetadataReader reader = this.metadataReaderFactory.getMetadataReader(memberClassName);\n        AnnotationMetadata memberClassMetadata = reader.getAnnotationMetadata();\n        if (isConfigurationCandidate(memberClassMetadata)) {\n            processConfigurationClass(new ConfigurationClass(reader, null));\n        }\n    }\n    Map<String, Object> propertySourceAttributes = metadata.getAnnotationAttributes(org.springframework.context.annotation.PropertySource.class.getName());\n    if (propertySourceAttributes != null) {\n        String name = (String) propertySourceAttributes.get(\"name\");\n        String[] locations = (String[]) propertySourceAttributes.get(\"value\");\n        ClassLoader classLoader = this.resourceLoader.getClassLoader();\n        for (String location : locations) {\n            location = this.environment.resolveRequiredPlaceholders(location);\n            ResourcePropertySource ps = StringUtils.hasText(name) ? new ResourcePropertySource(name, location, classLoader) : new ResourcePropertySource(location, classLoader);\n            this.propertySources.push(ps);\n        }\n    }\n    Map<String, Object> componentScanAttributes = metadata.getAnnotationAttributes(ComponentScan.class.getName());\n    if (componentScanAttributes != null) {\n        Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScanAttributes);\n        for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n            if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), metadataReaderFactory)) {\n                this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n            }\n        }\n    }\n    List<Map<String, Object>> allImportAttribs = AnnotationUtils.findAllAnnotationAttributes(Import.class, metadata.getClassName(), true, metadataReaderFactory);\n    for (Map<String, Object> importAttribs : allImportAttribs) {\n        processImport(configClass, (String[]) importAttribs.get(\"value\"), true);\n    }\n    if (metadata.isAnnotated(ImportResource.class.getName())) {\n        String[] resources = (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n        Class<?> readerClass = (Class<?>) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n        if (readerClass == null) {\n            throw new IllegalStateException(\"No reader class associated with imported resources: \" + StringUtils.arrayToCommaDelimitedString(resources));\n        }\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n}"
    },
    {
      "commit": "6837111bda5e4df9bdfa617c78c1ea32ced7ab5c",
      "startLine": 37,
      "endLine": 46,
      "methodCode": "protected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    for (String memberClassName : metadata.getMemberClassNames()) {\n        MetadataReader reader = this.metadataReaderFactory.getMetadataReader(memberClassName);\n        AnnotationMetadata memberClassMetadata = reader.getAnnotationMetadata();\n        if (isConfigurationCandidate(memberClassMetadata)) {\n            processConfigurationClass(new ConfigurationClass(reader, null));\n        }\n    }\n    Map<String, Object> propertySourceAttributes = metadata.getAnnotationAttributes(org.springframework.context.annotation.PropertySource.class.getName());\n    if (propertySourceAttributes != null) {\n        String name = (String) propertySourceAttributes.get(\"name\");\n        String[] locations = (String[]) propertySourceAttributes.get(\"value\");\n        ClassLoader classLoader = this.resourceLoader.getClassLoader();\n        for (String location : locations) {\n            location = this.environment.resolveRequiredPlaceholders(location);\n            ResourcePropertySource ps = StringUtils.hasText(name) ? new ResourcePropertySource(name, location, classLoader) : new ResourcePropertySource(location, classLoader);\n            this.propertySources.push(ps);\n        }\n    }\n    Map<String, Object> componentScanAttributes = metadata.getAnnotationAttributes(ComponentScan.class.getName());\n    if (componentScanAttributes != null) {\n        Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScanAttributes);\n        for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n            if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), metadataReaderFactory)) {\n                try {\n                    this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                } catch (ConflictingBeanDefinitionException ex) {\n                    throw new CircularComponentScanException(\"A conflicting bean definition was detected while processing @ComponentScan annotations. \" + \"This usually indicates a circle between scanned packages.\", ex);\n                }\n            }\n        }\n    }\n    List<Map<String, Object>> allImportAttribs = AnnotationUtils.findAllAnnotationAttributes(Import.class, metadata.getClassName(), true, metadataReaderFactory);\n    for (Map<String, Object> importAttribs : allImportAttribs) {\n        processImport(configClass, (String[]) importAttribs.get(\"value\"), true);\n    }\n    if (metadata.isAnnotated(ImportResource.class.getName())) {\n        String[] resources = (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n        Class<?> readerClass = (Class<?>) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n        if (readerClass == null) {\n            throw new IllegalStateException(\"No reader class associated with imported resources: \" + StringUtils.arrayToCommaDelimitedString(resources));\n        }\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n}"
    },
    {
      "commit": "234bca64624d0fadd0333e1ec3fc2c680308f081",
      "startLine": 37,
      "endLine": 46,
      "methodCode": "protected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    for (String memberClassName : metadata.getMemberClassNames()) {\n        MetadataReader reader = this.metadataReaderFactory.getMetadataReader(memberClassName);\n        AnnotationMetadata memberClassMetadata = reader.getAnnotationMetadata();\n        if (isConfigurationCandidate(memberClassMetadata)) {\n            processConfigurationClass(new ConfigurationClass(reader, null));\n        }\n    }\n    Map<String, Object> propertySourceAttributes = metadata.getAnnotationAttributes(org.springframework.context.annotation.PropertySource.class.getName());\n    if (propertySourceAttributes != null) {\n        String name = (String) propertySourceAttributes.get(\"name\");\n        String[] locations = (String[]) propertySourceAttributes.get(\"value\");\n        ClassLoader classLoader = this.resourceLoader.getClassLoader();\n        for (String location : locations) {\n            location = this.environment.resolveRequiredPlaceholders(location);\n            ResourcePropertySource ps = StringUtils.hasText(name) ? new ResourcePropertySource(name, location, classLoader) : new ResourcePropertySource(location, classLoader);\n            this.propertySources.push(ps);\n        }\n    }\n    Map<String, Object> componentScanAttributes = metadata.getAnnotationAttributes(ComponentScan.class.getName());\n    if (componentScanAttributes != null) {\n        Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScanAttributes);\n        for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n            if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), metadataReaderFactory)) {\n                try {\n                    this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                } catch (ConflictingBeanDefinitionException ex) {\n                    throw new CircularComponentScanException(\"A conflicting bean definition was detected while processing @ComponentScan annotations. \" + \"This usually indicates a circle between scanned packages.\", ex);\n                }\n            }\n        }\n    }\n    List<Map<String, Object>> allImportAttribs = AnnotationUtils.findAllAnnotationAttributes(Import.class, metadata.getClassName(), true);\n    for (Map<String, Object> importAttribs : allImportAttribs) {\n        processImport(configClass, (String[]) importAttribs.get(\"value\"), true);\n    }\n    if (metadata.isAnnotated(ImportResource.class.getName())) {\n        String[] resources = (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n        Class<?> readerClass = (Class<?>) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n        if (readerClass == null) {\n            throw new IllegalStateException(\"No reader class associated with imported resources: \" + StringUtils.arrayToCommaDelimitedString(resources));\n        }\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n}"
    },
    {
      "commit": "2ceeff370aff402bd669f9125d93e99d09e8ce71",
      "startLine": 36,
      "endLine": 45,
      "methodCode": "protected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    for (String memberClassName : metadata.getMemberClassNames()) {\n        MetadataReader reader = this.metadataReaderFactory.getMetadataReader(memberClassName);\n        AnnotationMetadata memberClassMetadata = reader.getAnnotationMetadata();\n        if (isConfigurationCandidate(memberClassMetadata)) {\n            processConfigurationClass(new ConfigurationClass(reader, null));\n        }\n    }\n    Map<String, Object> propertySourceAttributes = metadata.getAnnotationAttributes(org.springframework.context.annotation.PropertySource.class.getName());\n    if (propertySourceAttributes != null) {\n        String name = (String) propertySourceAttributes.get(\"name\");\n        String[] locations = (String[]) propertySourceAttributes.get(\"value\");\n        ClassLoader classLoader = this.resourceLoader.getClassLoader();\n        for (String location : locations) {\n            ResourcePropertySource ps = StringUtils.hasText(name) ? new ResourcePropertySource(name, location, classLoader) : new ResourcePropertySource(location, classLoader);\n            this.propertySources.push(ps);\n        }\n    }\n    Map<String, Object> componentScanAttributes = metadata.getAnnotationAttributes(ComponentScan.class.getName());\n    if (componentScanAttributes != null) {\n        Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScanAttributes);\n        for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n            if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), metadataReaderFactory)) {\n                try {\n                    this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                } catch (ConflictingBeanDefinitionException ex) {\n                    throw new CircularComponentScanException(\"A conflicting bean definition was detected while processing @ComponentScan annotations. \" + \"This usually indicates a circle between scanned packages.\", ex);\n                }\n            }\n        }\n    }\n    List<Map<String, Object>> allImportAttribs = AnnotationUtils.findAllAnnotationAttributes(Import.class, metadata.getClassName(), true);\n    for (Map<String, Object> importAttribs : allImportAttribs) {\n        processImport(configClass, (String[]) importAttribs.get(\"value\"), true);\n    }\n    if (metadata.isAnnotated(ImportResource.class.getName())) {\n        String[] resources = (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n        Class<?> readerClass = (Class<?>) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n        if (readerClass == null) {\n            throw new IllegalStateException(\"No reader class associated with imported resources: \" + StringUtils.arrayToCommaDelimitedString(resources));\n        }\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n}"
    },
    {
      "commit": "95b1dbadb0014e791b93d73254903a683bd49433",
      "startLine": 34,
      "endLine": 43,
      "methodCode": "protected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    for (String memberClassName : metadata.getMemberClassNames()) {\n        MetadataReader reader = this.metadataReaderFactory.getMetadataReader(memberClassName);\n        AnnotationMetadata memberClassMetadata = reader.getAnnotationMetadata();\n        if (isConfigurationCandidate(memberClassMetadata)) {\n            processConfigurationClass(new ConfigurationClass(reader, null));\n        }\n    }\n    Map<String, Object> propertySourceAttributes = metadata.getAnnotationAttributes(org.springframework.context.annotation.PropertySource.class.getName());\n    if (propertySourceAttributes != null) {\n        String name = (String) propertySourceAttributes.get(\"name\");\n        String location = (String) propertySourceAttributes.get(\"value\");\n        ClassLoader classLoader = this.resourceLoader.getClassLoader();\n        ResourcePropertySource ps = StringUtils.hasText(name) ? new ResourcePropertySource(name, location, classLoader) : new ResourcePropertySource(location, classLoader);\n        this.propertySources.push(ps);\n    }\n    Map<String, Object> componentScanAttributes = metadata.getAnnotationAttributes(ComponentScan.class.getName());\n    if (componentScanAttributes != null) {\n        Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScanAttributes);\n        for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n            if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), metadataReaderFactory)) {\n                try {\n                    this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                } catch (ConflictingBeanDefinitionException ex) {\n                    throw new CircularComponentScanException(\"A conflicting bean definition was detected while processing @ComponentScan annotations. \" + \"This usually indicates a circle between scanned packages.\", ex);\n                }\n            }\n        }\n    }\n    List<Map<String, Object>> allImportAttribs = AnnotationUtils.findAllAnnotationAttributes(Import.class, metadata.getClassName(), true);\n    for (Map<String, Object> importAttribs : allImportAttribs) {\n        processImport(configClass, (String[]) importAttribs.get(\"value\"), true);\n    }\n    if (metadata.isAnnotated(ImportResource.class.getName())) {\n        String[] resources = (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n        Class<?> readerClass = (Class<?>) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n        if (readerClass == null) {\n            throw new IllegalStateException(\"No reader class associated with imported resources: \" + StringUtils.arrayToCommaDelimitedString(resources));\n        }\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n}"
    },
    {
      "commit": "c8bc54e0ccad49f0785856f911349283619eb8ba",
      "startLine": 27,
      "endLine": 36,
      "methodCode": "protected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    Map<String, Object> propertySourceAttributes = metadata.getAnnotationAttributes(org.springframework.context.annotation.PropertySource.class.getName());\n    if (propertySourceAttributes != null) {\n        String name = (String) propertySourceAttributes.get(\"name\");\n        String location = (String) propertySourceAttributes.get(\"value\");\n        ClassLoader classLoader = this.resourceLoader.getClassLoader();\n        ResourcePropertySource ps = StringUtils.hasText(name) ? new ResourcePropertySource(name, location, classLoader) : new ResourcePropertySource(location, classLoader);\n        this.propertySources.push(ps);\n    }\n    Map<String, Object> componentScanAttributes = metadata.getAnnotationAttributes(ComponentScan.class.getName());\n    if (componentScanAttributes != null) {\n        Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScanAttributes);\n        for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n            if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), metadataReaderFactory)) {\n                try {\n                    this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                } catch (ConflictingBeanDefinitionException ex) {\n                    throw new CircularComponentScanException(\"A conflicting bean definition was detected while processing @ComponentScan annotations. \" + \"This usually indicates a circle between scanned packages.\", ex);\n                }\n            }\n        }\n    }\n    List<Map<String, Object>> allImportAttribs = AnnotationUtils.findAllAnnotationAttributes(Import.class, metadata.getClassName(), true);\n    for (Map<String, Object> importAttribs : allImportAttribs) {\n        processImport(configClass, (String[]) importAttribs.get(\"value\"), true);\n    }\n    if (metadata.isAnnotated(ImportResource.class.getName())) {\n        String[] resources = (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n        Class<?> readerClass = (Class<?>) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n        if (readerClass == null) {\n            throw new IllegalStateException(\"No reader class associated with imported resources: \" + StringUtils.arrayToCommaDelimitedString(resources));\n        }\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n}"
    },
    {
      "commit": "d0c31ad84cffd7af718a45d679483a1c51f9e552",
      "startLine": 19,
      "endLine": 28,
      "methodCode": "protected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    Map<String, Object> componentScanAttributes = metadata.getAnnotationAttributes(ComponentScan.class.getName());\n    if (componentScanAttributes != null) {\n        Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScanAttributes);\n        for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n            if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), metadataReaderFactory)) {\n                try {\n                    this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                } catch (ConflictingBeanDefinitionException ex) {\n                    throw new CircularComponentScanException(\"A conflicting bean definition was detected while processing @ComponentScan annotations. \" + \"This usually indicates a circle between scanned packages.\", ex);\n                }\n            }\n        }\n    }\n    List<Map<String, Object>> allImportAttribs = AnnotationUtils.findAllAnnotationAttributes(Import.class, metadata.getClassName(), true);\n    for (Map<String, Object> importAttribs : allImportAttribs) {\n        processImport(configClass, (String[]) importAttribs.get(\"value\"), true);\n    }\n    if (metadata.isAnnotated(ImportResource.class.getName())) {\n        String[] resources = (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n        Class<?> readerClass = (Class<?>) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n        if (readerClass == null) {\n            throw new IllegalStateException(\"No reader class associated with imported resources: \" + StringUtils.arrayToCommaDelimitedString(resources));\n        }\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n}"
    },
    {
      "commit": "9a271ce6c92695b9421aa603c9aa56e805c7920c",
      "startLine": 6,
      "endLine": 15,
      "methodCode": "protected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    List<Map<String, Object>> allImportAttribs = AnnotationUtils.findAllAnnotationAttributes(Import.class, metadata.getClassName(), true);\n    for (Map<String, Object> importAttribs : allImportAttribs) {\n        processImport(configClass, (String[]) importAttribs.get(\"value\"), true);\n    }\n    if (metadata.isAnnotated(ImportResource.class.getName())) {\n        String[] resources = (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n        Class<?> readerClass = (Class<?>) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n        if (readerClass == null) {\n            throw new IllegalStateException(\"No reader class associated with imported resources: \" + StringUtils.arrayToCommaDelimitedString(resources));\n        }\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n}"
    },
    {
      "commit": "89005a5b7034cc1c2f702eac4bd36836b99f3765",
      "startLine": 6,
      "endLine": 15,
      "methodCode": "protected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    List<Map<String, Object>> allImportAttribs = AnnotationUtils.findAllAnnotationAttributes(Import.class, metadata.getClassName(), true);\n    for (Map<String, Object> importAttribs : allImportAttribs) {\n        processImport(configClass, (String[]) importAttribs.get(\"value\"));\n    }\n    if (metadata.isAnnotated(ImportResource.class.getName())) {\n        String[] resources = (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n        Class<?> readerClass = (Class<?>) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n        if (readerClass == null) {\n            throw new IllegalStateException(\"No reader class associated with imported resources: \" + StringUtils.arrayToCommaDelimitedString(resources));\n        }\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n}"
    },
    {
      "commit": "0a790c143feeabf571e98f8ee0700a4586cbb67c",
      "startLine": 5,
      "endLine": 14,
      "methodCode": "protected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    if (metadata.isAnnotated(Import.class.getName())) {\n        processImport(configClass, (String[]) metadata.getAnnotationAttributes(Import.class.getName(), true).get(\"value\"));\n    }\n    if (metadata.isAnnotated(ImportResource.class.getName())) {\n        String[] resources = (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n        Class<?> readerClass = (Class<?>) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n        if (readerClass == null) {\n            throw new IllegalStateException(\"No reader class associated with imported resources: \" + StringUtils.arrayToCommaDelimitedString(resources));\n        }\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n}"
    },
    {
      "commit": "d78eda8aebda0704e29fdccf619e9931b5446efc",
      "startLine": 5,
      "endLine": 14,
      "methodCode": "protected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    if (metadata.isAnnotated(Import.class.getName())) {\n        processImport(configClass, (String[]) metadata.getAnnotationAttributes(Import.class.getName(), true).get(\"value\"));\n    }\n    if (metadata.isAnnotated(ImportResource.class.getName())) {\n        String[] resources = (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n        Class<?> readerClass = (Class<?>) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n        if (readerClass == null) {\n            throw new IllegalStateException(\"No reader class associated with imported resources: \" + StringUtils.arrayToCommaDelimitedString(resources));\n        }\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata beanMethod : beanMethods) {\n        configClass.addMethod(new ConfigurationClassMethod(beanMethod, configClass));\n    }\n}"
    },
    {
      "commit": "d1b3f57320d5567ff8f6420c9bcf07521ea5e2b9",
      "startLine": 5,
      "endLine": 14,
      "methodCode": "protected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    if (metadata.isAnnotated(Import.class.getName())) {\n        processImport(configClass, (String[]) metadata.getAnnotationAttributes(Import.class.getName(), true).get(\"value\"));\n    }\n    if (metadata.isAnnotated(ImportResource.class.getName())) {\n        String[] resources = (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n        Class<?> readerClass = (Class<?>) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n        if (readerClass == null) {\n            throw new IllegalStateException(\"No reader class associated with imported resources: \" + StringUtils.arrayToCommaDelimitedString(resources));\n        }\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addMethod(new ConfigurationClassMethod(methodMetadata, configClass));\n    }\n}"
    },
    {
      "commit": "bbd7fb3969b7fd93c814380209d8f28e2a9c6714",
      "startLine": 5,
      "endLine": 14,
      "methodCode": "protected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    if (metadata.isAnnotated(Import.class.getName())) {\n        processImport(configClass, (String[]) metadata.getAnnotationAttributes(Import.class.getName(), true).get(\"value\"));\n    }\n    if (metadata.isAnnotated(ImportResource.class.getName())) {\n        String[] resources = (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n        Class readerClass = (Class) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n        if (readerClass == null) {\n            throw new IllegalStateException(\"No reader class associated with imported resources: \" + StringUtils.arrayToCommaDelimitedString(resources));\n        }\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set<MethodMetadata> methods = metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : methods) {\n        configClass.addMethod(new ConfigurationClassMethod(methodMetadata, configClass));\n    }\n}"
    },
    {
      "commit": "ee553f7804c9cc2ac89b963bcff58974503c20fe",
      "startLine": 5,
      "endLine": 10,
      "methodCode": "protected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    if (metadata.isAnnotated(Import.class.getName())) {\n        processImport(configClass, (String[]) metadata.getAnnotationAttributes(Import.class.getName()).get(\"value\"));\n    }\n    if (metadata.isAnnotated(ImportResource.class.getName())) {\n        String readerClassName = (String) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n        for (String importedResource : (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\")) {\n            configClass.addImportedResource(importedResource, readerClassName);\n        }\n    }\n    Set<MethodMetadata> methods = metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : methods) {\n        configClass.addMethod(new ConfigurationClassMethod(methodMetadata, configClass));\n    }\n}"
    },
    {
      "commit": "0a4463fb71e6901a943a5bafc9d1957da2229333",
      "startLine": 5,
      "endLine": 9,
      "methodCode": "protected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    if (metadata.isAnnotated(Import.class.getName())) {\n        processImport(configClass, (String[]) metadata.getAnnotationAttributes(Import.class.getName()).get(\"value\"));\n    }\n    if (metadata.isAnnotated(ImportXml.class.getName())) {\n        for (String xmlImport : (String[]) metadata.getAnnotationAttributes(ImportXml.class.getName()).get(\"value\")) {\n            configClass.addXmlImport(xmlImport);\n        }\n    }\n    Set<MethodMetadata> methods = metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : methods) {\n        configClass.addMethod(new ConfigurationClassMethod(methodMetadata, configClass));\n    }\n}"
    }
  ]
}