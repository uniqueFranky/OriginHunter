{
  "statementVersions": [
    {
      "commit": "26c5d0e56a8c5adb2c93cda45e25175363798516",
      "startLine": 9,
      "endLine": 26,
      "methodCode": "@Override\npublic RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n    newHead = null;\n    lastStepWasForward = false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case PROCESS_STEPS:\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitId = rebaseState.readFile(ONTO);\n                try {\n                    upstreamCommitName = rebaseState.readFile(ONTO_NAME);\n                } catch (FileNotFoundException e) {\n                    upstreamCommitName = upstreamCommitId;\n                }\n                this.upstreamCommit = walk.parseCommit(repo.resolve(upstreamCommitId));\n                preserveMerges = rebaseState.getRewrittenDir().exists();\n                break;\n            case BEGIN:\n                autoStash();\n                if (stopAfterInitialization || !walk.isMergedInto(walk.parseCommit(repo.resolve(Constants.HEAD)), upstreamCommit)) {\n                    org.eclipse.jgit.api.Status status = Git.wrap(repo).status().setIgnoreSubmodules(IgnoreSubmoduleMode.ALL).call();\n                    if (status.hasUncommittedChanges()) {\n                        List<String> list = new ArrayList<>();\n                        list.addAll(status.getUncommittedChanges());\n                        return RebaseResult.uncommittedChanges(list);\n                    }\n                }\n                RebaseResult res = initFilesAndRewind();\n                if (stopAfterInitialization)\n                    return RebaseResult.INTERACTIVE_PREPARED_RESULT;\n                if (res != null) {\n                    autoStashApply();\n                    if (rebaseState.getDir().exists())\n                        FileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n                    return res;\n                }\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation == Operation.CONTINUE) {\n            newHead = continueRebase();\n            List<RebaseTodoLine> doneLines = repo.readRebaseTodo(rebaseState.getPath(DONE), true);\n            RebaseTodoLine step = doneLines.get(doneLines.size() - 1);\n            if (newHead != null && step.getAction() != Action.PICK) {\n                RebaseTodoLine newStep = new RebaseTodoLine(step.getAction(), AbbreviatedObjectId.fromObjectId(newHead), step.getShortMessage());\n                RebaseResult result = processStep(newStep, false);\n                if (result != null)\n                    return result;\n            }\n            File amendFile = rebaseState.getFile(AMEND);\n            boolean amendExists = amendFile.exists();\n            if (amendExists) {\n                FileUtils.delete(amendFile);\n            }\n            if (newHead == null && !amendExists) {\n                return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n            }\n        }\n        if (operation == Operation.SKIP)\n            newHead = checkoutCurrentHead();\n        List<RebaseTodoLine> steps = repo.readRebaseTodo(rebaseState.getPath(GIT_REBASE_TODO), false);\n        if (steps.size() == 0) {\n            return finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n        }\n        if (isInteractive()) {\n            interactiveHandler.prepareSteps(steps);\n            repo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO), steps, false);\n        }\n        checkSteps(steps);\n        for (int i = 0; i < steps.size(); i++) {\n            RebaseTodoLine step = steps.get(i);\n            popSteps(1);\n            RebaseResult result = processStep(step, true);\n            if (result != null) {\n                return result;\n            }\n        }\n        return finishRebase(newHead, lastStepWasForward);\n    } catch (CheckoutConflictException cce) {\n        return RebaseResult.conflicts(cce.getConflictingPaths());\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}"
    },
    {
      "commit": "0210e0e299bed69176e0a929d0b67f3cf9fb1e37",
      "startLine": 9,
      "endLine": 26,
      "methodCode": "@Override\npublic RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n    newHead = null;\n    lastStepWasForward = false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case PROCESS_STEPS:\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitId = rebaseState.readFile(ONTO);\n                try {\n                    upstreamCommitName = rebaseState.readFile(ONTO_NAME);\n                } catch (FileNotFoundException e) {\n                    upstreamCommitName = upstreamCommitId;\n                }\n                this.upstreamCommit = walk.parseCommit(repo.resolve(upstreamCommitId));\n                preserveMerges = rebaseState.getRewrittenDir().exists();\n                break;\n            case BEGIN:\n                autoStash();\n                if (stopAfterInitialization || !walk.isMergedInto(walk.parseCommit(repo.resolve(Constants.HEAD)), upstreamCommit)) {\n                    org.eclipse.jgit.api.Status status = Git.wrap(repo).status().setIgnoreSubmodules(IgnoreSubmoduleMode.ALL).call();\n                    if (status.hasUncommittedChanges()) {\n                        List<String> list = new ArrayList<>();\n                        list.addAll(status.getUncommittedChanges());\n                        return RebaseResult.uncommittedChanges(list);\n                    }\n                }\n                RebaseResult res = initFilesAndRewind();\n                if (stopAfterInitialization)\n                    return RebaseResult.INTERACTIVE_PREPARED_RESULT;\n                if (res != null) {\n                    autoStashApply();\n                    if (rebaseState.getDir().exists())\n                        FileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n                    return res;\n                }\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation == Operation.CONTINUE) {\n            newHead = continueRebase();\n            List<RebaseTodoLine> doneLines = repo.readRebaseTodo(rebaseState.getPath(DONE), true);\n            RebaseTodoLine step = doneLines.get(doneLines.size() - 1);\n            if (newHead != null && step.getAction() != Action.PICK) {\n                RebaseTodoLine newStep = new RebaseTodoLine(step.getAction(), AbbreviatedObjectId.fromObjectId(newHead), step.getShortMessage());\n                RebaseResult result = processStep(newStep, false);\n                if (result != null)\n                    return result;\n            }\n            File amendFile = rebaseState.getFile(AMEND);\n            boolean amendExists = amendFile.exists();\n            if (amendExists) {\n                FileUtils.delete(amendFile);\n            }\n            if (newHead == null && !amendExists) {\n                return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n            }\n        }\n        if (operation == Operation.SKIP)\n            newHead = checkoutCurrentHead();\n        List<RebaseTodoLine> steps = repo.readRebaseTodo(rebaseState.getPath(GIT_REBASE_TODO), false);\n        if (steps.size() == 0) {\n            return finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n        }\n        if (isInteractive()) {\n            interactiveHandler.prepareSteps(steps);\n            repo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO), steps, false);\n        }\n        checkSteps(steps);\n        for (int i = 0; i < steps.size(); i++) {\n            RebaseTodoLine step = steps.get(i);\n            popSteps(1);\n            RebaseResult result = processStep(step, true);\n            if (result != null) {\n                return result;\n            }\n        }\n        return finishRebase(newHead, lastStepWasForward);\n    } catch (CheckoutConflictException cce) {\n        return RebaseResult.conflicts(cce.getConflictingPaths());\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}"
    },
    {
      "commit": "3b4448637fbb9d74e0c9d44048ba76bb7c1214ce",
      "startLine": 9,
      "endLine": 26,
      "methodCode": "@Override\npublic RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n    newHead = null;\n    lastStepWasForward = false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case PROCESS_STEPS:\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitId = rebaseState.readFile(ONTO);\n                try {\n                    upstreamCommitName = rebaseState.readFile(ONTO_NAME);\n                } catch (FileNotFoundException e) {\n                    upstreamCommitName = upstreamCommitId;\n                }\n                this.upstreamCommit = walk.parseCommit(repo.resolve(upstreamCommitId));\n                preserveMerges = rebaseState.getRewrittenDir().exists();\n                break;\n            case BEGIN:\n                autoStash();\n                if (stopAfterInitialization || !walk.isMergedInto(walk.parseCommit(repo.resolve(Constants.HEAD)), upstreamCommit)) {\n                    org.eclipse.jgit.api.Status status = Git.wrap(repo).status().setIgnoreSubmodules(IgnoreSubmoduleMode.ALL).call();\n                    if (status.hasUncommittedChanges()) {\n                        List<String> list = new ArrayList<>();\n                        list.addAll(status.getUncommittedChanges());\n                        return RebaseResult.uncommittedChanges(list);\n                    }\n                }\n                RebaseResult res = initFilesAndRewind();\n                if (stopAfterInitialization)\n                    return RebaseResult.INTERACTIVE_PREPARED_RESULT;\n                if (res != null) {\n                    autoStashApply();\n                    if (rebaseState.getDir().exists())\n                        FileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n                    return res;\n                }\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation == Operation.CONTINUE) {\n            newHead = continueRebase();\n            List<RebaseTodoLine> doneLines = repo.readRebaseTodo(rebaseState.getPath(DONE), true);\n            RebaseTodoLine step = doneLines.get(doneLines.size() - 1);\n            if (newHead != null && step.getAction() != Action.PICK) {\n                RebaseTodoLine newStep = new RebaseTodoLine(step.getAction(), AbbreviatedObjectId.fromObjectId(newHead), step.getShortMessage());\n                RebaseResult result = processStep(newStep, false);\n                if (result != null)\n                    return result;\n            }\n            File amendFile = rebaseState.getFile(AMEND);\n            boolean amendExists = amendFile.exists();\n            if (amendExists) {\n                FileUtils.delete(amendFile);\n            }\n            if (newHead == null && !amendExists) {\n                return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n            }\n        }\n        if (operation == Operation.SKIP)\n            newHead = checkoutCurrentHead();\n        List<RebaseTodoLine> steps = repo.readRebaseTodo(rebaseState.getPath(GIT_REBASE_TODO), false);\n        if (steps.size() == 0) {\n            return finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n        }\n        if (isInteractive()) {\n            interactiveHandler.prepareSteps(steps);\n            repo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO), steps, false);\n        }\n        checkSteps(steps);\n        for (int i = 0; i < steps.size(); i++) {\n            RebaseTodoLine step = steps.get(i);\n            popSteps(1);\n            RebaseResult result = processStep(step, true);\n            if (result != null) {\n                return result;\n            }\n        }\n        return finishRebase(newHead, lastStepWasForward);\n    } catch (CheckoutConflictException cce) {\n        return RebaseResult.conflicts(cce.getConflictingPaths());\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}"
    },
    {
      "commit": "7ac182f4e427e0d5a986b8ca67a56fc22828b1a0",
      "startLine": 9,
      "endLine": 26,
      "methodCode": "@Override\npublic RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n    newHead = null;\n    lastStepWasForward = false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case PROCESS_STEPS:\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitId = rebaseState.readFile(ONTO);\n                try {\n                    upstreamCommitName = rebaseState.readFile(ONTO_NAME);\n                } catch (FileNotFoundException e) {\n                    upstreamCommitName = upstreamCommitId;\n                }\n                this.upstreamCommit = walk.parseCommit(repo.resolve(upstreamCommitId));\n                preserveMerges = rebaseState.getRewrittenDir().exists();\n                break;\n            case BEGIN:\n                autoStash();\n                if (stopAfterInitialization || !walk.isMergedInto(walk.parseCommit(repo.resolve(Constants.HEAD)), upstreamCommit)) {\n                    org.eclipse.jgit.api.Status status = Git.wrap(repo).status().setIgnoreSubmodules(IgnoreSubmoduleMode.ALL).call();\n                    if (status.hasUncommittedChanges()) {\n                        List<String> list = new ArrayList<String>();\n                        list.addAll(status.getUncommittedChanges());\n                        return RebaseResult.uncommittedChanges(list);\n                    }\n                }\n                RebaseResult res = initFilesAndRewind();\n                if (stopAfterInitialization)\n                    return RebaseResult.INTERACTIVE_PREPARED_RESULT;\n                if (res != null) {\n                    autoStashApply();\n                    if (rebaseState.getDir().exists())\n                        FileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n                    return res;\n                }\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation == Operation.CONTINUE) {\n            newHead = continueRebase();\n            List<RebaseTodoLine> doneLines = repo.readRebaseTodo(rebaseState.getPath(DONE), true);\n            RebaseTodoLine step = doneLines.get(doneLines.size() - 1);\n            if (newHead != null && step.getAction() != Action.PICK) {\n                RebaseTodoLine newStep = new RebaseTodoLine(step.getAction(), AbbreviatedObjectId.fromObjectId(newHead), step.getShortMessage());\n                RebaseResult result = processStep(newStep, false);\n                if (result != null)\n                    return result;\n            }\n            File amendFile = rebaseState.getFile(AMEND);\n            boolean amendExists = amendFile.exists();\n            if (amendExists) {\n                FileUtils.delete(amendFile);\n            }\n            if (newHead == null && !amendExists) {\n                return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n            }\n        }\n        if (operation == Operation.SKIP)\n            newHead = checkoutCurrentHead();\n        List<RebaseTodoLine> steps = repo.readRebaseTodo(rebaseState.getPath(GIT_REBASE_TODO), false);\n        if (steps.size() == 0) {\n            return finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n        }\n        if (isInteractive()) {\n            interactiveHandler.prepareSteps(steps);\n            repo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO), steps, false);\n        }\n        checkSteps(steps);\n        for (int i = 0; i < steps.size(); i++) {\n            RebaseTodoLine step = steps.get(i);\n            popSteps(1);\n            RebaseResult result = processStep(step, true);\n            if (result != null) {\n                return result;\n            }\n        }\n        return finishRebase(newHead, lastStepWasForward);\n    } catch (CheckoutConflictException cce) {\n        return RebaseResult.conflicts(cce.getConflictingPaths());\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}"
    },
    {
      "commit": "6f0b92ff22ff58a4c8eb9de8d9b3281d77852070",
      "startLine": 8,
      "endLine": 25,
      "methodCode": "public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n    newHead = null;\n    lastStepWasForward = false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case PROCESS_STEPS:\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitId = rebaseState.readFile(ONTO);\n                try {\n                    upstreamCommitName = rebaseState.readFile(ONTO_NAME);\n                } catch (FileNotFoundException e) {\n                    upstreamCommitName = upstreamCommitId;\n                }\n                this.upstreamCommit = walk.parseCommit(repo.resolve(upstreamCommitId));\n                preserveMerges = rebaseState.getRewrittenDir().exists();\n                break;\n            case BEGIN:\n                autoStash();\n                if (stopAfterInitialization || !walk.isMergedInto(walk.parseCommit(repo.resolve(Constants.HEAD)), upstreamCommit)) {\n                    org.eclipse.jgit.api.Status status = Git.wrap(repo).status().setIgnoreSubmodules(IgnoreSubmoduleMode.ALL).call();\n                    if (status.hasUncommittedChanges()) {\n                        List<String> list = new ArrayList<String>();\n                        list.addAll(status.getUncommittedChanges());\n                        return RebaseResult.uncommittedChanges(list);\n                    }\n                }\n                RebaseResult res = initFilesAndRewind();\n                if (stopAfterInitialization)\n                    return RebaseResult.INTERACTIVE_PREPARED_RESULT;\n                if (res != null) {\n                    autoStashApply();\n                    if (rebaseState.getDir().exists())\n                        FileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n                    return res;\n                }\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation == Operation.CONTINUE) {\n            newHead = continueRebase();\n            List<RebaseTodoLine> doneLines = repo.readRebaseTodo(rebaseState.getPath(DONE), true);\n            RebaseTodoLine step = doneLines.get(doneLines.size() - 1);\n            if (newHead != null && step.getAction() != Action.PICK) {\n                RebaseTodoLine newStep = new RebaseTodoLine(step.getAction(), AbbreviatedObjectId.fromObjectId(newHead), step.getShortMessage());\n                RebaseResult result = processStep(newStep, false);\n                if (result != null)\n                    return result;\n            }\n            File amendFile = rebaseState.getFile(AMEND);\n            boolean amendExists = amendFile.exists();\n            if (amendExists) {\n                FileUtils.delete(amendFile);\n            }\n            if (newHead == null && !amendExists) {\n                return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n            }\n        }\n        if (operation == Operation.SKIP)\n            newHead = checkoutCurrentHead();\n        List<RebaseTodoLine> steps = repo.readRebaseTodo(rebaseState.getPath(GIT_REBASE_TODO), false);\n        if (steps.size() == 0) {\n            return finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n        }\n        if (isInteractive()) {\n            interactiveHandler.prepareSteps(steps);\n            repo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO), steps, false);\n        }\n        checkSteps(steps);\n        for (int i = 0; i < steps.size(); i++) {\n            RebaseTodoLine step = steps.get(i);\n            popSteps(1);\n            RebaseResult result = processStep(step, true);\n            if (result != null) {\n                return result;\n            }\n        }\n        return finishRebase(newHead, lastStepWasForward);\n    } catch (CheckoutConflictException cce) {\n        return RebaseResult.conflicts(cce.getConflictingPaths());\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}"
    },
    {
      "commit": "e0fbae5dc3fc2345383ec373b384fcca10e64f24",
      "startLine": 8,
      "endLine": 25,
      "methodCode": "public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n    newHead = null;\n    lastStepWasForward = false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case PROCESS_STEPS:\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitId = rebaseState.readFile(ONTO);\n                try {\n                    upstreamCommitName = rebaseState.readFile(ONTO_NAME);\n                } catch (FileNotFoundException e) {\n                    upstreamCommitName = upstreamCommitId;\n                }\n                this.upstreamCommit = walk.parseCommit(repo.resolve(upstreamCommitId));\n                preserveMerges = rebaseState.getRewrittenDir().exists();\n                break;\n            case BEGIN:\n                autoStash();\n                if (stopAfterInitialization || !walk.isMergedInto(walk.parseCommit(repo.resolve(Constants.HEAD)), upstreamCommit)) {\n                    org.eclipse.jgit.api.Status status = Git.wrap(repo).status().call();\n                    if (status.hasUncommittedChanges()) {\n                        List<String> list = new ArrayList<String>();\n                        list.addAll(status.getUncommittedChanges());\n                        return RebaseResult.uncommittedChanges(list);\n                    }\n                }\n                RebaseResult res = initFilesAndRewind();\n                if (stopAfterInitialization)\n                    return RebaseResult.INTERACTIVE_PREPARED_RESULT;\n                if (res != null) {\n                    autoStashApply();\n                    if (rebaseState.getDir().exists())\n                        FileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n                    return res;\n                }\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation == Operation.CONTINUE) {\n            newHead = continueRebase();\n            List<RebaseTodoLine> doneLines = repo.readRebaseTodo(rebaseState.getPath(DONE), true);\n            RebaseTodoLine step = doneLines.get(doneLines.size() - 1);\n            if (newHead != null && step.getAction() != Action.PICK) {\n                RebaseTodoLine newStep = new RebaseTodoLine(step.getAction(), AbbreviatedObjectId.fromObjectId(newHead), step.getShortMessage());\n                RebaseResult result = processStep(newStep, false);\n                if (result != null)\n                    return result;\n            }\n            File amendFile = rebaseState.getFile(AMEND);\n            boolean amendExists = amendFile.exists();\n            if (amendExists) {\n                FileUtils.delete(amendFile);\n            }\n            if (newHead == null && !amendExists) {\n                return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n            }\n        }\n        if (operation == Operation.SKIP)\n            newHead = checkoutCurrentHead();\n        List<RebaseTodoLine> steps = repo.readRebaseTodo(rebaseState.getPath(GIT_REBASE_TODO), false);\n        if (steps.size() == 0) {\n            return finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n        }\n        if (isInteractive()) {\n            interactiveHandler.prepareSteps(steps);\n            repo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO), steps, false);\n        }\n        checkSteps(steps);\n        for (int i = 0; i < steps.size(); i++) {\n            RebaseTodoLine step = steps.get(i);\n            popSteps(1);\n            RebaseResult result = processStep(step, true);\n            if (result != null) {\n                return result;\n            }\n        }\n        return finishRebase(newHead, lastStepWasForward);\n    } catch (CheckoutConflictException cce) {\n        return RebaseResult.conflicts(cce.getConflictingPaths());\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}"
    },
    {
      "commit": "3db6e05e52b24e16fbe93376d3fd8935e5f4fc9b",
      "startLine": 8,
      "endLine": 24,
      "methodCode": "public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n    newHead = null;\n    lastStepWasForward = false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case PROCESS_STEPS:\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitId = rebaseState.readFile(ONTO);\n                try {\n                    upstreamCommitName = rebaseState.readFile(ONTO_NAME);\n                } catch (FileNotFoundException e) {\n                    upstreamCommitName = upstreamCommitId;\n                }\n                this.upstreamCommit = walk.parseCommit(repo.resolve(upstreamCommitId));\n                break;\n            case BEGIN:\n                autoStash();\n                if (stopAfterInitialization || !walk.isMergedInto(walk.parseCommit(repo.resolve(Constants.HEAD)), upstreamCommit)) {\n                    org.eclipse.jgit.api.Status status = Git.wrap(repo).status().call();\n                    if (status.hasUncommittedChanges()) {\n                        List<String> list = new ArrayList<String>();\n                        list.addAll(status.getUncommittedChanges());\n                        return RebaseResult.uncommittedChanges(list);\n                    }\n                }\n                RebaseResult res = initFilesAndRewind();\n                if (stopAfterInitialization)\n                    return RebaseResult.INTERACTIVE_PREPARED_RESULT;\n                if (res != null) {\n                    autoStashApply();\n                    if (rebaseState.getDir().exists())\n                        FileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n                    return res;\n                }\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation == Operation.CONTINUE) {\n            newHead = continueRebase();\n            List<RebaseTodoLine> doneLines = repo.readRebaseTodo(rebaseState.getPath(DONE), true);\n            RebaseTodoLine step = doneLines.get(doneLines.size() - 1);\n            if (newHead != null && step.getAction() != Action.PICK) {\n                RebaseTodoLine newStep = new RebaseTodoLine(step.getAction(), AbbreviatedObjectId.fromObjectId(newHead), step.getShortMessage());\n                RebaseResult result = processStep(newStep, false);\n                if (result != null)\n                    return result;\n            }\n            File amendFile = rebaseState.getFile(AMEND);\n            boolean amendExists = amendFile.exists();\n            if (amendExists) {\n                FileUtils.delete(amendFile);\n            }\n            if (newHead == null && !amendExists) {\n                return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n            }\n        }\n        if (operation == Operation.SKIP)\n            newHead = checkoutCurrentHead();\n        List<RebaseTodoLine> steps = repo.readRebaseTodo(rebaseState.getPath(GIT_REBASE_TODO), false);\n        if (steps.size() == 0) {\n            return finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n        }\n        if (isInteractive()) {\n            interactiveHandler.prepareSteps(steps);\n            repo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO), steps, false);\n        }\n        checkSteps(steps);\n        for (int i = 0; i < steps.size(); i++) {\n            RebaseTodoLine step = steps.get(i);\n            popSteps(1);\n            RebaseResult result = processStep(step, true);\n            if (result != null) {\n                return result;\n            }\n        }\n        return finishRebase(newHead, lastStepWasForward);\n    } catch (CheckoutConflictException cce) {\n        return RebaseResult.conflicts(cce.getConflictingPaths());\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}"
    },
    {
      "commit": "f86a488e32906593903acb31a93a82bed8d87915",
      "startLine": 8,
      "endLine": 24,
      "methodCode": "public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n    newHead = null;\n    lastStepWasForward = false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case PROCESS_STEPS:\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitId = rebaseState.readFile(ONTO);\n                try {\n                    upstreamCommitName = rebaseState.readFile(ONTO_NAME);\n                } catch (FileNotFoundException e) {\n                    upstreamCommitName = upstreamCommitId;\n                }\n                this.upstreamCommit = walk.parseCommit(repo.resolve(upstreamCommitId));\n                break;\n            case BEGIN:\n                autoStash();\n                if (stopAfterInitialization || !walk.isMergedInto(walk.parseCommit(repo.resolve(Constants.HEAD)), upstreamCommit)) {\n                    org.eclipse.jgit.api.Status status = Git.wrap(repo).status().call();\n                    if (status.hasUncommittedChanges()) {\n                        List<String> list = new ArrayList<String>();\n                        list.addAll(status.getUncommittedChanges());\n                        return RebaseResult.uncommittedChanges(list);\n                    }\n                }\n                RebaseResult res = initFilesAndRewind();\n                if (stopAfterInitialization)\n                    return RebaseResult.INTERACTIVE_PREPARED_RESULT;\n                if (res != null) {\n                    autoStashApply();\n                    return res;\n                }\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation == Operation.CONTINUE) {\n            newHead = continueRebase();\n            List<RebaseTodoLine> doneLines = repo.readRebaseTodo(rebaseState.getPath(DONE), true);\n            RebaseTodoLine step = doneLines.get(doneLines.size() - 1);\n            if (newHead != null && step.getAction() != Action.PICK) {\n                RebaseTodoLine newStep = new RebaseTodoLine(step.getAction(), AbbreviatedObjectId.fromObjectId(newHead), step.getShortMessage());\n                RebaseResult result = processStep(newStep, false);\n                if (result != null)\n                    return result;\n            }\n            File amendFile = rebaseState.getFile(AMEND);\n            boolean amendExists = amendFile.exists();\n            if (amendExists) {\n                FileUtils.delete(amendFile);\n            }\n            if (newHead == null && !amendExists) {\n                return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n            }\n        }\n        if (operation == Operation.SKIP)\n            newHead = checkoutCurrentHead();\n        List<RebaseTodoLine> steps = repo.readRebaseTodo(rebaseState.getPath(GIT_REBASE_TODO), false);\n        if (steps.size() == 0) {\n            return finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n        }\n        if (isInteractive()) {\n            interactiveHandler.prepareSteps(steps);\n            repo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO), steps, false);\n        }\n        checkSteps(steps);\n        for (int i = 0; i < steps.size(); i++) {\n            RebaseTodoLine step = steps.get(i);\n            popSteps(1);\n            RebaseResult result = processStep(step, true);\n            if (result != null) {\n                return result;\n            }\n        }\n        return finishRebase(newHead, lastStepWasForward);\n    } catch (CheckoutConflictException cce) {\n        return RebaseResult.conflicts(cce.getConflictingPaths());\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}"
    },
    {
      "commit": "591998c2d628ec4f6309caea826fab16a6de2adc",
      "startLine": 8,
      "endLine": 24,
      "methodCode": "public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n    newHead = null;\n    lastStepWasForward = false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case PROCESS_STEPS:\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitId = rebaseState.readFile(ONTO);\n                try {\n                    upstreamCommitName = rebaseState.readFile(ONTO_NAME);\n                } catch (FileNotFoundException e) {\n                    upstreamCommitName = upstreamCommitId;\n                }\n                this.upstreamCommit = walk.parseCommit(repo.resolve(upstreamCommitId));\n                break;\n            case BEGIN:\n                if (stopAfterInitialization || !walk.isMergedInto(walk.parseCommit(repo.resolve(Constants.HEAD)), upstreamCommit)) {\n                    org.eclipse.jgit.api.Status status = Git.wrap(repo).status().call();\n                    if (status.hasUncommittedChanges()) {\n                        List<String> list = new ArrayList<String>();\n                        list.addAll(status.getUncommittedChanges());\n                        return RebaseResult.uncommittedChanges(list);\n                    }\n                }\n                RebaseResult res = initFilesAndRewind();\n                if (stopAfterInitialization)\n                    return RebaseResult.INTERACTIVE_PREPARED_RESULT;\n                if (res != null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation == Operation.CONTINUE) {\n            newHead = continueRebase();\n            List<RebaseTodoLine> doneLines = repo.readRebaseTodo(rebaseState.getPath(DONE), true);\n            RebaseTodoLine step = doneLines.get(doneLines.size() - 1);\n            if (newHead != null && step.getAction() != Action.PICK) {\n                RebaseTodoLine newStep = new RebaseTodoLine(step.getAction(), AbbreviatedObjectId.fromObjectId(newHead), step.getShortMessage());\n                RebaseResult result = processStep(newStep, false);\n                if (result != null)\n                    return result;\n            }\n            File amendFile = rebaseState.getFile(AMEND);\n            boolean amendExists = amendFile.exists();\n            if (amendExists) {\n                FileUtils.delete(amendFile);\n            }\n            if (newHead == null && !amendExists) {\n                return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n            }\n        }\n        if (operation == Operation.SKIP)\n            newHead = checkoutCurrentHead();\n        List<RebaseTodoLine> steps = repo.readRebaseTodo(rebaseState.getPath(GIT_REBASE_TODO), false);\n        if (steps.size() == 0) {\n            return finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n        }\n        if (isInteractive()) {\n            interactiveHandler.prepareSteps(steps);\n            repo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO), steps, false);\n        }\n        checkSteps(steps);\n        for (int i = 0; i < steps.size(); i++) {\n            RebaseTodoLine step = steps.get(i);\n            popSteps(1);\n            RebaseResult result = processStep(step, true);\n            if (result != null) {\n                return result;\n            }\n        }\n        return finishRebase(newHead, lastStepWasForward);\n    } catch (CheckoutConflictException cce) {\n        return RebaseResult.conflicts(cce.getConflictingPaths());\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}"
    },
    {
      "commit": "ec0d78d0939ee8ce30bd349bd885186c13d3b645",
      "startLine": 8,
      "endLine": 24,
      "methodCode": "public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n    newHead = null;\n    lastStepWasForward = false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case PROCESS_STEPS:\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitId = rebaseState.readFile(ONTO);\n                try {\n                    upstreamCommitName = rebaseState.readFile(ONTO_NAME);\n                } catch (FileNotFoundException e) {\n                    upstreamCommitName = upstreamCommitId;\n                }\n                this.upstreamCommit = walk.parseCommit(repo.resolve(upstreamCommitId));\n                break;\n            case BEGIN:\n                RebaseResult res = initFilesAndRewind();\n                if (stopAfterInitialization)\n                    return RebaseResult.INTERACTIVE_PREPARED_RESULT;\n                if (res != null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation == Operation.CONTINUE) {\n            newHead = continueRebase();\n            List<RebaseTodoLine> doneLines = repo.readRebaseTodo(rebaseState.getPath(DONE), true);\n            RebaseTodoLine step = doneLines.get(doneLines.size() - 1);\n            if (newHead != null && step.getAction() != Action.PICK) {\n                RebaseTodoLine newStep = new RebaseTodoLine(step.getAction(), AbbreviatedObjectId.fromObjectId(newHead), step.getShortMessage());\n                RebaseResult result = processStep(newStep, false);\n                if (result != null)\n                    return result;\n            }\n            File amendFile = rebaseState.getFile(AMEND);\n            boolean amendExists = amendFile.exists();\n            if (amendExists) {\n                FileUtils.delete(amendFile);\n            }\n            if (newHead == null && !amendExists) {\n                return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n            }\n        }\n        if (operation == Operation.SKIP)\n            newHead = checkoutCurrentHead();\n        List<RebaseTodoLine> steps = repo.readRebaseTodo(rebaseState.getPath(GIT_REBASE_TODO), false);\n        if (steps.size() == 0) {\n            return finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n        }\n        if (isInteractive()) {\n            interactiveHandler.prepareSteps(steps);\n            repo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO), steps, false);\n        }\n        checkSteps(steps);\n        for (int i = 0; i < steps.size(); i++) {\n            RebaseTodoLine step = steps.get(i);\n            popSteps(1);\n            RebaseResult result = processStep(step, true);\n            if (result != null) {\n                return result;\n            }\n        }\n        return finishRebase(newHead, lastStepWasForward);\n    } catch (CheckoutConflictException cce) {\n        return RebaseResult.conflicts(cce.getConflictingPaths());\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}"
    },
    {
      "commit": "979e3467112618cc787e161097986212eaaa4533",
      "startLine": 8,
      "endLine": 24,
      "methodCode": "public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n    newHead = null;\n    lastStepWasForward = false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case PROCESS_STEPS:\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitId = rebaseState.readFile(ONTO);\n                try {\n                    upstreamCommitName = rebaseState.readFile(ONTO_NAME);\n                } catch (FileNotFoundException e) {\n                    upstreamCommitName = upstreamCommitId;\n                }\n                this.upstreamCommit = walk.parseCommit(repo.resolve(upstreamCommitId));\n                break;\n            case BEGIN:\n                RebaseResult res = initFilesAndRewind();\n                if (stopAfterInitialization)\n                    return RebaseResult.INTERACTIVE_PREPARED_RESULT;\n                if (res != null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation == Operation.CONTINUE) {\n            newHead = continueRebase();\n            List<RebaseTodoLine> doneLines = repo.readRebaseTodo(rebaseState.getPath(DONE), true);\n            RebaseTodoLine step = doneLines.get(doneLines.size() - 1);\n            if (newHead != null && step.getAction() != Action.PICK) {\n                RebaseTodoLine newStep = new RebaseTodoLine(step.getAction(), AbbreviatedObjectId.fromObjectId(newHead), step.getShortMessage());\n                RebaseResult result = processStep(newStep, false);\n                if (result != null)\n                    return result;\n            }\n            File amendFile = rebaseState.getFile(AMEND);\n            boolean amendExists = amendFile.exists();\n            if (amendExists) {\n                FileUtils.delete(amendFile);\n            }\n            if (newHead == null && !amendExists) {\n                return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n            }\n        }\n        if (operation == Operation.SKIP)\n            newHead = checkoutCurrentHead();\n        List<RebaseTodoLine> steps = repo.readRebaseTodo(rebaseState.getPath(GIT_REBASE_TODO), false);\n        if (steps.size() == 0) {\n            return finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n        }\n        if (isInteractive()) {\n            interactiveHandler.prepareSteps(steps);\n            repo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO), steps, false);\n        }\n        checkSteps(steps);\n        for (int i = 0; i < steps.size(); i++) {\n            RebaseTodoLine step = steps.get(i);\n            popSteps(1);\n            RebaseResult result = processStep(step, true);\n            if (result != null) {\n                return result;\n            }\n        }\n        return finishRebase(newHead, lastStepWasForward);\n    } catch (CheckoutConflictException cce) {\n        return new RebaseResult(cce.getConflictingPaths());\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}"
    },
    {
      "commit": "18069ffe8cbede40cf2524922c262b67656e7021",
      "startLine": 8,
      "endLine": 24,
      "methodCode": "public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n    RevCommit newHead = null;\n    boolean lastStepWasForward = false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case PROCESS_STEPS:\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitId = rebaseState.readFile(ONTO);\n                try {\n                    upstreamCommitName = rebaseState.readFile(ONTO_NAME);\n                } catch (FileNotFoundException e) {\n                    upstreamCommitName = upstreamCommitId;\n                }\n                this.upstreamCommit = walk.parseCommit(repo.resolve(upstreamCommitId));\n                break;\n            case BEGIN:\n                RebaseResult res = initFilesAndRewind();\n                if (stopAfterInitialization)\n                    return RebaseResult.INTERACTIVE_PREPARED_RESULT;\n                if (res != null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation == Operation.CONTINUE) {\n            newHead = continueRebase();\n            File amendFile = rebaseState.getFile(AMEND);\n            boolean amendExists = amendFile.exists();\n            if (amendExists) {\n                FileUtils.delete(amendFile);\n            }\n            if (newHead == null && !amendExists) {\n                return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n            }\n        }\n        if (operation == Operation.SKIP)\n            newHead = checkoutCurrentHead();\n        ObjectReader or = repo.newObjectReader();\n        List<RebaseTodoLine> steps = repo.readRebaseTodo(rebaseState.getPath(GIT_REBASE_TODO), false);\n        if (steps.size() == 0) {\n            return finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n        }\n        if (isInteractive()) {\n            interactiveHandler.prepareSteps(steps);\n            repo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO), steps, false);\n        }\n        checkSteps(steps);\n        for (int i = 0; i < steps.size(); i++) {\n            RebaseTodoLine step = steps.get(i);\n            popSteps(1);\n            if (Action.COMMENT.equals(step.getAction()))\n                continue;\n            Collection<ObjectId> ids = or.resolve(step.getCommit());\n            if (ids.size() != 1)\n                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n            RevCommit commitToPick = walk.parseCommit(ids.iterator().next());\n            if (monitor.isCancelled())\n                return new RebaseResult(commitToPick, Status.STOPPED);\n            try {\n                monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n                newHead = tryFastForward(commitToPick);\n                lastStepWasForward = newHead != null;\n                if (!lastStepWasForward) {\n                    String ourCommitName = getOurCommitName();\n                    CherryPickResult cherryPickResult = new Git(repo).cherryPick().include(commitToPick).setOurCommitName(ourCommitName).setReflogPrefix(\"rebase:\").call();\n                    switch(cherryPickResult.getStatus()) {\n                        case FAILED:\n                            if (operation == Operation.BEGIN)\n                                return abort(new RebaseResult(cherryPickResult.getFailingPaths()));\n                            else\n                                return stop(commitToPick, Status.STOPPED);\n                        case CONFLICTING:\n                            return stop(commitToPick, Status.STOPPED);\n                        case OK:\n                            newHead = cherryPickResult.getNewHead();\n                    }\n                }\n                boolean isSquash = false;\n                switch(step.getAction()) {\n                    case PICK:\n                        continue;\n                    case REWORD:\n                        String oldMessage = commitToPick.getFullMessage();\n                        String newMessage = interactiveHandler.modifyCommitMessage(oldMessage);\n                        newHead = new Git(repo).commit().setMessage(newMessage).setAmend(true).call();\n                        continue;\n                    case EDIT:\n                        rebaseState.createFile(AMEND, commitToPick.name());\n                        return stop(commitToPick, Status.EDIT);\n                    case COMMENT:\n                        break;\n                    case SQUASH:\n                        isSquash = true;\n                    case FIXUP:\n                        resetSoftToParent();\n                        RebaseTodoLine nextStep = (i >= steps.size() - 1 ? null : steps.get(i + 1));\n                        File messageFixupFile = rebaseState.getFile(MESSAGE_FIXUP);\n                        File messageSquashFile = rebaseState.getFile(MESSAGE_SQUASH);\n                        if (isSquash && messageFixupFile.exists())\n                            messageFixupFile.delete();\n                        newHead = doSquashFixup(isSquash, commitToPick, nextStep, messageFixupFile, messageSquashFile);\n                }\n            } finally {\n                monitor.endTask();\n            }\n        }\n        return finishRebase(newHead, lastStepWasForward);\n    } catch (CheckoutConflictException cce) {\n        return new RebaseResult(cce.getConflictingPaths());\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}"
    },
    {
      "commit": "cce2561e9fe2ce1cf60182f9d95c8537ce13de92",
      "startLine": 8,
      "endLine": 24,
      "methodCode": "public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n    RevCommit newHead = null;\n    boolean lastStepWasForward = false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case PROCESS_STEPS:\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitId = rebaseState.readFile(ONTO);\n                try {\n                    upstreamCommitName = rebaseState.readFile(ONTO_NAME);\n                } catch (FileNotFoundException e) {\n                    upstreamCommitName = upstreamCommitId;\n                }\n                this.upstreamCommit = walk.parseCommit(repo.resolve(upstreamCommitId));\n                break;\n            case BEGIN:\n                RebaseResult res = initFilesAndRewind();\n                if (stopAfterInitialization)\n                    return RebaseResult.INTERACTIVE_PREPARED_RESULT;\n                if (res != null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation == Operation.CONTINUE) {\n            newHead = continueRebase();\n            File amendFile = rebaseState.getFile(AMEND);\n            boolean amendExists = amendFile.exists();\n            if (amendExists) {\n                FileUtils.delete(amendFile);\n            }\n            if (newHead == null && !amendExists) {\n                return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n            }\n        }\n        if (operation == Operation.SKIP)\n            newHead = checkoutCurrentHead();\n        ObjectReader or = repo.newObjectReader();\n        List<RebaseTodoLine> steps = repo.readRebaseTodo(rebaseState.getPath(GIT_REBASE_TODO), false);\n        if (isInteractive()) {\n            interactiveHandler.prepareSteps(steps);\n            repo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO), steps, false);\n        }\n        checkSteps(steps);\n        for (int i = 0; i < steps.size(); i++) {\n            RebaseTodoLine step = steps.get(i);\n            popSteps(1);\n            if (Action.COMMENT.equals(step.getAction()))\n                continue;\n            Collection<ObjectId> ids = or.resolve(step.getCommit());\n            if (ids.size() != 1)\n                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n            RevCommit commitToPick = walk.parseCommit(ids.iterator().next());\n            if (monitor.isCancelled())\n                return new RebaseResult(commitToPick, Status.STOPPED);\n            try {\n                monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n                newHead = tryFastForward(commitToPick);\n                lastStepWasForward = newHead != null;\n                if (!lastStepWasForward) {\n                    String ourCommitName = getOurCommitName();\n                    CherryPickResult cherryPickResult = new Git(repo).cherryPick().include(commitToPick).setOurCommitName(ourCommitName).setReflogPrefix(\"rebase:\").call();\n                    switch(cherryPickResult.getStatus()) {\n                        case FAILED:\n                            if (operation == Operation.BEGIN)\n                                return abort(new RebaseResult(cherryPickResult.getFailingPaths()));\n                            else\n                                return stop(commitToPick, Status.STOPPED);\n                        case CONFLICTING:\n                            return stop(commitToPick, Status.STOPPED);\n                        case OK:\n                            newHead = cherryPickResult.getNewHead();\n                    }\n                }\n                boolean isSquash = false;\n                switch(step.getAction()) {\n                    case PICK:\n                        continue;\n                    case REWORD:\n                        String oldMessage = commitToPick.getFullMessage();\n                        String newMessage = interactiveHandler.modifyCommitMessage(oldMessage);\n                        newHead = new Git(repo).commit().setMessage(newMessage).setAmend(true).call();\n                        continue;\n                    case EDIT:\n                        rebaseState.createFile(AMEND, commitToPick.name());\n                        return stop(commitToPick, Status.EDIT);\n                    case COMMENT:\n                        break;\n                    case SQUASH:\n                        isSquash = true;\n                    case FIXUP:\n                        resetSoftToParent();\n                        RebaseTodoLine nextStep = (i >= steps.size() - 1 ? null : steps.get(i + 1));\n                        File messageFixupFile = rebaseState.getFile(MESSAGE_FIXUP);\n                        File messageSquashFile = rebaseState.getFile(MESSAGE_SQUASH);\n                        if (isSquash && messageFixupFile.exists())\n                            messageFixupFile.delete();\n                        newHead = doSquashFixup(isSquash, commitToPick, nextStep, messageFixupFile, messageSquashFile);\n                }\n            } finally {\n                monitor.endTask();\n            }\n        }\n        if (newHead != null) {\n            String headName = rebaseState.readFile(HEAD_NAME);\n            updateHead(headName, newHead, upstreamCommit);\n            FileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n            if (lastStepWasForward)\n                return RebaseResult.FAST_FORWARD_RESULT;\n            return RebaseResult.OK_RESULT;\n        }\n        return RebaseResult.FAST_FORWARD_RESULT;\n    } catch (CheckoutConflictException cce) {\n        return new RebaseResult(cce.getConflictingPaths());\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}"
    },
    {
      "commit": "765896febb4b63cfe2c37dc0a73c90c79dd1591b",
      "startLine": 8,
      "endLine": 24,
      "methodCode": "public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n    RevCommit newHead = null;\n    boolean lastStepWasForward = false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case PROCESS_STEPS:\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitId = rebaseState.readFile(ONTO);\n                try {\n                    upstreamCommitName = rebaseState.readFile(ONTO_NAME);\n                } catch (FileNotFoundException e) {\n                    upstreamCommitName = upstreamCommitId;\n                }\n                this.upstreamCommit = walk.parseCommit(repo.resolve(upstreamCommitId));\n                break;\n            case BEGIN:\n                RebaseResult res = initFilesAndRewind();\n                if (stopAfterInitialization)\n                    return RebaseResult.INTERACTIVE_PREPARED_RESULT;\n                if (res != null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation == Operation.CONTINUE) {\n            newHead = continueRebase();\n            File amendFile = rebaseState.getFile(AMEND);\n            boolean amendExists = amendFile.exists();\n            if (amendExists) {\n                FileUtils.delete(amendFile);\n            }\n            if (newHead == null && !amendExists) {\n                return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n            }\n        }\n        if (operation == Operation.SKIP)\n            newHead = checkoutCurrentHead();\n        ObjectReader or = repo.newObjectReader();\n        List<RebaseTodoLine> steps = repo.readRebaseTodo(rebaseState.getPath(GIT_REBASE_TODO), false);\n        if (isInteractive()) {\n            interactiveHandler.prepareSteps(steps);\n            repo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO), steps, false);\n        }\n        checkSteps(steps);\n        for (int i = 0; i < steps.size(); i++) {\n            RebaseTodoLine step = steps.get(i);\n            popSteps(1);\n            if (Action.COMMENT.equals(step.getAction()))\n                continue;\n            Collection<ObjectId> ids = or.resolve(step.getCommit());\n            if (ids.size() != 1)\n                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n            RevCommit commitToPick = walk.parseCommit(ids.iterator().next());\n            if (monitor.isCancelled())\n                return new RebaseResult(commitToPick);\n            try {\n                monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n                newHead = tryFastForward(commitToPick);\n                lastStepWasForward = newHead != null;\n                if (!lastStepWasForward) {\n                    String ourCommitName = getOurCommitName();\n                    CherryPickResult cherryPickResult = new Git(repo).cherryPick().include(commitToPick).setOurCommitName(ourCommitName).setReflogPrefix(\"rebase:\").call();\n                    switch(cherryPickResult.getStatus()) {\n                        case FAILED:\n                            if (operation == Operation.BEGIN)\n                                return abort(new RebaseResult(cherryPickResult.getFailingPaths()));\n                            else\n                                return stop(commitToPick);\n                        case CONFLICTING:\n                            return stop(commitToPick);\n                        case OK:\n                            newHead = cherryPickResult.getNewHead();\n                    }\n                }\n                boolean isSquash = false;\n                switch(step.getAction()) {\n                    case PICK:\n                        continue;\n                    case REWORD:\n                        String oldMessage = commitToPick.getFullMessage();\n                        String newMessage = interactiveHandler.modifyCommitMessage(oldMessage);\n                        newHead = new Git(repo).commit().setMessage(newMessage).setAmend(true).call();\n                        continue;\n                    case EDIT:\n                        rebaseState.createFile(AMEND, commitToPick.name());\n                        return stop(commitToPick);\n                    case COMMENT:\n                        break;\n                    case SQUASH:\n                        isSquash = true;\n                    case FIXUP:\n                        resetSoftToParent();\n                        RebaseTodoLine nextStep = (i >= steps.size() - 1 ? null : steps.get(i + 1));\n                        File messageFixupFile = rebaseState.getFile(MESSAGE_FIXUP);\n                        File messageSquashFile = rebaseState.getFile(MESSAGE_SQUASH);\n                        if (isSquash && messageFixupFile.exists())\n                            messageFixupFile.delete();\n                        newHead = doSquashFixup(isSquash, commitToPick, nextStep, messageFixupFile, messageSquashFile);\n                }\n            } finally {\n                monitor.endTask();\n            }\n        }\n        if (newHead != null) {\n            String headName = rebaseState.readFile(HEAD_NAME);\n            updateHead(headName, newHead, upstreamCommit);\n            FileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n            if (lastStepWasForward)\n                return RebaseResult.FAST_FORWARD_RESULT;\n            return RebaseResult.OK_RESULT;\n        }\n        return RebaseResult.FAST_FORWARD_RESULT;\n    } catch (CheckoutConflictException cce) {\n        return new RebaseResult(cce.getConflictingPaths());\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}"
    },
    {
      "commit": "da9db6b20c6203dae3f828adbd14218ea063ad91",
      "startLine": 8,
      "endLine": 24,
      "methodCode": "public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n    RevCommit newHead = null;\n    boolean lastStepWasForward = false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case PROCESS_STEPS:\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitId = rebaseState.readFile(ONTO);\n                try {\n                    upstreamCommitName = rebaseState.readFile(ONTO_NAME);\n                } catch (FileNotFoundException e) {\n                    upstreamCommitName = upstreamCommitId;\n                }\n                this.upstreamCommit = walk.parseCommit(repo.resolve(upstreamCommitId));\n                break;\n            case BEGIN:\n                RebaseResult res = initFilesAndRewind();\n                if (stopAfterInitialization)\n                    return RebaseResult.INTERACTIVE_PREPARED_RESULT;\n                if (res != null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation == Operation.CONTINUE) {\n            newHead = continueRebase();\n            File amendFile = rebaseState.getFile(AMEND);\n            boolean amendExists = amendFile.exists();\n            if (amendExists) {\n                FileUtils.delete(amendFile);\n            }\n            if (newHead == null && !amendExists) {\n                return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n            }\n        }\n        if (operation == Operation.SKIP)\n            newHead = checkoutCurrentHead();\n        ObjectReader or = repo.newObjectReader();\n        List<RebaseTodoLine> steps = repo.readRebaseTodo(rebaseState.getPath(GIT_REBASE_TODO), false);\n        if (isInteractive()) {\n            interactiveHandler.prepareSteps(steps);\n            repo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO), steps, false);\n        }\n        for (RebaseTodoLine step : steps) {\n            popSteps(1);\n            if (Action.COMMENT.equals(step.getAction()))\n                continue;\n            Collection<ObjectId> ids = or.resolve(step.getCommit());\n            if (ids.size() != 1)\n                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n            RevCommit commitToPick = walk.parseCommit(ids.iterator().next());\n            if (monitor.isCancelled())\n                return new RebaseResult(commitToPick);\n            try {\n                monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n                newHead = tryFastForward(commitToPick);\n                lastStepWasForward = newHead != null;\n                if (!lastStepWasForward) {\n                    String ourCommitName = getOurCommitName();\n                    CherryPickResult cherryPickResult = new Git(repo).cherryPick().include(commitToPick).setOurCommitName(ourCommitName).setReflogPrefix(\"rebase:\").call();\n                    switch(cherryPickResult.getStatus()) {\n                        case FAILED:\n                            if (operation == Operation.BEGIN)\n                                return abort(new RebaseResult(cherryPickResult.getFailingPaths()));\n                            else\n                                return stop(commitToPick);\n                        case CONFLICTING:\n                            return stop(commitToPick);\n                        case OK:\n                            newHead = cherryPickResult.getNewHead();\n                    }\n                }\n                switch(step.getAction()) {\n                    case PICK:\n                        continue;\n                    case REWORD:\n                        String oldMessage = commitToPick.getFullMessage();\n                        String newMessage = interactiveHandler.modifyCommitMessage(oldMessage);\n                        newHead = new Git(repo).commit().setMessage(newMessage).setAmend(true).call();\n                        continue;\n                    case EDIT:\n                        rebaseState.createFile(AMEND, commitToPick.name());\n                        return stop(commitToPick);\n                    case COMMENT:\n                        break;\n                }\n            } finally {\n                monitor.endTask();\n            }\n        }\n        if (newHead != null) {\n            String headName = rebaseState.readFile(HEAD_NAME);\n            updateHead(headName, newHead, upstreamCommit);\n            FileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n            if (lastStepWasForward)\n                return RebaseResult.FAST_FORWARD_RESULT;\n            return RebaseResult.OK_RESULT;\n        }\n        return RebaseResult.FAST_FORWARD_RESULT;\n    } catch (CheckoutConflictException cce) {\n        return new RebaseResult(cce.getConflictingPaths());\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}"
    },
    {
      "commit": "c3873b584f81bc5be3fdea53e9e0e76271a9a854",
      "startLine": 8,
      "endLine": 23,
      "methodCode": "public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n    RevCommit newHead = null;\n    boolean lastStepWasForward = false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitId = rebaseState.readFile(ONTO);\n                try {\n                    upstreamCommitName = rebaseState.readFile(ONTO_NAME);\n                } catch (FileNotFoundException e) {\n                    upstreamCommitName = upstreamCommitId;\n                }\n                this.upstreamCommit = walk.parseCommit(repo.resolve(upstreamCommitId));\n                break;\n            case BEGIN:\n                RebaseResult res = initFilesAndRewind();\n                if (res != null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation == Operation.CONTINUE) {\n            newHead = continueRebase();\n            File amendFile = rebaseState.getFile(AMEND);\n            boolean amendExists = amendFile.exists();\n            if (amendExists) {\n                FileUtils.delete(amendFile);\n            }\n            if (newHead == null && !amendExists) {\n                return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n            }\n        }\n        if (operation == Operation.SKIP)\n            newHead = checkoutCurrentHead();\n        ObjectReader or = repo.newObjectReader();\n        List<RebaseTodoLine> steps = repo.readRebaseTodo(rebaseState.getPath(GIT_REBASE_TODO), false);\n        if (isInteractive()) {\n            interactiveHandler.prepareSteps(steps);\n            repo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO), steps, false);\n        }\n        for (RebaseTodoLine step : steps) {\n            popSteps(1);\n            if (Action.COMMENT.equals(step.getAction()))\n                continue;\n            Collection<ObjectId> ids = or.resolve(step.getCommit());\n            if (ids.size() != 1)\n                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n            RevCommit commitToPick = walk.parseCommit(ids.iterator().next());\n            if (monitor.isCancelled())\n                return new RebaseResult(commitToPick);\n            try {\n                monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n                newHead = tryFastForward(commitToPick);\n                lastStepWasForward = newHead != null;\n                if (!lastStepWasForward) {\n                    String ourCommitName = getOurCommitName();\n                    CherryPickResult cherryPickResult = new Git(repo).cherryPick().include(commitToPick).setOurCommitName(ourCommitName).setReflogPrefix(\"rebase:\").call();\n                    switch(cherryPickResult.getStatus()) {\n                        case FAILED:\n                            if (operation == Operation.BEGIN)\n                                return abort(new RebaseResult(cherryPickResult.getFailingPaths()));\n                            else\n                                return stop(commitToPick);\n                        case CONFLICTING:\n                            return stop(commitToPick);\n                        case OK:\n                            newHead = cherryPickResult.getNewHead();\n                    }\n                }\n                switch(step.getAction()) {\n                    case PICK:\n                        continue;\n                    case REWORD:\n                        String oldMessage = commitToPick.getFullMessage();\n                        String newMessage = interactiveHandler.modifyCommitMessage(oldMessage);\n                        newHead = new Git(repo).commit().setMessage(newMessage).setAmend(true).call();\n                        continue;\n                    case EDIT:\n                        rebaseState.createFile(AMEND, commitToPick.name());\n                        return stop(commitToPick);\n                    case COMMENT:\n                        break;\n                }\n            } finally {\n                monitor.endTask();\n            }\n        }\n        if (newHead != null) {\n            String headName = rebaseState.readFile(HEAD_NAME);\n            updateHead(headName, newHead, upstreamCommit);\n            FileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n            if (lastStepWasForward)\n                return RebaseResult.FAST_FORWARD_RESULT;\n            return RebaseResult.OK_RESULT;\n        }\n        return RebaseResult.FAST_FORWARD_RESULT;\n    } catch (CheckoutConflictException cce) {\n        return new RebaseResult(cce.getConflictingPaths());\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}"
    },
    {
      "commit": "60e01cff2f763a85ed24a706d26eb9f159ffa832",
      "startLine": 8,
      "endLine": 23,
      "methodCode": "public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n    RevCommit newHead = null;\n    boolean lastStepWasForward = false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitId = rebaseState.readFile(ONTO);\n                try {\n                    upstreamCommitName = rebaseState.readFile(ONTO_NAME);\n                } catch (FileNotFoundException e) {\n                    upstreamCommitName = upstreamCommitId;\n                }\n                this.upstreamCommit = walk.parseCommit(repo.resolve(upstreamCommitId));\n                break;\n            case BEGIN:\n                RebaseResult res = initFilesAndRewind();\n                if (res != null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation == Operation.CONTINUE) {\n            newHead = continueRebase();\n            File amendFile = rebaseState.getFile(AMEND);\n            boolean amendExists = amendFile.exists();\n            if (amendExists) {\n                FileUtils.delete(amendFile);\n            }\n            if (newHead == null && !amendExists) {\n                return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n            }\n        }\n        if (operation == Operation.SKIP)\n            newHead = checkoutCurrentHead();\n        ObjectReader or = repo.newObjectReader();\n        List<Step> steps = loadSteps();\n        if (isInteractive()) {\n            interactiveHandler.prepareSteps(steps);\n            BufferedWriter fw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(rebaseState.getFile(GIT_REBASE_TODO)), Constants.CHARACTER_ENCODING));\n            fw.newLine();\n            try {\n                StringBuilder sb = new StringBuilder();\n                for (Step step : steps) {\n                    sb.setLength(0);\n                    sb.append(step.action.token);\n                    sb.append(\" \");\n                    sb.append(step.commit.name());\n                    sb.append(\" \");\n                    sb.append(RawParseUtils.decode(step.shortMessage).trim());\n                    fw.write(sb.toString());\n                    fw.newLine();\n                }\n            } finally {\n                fw.close();\n            }\n        }\n        for (Step step : steps) {\n            popSteps(1);\n            Collection<ObjectId> ids = or.resolve(step.commit);\n            if (ids.size() != 1)\n                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n            RevCommit commitToPick = walk.parseCommit(ids.iterator().next());\n            if (monitor.isCancelled())\n                return new RebaseResult(commitToPick);\n            try {\n                monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n                newHead = tryFastForward(commitToPick);\n                lastStepWasForward = newHead != null;\n                if (!lastStepWasForward) {\n                    String ourCommitName = getOurCommitName();\n                    CherryPickResult cherryPickResult = new Git(repo).cherryPick().include(commitToPick).setOurCommitName(ourCommitName).setReflogPrefix(\"rebase:\").call();\n                    switch(cherryPickResult.getStatus()) {\n                        case FAILED:\n                            if (operation == Operation.BEGIN)\n                                return abort(new RebaseResult(cherryPickResult.getFailingPaths()));\n                            else\n                                return stop(commitToPick);\n                        case CONFLICTING:\n                            return stop(commitToPick);\n                        case OK:\n                            newHead = cherryPickResult.getNewHead();\n                    }\n                }\n                switch(step.action) {\n                    case PICK:\n                        continue;\n                    case REWORD:\n                        String oldMessage = commitToPick.getFullMessage();\n                        String newMessage = interactiveHandler.modifyCommitMessage(oldMessage);\n                        newHead = new Git(repo).commit().setMessage(newMessage).setAmend(true).call();\n                        continue;\n                    case EDIT:\n                        rebaseState.createFile(AMEND, commitToPick.name());\n                        return stop(commitToPick);\n                }\n            } finally {\n                monitor.endTask();\n            }\n        }\n        if (newHead != null) {\n            String headName = rebaseState.readFile(HEAD_NAME);\n            updateHead(headName, newHead, upstreamCommit);\n            FileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n            if (lastStepWasForward)\n                return RebaseResult.FAST_FORWARD_RESULT;\n            return RebaseResult.OK_RESULT;\n        }\n        return RebaseResult.FAST_FORWARD_RESULT;\n    } catch (CheckoutConflictException cce) {\n        return new RebaseResult(cce.getConflictingPaths());\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}"
    },
    {
      "commit": "0e9f1cf57dac274f92a6db38197e14b55b3277af",
      "startLine": 8,
      "endLine": 23,
      "methodCode": "public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n    RevCommit newHead = null;\n    boolean lastStepWasForward = false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitId = rebaseState.readFile(ONTO);\n                try {\n                    upstreamCommitName = rebaseState.readFile(ONTO_NAME);\n                } catch (FileNotFoundException e) {\n                    upstreamCommitName = upstreamCommitId;\n                }\n                this.upstreamCommit = walk.parseCommit(repo.resolve(upstreamCommitId));\n                break;\n            case BEGIN:\n                RebaseResult res = initFilesAndRewind();\n                if (res != null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation == Operation.CONTINUE) {\n            newHead = continueRebase();\n            File amendFile = rebaseState.getFile(AMEND);\n            boolean amendExists = amendFile.exists();\n            if (amendExists) {\n                FileUtils.delete(amendFile);\n            }\n            if (newHead == null && !amendExists) {\n                return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n            }\n        }\n        if (operation == Operation.SKIP)\n            newHead = checkoutCurrentHead();\n        ObjectReader or = repo.newObjectReader();\n        List<Step> steps = loadSteps();\n        if (isInteractive()) {\n            interactiveHandler.prepareSteps(steps);\n            BufferedWriter fw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(rebaseState.getFile(GIT_REBASE_TODO)), Constants.CHARACTER_ENCODING));\n            fw.newLine();\n            try {\n                StringBuilder sb = new StringBuilder();\n                for (Step step : steps) {\n                    sb.setLength(0);\n                    sb.append(step.action.token);\n                    sb.append(\" \");\n                    sb.append(step.commit.name());\n                    sb.append(\" \");\n                    sb.append(RawParseUtils.decode(step.shortMessage).trim());\n                    fw.write(sb.toString());\n                    fw.newLine();\n                }\n            } finally {\n                fw.close();\n            }\n        }\n        for (Step step : steps) {\n            popSteps(1);\n            Collection<ObjectId> ids = or.resolve(step.commit);\n            if (ids.size() != 1)\n                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n            RevCommit commitToPick = walk.parseCommit(ids.iterator().next());\n            if (monitor.isCancelled())\n                return new RebaseResult(commitToPick);\n            try {\n                monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n                newHead = tryFastForward(commitToPick);\n                lastStepWasForward = newHead != null;\n                if (!lastStepWasForward) {\n                    String ourCommitName = getOurCommitName();\n                    CherryPickResult cherryPickResult = new Git(repo).cherryPick().include(commitToPick).setOurCommitName(ourCommitName).call();\n                    switch(cherryPickResult.getStatus()) {\n                        case FAILED:\n                            if (operation == Operation.BEGIN)\n                                return abort(new RebaseResult(cherryPickResult.getFailingPaths()));\n                            else\n                                return stop(commitToPick);\n                        case CONFLICTING:\n                            return stop(commitToPick);\n                        case OK:\n                            newHead = cherryPickResult.getNewHead();\n                    }\n                }\n                switch(step.action) {\n                    case PICK:\n                        continue;\n                    case REWORD:\n                        String oldMessage = commitToPick.getFullMessage();\n                        String newMessage = interactiveHandler.modifyCommitMessage(oldMessage);\n                        newHead = new Git(repo).commit().setMessage(newMessage).setAmend(true).call();\n                        continue;\n                    case EDIT:\n                        rebaseState.createFile(AMEND, commitToPick.name());\n                        return stop(commitToPick);\n                }\n            } finally {\n                monitor.endTask();\n            }\n        }\n        if (newHead != null) {\n            String headName = rebaseState.readFile(HEAD_NAME);\n            updateHead(headName, newHead);\n            FileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n            if (lastStepWasForward)\n                return RebaseResult.FAST_FORWARD_RESULT;\n            return RebaseResult.OK_RESULT;\n        }\n        return RebaseResult.FAST_FORWARD_RESULT;\n    } catch (CheckoutConflictException cce) {\n        return new RebaseResult(cce.getConflictingPaths());\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}"
    },
    {
      "commit": "baf7ca9cc0d2bdf237a9bb19486d6fde5250a7f5",
      "startLine": 8,
      "endLine": 23,
      "methodCode": "public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n    RevCommit newHead = null;\n    boolean lastStepWasForward = false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitId = readFile(rebaseDir, ONTO);\n                try {\n                    upstreamCommitName = readFile(rebaseDir, ONTO_NAME);\n                } catch (FileNotFoundException e) {\n                    upstreamCommitName = upstreamCommitId;\n                }\n                this.upstreamCommit = walk.parseCommit(repo.resolve(upstreamCommitId));\n                break;\n            case BEGIN:\n                RebaseResult res = initFilesAndRewind();\n                if (res != null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation == Operation.CONTINUE) {\n            newHead = continueRebase();\n            File amendFile = new File(rebaseDir, AMEND);\n            boolean amendExists = amendFile.exists();\n            if (amendExists) {\n                FileUtils.delete(amendFile);\n            }\n            if (newHead == null && !amendExists) {\n                return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n            }\n        }\n        if (operation == Operation.SKIP)\n            newHead = checkoutCurrentHead();\n        ObjectReader or = repo.newObjectReader();\n        List<Step> steps = loadSteps();\n        if (isInteractive()) {\n            interactiveHandler.prepareSteps(steps);\n            BufferedWriter fw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(new File(rebaseDir, GIT_REBASE_TODO)), Constants.CHARACTER_ENCODING));\n            fw.newLine();\n            try {\n                StringBuilder sb = new StringBuilder();\n                for (Step step : steps) {\n                    sb.setLength(0);\n                    sb.append(step.action.token);\n                    sb.append(\" \");\n                    sb.append(step.commit.name());\n                    sb.append(\" \");\n                    sb.append(RawParseUtils.decode(step.shortMessage).trim());\n                    fw.write(sb.toString());\n                    fw.newLine();\n                }\n            } finally {\n                fw.close();\n            }\n        }\n        for (Step step : steps) {\n            popSteps(1);\n            Collection<ObjectId> ids = or.resolve(step.commit);\n            if (ids.size() != 1)\n                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n            RevCommit commitToPick = walk.parseCommit(ids.iterator().next());\n            if (monitor.isCancelled())\n                return new RebaseResult(commitToPick);\n            try {\n                monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n                newHead = tryFastForward(commitToPick);\n                lastStepWasForward = newHead != null;\n                if (!lastStepWasForward) {\n                    String ourCommitName = getOurCommitName();\n                    CherryPickResult cherryPickResult = new Git(repo).cherryPick().include(commitToPick).setOurCommitName(ourCommitName).call();\n                    switch(cherryPickResult.getStatus()) {\n                        case FAILED:\n                            if (operation == Operation.BEGIN)\n                                return abort(new RebaseResult(cherryPickResult.getFailingPaths()));\n                            else\n                                return stop(commitToPick);\n                        case CONFLICTING:\n                            return stop(commitToPick);\n                        case OK:\n                            newHead = cherryPickResult.getNewHead();\n                    }\n                }\n                switch(step.action) {\n                    case PICK:\n                        continue;\n                    case REWORD:\n                        String oldMessage = commitToPick.getFullMessage();\n                        String newMessage = interactiveHandler.modifyCommitMessage(oldMessage);\n                        newHead = new Git(repo).commit().setMessage(newMessage).setAmend(true).call();\n                        continue;\n                    case EDIT:\n                        createFile(rebaseDir, AMEND, commitToPick.name());\n                        return stop(commitToPick);\n                }\n            } finally {\n                monitor.endTask();\n            }\n        }\n        if (newHead != null) {\n            String headName = readFile(rebaseDir, HEAD_NAME);\n            updateHead(headName, newHead);\n            FileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n            if (lastStepWasForward)\n                return RebaseResult.FAST_FORWARD_RESULT;\n            return RebaseResult.OK_RESULT;\n        }\n        return RebaseResult.FAST_FORWARD_RESULT;\n    } catch (CheckoutConflictException cce) {\n        return new RebaseResult(cce.getConflictingPaths());\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}"
    },
    {
      "commit": "c310fa0c802f40a774edb58641de3ac5bfad0e2c",
      "startLine": 8,
      "endLine": 23,
      "methodCode": "public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n    RevCommit newHead = null;\n    boolean lastStepWasForward = false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitId = readFile(rebaseDir, ONTO);\n                try {\n                    upstreamCommitName = readFile(rebaseDir, ONTO_NAME);\n                } catch (FileNotFoundException e) {\n                    upstreamCommitName = upstreamCommitId;\n                }\n                this.upstreamCommit = walk.parseCommit(repo.resolve(upstreamCommitId));\n                break;\n            case BEGIN:\n                RebaseResult res = initFilesAndRewind();\n                if (res != null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation == Operation.CONTINUE) {\n            newHead = continueRebase();\n            File amendFile = new File(rebaseDir, AMEND);\n            boolean amendExists = amendFile.exists();\n            if (amendExists) {\n                FileUtils.delete(amendFile);\n            }\n            if (newHead == null && !amendExists) {\n                return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n            }\n        }\n        if (operation == Operation.SKIP)\n            newHead = checkoutCurrentHead();\n        ObjectReader or = repo.newObjectReader();\n        List<Step> steps = loadSteps();\n        if (isInteractive()) {\n            interactiveHandler.prepareSteps(steps);\n            BufferedWriter fw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(new File(rebaseDir, GIT_REBASE_TODO)), Constants.CHARACTER_ENCODING));\n            fw.newLine();\n            try {\n                StringBuilder sb = new StringBuilder();\n                for (Step step : steps) {\n                    sb.setLength(0);\n                    sb.append(step.action.token);\n                    sb.append(\" \");\n                    sb.append(step.commit.name());\n                    sb.append(\" \");\n                    sb.append(RawParseUtils.decode(step.shortMessage).trim());\n                    fw.write(sb.toString());\n                    fw.newLine();\n                }\n            } finally {\n                fw.close();\n            }\n        }\n        for (Step step : steps) {\n            popSteps(1);\n            Collection<ObjectId> ids = or.resolve(step.commit);\n            if (ids.size() != 1)\n                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n            RevCommit commitToPick = walk.parseCommit(ids.iterator().next());\n            if (monitor.isCancelled())\n                return new RebaseResult(commitToPick);\n            try {\n                monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n                newHead = tryFastForward(commitToPick);\n                lastStepWasForward = newHead != null;\n                if (!lastStepWasForward) {\n                    String ourCommitName = getOurCommitName();\n                    CherryPickResult cherryPickResult = new Git(repo).cherryPick().include(commitToPick).setOurCommitName(ourCommitName).call();\n                    switch(cherryPickResult.getStatus()) {\n                        case FAILED:\n                            if (operation == Operation.BEGIN)\n                                return abort(new RebaseResult(cherryPickResult.getFailingPaths()));\n                            else\n                                return stop(commitToPick);\n                        case CONFLICTING:\n                            return stop(commitToPick);\n                        case OK:\n                            newHead = cherryPickResult.getNewHead();\n                    }\n                }\n                switch(step.action) {\n                    case PICK:\n                        continue;\n                    case REWORD:\n                        String oldMessage = commitToPick.getFullMessage();\n                        String newMessage = interactiveHandler.modifyCommitMessage(oldMessage);\n                        newHead = new Git(repo).commit().setMessage(newMessage).setAmend(true).call();\n                        continue;\n                    case EDIT:\n                        createFile(rebaseDir, AMEND, commitToPick.name());\n                        return stop(commitToPick);\n                }\n            } finally {\n                monitor.endTask();\n            }\n        }\n        if (newHead != null) {\n            String headName = readFile(rebaseDir, HEAD_NAME);\n            updateHead(headName, newHead);\n            FileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n            if (lastStepWasForward)\n                return RebaseResult.FAST_FORWARD_RESULT;\n            return RebaseResult.OK_RESULT;\n        }\n        return RebaseResult.FAST_FORWARD_RESULT;\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}"
    },
    {
      "commit": "257f3fe4a1b9e450b2f665b5f0ed09a3ab3839b9",
      "startLine": 8,
      "endLine": 23,
      "methodCode": "public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n    RevCommit newHead = null;\n    boolean lastStepWasForward = false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitId = readFile(rebaseDir, ONTO);\n                try {\n                    upstreamCommitName = readFile(rebaseDir, ONTO_NAME);\n                } catch (FileNotFoundException e) {\n                    upstreamCommitName = upstreamCommitId;\n                }\n                this.upstreamCommit = walk.parseCommit(repo.resolve(upstreamCommitId));\n                break;\n            case BEGIN:\n                RebaseResult res = initFilesAndRewind();\n                if (res != null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation == Operation.CONTINUE) {\n            newHead = continueRebase();\n            File amendFile = new File(rebaseDir, AMEND);\n            boolean amendExists = amendFile.exists();\n            if (amendExists) {\n                FileUtils.delete(amendFile);\n            }\n            if (newHead == null && !amendExists) {\n                return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n            }\n        }\n        if (operation == Operation.SKIP)\n            newHead = checkoutCurrentHead();\n        ObjectReader or = repo.newObjectReader();\n        List<Step> steps = loadSteps();\n        if (isInteractive()) {\n            interactiveHandler.prepareSteps(steps);\n            BufferedWriter fw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(new File(rebaseDir, GIT_REBASE_TODO)), Constants.CHARACTER_ENCODING));\n            fw.newLine();\n            try {\n                StringBuilder sb = new StringBuilder();\n                for (Step step : steps) {\n                    sb.setLength(0);\n                    sb.append(step.action.token);\n                    sb.append(\" \");\n                    sb.append(step.commit.name());\n                    sb.append(\" \");\n                    sb.append(RawParseUtils.decode(step.shortMessage).trim());\n                    fw.write(sb.toString());\n                    fw.newLine();\n                }\n            } finally {\n                fw.close();\n            }\n        }\n        for (Step step : steps) {\n            popSteps(1);\n            Collection<ObjectId> ids = or.resolve(step.commit);\n            if (ids.size() != 1)\n                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n            RevCommit commitToPick = walk.parseCommit(ids.iterator().next());\n            if (monitor.isCancelled())\n                return new RebaseResult(commitToPick);\n            try {\n                monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n                newHead = tryFastForward(commitToPick);\n                lastStepWasForward = newHead != null;\n                if (!lastStepWasForward) {\n                    String ourCommitName = getOurCommitName();\n                    CherryPickResult cherryPickResult = new Git(repo).cherryPick().include(commitToPick).setOurCommitName(ourCommitName).call();\n                    switch(cherryPickResult.getStatus()) {\n                        case FAILED:\n                            if (operation == Operation.BEGIN)\n                                return abort(new RebaseResult(cherryPickResult.getFailingPaths()));\n                            else\n                                return stop(commitToPick);\n                        case CONFLICTING:\n                            return stop(commitToPick);\n                        case OK:\n                            newHead = cherryPickResult.getNewHead();\n                    }\n                }\n                switch(step.action) {\n                    case PICK:\n                        continue;\n                    case REWORD:\n                        String oldMessage = commitToPick.getFullMessage();\n                        String newMessage = interactiveHandler.modifyCommitMessage(oldMessage);\n                        newHead = new Git(repo).commit().setMessage(newMessage).setAmend(true).call();\n                        continue;\n                    case EDIT:\n                        createFile(rebaseDir, AMEND, commitToPick.name());\n                        return stop(commitToPick);\n                }\n            } finally {\n                monitor.endTask();\n            }\n        }\n        if (newHead != null) {\n            String headName = readFile(rebaseDir, HEAD_NAME);\n            updateHead(headName, newHead);\n            FileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n            if (lastStepWasForward)\n                return RebaseResult.FAST_FORWARD_RESULT;\n            return RebaseResult.OK_RESULT;\n        }\n        return RebaseResult.FAST_FORWARD_RESULT;\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}"
    },
    {
      "commit": "8eb4d926371edea2d58dc598e3ebcddacbdc326e",
      "startLine": 8,
      "endLine": 23,
      "methodCode": "public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n    RevCommit newHead = null;\n    boolean lastStepWasForward = false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitId = readFile(rebaseDir, ONTO);\n                try {\n                    upstreamCommitName = readFile(rebaseDir, ONTO_NAME);\n                } catch (FileNotFoundException e) {\n                    upstreamCommitName = upstreamCommitId;\n                }\n                this.upstreamCommit = walk.parseCommit(repo.resolve(upstreamCommitId));\n                break;\n            case BEGIN:\n                RebaseResult res = initFilesAndRewind();\n                if (res != null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation == Operation.CONTINUE) {\n            newHead = continueRebase();\n            File amendFile = new File(rebaseDir, AMEND);\n            boolean amendExists = amendFile.exists();\n            if (amendExists) {\n                FileUtils.delete(amendFile);\n            }\n            if (newHead == null && !amendExists) {\n                return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n            }\n        }\n        if (operation == Operation.SKIP)\n            newHead = checkoutCurrentHead();\n        ObjectReader or = repo.newObjectReader();\n        List<Step> steps = loadSteps();\n        if (isInteractive()) {\n            interactiveHandler.prepareSteps(steps);\n            BufferedWriter fw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(new File(rebaseDir, GIT_REBASE_TODO)), Constants.CHARACTER_ENCODING));\n            fw.newLine();\n            try {\n                StringBuilder sb = new StringBuilder();\n                for (Step step : steps) {\n                    sb.setLength(0);\n                    sb.append(step.action.token);\n                    sb.append(\" \");\n                    sb.append(step.commit.name());\n                    sb.append(\" \");\n                    sb.append(new String(step.shortMessage, Constants.CHARACTER_ENCODING).trim());\n                    fw.write(sb.toString());\n                    fw.newLine();\n                }\n            } finally {\n                fw.close();\n            }\n        }\n        for (Step step : steps) {\n            popSteps(1);\n            Collection<ObjectId> ids = or.resolve(step.commit);\n            if (ids.size() != 1)\n                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n            RevCommit commitToPick = walk.parseCommit(ids.iterator().next());\n            if (monitor.isCancelled())\n                return new RebaseResult(commitToPick);\n            try {\n                monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n                newHead = tryFastForward(commitToPick);\n                lastStepWasForward = newHead != null;\n                if (!lastStepWasForward) {\n                    String ourCommitName = getOurCommitName();\n                    CherryPickResult cherryPickResult = new Git(repo).cherryPick().include(commitToPick).setOurCommitName(ourCommitName).call();\n                    switch(cherryPickResult.getStatus()) {\n                        case FAILED:\n                            if (operation == Operation.BEGIN)\n                                return abort(new RebaseResult(cherryPickResult.getFailingPaths()));\n                            else\n                                return stop(commitToPick);\n                        case CONFLICTING:\n                            return stop(commitToPick);\n                        case OK:\n                            newHead = cherryPickResult.getNewHead();\n                    }\n                }\n                switch(step.action) {\n                    case PICK:\n                        continue;\n                    case REWORD:\n                        String oldMessage = commitToPick.getFullMessage();\n                        String newMessage = interactiveHandler.modifyCommitMessage(oldMessage);\n                        newHead = new Git(repo).commit().setMessage(newMessage).setAmend(true).call();\n                        continue;\n                    case EDIT:\n                        createFile(rebaseDir, AMEND, commitToPick.name());\n                        return stop(commitToPick);\n                }\n            } finally {\n                monitor.endTask();\n            }\n        }\n        if (newHead != null) {\n            String headName = readFile(rebaseDir, HEAD_NAME);\n            updateHead(headName, newHead);\n            FileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n            if (lastStepWasForward)\n                return RebaseResult.FAST_FORWARD_RESULT;\n            return RebaseResult.OK_RESULT;\n        }\n        return RebaseResult.FAST_FORWARD_RESULT;\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}"
    },
    {
      "commit": "84fb2b59d11418d2fa753d27de11775ddc18adde",
      "startLine": 8,
      "endLine": 23,
      "methodCode": "public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n    RevCommit newHead = null;\n    boolean lastStepWasForward = false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitId = readFile(rebaseDir, ONTO);\n                try {\n                    upstreamCommitName = readFile(rebaseDir, ONTO_NAME);\n                } catch (FileNotFoundException e) {\n                    upstreamCommitName = upstreamCommitId;\n                }\n                this.upstreamCommit = walk.parseCommit(repo.resolve(upstreamCommitId));\n                break;\n            case BEGIN:\n                RebaseResult res = initFilesAndRewind();\n                if (res != null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation == Operation.CONTINUE) {\n            newHead = continueRebase();\n            if (newHead == null) {\n                return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n            }\n        }\n        if (operation == Operation.SKIP)\n            newHead = checkoutCurrentHead();\n        ObjectReader or = repo.newObjectReader();\n        List<Step> steps = loadSteps();\n        if (isInteractive()) {\n            interactiveHandler.prepareSteps(steps);\n            BufferedWriter fw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(new File(rebaseDir, GIT_REBASE_TODO)), Constants.CHARACTER_ENCODING));\n            fw.newLine();\n            try {\n                StringBuilder sb = new StringBuilder();\n                for (Step step : steps) {\n                    sb.setLength(0);\n                    sb.append(step.action.token);\n                    sb.append(\" \");\n                    sb.append(step.commit.name());\n                    sb.append(\" \");\n                    sb.append(new String(step.shortMessage, Constants.CHARACTER_ENCODING).trim());\n                    fw.write(sb.toString());\n                    fw.newLine();\n                }\n            } finally {\n                fw.close();\n            }\n        }\n        for (Step step : steps) {\n            popSteps(1);\n            Collection<ObjectId> ids = or.resolve(step.commit);\n            if (ids.size() != 1)\n                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n            RevCommit commitToPick = walk.parseCommit(ids.iterator().next());\n            if (monitor.isCancelled())\n                return new RebaseResult(commitToPick);\n            try {\n                monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n                newHead = tryFastForward(commitToPick);\n                lastStepWasForward = newHead != null;\n                if (!lastStepWasForward) {\n                    String ourCommitName = getOurCommitName();\n                    CherryPickResult cherryPickResult = new Git(repo).cherryPick().include(commitToPick).setOurCommitName(ourCommitName).call();\n                    switch(cherryPickResult.getStatus()) {\n                        case FAILED:\n                            if (operation == Operation.BEGIN)\n                                return abort(new RebaseResult(cherryPickResult.getFailingPaths()));\n                            else\n                                return stop(commitToPick);\n                        case CONFLICTING:\n                            return stop(commitToPick);\n                        case OK:\n                            newHead = cherryPickResult.getNewHead();\n                    }\n                }\n                switch(step.action) {\n                    case PICK:\n                        continue;\n                    case REWORD:\n                        String oldMessage = commitToPick.getFullMessage();\n                        String newMessage = interactiveHandler.modifyCommitMessage(oldMessage);\n                        newHead = new Git(repo).commit().setMessage(newMessage).setAmend(true).call();\n                        continue;\n                }\n            } finally {\n                monitor.endTask();\n            }\n        }\n        if (newHead != null) {\n            String headName = readFile(rebaseDir, HEAD_NAME);\n            updateHead(headName, newHead);\n            FileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n            if (lastStepWasForward)\n                return RebaseResult.FAST_FORWARD_RESULT;\n            return RebaseResult.OK_RESULT;\n        }\n        return RebaseResult.FAST_FORWARD_RESULT;\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}"
    },
    {
      "commit": "5854ca091a22346e1c710ca9f875165afb3f2cc8",
      "startLine": 8,
      "endLine": 23,
      "methodCode": "public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n    RevCommit newHead = null;\n    boolean lastStepWasForward = false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitId = readFile(rebaseDir, ONTO);\n                try {\n                    upstreamCommitName = readFile(rebaseDir, ONTO_NAME);\n                } catch (FileNotFoundException e) {\n                    upstreamCommitName = upstreamCommitId;\n                }\n                this.upstreamCommit = walk.parseCommit(repo.resolve(upstreamCommitId));\n                break;\n            case BEGIN:\n                RebaseResult res = initFilesAndRewind();\n                if (res != null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation == Operation.CONTINUE) {\n            newHead = continueRebase();\n            if (newHead == null) {\n                return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n            }\n        }\n        if (operation == Operation.SKIP)\n            newHead = checkoutCurrentHead();\n        ObjectReader or = repo.newObjectReader();\n        List<Step> steps = loadSteps();\n        for (Step step : steps) {\n            popSteps(1);\n            Collection<ObjectId> ids = or.resolve(step.commit);\n            if (ids.size() != 1)\n                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n            RevCommit commitToPick = walk.parseCommit(ids.iterator().next());\n            if (monitor.isCancelled())\n                return new RebaseResult(commitToPick);\n            try {\n                monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n                newHead = tryFastForward(commitToPick);\n                lastStepWasForward = newHead != null;\n                if (!lastStepWasForward) {\n                    String ourCommitName = getOurCommitName();\n                    CherryPickResult cherryPickResult = new Git(repo).cherryPick().include(commitToPick).setOurCommitName(ourCommitName).call();\n                    switch(cherryPickResult.getStatus()) {\n                        case FAILED:\n                            if (operation == Operation.BEGIN)\n                                return abort(new RebaseResult(cherryPickResult.getFailingPaths()));\n                            else\n                                return stop(commitToPick);\n                        case CONFLICTING:\n                            return stop(commitToPick);\n                        case OK:\n                            newHead = cherryPickResult.getNewHead();\n                    }\n                }\n            } finally {\n                monitor.endTask();\n            }\n        }\n        if (newHead != null) {\n            String headName = readFile(rebaseDir, HEAD_NAME);\n            updateHead(headName, newHead);\n            FileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n            if (lastStepWasForward)\n                return RebaseResult.FAST_FORWARD_RESULT;\n            return RebaseResult.OK_RESULT;\n        }\n        return RebaseResult.FAST_FORWARD_RESULT;\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}"
    },
    {
      "commit": "b61d35e848e637ef85fde4ebe95d60ced171e963",
      "startLine": 8,
      "endLine": 18,
      "methodCode": "public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException {\n    RevCommit newHead = null;\n    boolean lastStepWasForward = false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitName = readFile(rebaseDir, ONTO);\n                this.upstreamCommit = walk.parseCommit(repo.resolve(upstreamCommitName));\n                break;\n            case BEGIN:\n                RebaseResult res = initFilesAndRewind();\n                if (res != null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation == Operation.CONTINUE) {\n            newHead = continueRebase();\n            if (newHead == null) {\n                return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n            }\n        }\n        if (operation == Operation.SKIP)\n            newHead = checkoutCurrentHead();\n        ObjectReader or = repo.newObjectReader();\n        List<Step> steps = loadSteps();\n        for (Step step : steps) {\n            popSteps(1);\n            Collection<ObjectId> ids = or.resolve(step.commit);\n            if (ids.size() != 1)\n                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n            RevCommit commitToPick = walk.parseCommit(ids.iterator().next());\n            if (monitor.isCancelled())\n                return new RebaseResult(commitToPick);\n            try {\n                monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n                newHead = tryFastForward(commitToPick);\n                lastStepWasForward = newHead != null;\n                if (!lastStepWasForward) {\n                    CherryPickResult cherryPickResult = new Git(repo).cherryPick().include(commitToPick).call();\n                    switch(cherryPickResult.getStatus()) {\n                        case FAILED:\n                            if (operation == Operation.BEGIN)\n                                return abort(new RebaseResult(cherryPickResult.getFailingPaths()));\n                            else\n                                return stop(commitToPick);\n                        case CONFLICTING:\n                            return stop(commitToPick);\n                        case OK:\n                            newHead = cherryPickResult.getNewHead();\n                    }\n                }\n            } finally {\n                monitor.endTask();\n            }\n        }\n        if (newHead != null) {\n            String headName = readFile(rebaseDir, HEAD_NAME);\n            updateHead(headName, newHead);\n            FileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n            if (lastStepWasForward)\n                return RebaseResult.FAST_FORWARD_RESULT;\n            return RebaseResult.OK_RESULT;\n        }\n        return RebaseResult.FAST_FORWARD_RESULT;\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}"
    },
    {
      "commit": "4e1454ded6e2fcf6cb789c004756883c3ea5f77e",
      "startLine": 8,
      "endLine": 18,
      "methodCode": "public RebaseResult call() throws GitAPIException, NoHeadException, RefNotFoundException {\n    RevCommit newHead = null;\n    boolean lastStepWasForward = false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitName = readFile(rebaseDir, ONTO);\n                this.upstreamCommit = walk.parseCommit(repo.resolve(upstreamCommitName));\n                break;\n            case BEGIN:\n                RebaseResult res = initFilesAndRewind();\n                if (res != null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation == Operation.CONTINUE) {\n            newHead = continueRebase();\n            if (newHead == null) {\n                return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n            }\n        }\n        if (operation == Operation.SKIP)\n            newHead = checkoutCurrentHead();\n        ObjectReader or = repo.newObjectReader();\n        List<Step> steps = loadSteps();\n        for (Step step : steps) {\n            popSteps(1);\n            Collection<ObjectId> ids = or.resolve(step.commit);\n            if (ids.size() != 1)\n                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n            RevCommit commitToPick = walk.parseCommit(ids.iterator().next());\n            if (monitor.isCancelled())\n                return new RebaseResult(commitToPick);\n            try {\n                monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n                newHead = tryFastForward(commitToPick);\n                lastStepWasForward = newHead != null;\n                if (!lastStepWasForward) {\n                    CherryPickResult cherryPickResult = new Git(repo).cherryPick().include(commitToPick).call();\n                    switch(cherryPickResult.getStatus()) {\n                        case FAILED:\n                            if (operation == Operation.BEGIN)\n                                return abort(new RebaseResult(cherryPickResult.getFailingPaths()));\n                            else\n                                return stop(commitToPick);\n                        case CONFLICTING:\n                            return stop(commitToPick);\n                        case OK:\n                            newHead = cherryPickResult.getNewHead();\n                    }\n                }\n            } finally {\n                monitor.endTask();\n            }\n        }\n        if (newHead != null) {\n            String headName = readFile(rebaseDir, HEAD_NAME);\n            updateHead(headName, newHead);\n            FileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n            if (lastStepWasForward)\n                return RebaseResult.FAST_FORWARD_RESULT;\n            return RebaseResult.OK_RESULT;\n        }\n        return RebaseResult.FAST_FORWARD_RESULT;\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}"
    },
    {
      "commit": "edc1fee033a23189742cea1807d8029d1b77da00",
      "startLine": 8,
      "endLine": 18,
      "methodCode": "public RebaseResult call() throws NoHeadException, RefNotFoundException, JGitInternalException, GitAPIException {\n    RevCommit newHead = null;\n    boolean lastStepWasForward = false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitName = readFile(rebaseDir, ONTO);\n                this.upstreamCommit = walk.parseCommit(repo.resolve(upstreamCommitName));\n                break;\n            case BEGIN:\n                RebaseResult res = initFilesAndRewind();\n                if (res != null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation == Operation.CONTINUE) {\n            newHead = continueRebase();\n            if (newHead == null) {\n                return RebaseResult.NOTHING_TO_COMMIT_RESULT;\n            }\n        }\n        if (operation == Operation.SKIP)\n            newHead = checkoutCurrentHead();\n        ObjectReader or = repo.newObjectReader();\n        List<Step> steps = loadSteps();\n        for (Step step : steps) {\n            popSteps(1);\n            Collection<ObjectId> ids = or.resolve(step.commit);\n            if (ids.size() != 1)\n                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n            RevCommit commitToPick = walk.parseCommit(ids.iterator().next());\n            if (monitor.isCancelled())\n                return new RebaseResult(commitToPick);\n            try {\n                monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n                newHead = tryFastForward(commitToPick);\n                lastStepWasForward = newHead != null;\n                if (!lastStepWasForward) {\n                    CherryPickResult cherryPickResult = new Git(repo).cherryPick().include(commitToPick).call();\n                    switch(cherryPickResult.getStatus()) {\n                        case FAILED:\n                            if (operation == Operation.BEGIN)\n                                return abort(new RebaseResult(cherryPickResult.getFailingPaths()));\n                            else\n                                return stop(commitToPick);\n                        case CONFLICTING:\n                            return stop(commitToPick);\n                        case OK:\n                            newHead = cherryPickResult.getNewHead();\n                    }\n                }\n            } finally {\n                monitor.endTask();\n            }\n        }\n        if (newHead != null) {\n            String headName = readFile(rebaseDir, HEAD_NAME);\n            updateHead(headName, newHead);\n            FileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n            if (lastStepWasForward)\n                return RebaseResult.FAST_FORWARD_RESULT;\n            return RebaseResult.OK_RESULT;\n        }\n        return RebaseResult.FAST_FORWARD_RESULT;\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}"
    },
    {
      "commit": "557ea857e3b5229379476f1ee4160fcf5b695bbd",
      "startLine": 8,
      "endLine": 18,
      "methodCode": "public RebaseResult call() throws NoHeadException, RefNotFoundException, JGitInternalException, GitAPIException {\n    RevCommit newHead = null;\n    boolean lastStepWasForward = false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(RebaseResult.ABORTED_RESULT);\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitName = readFile(rebaseDir, ONTO);\n                this.upstreamCommit = walk.parseCommit(repo.resolve(upstreamCommitName));\n                break;\n            case BEGIN:\n                RebaseResult res = initFilesAndRewind();\n                if (res != null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort(RebaseResult.ABORTED_RESULT);\n        if (operation == Operation.CONTINUE)\n            newHead = continueRebase();\n        if (operation == Operation.SKIP)\n            newHead = checkoutCurrentHead();\n        ObjectReader or = repo.newObjectReader();\n        List<Step> steps = loadSteps();\n        for (Step step : steps) {\n            popSteps(1);\n            Collection<ObjectId> ids = or.resolve(step.commit);\n            if (ids.size() != 1)\n                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n            RevCommit commitToPick = walk.parseCommit(ids.iterator().next());\n            if (monitor.isCancelled())\n                return new RebaseResult(commitToPick);\n            try {\n                monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n                newHead = tryFastForward(commitToPick);\n                lastStepWasForward = newHead != null;\n                if (!lastStepWasForward) {\n                    CherryPickResult cherryPickResult = new Git(repo).cherryPick().include(commitToPick).call();\n                    switch(cherryPickResult.getStatus()) {\n                        case FAILED:\n                            if (operation == Operation.BEGIN)\n                                return abort(new RebaseResult(cherryPickResult.getFailingPaths()));\n                            else\n                                return stop(commitToPick);\n                        case CONFLICTING:\n                            return stop(commitToPick);\n                        case OK:\n                            newHead = cherryPickResult.getNewHead();\n                    }\n                }\n            } finally {\n                monitor.endTask();\n            }\n        }\n        if (newHead != null) {\n            String headName = readFile(rebaseDir, HEAD_NAME);\n            updateHead(headName, newHead);\n            FileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n            if (lastStepWasForward)\n                return RebaseResult.FAST_FORWARD_RESULT;\n            return RebaseResult.OK_RESULT;\n        }\n        return RebaseResult.FAST_FORWARD_RESULT;\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}"
    },
    {
      "commit": "0b5ad24915824a8c999bb6951b131a958e418306",
      "startLine": 8,
      "endLine": 18,
      "methodCode": "public RebaseResult call() throws NoHeadException, RefNotFoundException, JGitInternalException, GitAPIException {\n    RevCommit newHead = null;\n    boolean lastStepWasForward = false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort(new RebaseResult(Status.ABORTED));\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitName = readFile(rebaseDir, ONTO);\n                this.upstreamCommit = walk.parseCommit(repo.resolve(upstreamCommitName));\n                break;\n            case BEGIN:\n                RebaseResult res = initFilesAndRewind();\n                if (res != null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort(new RebaseResult(Status.ABORTED));\n        if (operation == Operation.CONTINUE)\n            newHead = continueRebase();\n        if (operation == Operation.SKIP)\n            newHead = checkoutCurrentHead();\n        ObjectReader or = repo.newObjectReader();\n        List<Step> steps = loadSteps();\n        for (Step step : steps) {\n            popSteps(1);\n            Collection<ObjectId> ids = or.resolve(step.commit);\n            if (ids.size() != 1)\n                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n            RevCommit commitToPick = walk.parseCommit(ids.iterator().next());\n            if (monitor.isCancelled())\n                return new RebaseResult(commitToPick);\n            try {\n                monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n                newHead = tryFastForward(commitToPick);\n                lastStepWasForward = newHead != null;\n                if (!lastStepWasForward) {\n                    CherryPickResult cherryPickResult = new Git(repo).cherryPick().include(commitToPick).call();\n                    switch(cherryPickResult.getStatus()) {\n                        case FAILED:\n                            if (operation == Operation.BEGIN)\n                                return abort(new RebaseResult(cherryPickResult.getFailingPaths()));\n                            else\n                                return stop(commitToPick);\n                        case CONFLICTING:\n                            return stop(commitToPick);\n                        case OK:\n                            newHead = cherryPickResult.getNewHead();\n                    }\n                }\n            } finally {\n                monitor.endTask();\n            }\n        }\n        if (newHead != null) {\n            String headName = readFile(rebaseDir, HEAD_NAME);\n            if (headName.startsWith(Constants.R_REFS)) {\n                RefUpdate rup = repo.updateRef(headName);\n                rup.setNewObjectId(newHead);\n                Result res = rup.forceUpdate();\n                switch(res) {\n                    case FAST_FORWARD:\n                    case FORCED:\n                    case NO_CHANGE:\n                        break;\n                    default:\n                        throw new JGitInternalException(\"Updating HEAD failed\");\n                }\n                rup = repo.updateRef(Constants.HEAD);\n                res = rup.link(headName);\n                switch(res) {\n                    case FAST_FORWARD:\n                    case FORCED:\n                    case NO_CHANGE:\n                        break;\n                    default:\n                        throw new JGitInternalException(\"Updating HEAD failed\");\n                }\n            }\n            FileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n            if (lastStepWasForward)\n                return new RebaseResult(Status.FAST_FORWARD);\n            return new RebaseResult(Status.OK);\n        }\n        return new RebaseResult(Status.UP_TO_DATE);\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}"
    },
    {
      "commit": "a21e508a318664dac23701ca29d5f0b64d36a76a",
      "startLine": 8,
      "endLine": 18,
      "methodCode": "public RebaseResult call() throws NoHeadException, RefNotFoundException, JGitInternalException, GitAPIException {\n    RevCommit newHead = null;\n    boolean lastStepWasForward = false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort();\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitName = readFile(rebaseDir, ONTO);\n                this.upstreamCommit = walk.parseCommit(repo.resolve(upstreamCommitName));\n                break;\n            case BEGIN:\n                RebaseResult res = initFilesAndRewind();\n                if (res != null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort();\n        if (this.operation == Operation.CONTINUE)\n            newHead = continueRebase();\n        if (this.operation == Operation.SKIP)\n            newHead = checkoutCurrentHead();\n        ObjectReader or = repo.newObjectReader();\n        List<Step> steps = loadSteps();\n        for (Step step : steps) {\n            popSteps(1);\n            Collection<ObjectId> ids = or.resolve(step.commit);\n            if (ids.size() != 1)\n                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n            RevCommit commitToPick = walk.parseCommit(ids.iterator().next());\n            if (monitor.isCancelled())\n                return new RebaseResult(commitToPick);\n            monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n            newHead = tryFastForward(commitToPick);\n            lastStepWasForward = newHead != null;\n            if (!lastStepWasForward)\n                newHead = new Git(repo).cherryPick().include(commitToPick).call().getNewHead();\n            monitor.endTask();\n            if (newHead == null) {\n                return stop(commitToPick);\n            }\n        }\n        if (newHead != null) {\n            String headName = readFile(rebaseDir, HEAD_NAME);\n            if (headName.startsWith(Constants.R_REFS)) {\n                RefUpdate rup = repo.updateRef(headName);\n                rup.setNewObjectId(newHead);\n                Result res = rup.forceUpdate();\n                switch(res) {\n                    case FAST_FORWARD:\n                    case FORCED:\n                    case NO_CHANGE:\n                        break;\n                    default:\n                        throw new JGitInternalException(\"Updating HEAD failed\");\n                }\n                rup = repo.updateRef(Constants.HEAD);\n                res = rup.link(headName);\n                switch(res) {\n                    case FAST_FORWARD:\n                    case FORCED:\n                    case NO_CHANGE:\n                        break;\n                    default:\n                        throw new JGitInternalException(\"Updating HEAD failed\");\n                }\n            }\n            FileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n            if (lastStepWasForward)\n                return new RebaseResult(Status.FAST_FORWARD);\n            return new RebaseResult(Status.OK);\n        }\n        return new RebaseResult(Status.UP_TO_DATE);\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}"
    },
    {
      "commit": "e8a1328d05aa55b7ace0d101e34b87422219c959",
      "startLine": 8,
      "endLine": 18,
      "methodCode": "public RebaseResult call() throws NoHeadException, RefNotFoundException, JGitInternalException, GitAPIException {\n    RevCommit newHead = null;\n    boolean lastStepWasForward = false;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort();\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitName = readFile(rebaseDir, ONTO);\n                this.upstreamCommit = walk.parseCommit(repo.resolve(upstreamCommitName));\n                break;\n            case BEGIN:\n                RebaseResult res = initFilesAndRewind();\n                if (res != null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort();\n        if (this.operation == Operation.CONTINUE)\n            newHead = continueRebase();\n        if (this.operation == Operation.SKIP)\n            newHead = checkoutCurrentHead();\n        ObjectReader or = repo.newObjectReader();\n        List<Step> steps = loadSteps();\n        for (Step step : steps) {\n            popSteps(1);\n            Collection<ObjectId> ids = or.resolve(step.commit);\n            if (ids.size() != 1)\n                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n            RevCommit commitToPick = walk.parseCommit(ids.iterator().next());\n            if (monitor.isCancelled())\n                return new RebaseResult(commitToPick);\n            monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n            newHead = tryFastForward(commitToPick);\n            lastStepWasForward = newHead != null;\n            if (!lastStepWasForward)\n                newHead = new Git(repo).cherryPick().include(commitToPick).call();\n            monitor.endTask();\n            if (newHead == null) {\n                return stop(commitToPick);\n            }\n        }\n        if (newHead != null) {\n            String headName = readFile(rebaseDir, HEAD_NAME);\n            if (headName.startsWith(Constants.R_REFS)) {\n                RefUpdate rup = repo.updateRef(headName);\n                rup.setNewObjectId(newHead);\n                Result res = rup.forceUpdate();\n                switch(res) {\n                    case FAST_FORWARD:\n                    case FORCED:\n                    case NO_CHANGE:\n                        break;\n                    default:\n                        throw new JGitInternalException(\"Updating HEAD failed\");\n                }\n                rup = repo.updateRef(Constants.HEAD);\n                res = rup.link(headName);\n                switch(res) {\n                    case FAST_FORWARD:\n                    case FORCED:\n                    case NO_CHANGE:\n                        break;\n                    default:\n                        throw new JGitInternalException(\"Updating HEAD failed\");\n                }\n            }\n            FileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n            if (lastStepWasForward)\n                return new RebaseResult(Status.FAST_FORWARD);\n            return new RebaseResult(Status.OK);\n        }\n        return new RebaseResult(Status.UP_TO_DATE);\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}"
    },
    {
      "commit": "9b039b42e0ecf69640c5f1a34ee72a86dba3f1c2",
      "startLine": 7,
      "endLine": 17,
      "methodCode": "public RebaseResult call() throws NoHeadException, RefNotFoundException, JGitInternalException, GitAPIException {\n    RevCommit newHead = null;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort();\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitName = readFile(rebaseDir, ONTO);\n                this.upstreamCommit = walk.parseCommit(repo.resolve(upstreamCommitName));\n                break;\n            case BEGIN:\n                RebaseResult res = initFilesAndRewind();\n                if (res != null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort();\n        if (this.operation == Operation.CONTINUE)\n            newHead = continueRebase();\n        if (this.operation == Operation.SKIP)\n            newHead = checkoutCurrentHead();\n        ObjectReader or = repo.newObjectReader();\n        List<Step> steps = loadSteps();\n        for (Step step : steps) {\n            popSteps(1);\n            Collection<ObjectId> ids = or.resolve(step.commit);\n            if (ids.size() != 1)\n                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n            RevCommit commitToPick = walk.parseCommit(ids.iterator().next());\n            if (monitor.isCancelled())\n                return new RebaseResult(commitToPick);\n            monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n            newHead = new Git(repo).cherryPick().include(commitToPick).call();\n            monitor.endTask();\n            if (newHead == null) {\n                return stop(commitToPick);\n            }\n        }\n        if (newHead != null) {\n            String headName = readFile(rebaseDir, HEAD_NAME);\n            if (headName.startsWith(Constants.R_REFS)) {\n                RefUpdate rup = repo.updateRef(headName);\n                rup.setNewObjectId(newHead);\n                Result res = rup.forceUpdate();\n                switch(res) {\n                    case FAST_FORWARD:\n                    case FORCED:\n                    case NO_CHANGE:\n                        break;\n                    default:\n                        throw new JGitInternalException(\"Updating HEAD failed\");\n                }\n                rup = repo.updateRef(Constants.HEAD);\n                res = rup.link(headName);\n                switch(res) {\n                    case FAST_FORWARD:\n                    case FORCED:\n                    case NO_CHANGE:\n                        break;\n                    default:\n                        throw new JGitInternalException(\"Updating HEAD failed\");\n                }\n            }\n            FileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n            return new RebaseResult(Status.OK);\n        }\n        return new RebaseResult(Status.UP_TO_DATE);\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}"
    },
    {
      "commit": "2a7cd0086bf1bd614478c5722eac5142326e6f2b",
      "startLine": 7,
      "endLine": 17,
      "methodCode": "public RebaseResult call() throws NoHeadException, RefNotFoundException, JGitInternalException, GitAPIException {\n    RevCommit newHead = null;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort();\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitName = readFile(rebaseDir, ONTO);\n                this.upstreamCommit = walk.parseCommit(repo.resolve(upstreamCommitName));\n                break;\n            case BEGIN:\n                RebaseResult res = initFilesAndRewind();\n                if (res != null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort();\n        if (this.operation == Operation.CONTINUE)\n            newHead = continueRebase();\n        if (this.operation == Operation.SKIP)\n            newHead = checkoutCurrentHead();\n        ObjectReader or = repo.newObjectReader();\n        List<Step> steps = loadSteps();\n        for (Step step : steps) {\n            if (step.action != Action.PICK)\n                continue;\n            popSteps(1);\n            Collection<ObjectId> ids = or.resolve(step.commit);\n            if (ids.size() != 1)\n                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n            RevCommit commitToPick = walk.parseCommit(ids.iterator().next());\n            if (monitor.isCancelled())\n                return new RebaseResult(commitToPick);\n            monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n            newHead = new Git(repo).cherryPick().include(commitToPick).call();\n            monitor.endTask();\n            if (newHead == null) {\n                return stop(commitToPick);\n            }\n        }\n        if (newHead != null) {\n            String headName = readFile(rebaseDir, HEAD_NAME);\n            if (headName.startsWith(Constants.R_REFS)) {\n                RefUpdate rup = repo.updateRef(headName);\n                rup.setNewObjectId(newHead);\n                Result res = rup.forceUpdate();\n                switch(res) {\n                    case FAST_FORWARD:\n                    case FORCED:\n                    case NO_CHANGE:\n                        break;\n                    default:\n                        throw new JGitInternalException(\"Updating HEAD failed\");\n                }\n                rup = repo.updateRef(Constants.HEAD);\n                res = rup.link(headName);\n                switch(res) {\n                    case FAST_FORWARD:\n                    case FORCED:\n                    case NO_CHANGE:\n                        break;\n                    default:\n                        throw new JGitInternalException(\"Updating HEAD failed\");\n                }\n            }\n            FileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n            return new RebaseResult(Status.OK);\n        }\n        return new RebaseResult(Status.UP_TO_DATE);\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}"
    },
    {
      "commit": "6bca46e1683a07f18f00f6ad552eab79ab50bb88",
      "startLine": 7,
      "endLine": 17,
      "methodCode": "public RebaseResult call() throws NoHeadException, RefNotFoundException, JGitInternalException, GitAPIException {\n    RevCommit newHead = null;\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort();\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitName = readFile(rebaseDir, ONTO);\n                this.upstreamCommit = walk.parseCommit(repo.resolve(upstreamCommitName));\n                break;\n            case BEGIN:\n                RebaseResult res = initFilesAndRewind();\n                if (res != null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort();\n        if (this.operation == Operation.CONTINUE)\n            newHead = continueRebase();\n        List<Step> steps = loadSteps();\n        if (this.operation == Operation.SKIP && !steps.isEmpty())\n            checkoutCurrentHead();\n        ObjectReader or = repo.newObjectReader();\n        int stepsToPop = 0;\n        for (Step step : steps) {\n            if (step.action != Action.PICK)\n                continue;\n            popSteps(1);\n            Collection<ObjectId> ids = or.resolve(step.commit);\n            if (ids.size() != 1)\n                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n            RevCommit commitToPick = walk.parseCommit(ids.iterator().next());\n            if (monitor.isCancelled())\n                return new RebaseResult(commitToPick);\n            monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n            newHead = new Git(repo).cherryPick().include(commitToPick).call();\n            monitor.endTask();\n            if (newHead == null) {\n                return stop(commitToPick);\n            }\n            stepsToPop++;\n        }\n        if (newHead != null || steps.isEmpty()) {\n            String headName = readFile(rebaseDir, HEAD_NAME);\n            if (headName.startsWith(Constants.R_REFS)) {\n                RefUpdate rup = repo.updateRef(headName);\n                if (newHead != null) {\n                    rup.setNewObjectId(newHead);\n                    rup.forceUpdate();\n                }\n                rup = repo.updateRef(Constants.HEAD);\n                rup.link(headName);\n            }\n            if (this.operation == Operation.SKIP && steps.isEmpty()) {\n                checkoutCurrentHead();\n            }\n            FileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n            return new RebaseResult(Status.OK);\n        }\n        return new RebaseResult(Status.UP_TO_DATE);\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}"
    },
    {
      "commit": "45731756a56361a51e839e26d3b0bed1c06ee37a",
      "startLine": 6,
      "endLine": 16,
      "methodCode": "public RebaseResult call() throws NoHeadException, RefNotFoundException, JGitInternalException, GitAPIException {\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort();\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitName = readFile(rebaseDir, \"onto\");\n                this.upstreamCommit = walk.parseCommit(repo.resolve(upstreamCommitName));\n                break;\n            case BEGIN:\n                RebaseResult res = initFilesAndRewind();\n                if (res != null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort();\n        if (this.operation == Operation.CONTINUE)\n            throw new UnsupportedOperationException(\"--continue Not yet implemented\");\n        if (this.operation == Operation.SKIP)\n            throw new UnsupportedOperationException(\"--skip Not yet implemented\");\n        RevCommit newHead = null;\n        List<Step> steps = loadSteps();\n        ObjectReader or = repo.newObjectReader();\n        int stepsToPop = 0;\n        for (Step step : steps) {\n            if (step.action != Action.PICK)\n                continue;\n            popSteps(1);\n            Collection<ObjectId> ids = or.resolve(step.commit);\n            if (ids.size() != 1)\n                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n            RevCommit commitToPick = walk.parseCommit(ids.iterator().next());\n            if (monitor.isCancelled())\n                return new RebaseResult(commitToPick);\n            monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n            newHead = new Git(repo).cherryPick().include(commitToPick).call();\n            monitor.endTask();\n            if (newHead == null) {\n                return stop(commitToPick);\n            }\n            stepsToPop++;\n        }\n        if (newHead != null) {\n            String headName = readFile(rebaseDir, \"head-name\");\n            if (headName.startsWith(Constants.R_REFS)) {\n                RefUpdate rup = repo.updateRef(headName);\n                rup.setNewObjectId(newHead);\n                rup.forceUpdate();\n                rup = repo.updateRef(Constants.HEAD);\n                rup.link(headName);\n            }\n            FileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n            return new RebaseResult(Status.OK);\n        }\n        return new RebaseResult(Status.UP_TO_DATE);\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}"
    },
    {
      "commit": "ad96546ca023c260ed7250c447f4c8abe168afd3",
      "startLine": 6,
      "endLine": 16,
      "methodCode": "public RebaseResult call() throws NoHeadException, RefNotFoundException, JGitInternalException, GitAPIException {\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort();\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitName = readFile(rebaseDir, \"onto\");\n                this.upstreamCommit = walk.parseCommit(repo.resolve(upstreamCommitName));\n                break;\n            case BEGIN:\n                RebaseResult res = initFilesAndRewind();\n                if (res != null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort();\n        if (this.operation == Operation.CONTINUE)\n            throw new UnsupportedOperationException(\"--continue Not yet implemented\");\n        if (this.operation == Operation.SKIP)\n            throw new UnsupportedOperationException(\"--skip Not yet implemented\");\n        RevCommit newHead = null;\n        List<Step> steps = loadSteps();\n        ObjectReader or = repo.newObjectReader();\n        int stepsToPop = 0;\n        for (Step step : steps) {\n            if (step.action != Action.PICK)\n                continue;\n            popSteps(1);\n            Collection<ObjectId> ids = or.resolve(step.commit);\n            if (ids.size() != 1)\n                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n            RevCommit commitToPick = walk.parseCommit(ids.iterator().next());\n            if (monitor.isCancelled())\n                return new RebaseResult(commitToPick);\n            monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n            newHead = new Git(repo).cherryPick().include(commitToPick).call();\n            monitor.endTask();\n            if (newHead == null) {\n                return stop(commitToPick);\n            }\n            stepsToPop++;\n        }\n        if (newHead != null) {\n            String headName = readFile(rebaseDir, \"head-name\");\n            if (headName.startsWith(Constants.R_REFS)) {\n                RefUpdate rup = repo.updateRef(headName);\n                rup.setNewObjectId(newHead);\n                rup.forceUpdate();\n                rup = repo.updateRef(Constants.HEAD);\n                rup.link(headName);\n            }\n            deleteRecursive(rebaseDir);\n            return new RebaseResult(Status.OK);\n        }\n        return new RebaseResult(Status.UP_TO_DATE);\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}"
    },
    {
      "commit": "59e62ba7e10188c6170bd97ffbd9c8768d9745ea",
      "startLine": 6,
      "endLine": 16,
      "methodCode": "public RebaseResult call() throws NoHeadException, RefNotFoundException, JGitInternalException, GitAPIException {\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort();\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitName = readFile(rebaseDir, \"onto\");\n                this.upstreamCommit = walk.parseCommit(repo.resolve(upstreamCommitName));\n                break;\n            case BEGIN:\n                RebaseResult res = initFilesAndRewind();\n                if (res != null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort();\n        if (this.operation == Operation.CONTINUE)\n            throw new UnsupportedOperationException(\"--continue Not yet implemented\");\n        if (this.operation == Operation.SKIP)\n            throw new UnsupportedOperationException(\"--skip Not yet implemented\");\n        RevCommit newHead = null;\n        List<Step> steps = loadSteps();\n        ObjectReader or = repo.newObjectReader();\n        int stepsToPop = 0;\n        for (Step step : steps) {\n            if (step.action != Action.PICK)\n                continue;\n            popSteps(1);\n            Collection<ObjectId> ids = or.resolve(step.commit);\n            if (ids.size() != 1)\n                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n            RevCommit commitToPick = walk.parseCommit(ids.iterator().next());\n            if (monitor.isCancelled())\n                return new RebaseResult(commitToPick);\n            monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n            newHead = new Git(repo).cherryPick().include(commitToPick).call();\n            monitor.endTask();\n            if (newHead == null) {\n                return new RebaseResult(commitToPick);\n            }\n            stepsToPop++;\n        }\n        if (newHead != null) {\n            String headName = readFile(rebaseDir, \"head-name\");\n            if (headName.startsWith(Constants.R_REFS)) {\n                RefUpdate rup = repo.updateRef(headName);\n                rup.setNewObjectId(newHead);\n                rup.forceUpdate();\n                rup = repo.updateRef(Constants.HEAD);\n                rup.link(headName);\n            }\n            deleteRecursive(rebaseDir);\n            return new RebaseResult(Status.OK);\n        }\n        return new RebaseResult(Status.UP_TO_DATE);\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}"
    },
    {
      "commit": "e5b96a7848d680cf50123a44cbc147db91d798d3",
      "startLine": 6,
      "endLine": 16,
      "methodCode": "public RebaseResult call() throws NoHeadException, RefNotFoundException, JGitInternalException, GitAPIException {\n    checkCallable();\n    checkParameters();\n    try {\n        switch(operation) {\n            case ABORT:\n                try {\n                    return abort();\n                } catch (IOException ioe) {\n                    throw new JGitInternalException(ioe.getMessage(), ioe);\n                }\n            case SKIP:\n            case CONTINUE:\n                String upstreamCommitName = readFile(rebaseDir, \"onto\");\n                this.upstreamCommit = walk.parseCommit(repo.resolve(upstreamCommitName));\n                break;\n            case BEGIN:\n                RebaseResult res = initFilesAndRewind();\n                if (res != null)\n                    return res;\n        }\n        if (monitor.isCancelled())\n            return abort();\n        if (this.operation == Operation.CONTINUE)\n            throw new UnsupportedOperationException(\"--continue Not yet implemented\");\n        if (this.operation == Operation.SKIP)\n            throw new UnsupportedOperationException(\"--skip Not yet implemented\");\n        RevCommit newHead = null;\n        List<Step> steps = loadSteps();\n        ObjectReader or = repo.newObjectReader();\n        int stepsToPop = 0;\n        for (Step step : steps) {\n            if (step.action != Action.PICK)\n                continue;\n            Collection<ObjectId> ids = or.resolve(step.commit);\n            if (ids.size() != 1)\n                throw new JGitInternalException(\"Could not resolve uniquely the abbreviated object ID\");\n            RevCommit commitToPick = walk.parseCommit(ids.iterator().next());\n            if (monitor.isCancelled())\n                return new RebaseResult(commitToPick);\n            monitor.beginTask(MessageFormat.format(JGitText.get().applyingCommit, commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);\n            newHead = new Git(repo).cherryPick().include(commitToPick).call();\n            monitor.endTask();\n            if (newHead == null) {\n                popSteps(stepsToPop);\n                return new RebaseResult(commitToPick);\n            }\n            stepsToPop++;\n        }\n        if (newHead != null) {\n            String headName = readFile(rebaseDir, \"head-name\");\n            if (headName.startsWith(Constants.R_REFS)) {\n                RefUpdate rup = repo.updateRef(headName);\n                rup.setNewObjectId(newHead);\n                rup.forceUpdate();\n                rup = repo.updateRef(Constants.HEAD);\n                rup.link(headName);\n            }\n            deleteRecursive(rebaseDir);\n            return new RebaseResult(Status.OK);\n        }\n        return new RebaseResult(Status.UP_TO_DATE);\n    } catch (IOException ioe) {\n        throw new JGitInternalException(ioe.getMessage(), ioe);\n    }\n}"
    }
  ]
}