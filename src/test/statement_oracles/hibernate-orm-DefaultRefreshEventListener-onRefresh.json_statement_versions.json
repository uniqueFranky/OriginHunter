{
  "statementVersions": [
    {
      "commit": "12b79a59383d1b647c9957815ef53861f0752dad",
      "startLine": 24,
      "endLine": 28,
      "methodCode": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source = event.getSession();\n    boolean isTransient;\n    if (event.getEntityName() != null) {\n        isTransient = !source.contains(event.getEntityName(), event.getObject());\n    } else {\n        isTransient = !source.contains(event.getObject());\n    }\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n        if (isTransient) {\n            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n        }\n        return;\n    }\n    final Object object = source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        LOG.trace(\"Already refreshed\");\n        return;\n    }\n    final EntityEntry e = source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e == null) {\n        persister = source.getEntityPersister(event.getEntityName(), object);\n        id = persister.getIdentifier(object, event.getSession());\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing transient {0}\", MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n        final EntityKey key = source.generateEntityKey(id, persister);\n        if (source.getPersistenceContext().getEntry(key) != null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing \", MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        }\n        if (!e.isExistsInDatabase()) {\n            throw new UnresolvableObjectException(e.getId(), \"this instance does not yet exist as a row in the database\");\n        }\n        persister = e.getPersister();\n        id = e.getId();\n    }\n    refreshedAlready.put(object, object);\n    Cascade.cascade(CascadingActions.REFRESH, CascadePoint.BEFORE_REFRESH, source, persister, object, refreshedAlready);\n    if (e != null) {\n        final EntityKey key = source.generateEntityKey(id, persister);\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections()) {\n            new EvictVisitor(source, object).process(object, persister);\n        }\n    }\n    if (persister.canWriteToCache()) {\n        Object previousVersion = null;\n        if (persister.isVersionPropertyGenerated()) {\n            previousVersion = persister.getVersion(object);\n        }\n        final EntityDataAccess cache = persister.getCacheAccessStrategy();\n        final Object ck = cache.generateCacheKey(id, persister, source.getFactory(), source.getTenantIdentifier());\n        final SoftLock lock = cache.lockItem(source, ck, previousVersion);\n        cache.remove(source, ck);\n        source.getActionQueue().registerProcess((success, session) -> cache.unlockItem(session, ck, lock));\n    }\n    evictCachedCollections(persister, id, source);\n    String previousFetchProfile = source.getLoadQueryInfluencers().getInternalFetchProfile();\n    source.getLoadQueryInfluencers().setInternalFetchProfile(\"refresh\");\n    LockOptions lockOptionsToUse = event.getLockOptions();\n    final LockMode requestedLockMode = lockOptionsToUse.getLockMode();\n    LockMode postRefreshLockMode = null;\n    if (e != null) {\n        final LockMode currentLockMode = e.getLockMode();\n        if (currentLockMode.greaterThan(requestedLockMode)) {\n            lockOptionsToUse = LockOptions.copy(event.getLockOptions(), new LockOptions());\n            if (currentLockMode == LockMode.WRITE) {\n                lockOptionsToUse.setLockMode(LockMode.READ);\n                postRefreshLockMode = LockMode.WRITE;\n            } else {\n                lockOptionsToUse.setLockMode(currentLockMode);\n            }\n        }\n    }\n    final Object result = persister.load(id, object, lockOptionsToUse, source);\n    if (result != null) {\n        if (postRefreshLockMode != null) {\n            source.getPersistenceContext().getEntry(result).setLockMode(postRefreshLockMode);\n        }\n        if (!persister.isMutable()) {\n            source.setReadOnly(result, true);\n        } else {\n            source.setReadOnly(result, (e == null ? source.isDefaultReadOnly() : e.isReadOnly()));\n        }\n    }\n    source.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}"
    },
    {
      "commit": "a286232da374cbccefddbf406830dbb598b6c824",
      "startLine": 24,
      "endLine": 28,
      "methodCode": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source = event.getSession();\n    boolean isTransient;\n    if (event.getEntityName() != null) {\n        isTransient = !source.contains(event.getEntityName(), event.getObject());\n    } else {\n        isTransient = !source.contains(event.getObject());\n    }\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n        if (isTransient) {\n            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n        }\n        return;\n    }\n    final Object object = source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        LOG.trace(\"Already refreshed\");\n        return;\n    }\n    final EntityEntry e = source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e == null) {\n        persister = source.getEntityPersister(event.getEntityName(), object);\n        id = persister.getIdentifier(object, event.getSession());\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing transient {0}\", MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n        final EntityKey key = source.generateEntityKey(id, persister);\n        if (source.getPersistenceContext().getEntry(key) != null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing \", MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        }\n        if (!e.isExistsInDatabase()) {\n            throw new UnresolvableObjectException(e.getId(), \"this instance does not yet exist as a row in the database\");\n        }\n        persister = e.getPersister();\n        id = e.getId();\n    }\n    refreshedAlready.put(object, object);\n    Cascade.cascade(CascadingActions.REFRESH, CascadePoint.BEFORE_REFRESH, source, persister, object, refreshedAlready);\n    if (e != null) {\n        final EntityKey key = source.generateEntityKey(id, persister);\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections()) {\n            new EvictVisitor(source, object).process(object, persister);\n        }\n    }\n    if (persister.canWriteToCache()) {\n        Object previousVersion = null;\n        if (persister.isVersionPropertyGenerated()) {\n            previousVersion = persister.getVersion(object);\n        }\n        final EntityDataAccess cache = persister.getCacheAccessStrategy();\n        final Object ck = cache.generateCacheKey(id, persister, source.getFactory(), source.getTenantIdentifier());\n        final SoftLock lock = cache.lockItem(source, ck, previousVersion);\n        cache.remove(source, ck);\n        source.getActionQueue().registerProcess((success, session) -> cache.unlockItem(session, ck, lock));\n    }\n    evictCachedCollections(persister, id, source);\n    String previousFetchProfile = source.getLoadQueryInfluencers().getInternalFetchProfile();\n    source.getLoadQueryInfluencers().setInternalFetchProfile(\"refresh\");\n    final LockMode currentLockMode = e == null ? null : e.getLockMode();\n    LockOptions lockOptionsToUse = event.getLockOptions();\n    if (currentLockMode != null && currentLockMode.greaterThan(event.getLockMode())) {\n        lockOptionsToUse = LockOptions.copy(event.getLockOptions(), new LockOptions());\n        lockOptionsToUse.setLockMode(currentLockMode);\n    }\n    Object result = persister.load(id, object, lockOptionsToUse, source);\n    if (result != null) {\n        if (!persister.isMutable()) {\n            source.setReadOnly(result, true);\n        } else {\n            source.setReadOnly(result, (e == null ? source.isDefaultReadOnly() : e.isReadOnly()));\n        }\n    }\n    source.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}"
    },
    {
      "commit": "f432ecea687ce606144c8fca1f4fc7f1937e1c2a",
      "startLine": 24,
      "endLine": 28,
      "methodCode": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source = event.getSession();\n    boolean isTransient;\n    if (event.getEntityName() != null) {\n        isTransient = !source.contains(event.getEntityName(), event.getObject());\n    } else {\n        isTransient = !source.contains(event.getObject());\n    }\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n        if (isTransient) {\n            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n        }\n        return;\n    }\n    final Object object = source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        LOG.trace(\"Already refreshed\");\n        return;\n    }\n    final EntityEntry e = source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e == null) {\n        persister = source.getEntityPersister(event.getEntityName(), object);\n        id = persister.getIdentifier(object, event.getSession());\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing transient {0}\", MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n        final EntityKey key = source.generateEntityKey(id, persister);\n        if (source.getPersistenceContext().getEntry(key) != null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing \", MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        }\n        if (!e.isExistsInDatabase()) {\n            throw new UnresolvableObjectException(e.getId(), \"this instance does not yet exist as a row in the database\");\n        }\n        persister = e.getPersister();\n        id = e.getId();\n    }\n    refreshedAlready.put(object, object);\n    Cascade.cascade(CascadingActions.REFRESH, CascadePoint.BEFORE_REFRESH, source, persister, object, refreshedAlready);\n    if (e != null) {\n        final EntityKey key = source.generateEntityKey(id, persister);\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections()) {\n            new EvictVisitor(source, object).process(object, persister);\n        }\n    }\n    if (persister.canWriteToCache()) {\n        Object previousVersion = null;\n        if (persister.isVersionPropertyGenerated()) {\n            previousVersion = persister.getVersion(object);\n        }\n        final EntityDataAccess cache = persister.getCacheAccessStrategy();\n        final Object ck = cache.generateCacheKey(id, persister, source.getFactory(), source.getTenantIdentifier());\n        final SoftLock lock = cache.lockItem(source, ck, previousVersion);\n        cache.remove(source, ck);\n        source.getActionQueue().registerProcess((success, session) -> cache.unlockItem(session, ck, lock));\n    }\n    evictCachedCollections(persister, id, source);\n    String previousFetchProfile = source.getLoadQueryInfluencers().getInternalFetchProfile();\n    source.getLoadQueryInfluencers().setInternalFetchProfile(\"refresh\");\n    Object result = persister.load(id, object, event.getLockOptions(), source);\n    if (result != null) {\n        if (!persister.isMutable()) {\n            source.setReadOnly(result, true);\n        } else {\n            source.setReadOnly(result, (e == null ? source.isDefaultReadOnly() : e.isReadOnly()));\n        }\n    }\n    source.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}"
    },
    {
      "commit": "684cfe6383e100b8eefcc7a5439f0d9ce700ea4b",
      "startLine": 24,
      "endLine": 28,
      "methodCode": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source = event.getSession();\n    boolean isTransient;\n    if (event.getEntityName() != null) {\n        isTransient = !source.contains(event.getEntityName(), event.getObject());\n    } else {\n        isTransient = !source.contains(event.getObject());\n    }\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n        if (isTransient) {\n            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n        }\n        return;\n    }\n    final Object object = source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        LOG.trace(\"Already refreshed\");\n        return;\n    }\n    final EntityEntry e = source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e == null) {\n        persister = source.getEntityPersister(event.getEntityName(), object);\n        id = persister.getIdentifier(object, event.getSession());\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing transient {0}\", MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n        final EntityKey key = source.generateEntityKey(id, persister);\n        if (source.getPersistenceContext().getEntry(key) != null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing \", MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        }\n        if (!e.isExistsInDatabase()) {\n            throw new UnresolvableObjectException(e.getId(), \"this instance does not yet exist as a row in the database\");\n        }\n        persister = e.getPersister();\n        id = e.getId();\n    }\n    refreshedAlready.put(object, object);\n    Cascade.cascade(CascadingActions.REFRESH, CascadePoint.BEFORE_REFRESH, source, persister, object, refreshedAlready);\n    if (e != null) {\n        final EntityKey key = source.generateEntityKey(id, persister);\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections()) {\n            new EvictVisitor(source, object).process(object, persister);\n        }\n    }\n    if (persister.canWriteToCache()) {\n        Object previousVersion = null;\n        if (persister.isVersionPropertyGenerated()) {\n            previousVersion = persister.getVersion(object);\n        }\n        final EntityRegionAccessStrategy cache = persister.getCacheAccessStrategy();\n        final Object ck = cache.generateCacheKey(id, persister, source.getFactory(), source.getTenantIdentifier());\n        final SoftLock lock = cache.lockItem(source, ck, previousVersion);\n        source.getActionQueue().registerProcess(new AfterTransactionCompletionProcess() {\n\n            @Override\n            public void doAfterTransactionCompletion(boolean success, SharedSessionContractImplementor session) {\n                cache.unlockItem(session, ck, lock);\n            }\n        });\n        cache.remove(source, ck);\n    }\n    evictCachedCollections(persister, id, source);\n    String previousFetchProfile = source.getLoadQueryInfluencers().getInternalFetchProfile();\n    source.getLoadQueryInfluencers().setInternalFetchProfile(\"refresh\");\n    Object result = persister.load(id, object, event.getLockOptions(), source);\n    if (result != null) {\n        if (!persister.isMutable()) {\n            source.setReadOnly(result, true);\n        } else {\n            source.setReadOnly(result, (e == null ? source.isDefaultReadOnly() : e.isReadOnly()));\n        }\n    }\n    source.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}"
    },
    {
      "commit": "59c3baae3271247bed516fe50952b65be1a27e5b",
      "startLine": 24,
      "endLine": 28,
      "methodCode": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source = event.getSession();\n    boolean isTransient;\n    if (event.getEntityName() != null) {\n        isTransient = !source.contains(event.getEntityName(), event.getObject());\n    } else {\n        isTransient = !source.contains(event.getObject());\n    }\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n        if (isTransient) {\n            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n        }\n        return;\n    }\n    final Object object = source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        LOG.trace(\"Already refreshed\");\n        return;\n    }\n    final EntityEntry e = source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e == null) {\n        persister = source.getEntityPersister(event.getEntityName(), object);\n        id = persister.getIdentifier(object, event.getSession());\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing transient {0}\", MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n        final EntityKey key = source.generateEntityKey(id, persister);\n        if (source.getPersistenceContext().getEntry(key) != null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing \", MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        }\n        if (!e.isExistsInDatabase()) {\n            throw new UnresolvableObjectException(e.getId(), \"this instance does not yet exist as a row in the database\");\n        }\n        persister = e.getPersister();\n        id = e.getId();\n    }\n    refreshedAlready.put(object, object);\n    Cascade.cascade(CascadingActions.REFRESH, CascadePoint.BEFORE_REFRESH, source, persister, object, refreshedAlready);\n    if (e != null) {\n        final EntityKey key = source.generateEntityKey(id, persister);\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections()) {\n            new EvictVisitor(source).process(object, persister);\n        }\n    }\n    if (persister.canWriteToCache()) {\n        Object previousVersion = null;\n        if (persister.isVersionPropertyGenerated()) {\n            previousVersion = persister.getVersion(object);\n        }\n        final EntityRegionAccessStrategy cache = persister.getCacheAccessStrategy();\n        final Object ck = cache.generateCacheKey(id, persister, source.getFactory(), source.getTenantIdentifier());\n        final SoftLock lock = cache.lockItem(source, ck, previousVersion);\n        source.getActionQueue().registerProcess(new AfterTransactionCompletionProcess() {\n\n            @Override\n            public void doAfterTransactionCompletion(boolean success, SharedSessionContractImplementor session) {\n                cache.unlockItem(session, ck, lock);\n            }\n        });\n        cache.remove(source, ck);\n    }\n    evictCachedCollections(persister, id, source);\n    String previousFetchProfile = source.getLoadQueryInfluencers().getInternalFetchProfile();\n    source.getLoadQueryInfluencers().setInternalFetchProfile(\"refresh\");\n    Object result = persister.load(id, object, event.getLockOptions(), source);\n    if (result != null) {\n        if (!persister.isMutable()) {\n            source.setReadOnly(result, true);\n        } else {\n            source.setReadOnly(result, (e == null ? source.isDefaultReadOnly() : e.isReadOnly()));\n        }\n    }\n    source.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}"
    },
    {
      "commit": "cc5a13a3f007fad6067945e0bb011d902ba9b6f4",
      "startLine": 24,
      "endLine": 28,
      "methodCode": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source = event.getSession();\n    boolean isTransient;\n    if (event.getEntityName() != null) {\n        isTransient = !source.contains(event.getEntityName(), event.getObject());\n    } else {\n        isTransient = !source.contains(event.getObject());\n    }\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n        if (isTransient) {\n            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n        }\n        return;\n    }\n    final Object object = source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        LOG.trace(\"Already refreshed\");\n        return;\n    }\n    final EntityEntry e = source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e == null) {\n        persister = source.getEntityPersister(event.getEntityName(), object);\n        id = persister.getIdentifier(object, event.getSession());\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing transient {0}\", MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n        final EntityKey key = source.generateEntityKey(id, persister);\n        if (source.getPersistenceContext().getEntry(key) != null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing \", MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        }\n        if (!e.isExistsInDatabase()) {\n            throw new UnresolvableObjectException(e.getId(), \"this instance does not yet exist as a row in the database\");\n        }\n        persister = e.getPersister();\n        id = e.getId();\n    }\n    refreshedAlready.put(object, object);\n    Cascade.cascade(CascadingActions.REFRESH, CascadePoint.BEFORE_REFRESH, source, persister, object, refreshedAlready);\n    if (e != null) {\n        final EntityKey key = source.generateEntityKey(id, persister);\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections()) {\n            new EvictVisitor(source).process(object, persister);\n        }\n    }\n    if (persister.hasCache()) {\n        Object previousVersion = null;\n        if (persister.isVersionPropertyGenerated()) {\n            previousVersion = persister.getVersion(object);\n        }\n        final EntityRegionAccessStrategy cache = persister.getCacheAccessStrategy();\n        final Object ck = cache.generateCacheKey(id, persister, source.getFactory(), source.getTenantIdentifier());\n        final SoftLock lock = cache.lockItem(source, ck, previousVersion);\n        source.getActionQueue().registerProcess(new AfterTransactionCompletionProcess() {\n\n            @Override\n            public void doAfterTransactionCompletion(boolean success, SharedSessionContractImplementor session) {\n                cache.unlockItem(session, ck, lock);\n            }\n        });\n        cache.remove(source, ck);\n    }\n    evictCachedCollections(persister, id, source);\n    String previousFetchProfile = source.getLoadQueryInfluencers().getInternalFetchProfile();\n    source.getLoadQueryInfluencers().setInternalFetchProfile(\"refresh\");\n    Object result = persister.load(id, object, event.getLockOptions(), source);\n    if (result != null) {\n        if (!persister.isMutable()) {\n            source.setReadOnly(result, true);\n        } else {\n            source.setReadOnly(result, (e == null ? source.isDefaultReadOnly() : e.isReadOnly()));\n        }\n    }\n    source.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}"
    },
    {
      "commit": "8c9152040c469a096cd78b18234a66c973d5e07e",
      "startLine": 19,
      "endLine": 23,
      "methodCode": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source = event.getSession();\n    boolean isTransient = !source.contains(event.getObject());\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n        if (isTransient) {\n            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n        }\n        return;\n    }\n    final Object object = source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        LOG.trace(\"Already refreshed\");\n        return;\n    }\n    final EntityEntry e = source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e == null) {\n        persister = source.getEntityPersister(event.getEntityName(), object);\n        id = persister.getIdentifier(object, event.getSession());\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing transient {0}\", MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n        final EntityKey key = source.generateEntityKey(id, persister);\n        if (source.getPersistenceContext().getEntry(key) != null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing \", MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        }\n        if (!e.isExistsInDatabase()) {\n            throw new UnresolvableObjectException(e.getId(), \"this instance does not yet exist as a row in the database\");\n        }\n        persister = e.getPersister();\n        id = e.getId();\n    }\n    refreshedAlready.put(object, object);\n    Cascade.cascade(CascadingActions.REFRESH, CascadePoint.BEFORE_REFRESH, source, persister, object, refreshedAlready);\n    if (e != null) {\n        final EntityKey key = source.generateEntityKey(id, persister);\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections()) {\n            new EvictVisitor(source).process(object, persister);\n        }\n    }\n    if (persister.hasCache()) {\n        Object previousVersion = null;\n        if (persister.isVersionPropertyGenerated()) {\n            previousVersion = persister.getVersion(object);\n        }\n        final EntityRegionAccessStrategy cache = persister.getCacheAccessStrategy();\n        final Object ck = cache.generateCacheKey(id, persister, source.getFactory(), source.getTenantIdentifier());\n        final SoftLock lock = cache.lockItem(source, ck, previousVersion);\n        source.getActionQueue().registerProcess(new AfterTransactionCompletionProcess() {\n\n            @Override\n            public void doAfterTransactionCompletion(boolean success, SharedSessionContractImplementor session) {\n                cache.unlockItem(session, ck, lock);\n            }\n        });\n        cache.remove(source, ck);\n    }\n    evictCachedCollections(persister, id, source);\n    String previousFetchProfile = source.getLoadQueryInfluencers().getInternalFetchProfile();\n    source.getLoadQueryInfluencers().setInternalFetchProfile(\"refresh\");\n    Object result = persister.load(id, object, event.getLockOptions(), source);\n    if (result != null) {\n        if (!persister.isMutable()) {\n            source.setReadOnly(result, true);\n        } else {\n            source.setReadOnly(result, (e == null ? source.isDefaultReadOnly() : e.isReadOnly()));\n        }\n    }\n    source.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}"
    },
    {
      "commit": "cbdab9d87f05b4255c7930a32fe995f87f0f3e0b",
      "startLine": 19,
      "endLine": 23,
      "methodCode": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source = event.getSession();\n    boolean isTransient = !source.contains(event.getObject());\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n        if (isTransient) {\n            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n        }\n        return;\n    }\n    final Object object = source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        LOG.trace(\"Already refreshed\");\n        return;\n    }\n    final EntityEntry e = source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e == null) {\n        persister = source.getEntityPersister(event.getEntityName(), object);\n        id = persister.getIdentifier(object, event.getSession());\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing transient {0}\", MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n        final EntityKey key = source.generateEntityKey(id, persister);\n        if (source.getPersistenceContext().getEntry(key) != null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing \", MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        }\n        if (!e.isExistsInDatabase()) {\n            throw new UnresolvableObjectException(e.getId(), \"this instance does not yet exist as a row in the database\");\n        }\n        persister = e.getPersister();\n        id = e.getId();\n    }\n    refreshedAlready.put(object, object);\n    Cascade.cascade(CascadingActions.REFRESH, CascadePoint.BEFORE_REFRESH, source, persister, object, refreshedAlready);\n    if (e != null) {\n        final EntityKey key = source.generateEntityKey(id, persister);\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections()) {\n            new EvictVisitor(source).process(object, persister);\n        }\n    }\n    if (persister.hasCache()) {\n        Object previousVersion = null;\n        if (persister.isVersionPropertyGenerated()) {\n            previousVersion = persister.getVersion(object);\n        }\n        final EntityRegionAccessStrategy cache = persister.getCacheAccessStrategy();\n        final Object ck = cache.generateCacheKey(id, persister, source.getFactory(), source.getTenantIdentifier());\n        final SoftLock lock = cache.lockItem(source, ck, previousVersion);\n        source.getActionQueue().registerProcess(new AfterTransactionCompletionProcess() {\n\n            @Override\n            public void doAfterTransactionCompletion(boolean success, SessionImplementor session) {\n                cache.unlockItem(session, ck, lock);\n            }\n        });\n        cache.remove(source, ck);\n    }\n    evictCachedCollections(persister, id, source);\n    String previousFetchProfile = source.getLoadQueryInfluencers().getInternalFetchProfile();\n    source.getLoadQueryInfluencers().setInternalFetchProfile(\"refresh\");\n    Object result = persister.load(id, object, event.getLockOptions(), source);\n    if (result != null) {\n        if (!persister.isMutable()) {\n            source.setReadOnly(result, true);\n        } else {\n            source.setReadOnly(result, (e == null ? source.isDefaultReadOnly() : e.isReadOnly()));\n        }\n    }\n    source.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}"
    },
    {
      "commit": "cffe71aeba38977f526b5ce7e870609ea419471c",
      "startLine": 19,
      "endLine": 23,
      "methodCode": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source = event.getSession();\n    boolean isTransient = !source.contains(event.getObject());\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n        if (isTransient) {\n            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n        }\n        return;\n    }\n    final Object object = source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        LOG.trace(\"Already refreshed\");\n        return;\n    }\n    final EntityEntry e = source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e == null) {\n        persister = source.getEntityPersister(event.getEntityName(), object);\n        id = persister.getIdentifier(object, event.getSession());\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing transient {0}\", MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n        final EntityKey key = source.generateEntityKey(id, persister);\n        if (source.getPersistenceContext().getEntry(key) != null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing \", MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        }\n        if (!e.isExistsInDatabase()) {\n            throw new UnresolvableObjectException(e.getId(), \"this instance does not yet exist as a row in the database\");\n        }\n        persister = e.getPersister();\n        id = e.getId();\n    }\n    refreshedAlready.put(object, object);\n    Cascade.cascade(CascadingActions.REFRESH, CascadePoint.BEFORE_REFRESH, source, persister, object, refreshedAlready);\n    if (e != null) {\n        final EntityKey key = source.generateEntityKey(id, persister);\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections()) {\n            new EvictVisitor(source).process(object, persister);\n        }\n    }\n    if (persister.hasCache()) {\n        final EntityRegionAccessStrategy cache = persister.getCacheAccessStrategy();\n        Object ck = cache.generateCacheKey(id, persister, source.getFactory(), source.getTenantIdentifier());\n        cache.evict(ck);\n    }\n    evictCachedCollections(persister, id, source.getFactory());\n    String previousFetchProfile = source.getLoadQueryInfluencers().getInternalFetchProfile();\n    source.getLoadQueryInfluencers().setInternalFetchProfile(\"refresh\");\n    Object result = persister.load(id, object, event.getLockOptions(), source);\n    if (result != null) {\n        if (!persister.isMutable()) {\n            source.setReadOnly(result, true);\n        } else {\n            source.setReadOnly(result, (e == null ? source.isDefaultReadOnly() : e.isReadOnly()));\n        }\n    }\n    source.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}"
    },
    {
      "commit": "16ae00a53a9c58c841eb1dea8eb36354d5f3ff0f",
      "startLine": 19,
      "endLine": 23,
      "methodCode": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source = event.getSession();\n    boolean isTransient = !source.contains(event.getObject());\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n        if (isTransient) {\n            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n        }\n        return;\n    }\n    final Object object = source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        LOG.trace(\"Already refreshed\");\n        return;\n    }\n    final EntityEntry e = source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e == null) {\n        persister = source.getEntityPersister(event.getEntityName(), object);\n        id = persister.getIdentifier(object, event.getSession());\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing transient {0}\", MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n        final EntityKey key = source.generateEntityKey(id, persister);\n        if (source.getPersistenceContext().getEntry(key) != null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing \", MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        }\n        if (!e.isExistsInDatabase()) {\n            throw new UnresolvableObjectException(e.getId(), \"this instance does not yet exist as a row in the database\");\n        }\n        persister = e.getPersister();\n        id = e.getId();\n    }\n    refreshedAlready.put(object, object);\n    Cascade.cascade(CascadingActions.REFRESH, CascadePoint.BEFORE_REFRESH, source, persister, object, refreshedAlready);\n    if (e != null) {\n        final EntityKey key = source.generateEntityKey(id, persister);\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections()) {\n            new EvictVisitor(source).process(object, persister);\n        }\n    }\n    if (persister.hasCache()) {\n        final EntityRegionAccessStrategy cache = persister.getCacheAccessStrategy();\n        EntityCacheKey ck = cache.generateCacheKey(id, persister, source.getFactory(), source.getTenantIdentifier());\n        cache.evict(ck);\n    }\n    evictCachedCollections(persister, id, source.getFactory());\n    String previousFetchProfile = source.getLoadQueryInfluencers().getInternalFetchProfile();\n    source.getLoadQueryInfluencers().setInternalFetchProfile(\"refresh\");\n    Object result = persister.load(id, object, event.getLockOptions(), source);\n    if (result != null) {\n        if (!persister.isMutable()) {\n            source.setReadOnly(result, true);\n        } else {\n            source.setReadOnly(result, (e == null ? source.isDefaultReadOnly() : e.isReadOnly()));\n        }\n    }\n    source.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}"
    },
    {
      "commit": "fb15ee548ca1c8fb80f77497271931404f54c19e",
      "startLine": 19,
      "endLine": 23,
      "methodCode": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source = event.getSession();\n    boolean isTransient = !source.contains(event.getObject());\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n        if (isTransient) {\n            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n        }\n        return;\n    }\n    final Object object = source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        LOG.trace(\"Already refreshed\");\n        return;\n    }\n    final EntityEntry e = source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e == null) {\n        persister = source.getEntityPersister(event.getEntityName(), object);\n        id = persister.getIdentifier(object, event.getSession());\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing transient {0}\", MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n        final EntityKey key = source.generateEntityKey(id, persister);\n        if (source.getPersistenceContext().getEntry(key) != null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing \", MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        }\n        if (!e.isExistsInDatabase()) {\n            throw new UnresolvableObjectException(e.getId(), \"this instance does not yet exist as a row in the database\");\n        }\n        persister = e.getPersister();\n        id = e.getId();\n    }\n    refreshedAlready.put(object, object);\n    Cascade.cascade(CascadingActions.REFRESH, CascadePoint.BEFORE_REFRESH, source, persister, object, refreshedAlready);\n    if (e != null) {\n        final EntityKey key = source.generateEntityKey(id, persister);\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections()) {\n            new EvictVisitor(source).process(object, persister);\n        }\n    }\n    if (persister.hasCache()) {\n        final CacheKey ck = source.generateCacheKey(id, persister.getIdentifierType(), persister.getRootEntityName());\n        persister.getCacheAccessStrategy().evict(ck);\n    }\n    evictCachedCollections(persister, id, source.getFactory());\n    String previousFetchProfile = source.getLoadQueryInfluencers().getInternalFetchProfile();\n    source.getLoadQueryInfluencers().setInternalFetchProfile(\"refresh\");\n    Object result = persister.load(id, object, event.getLockOptions(), source);\n    if (result != null) {\n        if (!persister.isMutable()) {\n            source.setReadOnly(result, true);\n        } else {\n            source.setReadOnly(result, (e == null ? source.isDefaultReadOnly() : e.isReadOnly()));\n        }\n    }\n    source.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}"
    },
    {
      "commit": "241868e1dd4e9b31a0d03d2e0de2b8684b4f80fc",
      "startLine": 19,
      "endLine": 23,
      "methodCode": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source = event.getSession();\n    boolean isTransient = !source.contains(event.getObject());\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n        if (isTransient) {\n            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n        }\n        return;\n    }\n    final Object object = source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        LOG.trace(\"Already refreshed\");\n        return;\n    }\n    final EntityEntry e = source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e == null) {\n        persister = source.getEntityPersister(event.getEntityName(), object);\n        id = persister.getIdentifier(object, event.getSession());\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing transient {0}\", MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n        final EntityKey key = source.generateEntityKey(id, persister);\n        if (source.getPersistenceContext().getEntry(key) != null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing \", MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        }\n        if (!e.isExistsInDatabase()) {\n            throw new UnresolvableObjectException(e.getId(), \"this instance does not yet exist as a row in the database\");\n        }\n        persister = e.getPersister();\n        id = e.getId();\n    }\n    refreshedAlready.put(object, object);\n    new Cascade(CascadingActions.REFRESH, CascadePoint.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n    if (e != null) {\n        final EntityKey key = source.generateEntityKey(id, persister);\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections()) {\n            new EvictVisitor(source).process(object, persister);\n        }\n    }\n    if (persister.hasCache()) {\n        final CacheKey ck = source.generateCacheKey(id, persister.getIdentifierType(), persister.getRootEntityName());\n        persister.getCacheAccessStrategy().evict(ck);\n    }\n    evictCachedCollections(persister, id, source.getFactory());\n    String previousFetchProfile = source.getLoadQueryInfluencers().getInternalFetchProfile();\n    source.getLoadQueryInfluencers().setInternalFetchProfile(\"refresh\");\n    Object result = persister.load(id, object, event.getLockOptions(), source);\n    if (result != null) {\n        if (!persister.isMutable()) {\n            source.setReadOnly(result, true);\n        } else {\n            source.setReadOnly(result, (e == null ? source.isDefaultReadOnly() : e.isReadOnly()));\n        }\n    }\n    source.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}"
    },
    {
      "commit": "4428464d096c6a1fff3023cb707a2384ab6c0ffb",
      "startLine": 19,
      "endLine": 23,
      "methodCode": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source = event.getSession();\n    boolean isTransient = !source.contains(event.getObject());\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n        if (isTransient) {\n            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n        }\n        return;\n    }\n    final Object object = source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        LOG.trace(\"Already refreshed\");\n        return;\n    }\n    final EntityEntry e = source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e == null) {\n        persister = source.getEntityPersister(event.getEntityName(), object);\n        id = persister.getIdentifier(object, event.getSession());\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing transient {0}\", MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n        final EntityKey key = source.generateEntityKey(id, persister);\n        if (source.getPersistenceContext().getEntry(key) != null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing \", MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        }\n        if (!e.isExistsInDatabase()) {\n            throw new UnresolvableObjectException(e.getId(), \"this instance does not yet exist as a row in the database\");\n        }\n        persister = e.getPersister();\n        id = e.getId();\n    }\n    refreshedAlready.put(object, object);\n    new Cascade(CascadingActions.REFRESH, CascadePoint.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n    if (e != null) {\n        final EntityKey key = source.generateEntityKey(id, persister);\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections())\n            new EvictVisitor(source).process(object, persister);\n    }\n    if (persister.hasCache()) {\n        final CacheKey ck = source.generateCacheKey(id, persister.getIdentifierType(), persister.getRootEntityName());\n        persister.getCacheAccessStrategy().evict(ck);\n    }\n    evictCachedCollections(persister, id, source.getFactory());\n    String previousFetchProfile = source.getLoadQueryInfluencers().getInternalFetchProfile();\n    source.getLoadQueryInfluencers().setInternalFetchProfile(\"refresh\");\n    Object result = persister.load(id, object, event.getLockOptions(), source);\n    if (result != null) {\n        if (!persister.isMutable()) {\n            source.setReadOnly(result, true);\n        } else {\n            source.setReadOnly(result, (e == null ? source.isDefaultReadOnly() : e.isReadOnly()));\n        }\n    }\n    source.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}"
    },
    {
      "commit": "fc02da1c12f6a7487b56e76cf817dc72da8314e6",
      "startLine": 19,
      "endLine": 23,
      "methodCode": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source = event.getSession();\n    boolean isTransient = !source.contains(event.getObject());\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n        if (isTransient) {\n            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n        }\n        return;\n    }\n    final Object object = source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        LOG.trace(\"Already refreshed\");\n        return;\n    }\n    final EntityEntry e = source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e == null) {\n        persister = source.getEntityPersister(event.getEntityName(), object);\n        id = persister.getIdentifier(object, event.getSession());\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing transient {0}\", MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n        final EntityKey key = source.generateEntityKey(id, persister);\n        if (source.getPersistenceContext().getEntry(key) != null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing \", MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        }\n        if (!e.isExistsInDatabase()) {\n            throw new HibernateException(\"this instance does not yet exist as a row in the database\");\n        }\n        persister = e.getPersister();\n        id = e.getId();\n    }\n    refreshedAlready.put(object, object);\n    new Cascade(CascadingActions.REFRESH, CascadePoint.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n    if (e != null) {\n        final EntityKey key = source.generateEntityKey(id, persister);\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections())\n            new EvictVisitor(source).process(object, persister);\n    }\n    if (persister.hasCache()) {\n        final CacheKey ck = source.generateCacheKey(id, persister.getIdentifierType(), persister.getRootEntityName());\n        persister.getCacheAccessStrategy().evict(ck);\n    }\n    evictCachedCollections(persister, id, source.getFactory());\n    String previousFetchProfile = source.getLoadQueryInfluencers().getInternalFetchProfile();\n    source.getLoadQueryInfluencers().setInternalFetchProfile(\"refresh\");\n    Object result = persister.load(id, object, event.getLockOptions(), source);\n    if (result != null) {\n        if (!persister.isMutable()) {\n            source.setReadOnly(result, true);\n        } else {\n            source.setReadOnly(result, (e == null ? source.isDefaultReadOnly() : e.isReadOnly()));\n        }\n    }\n    source.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}"
    },
    {
      "commit": "6b5a428b3fed930227ae6a17e3b876c07745d5a3",
      "startLine": 19,
      "endLine": 23,
      "methodCode": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source = event.getSession();\n    boolean isTransient = !source.contains(event.getObject());\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n        if (isTransient) {\n            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n        }\n        return;\n    }\n    final Object object = source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        LOG.trace(\"Already refreshed\");\n        return;\n    }\n    final EntityEntry e = source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e == null) {\n        persister = source.getEntityPersister(event.getEntityName(), object);\n        id = persister.getIdentifier(object, event.getSession());\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing transient {0}\", MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n        final EntityKey key = source.generateEntityKey(id, persister);\n        if (source.getPersistenceContext().getEntry(key) != null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing \", MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        }\n        if (!e.isExistsInDatabase()) {\n            throw new HibernateException(\"this instance does not yet exist as a row in the database\");\n        }\n        persister = e.getPersister();\n        id = e.getId();\n    }\n    refreshedAlready.put(object, object);\n    new Cascade(CascadingActions.REFRESH, Cascade.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n    if (e != null) {\n        final EntityKey key = source.generateEntityKey(id, persister);\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections())\n            new EvictVisitor(source).process(object, persister);\n    }\n    if (persister.hasCache()) {\n        final CacheKey ck = source.generateCacheKey(id, persister.getIdentifierType(), persister.getRootEntityName());\n        persister.getCacheAccessStrategy().evict(ck);\n    }\n    evictCachedCollections(persister, id, source.getFactory());\n    String previousFetchProfile = source.getLoadQueryInfluencers().getInternalFetchProfile();\n    source.getLoadQueryInfluencers().setInternalFetchProfile(\"refresh\");\n    Object result = persister.load(id, object, event.getLockOptions(), source);\n    if (result != null) {\n        if (!persister.isMutable()) {\n            source.setReadOnly(result, true);\n        } else {\n            source.setReadOnly(result, (e == null ? source.isDefaultReadOnly() : e.isReadOnly()));\n        }\n    }\n    source.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}"
    },
    {
      "commit": "129c0f13482b99e2705f0e234b6bc0572a95c271",
      "startLine": 19,
      "endLine": 23,
      "methodCode": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source = event.getSession();\n    boolean isTransient = !source.contains(event.getObject());\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n        if (isTransient) {\n            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n        }\n        return;\n    }\n    final Object object = source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        LOG.trace(\"Already refreshed\");\n        return;\n    }\n    final EntityEntry e = source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e == null) {\n        persister = source.getEntityPersister(event.getEntityName(), object);\n        id = persister.getIdentifier(object, event.getSession());\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing transient {0}\", MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n        final EntityKey key = source.generateEntityKey(id, persister);\n        if (source.getPersistenceContext().getEntry(key) != null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing \", MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        }\n        if (!e.isExistsInDatabase()) {\n            throw new HibernateException(\"this instance does not yet exist as a row in the database\");\n        }\n        persister = e.getPersister();\n        id = e.getId();\n    }\n    refreshedAlready.put(object, object);\n    new Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n    if (e != null) {\n        final EntityKey key = source.generateEntityKey(id, persister);\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections())\n            new EvictVisitor(source).process(object, persister);\n    }\n    if (persister.hasCache()) {\n        final CacheKey ck = source.generateCacheKey(id, persister.getIdentifierType(), persister.getRootEntityName());\n        persister.getCacheAccessStrategy().evict(ck);\n    }\n    evictCachedCollections(persister, id, source.getFactory());\n    String previousFetchProfile = source.getLoadQueryInfluencers().getInternalFetchProfile();\n    source.getLoadQueryInfluencers().setInternalFetchProfile(\"refresh\");\n    Object result = persister.load(id, object, event.getLockOptions(), source);\n    if (result != null) {\n        if (!persister.isMutable()) {\n            source.setReadOnly(result, true);\n        } else {\n            source.setReadOnly(result, (e == null ? source.isDefaultReadOnly() : e.isReadOnly()));\n        }\n    }\n    source.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}"
    },
    {
      "commit": "625d781af1ec2ae0c03d3db5b4f4832a8c61d8e9",
      "startLine": 19,
      "endLine": 22,
      "methodCode": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source = event.getSession();\n    boolean isTransient = !source.contains(event.getObject());\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n        if (isTransient) {\n            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n        }\n        return;\n    }\n    final Object object = source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        LOG.trace(\"Already refreshed\");\n        return;\n    }\n    final EntityEntry e = source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e == null) {\n        persister = source.getEntityPersister(event.getEntityName(), object);\n        id = persister.getIdentifier(object, event.getSession());\n        if (LOG.isTraceEnabled())\n            LOG.trace(\"Refreshing transient \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        final EntityKey key = source.generateEntityKey(id, persister);\n        if (source.getPersistenceContext().getEntry(key) != null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (LOG.isTraceEnabled())\n            LOG.trace(\"Refreshing \" + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        if (!e.isExistsInDatabase()) {\n            throw new HibernateException(\"this instance does not yet exist as a row in the database\");\n        }\n        persister = e.getPersister();\n        id = e.getId();\n    }\n    refreshedAlready.put(object, object);\n    new Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n    if (e != null) {\n        final EntityKey key = source.generateEntityKey(id, persister);\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections())\n            new EvictVisitor(source).process(object, persister);\n    }\n    if (persister.hasCache()) {\n        final CacheKey ck = source.generateCacheKey(id, persister.getIdentifierType(), persister.getRootEntityName());\n        persister.getCacheAccessStrategy().evict(ck);\n    }\n    evictCachedCollections(persister, id, source.getFactory());\n    String previousFetchProfile = source.getLoadQueryInfluencers().getInternalFetchProfile();\n    source.getLoadQueryInfluencers().setInternalFetchProfile(\"refresh\");\n    Object result = persister.load(id, object, event.getLockOptions(), source);\n    if (result != null) {\n        if (!persister.isMutable()) {\n            source.setReadOnly(result, true);\n        } else {\n            source.setReadOnly(result, (e == null ? source.isDefaultReadOnly() : e.isReadOnly()));\n        }\n    }\n    source.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}"
    },
    {
      "commit": "eb5bc1609d28dc740a249e622850a3b3b15b5ace",
      "startLine": 19,
      "endLine": 22,
      "methodCode": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source = event.getSession();\n    boolean isTransient = !source.contains(event.getObject());\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n        if (isTransient) {\n            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n        }\n        return;\n    }\n    final Object object = source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        LOG.trace(\"Already refreshed\");\n        return;\n    }\n    final EntityEntry e = source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e == null) {\n        persister = source.getEntityPersister(null, object);\n        id = persister.getIdentifier(object, event.getSession());\n        if (LOG.isTraceEnabled())\n            LOG.trace(\"Refreshing transient \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        final EntityKey key = source.generateEntityKey(id, persister);\n        if (source.getPersistenceContext().getEntry(key) != null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (LOG.isTraceEnabled())\n            LOG.trace(\"Refreshing \" + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        if (!e.isExistsInDatabase()) {\n            throw new HibernateException(\"this instance does not yet exist as a row in the database\");\n        }\n        persister = e.getPersister();\n        id = e.getId();\n    }\n    refreshedAlready.put(object, object);\n    new Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n    if (e != null) {\n        final EntityKey key = source.generateEntityKey(id, persister);\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections())\n            new EvictVisitor(source).process(object, persister);\n    }\n    if (persister.hasCache()) {\n        final CacheKey ck = source.generateCacheKey(id, persister.getIdentifierType(), persister.getRootEntityName());\n        persister.getCacheAccessStrategy().evict(ck);\n    }\n    evictCachedCollections(persister, id, source.getFactory());\n    String previousFetchProfile = source.getLoadQueryInfluencers().getInternalFetchProfile();\n    source.getLoadQueryInfluencers().setInternalFetchProfile(\"refresh\");\n    Object result = persister.load(id, object, event.getLockOptions(), source);\n    if (result != null) {\n        if (!persister.isMutable()) {\n            source.setReadOnly(result, true);\n        } else {\n            source.setReadOnly(result, (e == null ? source.isDefaultReadOnly() : e.isReadOnly()));\n        }\n    }\n    source.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}"
    },
    {
      "commit": "4ee0d4237d9c5cb2d160a29bfc717dd9c2015173",
      "startLine": 19,
      "endLine": 22,
      "methodCode": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source = event.getSession();\n    boolean isTransient = !source.contains(event.getObject());\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n        if (isTransient) {\n            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n        }\n        return;\n    }\n    final Object object = source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        LOG.trace(\"Already refreshed\");\n        return;\n    }\n    final EntityEntry e = source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e == null) {\n        persister = source.getEntityPersister(null, object);\n        id = persister.getIdentifier(object, event.getSession());\n        if (LOG.isTraceEnabled())\n            LOG.trace(\"Refreshing transient \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        final EntityKey key = source.generateEntityKey(id, persister);\n        if (source.getPersistenceContext().getEntry(key) != null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (LOG.isTraceEnabled())\n            LOG.trace(\"Refreshing \" + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        if (!e.isExistsInDatabase()) {\n            throw new HibernateException(\"this instance does not yet exist as a row in the database\");\n        }\n        persister = e.getPersister();\n        id = e.getId();\n    }\n    refreshedAlready.put(object, object);\n    new Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n    if (e != null) {\n        final EntityKey key = source.generateEntityKey(id, persister);\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections())\n            new EvictVisitor(source).process(object, persister);\n    }\n    if (persister.hasCache()) {\n        final CacheKey ck = source.generateCacheKey(id, persister.getIdentifierType(), persister.getRootEntityName());\n        persister.getCacheAccessStrategy().evict(ck);\n    }\n    evictCachedCollections(persister, id, source.getFactory());\n    String previousFetchProfile = source.getFetchProfile();\n    source.setFetchProfile(\"refresh\");\n    Object result = persister.load(id, object, event.getLockOptions(), source);\n    if (result != null) {\n        if (!persister.isMutable()) {\n            source.setReadOnly(result, true);\n        } else {\n            source.setReadOnly(result, (e == null ? source.isDefaultReadOnly() : e.isReadOnly()));\n        }\n    }\n    source.setFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}"
    },
    {
      "commit": "47abaf12fa6be50e95b2a3b8b3d424611c873d66",
      "startLine": 19,
      "endLine": 22,
      "methodCode": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source = event.getSession();\n    boolean isTransient = !source.contains(event.getObject());\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n        if (isTransient) {\n            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n        }\n        return;\n    }\n    final Object object = source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        LOG.trace(\"Already refreshed\");\n        return;\n    }\n    final EntityEntry e = source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e == null) {\n        persister = source.getEntityPersister(null, object);\n        id = persister.getIdentifier(object, event.getSession());\n        if (LOG.isTraceEnabled())\n            LOG.trace(\"Refreshing transient \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        final EntityKey key = source.generateEntityKey(id, persister);\n        if (source.getPersistenceContext().getEntry(key) != null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (LOG.isTraceEnabled())\n            LOG.trace(\"Refreshing \" + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        if (!e.isExistsInDatabase()) {\n            throw new HibernateException(\"this instance does not yet exist as a row in the database\");\n        }\n        persister = e.getPersister();\n        id = e.getId();\n    }\n    refreshedAlready.put(object, object);\n    new Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n    if (e != null) {\n        final EntityKey key = source.generateEntityKey(id, persister);\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections())\n            new EvictVisitor(source).process(object, persister);\n    }\n    if (persister.hasCache()) {\n        final CacheKey ck = source.generateCacheKey(id, persister.getIdentifierType(), persister.getRootEntityName());\n        persister.getCacheAccessStrategy().evict(ck);\n    }\n    evictCachedCollections(persister, id, source.getFactory());\n    String previousFetchProfile = source.getFetchProfile();\n    source.setFetchProfile(\"refresh\");\n    Object result = persister.load(id, object, event.getLockOptions(), source);\n    if (result != null) {\n        if (!persister.isMutable()) {\n            source.setReadOnly(result, true);\n        } else {\n            source.setReadOnly(result, (e == null ? source.isDefaultReadOnly() : e.isReadOnly()));\n        }\n    }\n    source.setFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}"
    },
    {
      "commit": "fe8c7183d172946a03818be2cec1c9c2fc819316",
      "startLine": 19,
      "endLine": 22,
      "methodCode": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source = event.getSession();\n    boolean isTransient = !source.contains(event.getObject());\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n        if (isTransient) {\n            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n        }\n        return;\n    }\n    final Object object = source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        LOG.trace(\"Already refreshed\");\n        return;\n    }\n    final EntityEntry e = source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e == null) {\n        persister = source.getEntityPersister(null, object);\n        id = persister.getIdentifier(object, event.getSession());\n        if (LOG.isTraceEnabled())\n            LOG.trace(\"Refreshing transient \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        final EntityKey key = source.generateEntityKey(id, persister);\n        if (source.getPersistenceContext().getEntry(key) != null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (LOG.isTraceEnabled())\n            LOG.trace(\"Refreshing \" + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        if (!e.isExistsInDatabase()) {\n            throw new HibernateException(\"this instance does not yet exist as a row in the database\");\n        }\n        persister = e.getPersister();\n        id = e.getId();\n    }\n    refreshedAlready.put(object, object);\n    new Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n    if (e != null) {\n        final EntityKey key = source.generateEntityKey(id, persister);\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections())\n            new EvictVisitor(source).process(object, persister);\n    }\n    if (persister.hasCache()) {\n        final CacheKey ck = new CacheKey(id, persister.getIdentifierType(), persister.getRootEntityName(), source.getEntityMode(), source.getFactory());\n        persister.getCacheAccessStrategy().evict(ck);\n    }\n    evictCachedCollections(persister, id, source.getFactory());\n    String previousFetchProfile = source.getFetchProfile();\n    source.setFetchProfile(\"refresh\");\n    Object result = persister.load(id, object, event.getLockOptions(), source);\n    if (result != null) {\n        if (!persister.isMutable()) {\n            source.setReadOnly(result, true);\n        } else {\n            source.setReadOnly(result, (e == null ? source.isDefaultReadOnly() : e.isReadOnly()));\n        }\n    }\n    source.setFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}"
    },
    {
      "commit": "3712e1ad7efccd2ba0c24b3d7d3b23f84d948b9d",
      "startLine": 19,
      "endLine": 22,
      "methodCode": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source = event.getSession();\n    boolean isTransient = !source.contains(event.getObject());\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n        if (isTransient) {\n            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n        }\n        return;\n    }\n    final Object object = source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        LOG.trace(\"Already refreshed\");\n        return;\n    }\n    final EntityEntry e = source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e == null) {\n        persister = source.getEntityPersister(null, object);\n        id = persister.getIdentifier(object, event.getSession());\n        if (LOG.isTraceEnabled())\n            LOG.trace(\"Refreshing transient \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        EntityKey key = new EntityKey(id, persister, source.getEntityMode());\n        if (source.getPersistenceContext().getEntry(key) != null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (LOG.isTraceEnabled())\n            LOG.trace(\"Refreshing \" + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        if (!e.isExistsInDatabase()) {\n            throw new HibernateException(\"this instance does not yet exist as a row in the database\");\n        }\n        persister = e.getPersister();\n        id = e.getId();\n    }\n    refreshedAlready.put(object, object);\n    new Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n    if (e != null) {\n        EntityKey key = new EntityKey(id, persister, source.getEntityMode());\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections())\n            new EvictVisitor(source).process(object, persister);\n    }\n    if (persister.hasCache()) {\n        final CacheKey ck = new CacheKey(id, persister.getIdentifierType(), persister.getRootEntityName(), source.getEntityMode(), source.getFactory());\n        persister.getCacheAccessStrategy().evict(ck);\n    }\n    evictCachedCollections(persister, id, source.getFactory());\n    String previousFetchProfile = source.getFetchProfile();\n    source.setFetchProfile(\"refresh\");\n    Object result = persister.load(id, object, event.getLockOptions(), source);\n    if (result != null) {\n        if (!persister.isMutable()) {\n            source.setReadOnly(result, true);\n        } else {\n            source.setReadOnly(result, (e == null ? source.isDefaultReadOnly() : e.isReadOnly()));\n        }\n    }\n    source.setFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}"
    },
    {
      "commit": "a9b1425f3f07021dae556e710b2bdfdc3812661b",
      "startLine": 19,
      "endLine": 22,
      "methodCode": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source = event.getSession();\n    boolean isTransient = !source.contains(event.getObject());\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n        if (isTransient) {\n            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n        }\n        return;\n    }\n    final Object object = source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        LOG.alreadyRefreshed();\n        return;\n    }\n    final EntityEntry e = source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e == null) {\n        persister = source.getEntityPersister(null, object);\n        id = persister.getIdentifier(object, event.getSession());\n        if (LOG.isTraceEnabled())\n            LOG.refreshingTransient(MessageHelper.infoString(persister, id, source.getFactory()));\n        EntityKey key = new EntityKey(id, persister, source.getEntityMode());\n        if (source.getPersistenceContext().getEntry(key) != null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (LOG.isTraceEnabled())\n            LOG.refreshing(MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        if (!e.isExistsInDatabase()) {\n            throw new HibernateException(\"this instance does not yet exist as a row in the database\");\n        }\n        persister = e.getPersister();\n        id = e.getId();\n    }\n    refreshedAlready.put(object, object);\n    new Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n    if (e != null) {\n        EntityKey key = new EntityKey(id, persister, source.getEntityMode());\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections())\n            new EvictVisitor(source).process(object, persister);\n    }\n    if (persister.hasCache()) {\n        final CacheKey ck = new CacheKey(id, persister.getIdentifierType(), persister.getRootEntityName(), source.getEntityMode(), source.getFactory());\n        persister.getCacheAccessStrategy().evict(ck);\n    }\n    evictCachedCollections(persister, id, source.getFactory());\n    String previousFetchProfile = source.getFetchProfile();\n    source.setFetchProfile(\"refresh\");\n    Object result = persister.load(id, object, event.getLockOptions(), source);\n    if (result != null) {\n        if (!persister.isMutable()) {\n            source.setReadOnly(result, true);\n        } else {\n            source.setReadOnly(result, (e == null ? source.isDefaultReadOnly() : e.isReadOnly()));\n        }\n    }\n    source.setFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}"
    },
    {
      "commit": "34c2839dccef33a8f3abb4eaf3192c1e1d9e1814",
      "startLine": 19,
      "endLine": 23,
      "methodCode": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source = event.getSession();\n    boolean isTransient = !source.contains(event.getObject());\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n        if (isTransient) {\n            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n        }\n        return;\n    }\n    final Object object = source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        log.trace(\"already refreshed\");\n        return;\n    }\n    final EntityEntry e = source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e == null) {\n        persister = source.getEntityPersister(null, object);\n        id = persister.getIdentifier(object, event.getSession());\n        if (log.isTraceEnabled()) {\n            log.trace(\"refreshing transient \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n        EntityKey key = new EntityKey(id, persister, source.getEntityMode());\n        if (source.getPersistenceContext().getEntry(key) != null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (log.isTraceEnabled()) {\n            log.trace(\"refreshing \" + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        }\n        if (!e.isExistsInDatabase()) {\n            throw new HibernateException(\"this instance does not yet exist as a row in the database\");\n        }\n        persister = e.getPersister();\n        id = e.getId();\n    }\n    refreshedAlready.put(object, object);\n    new Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n    if (e != null) {\n        EntityKey key = new EntityKey(id, persister, source.getEntityMode());\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections())\n            new EvictVisitor(source).process(object, persister);\n    }\n    if (persister.hasCache()) {\n        final CacheKey ck = new CacheKey(id, persister.getIdentifierType(), persister.getRootEntityName(), source.getEntityMode(), source.getFactory());\n        persister.getCacheAccessStrategy().evict(ck);\n    }\n    evictCachedCollections(persister, id, source.getFactory());\n    String previousFetchProfile = source.getFetchProfile();\n    source.setFetchProfile(\"refresh\");\n    Object result = persister.load(id, object, event.getLockOptions(), source);\n    if (result != null) {\n        if (!persister.isMutable()) {\n            source.setReadOnly(result, true);\n        } else {\n            source.setReadOnly(result, (e == null ? source.isDefaultReadOnly() : e.isReadOnly()));\n        }\n    }\n    source.setFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}"
    },
    {
      "commit": "14bdaec5e75bded557e8410d818a7b77308dd80b",
      "startLine": 19,
      "endLine": 23,
      "methodCode": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source = event.getSession();\n    boolean isTransient = !source.contains(event.getObject());\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n        if (isTransient) {\n            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n        }\n        return;\n    }\n    final Object object = source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        log.trace(\"already refreshed\");\n        return;\n    }\n    final EntityEntry e = source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e == null) {\n        persister = source.getEntityPersister(null, object);\n        id = persister.getIdentifier(object, event.getSession());\n        if (log.isTraceEnabled()) {\n            log.trace(\"refreshing transient \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n        EntityKey key = new EntityKey(id, persister, source.getEntityMode());\n        if (source.getPersistenceContext().getEntry(key) != null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (log.isTraceEnabled()) {\n            log.trace(\"refreshing \" + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        }\n        if (!e.isExistsInDatabase()) {\n            throw new HibernateException(\"this instance does not yet exist as a row in the database\");\n        }\n        persister = e.getPersister();\n        id = e.getId();\n    }\n    refreshedAlready.put(object, object);\n    new Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n    if (e != null) {\n        EntityKey key = new EntityKey(id, persister, source.getEntityMode());\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections())\n            new EvictVisitor(source).process(object, persister);\n    }\n    if (persister.hasCache()) {\n        final CacheKey ck = new CacheKey(id, persister.getIdentifierType(), persister.getRootEntityName(), source.getEntityMode(), source.getFactory());\n        persister.getCacheAccessStrategy().evict(ck);\n    }\n    evictCachedCollections(persister, id, source.getFactory());\n    String previousFetchProfile = source.getFetchProfile();\n    source.setFetchProfile(\"refresh\");\n    Object result = persister.load(id, object, event.getLockOptions(), source);\n    if (result != null) {\n        if (!persister.isMutable()) {\n            source.setReadOnly(result, true);\n        } else {\n            source.setReadOnly(result, (e == null ? source.isDefaultReadOnly() : e.isReadOnly()));\n        }\n    }\n    source.setFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}"
    },
    {
      "commit": "839e23458aa0c50e1dc0d8f1a1bed87dbff49f3b",
      "startLine": 19,
      "endLine": 23,
      "methodCode": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source = event.getSession();\n    boolean isTransient = !source.contains(event.getObject());\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n        if (isTransient) {\n            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n        }\n        return;\n    }\n    final Object object = source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        log.trace(\"already refreshed\");\n        return;\n    }\n    final EntityEntry e = source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e == null) {\n        persister = source.getEntityPersister(null, object);\n        id = persister.getIdentifier(object, event.getSession());\n        if (log.isTraceEnabled()) {\n            log.trace(\"refreshing transient \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n        EntityKey key = new EntityKey(id, persister, source.getEntityMode());\n        if (source.getPersistenceContext().getEntry(key) != null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (log.isTraceEnabled()) {\n            log.trace(\"refreshing \" + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        }\n        if (!e.isExistsInDatabase()) {\n            throw new HibernateException(\"this instance does not yet exist as a row in the database\");\n        }\n        persister = e.getPersister();\n        id = e.getId();\n    }\n    refreshedAlready.put(object, object);\n    new Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n    if (e != null) {\n        EntityKey key = new EntityKey(id, persister, source.getEntityMode());\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections())\n            new EvictVisitor(source).process(object, persister);\n    }\n    if (persister.hasCache()) {\n        final CacheKey ck = new CacheKey(id, persister.getIdentifierType(), persister.getRootEntityName(), source.getEntityMode(), source.getFactory());\n        persister.getCacheAccessStrategy().evict(ck);\n    }\n    evictCachedCollections(persister, id, source.getFactory());\n    String previousFetchProfile = source.getFetchProfile();\n    source.setFetchProfile(\"refresh\");\n    Object result = persister.load(id, object, event.getLockOptions(), source);\n    if (result != null) {\n        source.setReadOnly(result, (e == null ? source.isDefaultReadOnly() : e.isReadOnly()));\n    }\n    source.setFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}"
    },
    {
      "commit": "c18a9306b9f8995331240b66c01fea304e01d06f",
      "startLine": 19,
      "endLine": 23,
      "methodCode": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source = event.getSession();\n    boolean isTransient = !source.contains(event.getObject());\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n        if (isTransient) {\n            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n        }\n        return;\n    }\n    final Object object = source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        log.trace(\"already refreshed\");\n        return;\n    }\n    final EntityEntry e = source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e == null) {\n        persister = source.getEntityPersister(null, object);\n        id = persister.getIdentifier(object, event.getSession().getEntityMode());\n        if (log.isTraceEnabled()) {\n            log.trace(\"refreshing transient \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n        EntityKey key = new EntityKey(id, persister, source.getEntityMode());\n        if (source.getPersistenceContext().getEntry(key) != null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (log.isTraceEnabled()) {\n            log.trace(\"refreshing \" + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        }\n        if (!e.isExistsInDatabase()) {\n            throw new HibernateException(\"this instance does not yet exist as a row in the database\");\n        }\n        persister = e.getPersister();\n        id = e.getId();\n    }\n    refreshedAlready.put(object, object);\n    new Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n    if (e != null) {\n        EntityKey key = new EntityKey(id, persister, source.getEntityMode());\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections())\n            new EvictVisitor(source).process(object, persister);\n    }\n    if (persister.hasCache()) {\n        final CacheKey ck = new CacheKey(id, persister.getIdentifierType(), persister.getRootEntityName(), source.getEntityMode(), source.getFactory());\n        persister.getCacheAccessStrategy().evict(ck);\n    }\n    evictCachedCollections(persister, id, source.getFactory());\n    String previousFetchProfile = source.getFetchProfile();\n    source.setFetchProfile(\"refresh\");\n    Object result = persister.load(id, object, event.getLockOptions(), source);\n    if (result != null) {\n        source.setReadOnly(result, (e == null ? source.isDefaultReadOnly() : e.isReadOnly()));\n    }\n    source.setFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}"
    },
    {
      "commit": "b40cfb58dbe4606609c3fa2b1e5e210466c593df",
      "startLine": 19,
      "endLine": 23,
      "methodCode": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source = event.getSession();\n    boolean isTransient = !source.contains(event.getObject());\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n        if (isTransient) {\n            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n        }\n        return;\n    }\n    final Object object = source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        log.trace(\"already refreshed\");\n        return;\n    }\n    final EntityEntry e = source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e == null) {\n        persister = source.getEntityPersister(null, object);\n        id = persister.getIdentifier(object, event.getSession().getEntityMode());\n        if (log.isTraceEnabled()) {\n            log.trace(\"refreshing transient \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n        EntityKey key = new EntityKey(id, persister, source.getEntityMode());\n        if (source.getPersistenceContext().getEntry(key) != null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (log.isTraceEnabled()) {\n            log.trace(\"refreshing \" + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        }\n        if (!e.isExistsInDatabase()) {\n            throw new HibernateException(\"this instance does not yet exist as a row in the database\");\n        }\n        persister = e.getPersister();\n        id = e.getId();\n    }\n    refreshedAlready.put(object, object);\n    new Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n    if (e != null) {\n        EntityKey key = new EntityKey(id, persister, source.getEntityMode());\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections())\n            new EvictVisitor(source).process(object, persister);\n    }\n    if (persister.hasCache()) {\n        final CacheKey ck = new CacheKey(id, persister.getIdentifierType(), persister.getRootEntityName(), source.getEntityMode(), source.getFactory());\n        persister.getCacheAccessStrategy().evict(ck);\n    }\n    evictCachedCollections(persister, id, source.getFactory());\n    String previousFetchProfile = source.getFetchProfile();\n    source.setFetchProfile(\"refresh\");\n    Object result = persister.load(id, object, event.getLockOptions(), source);\n    source.setReadOnly(result, (e == null ? source.isDefaultReadOnly() : e.isReadOnly()));\n    source.setFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}"
    },
    {
      "commit": "ceaea5a2a382e57fdded1ad717510d2e3e5bbf49",
      "startLine": 14,
      "endLine": 18,
      "methodCode": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source = event.getSession();\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject()))\n        return;\n    final Object object = source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        log.trace(\"already refreshed\");\n        return;\n    }\n    final EntityEntry e = source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e == null) {\n        persister = source.getEntityPersister(null, object);\n        id = persister.getIdentifier(object, event.getSession().getEntityMode());\n        if (log.isTraceEnabled()) {\n            log.trace(\"refreshing transient \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n        EntityKey key = new EntityKey(id, persister, source.getEntityMode());\n        if (source.getPersistenceContext().getEntry(key) != null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (log.isTraceEnabled()) {\n            log.trace(\"refreshing \" + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        }\n        if (!e.isExistsInDatabase()) {\n            throw new HibernateException(\"this instance does not yet exist as a row in the database\");\n        }\n        persister = e.getPersister();\n        id = e.getId();\n    }\n    refreshedAlready.put(object, object);\n    new Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n    if (e != null) {\n        EntityKey key = new EntityKey(id, persister, source.getEntityMode());\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections())\n            new EvictVisitor(source).process(object, persister);\n    }\n    if (persister.hasCache()) {\n        final CacheKey ck = new CacheKey(id, persister.getIdentifierType(), persister.getRootEntityName(), source.getEntityMode(), source.getFactory());\n        persister.getCacheAccessStrategy().evict(ck);\n    }\n    evictCachedCollections(persister, id, source.getFactory());\n    String previousFetchProfile = source.getFetchProfile();\n    source.setFetchProfile(\"refresh\");\n    Object result = persister.load(id, object, event.getLockOptions(), source);\n    source.setFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}"
    },
    {
      "commit": "35ca4c35635f26b9a86b260ad974ba7da429950b",
      "startLine": 14,
      "endLine": 18,
      "methodCode": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source = event.getSession();\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject()))\n        return;\n    final Object object = source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        log.trace(\"already refreshed\");\n        return;\n    }\n    final EntityEntry e = source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e == null) {\n        persister = source.getEntityPersister(null, object);\n        id = persister.getIdentifier(object, event.getSession().getEntityMode());\n        if (log.isTraceEnabled()) {\n            log.trace(\"refreshing transient \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n        EntityKey key = new EntityKey(id, persister, source.getEntityMode());\n        if (source.getPersistenceContext().getEntry(key) != null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (log.isTraceEnabled()) {\n            log.trace(\"refreshing \" + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        }\n        if (!e.isExistsInDatabase()) {\n            throw new HibernateException(\"this instance does not yet exist as a row in the database\");\n        }\n        persister = e.getPersister();\n        id = e.getId();\n    }\n    refreshedAlready.put(object, object);\n    new Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n    if (e != null) {\n        EntityKey key = new EntityKey(id, persister, source.getEntityMode());\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections())\n            new EvictVisitor(source).process(object, persister);\n    }\n    if (persister.hasCache()) {\n        final CacheKey ck = new CacheKey(id, persister.getIdentifierType(), persister.getRootEntityName(), source.getEntityMode(), source.getFactory());\n        persister.getCacheAccessStrategy().evict(ck);\n    }\n    evictCachedCollections(persister, id, source.getFactory());\n    String previousFetchProfile = source.getFetchProfile();\n    source.setFetchProfile(\"refresh\");\n    Object result = persister.load(id, object, event.getLockRequest(), source);\n    source.setFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}"
    },
    {
      "commit": "a797998927e2cbba9ec34ca7dc31b42a192fa2f1",
      "startLine": 14,
      "endLine": 18,
      "methodCode": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source = event.getSession();\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject()))\n        return;\n    final Object object = source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        log.trace(\"already refreshed\");\n        return;\n    }\n    final EntityEntry e = source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e == null) {\n        persister = source.getEntityPersister(null, object);\n        id = persister.getIdentifier(object, event.getSession().getEntityMode());\n        if (log.isTraceEnabled()) {\n            log.trace(\"refreshing transient \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n        EntityKey key = new EntityKey(id, persister, source.getEntityMode());\n        if (source.getPersistenceContext().getEntry(key) != null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (log.isTraceEnabled()) {\n            log.trace(\"refreshing \" + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        }\n        if (!e.isExistsInDatabase()) {\n            throw new HibernateException(\"this instance does not yet exist as a row in the database\");\n        }\n        persister = e.getPersister();\n        id = e.getId();\n    }\n    refreshedAlready.put(object, object);\n    new Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n    if (e != null) {\n        EntityKey key = new EntityKey(id, persister, source.getEntityMode());\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections())\n            new EvictVisitor(source).process(object, persister);\n    }\n    if (persister.hasCache()) {\n        final CacheKey ck = new CacheKey(id, persister.getIdentifierType(), persister.getRootEntityName(), source.getEntityMode(), source.getFactory());\n        persister.getCacheAccessStrategy().evict(ck);\n    }\n    evictCachedCollections(persister, id, source.getFactory());\n    String previousFetchProfile = source.getFetchProfile();\n    source.setFetchProfile(\"refresh\");\n    Object result = persister.load(id, object, event.getLockMode(), source);\n    source.setFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}"
    },
    {
      "commit": "d8d6d82e30960e0c255950eaf875ad48831b12b0",
      "startLine": 14,
      "endLine": 18,
      "methodCode": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source = event.getSession();\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject()))\n        return;\n    final Object object = source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        log.trace(\"already refreshed\");\n        return;\n    }\n    final EntityEntry e = source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e == null) {\n        persister = source.getEntityPersister(null, object);\n        id = persister.getIdentifier(object, event.getSession().getEntityMode());\n        if (log.isTraceEnabled()) {\n            log.trace(\"refreshing transient \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n        EntityKey key = new EntityKey(id, persister, source.getEntityMode());\n        if (source.getPersistenceContext().getEntry(key) != null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (log.isTraceEnabled()) {\n            log.trace(\"refreshing \" + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        }\n        if (!e.isExistsInDatabase()) {\n            throw new HibernateException(\"this instance does not yet exist as a row in the database\");\n        }\n        persister = e.getPersister();\n        id = e.getId();\n    }\n    refreshedAlready.put(object, object);\n    new Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n    if (e != null) {\n        EntityKey key = new EntityKey(id, persister, source.getEntityMode());\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections())\n            new EvictVisitor(source).process(object, persister);\n    }\n    if (persister.hasCache()) {\n        final CacheKey ck = new CacheKey(id, persister.getIdentifierType(), persister.getRootEntityName(), source.getEntityMode(), source.getFactory());\n        persister.getCacheAccessStrategy().evict(ck);\n    }\n    evictCachedCollections(persister, id, source.getFactory());\n    String previousFetchProfile = source.getFetchProfile();\n    source.setFetchProfile(\"refresh\");\n    Object result = persister.load(id, object, event.getLockMode(), source);\n    source.setFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}"
    }
  ]
}