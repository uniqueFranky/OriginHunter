{
  "statementVersions": [
    {
      "commit": "ebca36a76851c9b0b7ea406e1b1428225891de2f",
      "startLine": 134,
      "endLine": 149,
      "methodCode": "public static void bindClass(XClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, MetadataBuildingContext context) throws MappingException {\n    if (clazzToProcess.isAnnotationPresent(Entity.class) && clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n    }\n    InheritanceState inheritanceState = inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType = context.getMetadataCollector().getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, context);\n        bindTypeDefs(clazzToProcess, context);\n        bindFilterDefs(clazzToProcess, context);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    if (LOG.isDebugEnabled()) {\n        LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n    }\n    PersistentClass superEntity = getSuperEntity(clazzToProcess, inheritanceStatePerClass, context, inheritanceState);\n    if (superEntity != null && (clazzToProcess.getAnnotation(AttributeOverride.class) != null || clazzToProcess.getAnnotation(AttributeOverrides.class) != null)) {\n        throw new AnnotationException(\"An entity annotated with @Inheritance cannot use @AttributeOverride or @AttributeOverrides: \" + clazzToProcess.getName());\n    }\n    PersistentClass persistentClass = makePersistentClass(inheritanceState, superEntity, context);\n    Entity entityAnn = clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    EntityBinder entityBinder = new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, context);\n    entityBinder.setInheritanceState(inheritanceState);\n    bindQueries(clazzToProcess, context);\n    bindFilterDefs(clazzToProcess, context);\n    bindTypeDefs(clazzToProcess, context);\n    bindFetchProfiles(clazzToProcess, context);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, context);\n    String schema = \"\";\n    String table = \"\";\n    String catalog = \"\";\n    List<UniqueConstraintHolder> uniqueConstraints = new ArrayList<>();\n    javax.persistence.Table tabAnn = null;\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        tabAnn = clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table = tabAnn.name();\n        schema = tabAnn.schema();\n        catalog = tabAnn.catalog();\n        uniqueConstraints = TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(clazzToProcess, context, inheritanceState, superEntity);\n    final Ejb3DiscriminatorColumn discriminatorColumn;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        discriminatorColumn = processSingleTableDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n    } else if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n        discriminatorColumn = processJoinedDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n    } else {\n        discriminatorColumn = null;\n    }\n    entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n    entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n    entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n    applyCacheSettings(entityBinder, clazzToProcess, context);\n    bindFilters(clazzToProcess, entityBinder, context);\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn = clazzToProcess.getAnnotation(Check.class);\n        String constraints = checkAnn == null ? null : checkAnn.constraints();\n        EntityTableXref denormalizedTableXref = inheritanceState.hasDenormalizedTable() ? context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()) : null;\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, denormalizedTableXref);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            LOG.invalidTableAnnotation(clazzToProcess.getName());\n        }\n        if (inheritanceState.getType() == InheritanceType.SINGLE_TABLE) {\n            entityBinder.bindTableForDiscriminatedSubclass(context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()));\n        }\n    }\n    PropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, context, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn = clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate = false;\n    final boolean isInheritanceRoot = !inheritanceState.hasParents();\n    final boolean hasSubclasses = inheritanceState.hasSiblings();\n    if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            onDeleteAppropriate = true;\n            final JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n            SimpleValue key = new DependantValue(context, jsc.getTable(), jsc.getIdentifier());\n            jsc.setKey(key);\n            ForeignKey fk = clazzToProcess.getAnnotation(ForeignKey.class);\n            if (fk != null && !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n                key.setForeignKeyName(fk.name());\n            } else {\n                final PrimaryKeyJoinColumn pkJoinColumn = clazzToProcess.getAnnotation(PrimaryKeyJoinColumn.class);\n                final PrimaryKeyJoinColumns pkJoinColumns = clazzToProcess.getAnnotation(PrimaryKeyJoinColumns.class);\n                if (pkJoinColumns != null && pkJoinColumns.foreignKey().value() == ConstraintMode.NO_CONSTRAINT) {\n                    key.setForeignKeyName(\"none\");\n                } else if (pkJoinColumns != null && !StringHelper.isEmpty(pkJoinColumns.foreignKey().name())) {\n                    key.setForeignKeyName(pkJoinColumns.foreignKey().name());\n                } else if (pkJoinColumn != null && pkJoinColumn.foreignKey().value() == ConstraintMode.NO_CONSTRAINT) {\n                    key.setForeignKeyName(\"none\");\n                } else if (pkJoinColumn != null && !StringHelper.isEmpty(pkJoinColumn.foreignKey().name())) {\n                    key.setForeignKeyName(pkJoinColumn.foreignKey().name());\n                }\n            }\n            if (onDeleteAnn != null) {\n                key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n            } else {\n                key.setCascadeDeleteEnabled(false);\n            }\n            context.getMetadataCollector().addSecondPass(new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, context));\n            context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(jsc));\n        }\n        if (isInheritanceRoot) {\n            if (discriminatorColumn != null) {\n                if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                    bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                    entityBinder.bindDiscriminatorValue();\n                }\n            }\n        }\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (isInheritanceRoot) {\n            if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    }\n    if (onDeleteAnn != null && !onDeleteAppropriate) {\n        LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n    }\n    HashMap<String, IdentifierGeneratorDefinition> classGenerators = buildGenerators(clazzToProcess, context);\n    final InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE && inheritanceState.hasParents();\n    Set<String> idPropertiesIfIdClass = new HashSet<>();\n    boolean isIdClass = mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, context);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() > 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, context, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass = (RootClass) persistentClass;\n        context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    context.getMetadataCollector().addEntityBinding(persistentClass);\n    context.getMetadataCollector().addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n    entityBinder.processComplementaryTableDefinitions(tabAnn);\n}"
    },
    {
      "commit": "8f889e95d76f47945c9ec072fd08cb045767578c",
      "startLine": 131,
      "endLine": 146,
      "methodCode": "public static void bindClass(XClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, MetadataBuildingContext context) throws MappingException {\n    if (clazzToProcess.isAnnotationPresent(Entity.class) && clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n    }\n    InheritanceState inheritanceState = inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType = context.getMetadataCollector().getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, context);\n        bindTypeDefs(clazzToProcess, context);\n        bindFilterDefs(clazzToProcess, context);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    if (LOG.isDebugEnabled()) {\n        LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n    }\n    PersistentClass superEntity = getSuperEntity(clazzToProcess, inheritanceStatePerClass, context, inheritanceState);\n    PersistentClass persistentClass = makePersistentClass(inheritanceState, superEntity, context);\n    Entity entityAnn = clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    EntityBinder entityBinder = new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, context);\n    entityBinder.setInheritanceState(inheritanceState);\n    bindQueries(clazzToProcess, context);\n    bindFilterDefs(clazzToProcess, context);\n    bindTypeDefs(clazzToProcess, context);\n    bindFetchProfiles(clazzToProcess, context);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, context);\n    String schema = \"\";\n    String table = \"\";\n    String catalog = \"\";\n    List<UniqueConstraintHolder> uniqueConstraints = new ArrayList<>();\n    javax.persistence.Table tabAnn = null;\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        tabAnn = clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table = tabAnn.name();\n        schema = tabAnn.schema();\n        catalog = tabAnn.catalog();\n        uniqueConstraints = TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(clazzToProcess, context, inheritanceState, superEntity);\n    final Ejb3DiscriminatorColumn discriminatorColumn;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        discriminatorColumn = processSingleTableDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n    } else if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n        discriminatorColumn = processJoinedDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n    } else {\n        discriminatorColumn = null;\n    }\n    entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n    entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n    entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n    applyCacheSettings(entityBinder, clazzToProcess, context);\n    bindFilters(clazzToProcess, entityBinder, context);\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn = clazzToProcess.getAnnotation(Check.class);\n        String constraints = checkAnn == null ? null : checkAnn.constraints();\n        EntityTableXref denormalizedTableXref = inheritanceState.hasDenormalizedTable() ? context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()) : null;\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, denormalizedTableXref);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            LOG.invalidTableAnnotation(clazzToProcess.getName());\n        }\n        if (inheritanceState.getType() == InheritanceType.SINGLE_TABLE) {\n            entityBinder.bindTableForDiscriminatedSubclass(context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()));\n        }\n    }\n    PropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, context, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn = clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate = false;\n    final boolean isInheritanceRoot = !inheritanceState.hasParents();\n    final boolean hasSubclasses = inheritanceState.hasSiblings();\n    if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            onDeleteAppropriate = true;\n            final JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n            SimpleValue key = new DependantValue(context, jsc.getTable(), jsc.getIdentifier());\n            jsc.setKey(key);\n            ForeignKey fk = clazzToProcess.getAnnotation(ForeignKey.class);\n            if (fk != null && !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n                key.setForeignKeyName(fk.name());\n            } else {\n                final PrimaryKeyJoinColumn pkJoinColumn = clazzToProcess.getAnnotation(PrimaryKeyJoinColumn.class);\n                final PrimaryKeyJoinColumns pkJoinColumns = clazzToProcess.getAnnotation(PrimaryKeyJoinColumns.class);\n                if (pkJoinColumns != null && pkJoinColumns.foreignKey().value() == ConstraintMode.NO_CONSTRAINT) {\n                    key.setForeignKeyName(\"none\");\n                } else if (pkJoinColumns != null && !StringHelper.isEmpty(pkJoinColumns.foreignKey().name())) {\n                    key.setForeignKeyName(pkJoinColumns.foreignKey().name());\n                } else if (pkJoinColumn != null && pkJoinColumn.foreignKey().value() == ConstraintMode.NO_CONSTRAINT) {\n                    key.setForeignKeyName(\"none\");\n                } else if (pkJoinColumn != null && !StringHelper.isEmpty(pkJoinColumn.foreignKey().name())) {\n                    key.setForeignKeyName(pkJoinColumn.foreignKey().name());\n                }\n            }\n            if (onDeleteAnn != null) {\n                key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n            } else {\n                key.setCascadeDeleteEnabled(false);\n            }\n            context.getMetadataCollector().addSecondPass(new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, context));\n            context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(jsc));\n        }\n        if (isInheritanceRoot) {\n            if (discriminatorColumn != null) {\n                if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                    bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                    entityBinder.bindDiscriminatorValue();\n                }\n            }\n        }\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (isInheritanceRoot) {\n            if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    }\n    if (onDeleteAnn != null && !onDeleteAppropriate) {\n        LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n    }\n    HashMap<String, IdentifierGeneratorDefinition> classGenerators = buildGenerators(clazzToProcess, context);\n    final InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE && inheritanceState.hasParents();\n    Set<String> idPropertiesIfIdClass = new HashSet<>();\n    boolean isIdClass = mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, context);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() > 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, context, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass = (RootClass) persistentClass;\n        context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    context.getMetadataCollector().addEntityBinding(persistentClass);\n    context.getMetadataCollector().addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n    entityBinder.processComplementaryTableDefinitions(tabAnn);\n}"
    },
    {
      "commit": "8b11d5ecf9a71ae70e3f7c837ed3de1b55ec096d",
      "startLine": 131,
      "endLine": 146,
      "methodCode": "public static void bindClass(XClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, MetadataBuildingContext context) throws MappingException {\n    if (clazzToProcess.isAnnotationPresent(Entity.class) && clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n    }\n    InheritanceState inheritanceState = inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType = context.getMetadataCollector().getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, context);\n        bindTypeDefs(clazzToProcess, context);\n        bindFilterDefs(clazzToProcess, context);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    if (LOG.isDebugEnabled()) {\n        LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n    }\n    PersistentClass superEntity = getSuperEntity(clazzToProcess, inheritanceStatePerClass, context, inheritanceState);\n    PersistentClass persistentClass = makePersistentClass(inheritanceState, superEntity, context);\n    Entity entityAnn = clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    EntityBinder entityBinder = new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, context);\n    entityBinder.setInheritanceState(inheritanceState);\n    bindQueries(clazzToProcess, context);\n    bindFilterDefs(clazzToProcess, context);\n    bindTypeDefs(clazzToProcess, context);\n    bindFetchProfiles(clazzToProcess, context);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, context);\n    String schema = \"\";\n    String table = \"\";\n    String catalog = \"\";\n    List<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n    javax.persistence.Table tabAnn = null;\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        tabAnn = clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table = tabAnn.name();\n        schema = tabAnn.schema();\n        catalog = tabAnn.catalog();\n        uniqueConstraints = TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(clazzToProcess, context, inheritanceState, superEntity);\n    final Ejb3DiscriminatorColumn discriminatorColumn;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        discriminatorColumn = processSingleTableDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n    } else if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n        discriminatorColumn = processJoinedDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n    } else {\n        discriminatorColumn = null;\n    }\n    entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n    entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n    entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n    applyCacheSettings(entityBinder, clazzToProcess, context);\n    bindFilters(clazzToProcess, entityBinder, context);\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn = clazzToProcess.getAnnotation(Check.class);\n        String constraints = checkAnn == null ? null : checkAnn.constraints();\n        EntityTableXref denormalizedTableXref = inheritanceState.hasDenormalizedTable() ? context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()) : null;\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, denormalizedTableXref);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            LOG.invalidTableAnnotation(clazzToProcess.getName());\n        }\n        if (inheritanceState.getType() == InheritanceType.SINGLE_TABLE) {\n            entityBinder.bindTableForDiscriminatedSubclass(context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()));\n        }\n    }\n    PropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, context, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn = clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate = false;\n    final boolean isInheritanceRoot = !inheritanceState.hasParents();\n    final boolean hasSubclasses = inheritanceState.hasSiblings();\n    if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            onDeleteAppropriate = true;\n            final JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n            SimpleValue key = new DependantValue(context.getMetadataCollector(), jsc.getTable(), jsc.getIdentifier());\n            jsc.setKey(key);\n            ForeignKey fk = clazzToProcess.getAnnotation(ForeignKey.class);\n            if (fk != null && !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n                key.setForeignKeyName(fk.name());\n            } else {\n                final PrimaryKeyJoinColumn pkJoinColumn = clazzToProcess.getAnnotation(PrimaryKeyJoinColumn.class);\n                final PrimaryKeyJoinColumns pkJoinColumns = clazzToProcess.getAnnotation(PrimaryKeyJoinColumns.class);\n                if (pkJoinColumns != null && pkJoinColumns.foreignKey().value() == ConstraintMode.NO_CONSTRAINT) {\n                    key.setForeignKeyName(\"none\");\n                } else if (pkJoinColumns != null && !StringHelper.isEmpty(pkJoinColumns.foreignKey().name())) {\n                    key.setForeignKeyName(pkJoinColumns.foreignKey().name());\n                } else if (pkJoinColumn != null && pkJoinColumn.foreignKey().value() == ConstraintMode.NO_CONSTRAINT) {\n                    key.setForeignKeyName(\"none\");\n                } else if (pkJoinColumn != null && !StringHelper.isEmpty(pkJoinColumn.foreignKey().name())) {\n                    key.setForeignKeyName(pkJoinColumn.foreignKey().name());\n                }\n            }\n            if (onDeleteAnn != null) {\n                key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n            } else {\n                key.setCascadeDeleteEnabled(false);\n            }\n            context.getMetadataCollector().addSecondPass(new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, context));\n            context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(jsc));\n        }\n        if (isInheritanceRoot) {\n            if (discriminatorColumn != null) {\n                if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                    bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                    entityBinder.bindDiscriminatorValue();\n                }\n            }\n        }\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (isInheritanceRoot) {\n            if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    }\n    if (onDeleteAnn != null && !onDeleteAppropriate) {\n        LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n    }\n    HashMap<String, IdentifierGeneratorDefinition> classGenerators = buildGenerators(clazzToProcess, context);\n    final InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE && inheritanceState.hasParents();\n    Set<String> idPropertiesIfIdClass = new HashSet<>();\n    boolean isIdClass = mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, context);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() > 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, context, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass = (RootClass) persistentClass;\n        context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    context.getMetadataCollector().addEntityBinding(persistentClass);\n    context.getMetadataCollector().addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n    entityBinder.processComplementaryTableDefinitions(tabAnn);\n}"
    },
    {
      "commit": "b1a9c816a7e1159d6ae75898a8f455e425f94d4e",
      "startLine": 131,
      "endLine": 146,
      "methodCode": "public static void bindClass(XClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, MetadataBuildingContext context) throws MappingException {\n    if (clazzToProcess.isAnnotationPresent(Entity.class) && clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n    }\n    InheritanceState inheritanceState = inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType = context.getMetadataCollector().getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, context);\n        bindTypeDefs(clazzToProcess, context);\n        bindFilterDefs(clazzToProcess, context);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    if (LOG.isDebugEnabled()) {\n        LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n    }\n    PersistentClass superEntity = getSuperEntity(clazzToProcess, inheritanceStatePerClass, context, inheritanceState);\n    PersistentClass persistentClass = makePersistentClass(inheritanceState, superEntity, context);\n    Entity entityAnn = clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    EntityBinder entityBinder = new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, context);\n    entityBinder.setInheritanceState(inheritanceState);\n    bindQueries(clazzToProcess, context);\n    bindFilterDefs(clazzToProcess, context);\n    bindTypeDefs(clazzToProcess, context);\n    bindFetchProfiles(clazzToProcess, context);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, context);\n    String schema = \"\";\n    String table = \"\";\n    String catalog = \"\";\n    List<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n    javax.persistence.Table tabAnn = null;\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        tabAnn = clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table = tabAnn.name();\n        schema = tabAnn.schema();\n        catalog = tabAnn.catalog();\n        uniqueConstraints = TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(clazzToProcess, context, inheritanceState, superEntity);\n    final Ejb3DiscriminatorColumn discriminatorColumn;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        discriminatorColumn = processSingleTableDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n    } else if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n        discriminatorColumn = processJoinedDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n    } else {\n        discriminatorColumn = null;\n    }\n    entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n    entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n    entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n    applyCacheSettings(entityBinder, clazzToProcess, context);\n    bindFilters(clazzToProcess, entityBinder, context);\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn = clazzToProcess.getAnnotation(Check.class);\n        String constraints = checkAnn == null ? null : checkAnn.constraints();\n        EntityTableXref denormalizedTableXref = inheritanceState.hasDenormalizedTable() ? context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()) : null;\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, denormalizedTableXref);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            LOG.invalidTableAnnotation(clazzToProcess.getName());\n        }\n        if (inheritanceState.getType() == InheritanceType.SINGLE_TABLE) {\n            entityBinder.bindTableForDiscriminatedSubclass(context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()));\n        }\n    }\n    PropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, context, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn = clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate = false;\n    final boolean isInheritanceRoot = !inheritanceState.hasParents();\n    final boolean hasSubclasses = inheritanceState.hasSiblings();\n    if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            onDeleteAppropriate = true;\n            final JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n            SimpleValue key = new DependantValue(context.getMetadataCollector(), jsc.getTable(), jsc.getIdentifier());\n            jsc.setKey(key);\n            ForeignKey fk = clazzToProcess.getAnnotation(ForeignKey.class);\n            if (fk != null && !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n                key.setForeignKeyName(fk.name());\n            } else {\n                final PrimaryKeyJoinColumn pkJoinColumn = clazzToProcess.getAnnotation(PrimaryKeyJoinColumn.class);\n                final PrimaryKeyJoinColumns pkJoinColumns = clazzToProcess.getAnnotation(PrimaryKeyJoinColumns.class);\n                if (pkJoinColumns != null && pkJoinColumns.foreignKey().value() == ConstraintMode.NO_CONSTRAINT) {\n                    key.setForeignKeyName(\"none\");\n                } else if (pkJoinColumns != null && !StringHelper.isEmpty(pkJoinColumns.foreignKey().name())) {\n                    key.setForeignKeyName(pkJoinColumns.foreignKey().name());\n                } else if (pkJoinColumn != null && pkJoinColumn.foreignKey().value() == ConstraintMode.NO_CONSTRAINT) {\n                    key.setForeignKeyName(\"none\");\n                } else if (pkJoinColumn != null && !StringHelper.isEmpty(pkJoinColumn.foreignKey().name())) {\n                    key.setForeignKeyName(pkJoinColumn.foreignKey().name());\n                }\n            }\n            if (onDeleteAnn != null) {\n                key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n            } else {\n                key.setCascadeDeleteEnabled(false);\n            }\n            context.getMetadataCollector().addSecondPass(new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, context));\n            context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(jsc));\n        }\n        if (isInheritanceRoot) {\n            if (discriminatorColumn != null) {\n                if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                    bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                    entityBinder.bindDiscriminatorValue();\n                }\n            }\n        }\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (isInheritanceRoot) {\n            if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    }\n    if (onDeleteAnn != null && !onDeleteAppropriate) {\n        LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n    }\n    HashMap<String, IdentifierGeneratorDefinition> classGenerators = buildGenerators(clazzToProcess, context);\n    final InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE && inheritanceState.hasParents();\n    Set<String> idPropertiesIfIdClass = new HashSet<>();\n    boolean isIdClass = mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, context);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() > 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, context, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass = (RootClass) persistentClass;\n        context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    context.getMetadataCollector().addEntityBinding(persistentClass);\n    context.getMetadataCollector().addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n    entityBinder.processComplementaryTableDefinitions(tabAnn);\n}"
    },
    {
      "commit": "59c3baae3271247bed516fe50952b65be1a27e5b",
      "startLine": 131,
      "endLine": 146,
      "methodCode": "public static void bindClass(XClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, MetadataBuildingContext context) throws MappingException {\n    if (clazzToProcess.isAnnotationPresent(Entity.class) && clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n    }\n    InheritanceState inheritanceState = inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType = context.getMetadataCollector().getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, context);\n        bindTypeDefs(clazzToProcess, context);\n        bindFilterDefs(clazzToProcess, context);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    if (LOG.isDebugEnabled()) {\n        LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n    }\n    PersistentClass superEntity = getSuperEntity(clazzToProcess, inheritanceStatePerClass, context, inheritanceState);\n    PersistentClass persistentClass = makePersistentClass(inheritanceState, superEntity, context);\n    Entity entityAnn = clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    EntityBinder entityBinder = new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, context);\n    entityBinder.setInheritanceState(inheritanceState);\n    bindQueries(clazzToProcess, context);\n    bindFilterDefs(clazzToProcess, context);\n    bindTypeDefs(clazzToProcess, context);\n    bindFetchProfiles(clazzToProcess, context);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, context);\n    String schema = \"\";\n    String table = \"\";\n    String catalog = \"\";\n    List<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n    javax.persistence.Table tabAnn = null;\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        tabAnn = clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table = tabAnn.name();\n        schema = tabAnn.schema();\n        catalog = tabAnn.catalog();\n        uniqueConstraints = TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(clazzToProcess, context, inheritanceState, superEntity);\n    final Ejb3DiscriminatorColumn discriminatorColumn;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        discriminatorColumn = processSingleTableDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n    } else if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n        discriminatorColumn = processJoinedDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n    } else {\n        discriminatorColumn = null;\n    }\n    entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n    entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n    entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n    applyCacheSettings(entityBinder, clazzToProcess, context);\n    bindFilters(clazzToProcess, entityBinder, context);\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn = clazzToProcess.getAnnotation(Check.class);\n        String constraints = checkAnn == null ? null : checkAnn.constraints();\n        EntityTableXref denormalizedTableXref = inheritanceState.hasDenormalizedTable() ? context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()) : null;\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, denormalizedTableXref);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            LOG.invalidTableAnnotation(clazzToProcess.getName());\n        }\n        if (inheritanceState.getType() == InheritanceType.SINGLE_TABLE) {\n            entityBinder.bindTableForDiscriminatedSubclass(context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()));\n        }\n    }\n    PropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, context, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn = clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate = false;\n    final boolean isInheritanceRoot = !inheritanceState.hasParents();\n    final boolean hasSubclasses = inheritanceState.hasSiblings();\n    if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            onDeleteAppropriate = true;\n            final JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n            SimpleValue key = new DependantValue(context.getMetadataCollector(), jsc.getTable(), jsc.getIdentifier());\n            jsc.setKey(key);\n            ForeignKey fk = clazzToProcess.getAnnotation(ForeignKey.class);\n            if (fk != null && !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n                key.setForeignKeyName(fk.name());\n            } else {\n                final PrimaryKeyJoinColumn pkJoinColumn = clazzToProcess.getAnnotation(PrimaryKeyJoinColumn.class);\n                final PrimaryKeyJoinColumns pkJoinColumns = clazzToProcess.getAnnotation(PrimaryKeyJoinColumns.class);\n                if (pkJoinColumns != null && pkJoinColumns.foreignKey().value() == ConstraintMode.NO_CONSTRAINT) {\n                    key.setForeignKeyName(\"none\");\n                } else if (pkJoinColumns != null && !StringHelper.isEmpty(pkJoinColumns.foreignKey().name())) {\n                    key.setForeignKeyName(pkJoinColumns.foreignKey().name());\n                } else if (pkJoinColumn != null && pkJoinColumn.foreignKey().value() == ConstraintMode.NO_CONSTRAINT) {\n                    key.setForeignKeyName(\"none\");\n                } else if (pkJoinColumn != null && !StringHelper.isEmpty(pkJoinColumn.foreignKey().name())) {\n                    key.setForeignKeyName(pkJoinColumn.foreignKey().name());\n                }\n            }\n            if (onDeleteAnn != null) {\n                key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n            } else {\n                key.setCascadeDeleteEnabled(false);\n            }\n            context.getMetadataCollector().addSecondPass(new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, context));\n            context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(jsc));\n        }\n        if (isInheritanceRoot) {\n            if (discriminatorColumn != null) {\n                if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                    bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                    entityBinder.bindDiscriminatorValue();\n                }\n            }\n        }\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (isInheritanceRoot) {\n            if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    }\n    if (onDeleteAnn != null && !onDeleteAppropriate) {\n        LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n    }\n    HashMap<String, IdentifierGeneratorDefinition> classGenerators = buildLocalGenerators(clazzToProcess, context);\n    final InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE && inheritanceState.hasParents();\n    Set<String> idPropertiesIfIdClass = new HashSet<String>();\n    boolean isIdClass = mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, context);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() > 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, context, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass = (RootClass) persistentClass;\n        context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    context.getMetadataCollector().addEntityBinding(persistentClass);\n    context.getMetadataCollector().addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n    entityBinder.processComplementaryTableDefinitions(tabAnn);\n}"
    },
    {
      "commit": "3a813dcbb4b5cf5b13571c63ff0c66b94a83b53c",
      "startLine": 132,
      "endLine": 147,
      "methodCode": "public static void bindClass(XClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, MetadataBuildingContext context) throws MappingException {\n    if (clazzToProcess.isAnnotationPresent(Entity.class) && clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n    }\n    InheritanceState inheritanceState = inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType = context.getMetadataCollector().getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, context);\n        bindTypeDefs(clazzToProcess, context);\n        bindFilterDefs(clazzToProcess, context);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    if (LOG.isDebugEnabled()) {\n        LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n    }\n    PersistentClass superEntity = getSuperEntity(clazzToProcess, inheritanceStatePerClass, context, inheritanceState);\n    PersistentClass persistentClass = makePersistentClass(inheritanceState, superEntity, context);\n    Entity entityAnn = clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    EntityBinder entityBinder = new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, context);\n    entityBinder.setInheritanceState(inheritanceState);\n    bindQueries(clazzToProcess, context);\n    bindFilterDefs(clazzToProcess, context);\n    bindTypeDefs(clazzToProcess, context);\n    bindFetchProfiles(clazzToProcess, context);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, context);\n    String schema = \"\";\n    String table = \"\";\n    String catalog = \"\";\n    List<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n    javax.persistence.Table tabAnn = null;\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        tabAnn = clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table = tabAnn.name();\n        schema = tabAnn.schema();\n        catalog = tabAnn.catalog();\n        uniqueConstraints = TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(clazzToProcess, context, inheritanceState, superEntity);\n    final Ejb3DiscriminatorColumn discriminatorColumn;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        discriminatorColumn = processSingleTableDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n    } else if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n        discriminatorColumn = processJoinedDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n    } else {\n        discriminatorColumn = null;\n    }\n    entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n    entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n    entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n    entityBinder.setCache(determineCacheSettings(clazzToProcess, context));\n    entityBinder.setNaturalIdCache(clazzToProcess, clazzToProcess.getAnnotation(NaturalIdCache.class));\n    bindFilters(clazzToProcess, entityBinder, context);\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn = clazzToProcess.getAnnotation(Check.class);\n        String constraints = checkAnn == null ? null : checkAnn.constraints();\n        EntityTableXref denormalizedTableXref = inheritanceState.hasDenormalizedTable() ? context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()) : null;\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, denormalizedTableXref);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            LOG.invalidTableAnnotation(clazzToProcess.getName());\n        }\n        if (inheritanceState.getType() == InheritanceType.SINGLE_TABLE) {\n            entityBinder.bindTableForDiscriminatedSubclass(context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()));\n        }\n    }\n    PropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, context, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn = clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate = false;\n    final boolean isInheritanceRoot = !inheritanceState.hasParents();\n    final boolean hasSubclasses = inheritanceState.hasSiblings();\n    if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            onDeleteAppropriate = true;\n            final JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n            SimpleValue key = new DependantValue(context.getMetadataCollector(), jsc.getTable(), jsc.getIdentifier());\n            jsc.setKey(key);\n            ForeignKey fk = clazzToProcess.getAnnotation(ForeignKey.class);\n            if (fk != null && !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n                key.setForeignKeyName(fk.name());\n            } else {\n                final PrimaryKeyJoinColumn pkJoinColumn = clazzToProcess.getAnnotation(PrimaryKeyJoinColumn.class);\n                final PrimaryKeyJoinColumns pkJoinColumns = clazzToProcess.getAnnotation(PrimaryKeyJoinColumns.class);\n                if (pkJoinColumns != null && pkJoinColumns.foreignKey().value() == ConstraintMode.NO_CONSTRAINT) {\n                    key.setForeignKeyName(\"none\");\n                } else if (pkJoinColumns != null && !StringHelper.isEmpty(pkJoinColumns.foreignKey().name())) {\n                    key.setForeignKeyName(pkJoinColumns.foreignKey().name());\n                } else if (pkJoinColumn != null && pkJoinColumn.foreignKey().value() == ConstraintMode.NO_CONSTRAINT) {\n                    key.setForeignKeyName(\"none\");\n                } else if (pkJoinColumn != null && !StringHelper.isEmpty(pkJoinColumn.foreignKey().name())) {\n                    key.setForeignKeyName(pkJoinColumn.foreignKey().name());\n                }\n            }\n            if (onDeleteAnn != null) {\n                key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n            } else {\n                key.setCascadeDeleteEnabled(false);\n            }\n            context.getMetadataCollector().addSecondPass(new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, context));\n            context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(jsc));\n        }\n        if (isInheritanceRoot) {\n            if (discriminatorColumn != null) {\n                if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                    bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                    entityBinder.bindDiscriminatorValue();\n                }\n            }\n        }\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (isInheritanceRoot) {\n            if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    }\n    if (onDeleteAnn != null && !onDeleteAppropriate) {\n        LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n    }\n    HashMap<String, IdentifierGeneratorDefinition> classGenerators = buildLocalGenerators(clazzToProcess, context);\n    final InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE && inheritanceState.hasParents();\n    Set<String> idPropertiesIfIdClass = new HashSet<String>();\n    boolean isIdClass = mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, context);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() > 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, context, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass = (RootClass) persistentClass;\n        context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    context.getMetadataCollector().addEntityBinding(persistentClass);\n    context.getMetadataCollector().addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n    entityBinder.processComplementaryTableDefinitions(tabAnn);\n}"
    },
    {
      "commit": "aeb3aee62603f4e3613ed4037f2727c817a11016",
      "startLine": 132,
      "endLine": 147,
      "methodCode": "public static void bindClass(XClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, MetadataBuildingContext context) throws MappingException {\n    if (clazzToProcess.isAnnotationPresent(Entity.class) && clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n    }\n    InheritanceState inheritanceState = inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType = context.getMetadataCollector().getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, context);\n        bindTypeDefs(clazzToProcess, context);\n        bindFilterDefs(clazzToProcess, context);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    if (LOG.isDebugEnabled()) {\n        LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n    }\n    PersistentClass superEntity = getSuperEntity(clazzToProcess, inheritanceStatePerClass, context, inheritanceState);\n    PersistentClass persistentClass = makePersistentClass(inheritanceState, superEntity, context);\n    Entity entityAnn = clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    EntityBinder entityBinder = new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, context);\n    entityBinder.setInheritanceState(inheritanceState);\n    bindQueries(clazzToProcess, context);\n    bindFilterDefs(clazzToProcess, context);\n    bindTypeDefs(clazzToProcess, context);\n    bindFetchProfiles(clazzToProcess, context);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, context);\n    String schema = \"\";\n    String table = \"\";\n    String catalog = \"\";\n    List<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n    javax.persistence.Table tabAnn = null;\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        tabAnn = clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table = tabAnn.name();\n        schema = tabAnn.schema();\n        catalog = tabAnn.catalog();\n        uniqueConstraints = TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(clazzToProcess, context, inheritanceState, superEntity);\n    final Ejb3DiscriminatorColumn discriminatorColumn;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        discriminatorColumn = processSingleTableDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n    } else if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n        discriminatorColumn = processJoinedDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n    } else {\n        discriminatorColumn = null;\n    }\n    entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n    entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n    entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n    entityBinder.setCache(determineCacheSettings(clazzToProcess, context));\n    entityBinder.setNaturalIdCache(clazzToProcess, clazzToProcess.getAnnotation(NaturalIdCache.class));\n    bindFilters(clazzToProcess, entityBinder, context);\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn = clazzToProcess.getAnnotation(Check.class);\n        String constraints = checkAnn == null ? null : checkAnn.constraints();\n        EntityTableXref denormalizedTableXref = inheritanceState.hasDenormalizedTable() ? context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()) : null;\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, denormalizedTableXref);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            LOG.invalidTableAnnotation(clazzToProcess.getName());\n        }\n        if (inheritanceState.getType() == InheritanceType.SINGLE_TABLE) {\n            entityBinder.bindTableForDiscriminatedSubclass(context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()));\n        }\n    }\n    PropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, context, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn = clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate = false;\n    final boolean isInheritanceRoot = !inheritanceState.hasParents();\n    final boolean hasSubclasses = inheritanceState.hasSiblings();\n    if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            onDeleteAppropriate = true;\n            final JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n            SimpleValue key = new DependantValue(context.getMetadataCollector(), jsc.getTable(), jsc.getIdentifier());\n            jsc.setKey(key);\n            ForeignKey fk = clazzToProcess.getAnnotation(ForeignKey.class);\n            if (fk != null && !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n                key.setForeignKeyName(fk.name());\n            } else {\n                final PrimaryKeyJoinColumn pkJoinColumn = clazzToProcess.getAnnotation(PrimaryKeyJoinColumn.class);\n                final PrimaryKeyJoinColumns pkJoinColumns = clazzToProcess.getAnnotation(PrimaryKeyJoinColumns.class);\n                if (pkJoinColumns != null && pkJoinColumns.foreignKey().value() == ConstraintMode.NO_CONSTRAINT) {\n                    key.setForeignKeyName(\"none\");\n                } else if (pkJoinColumns != null && !StringHelper.isEmpty(pkJoinColumns.foreignKey().name())) {\n                    key.setForeignKeyName(pkJoinColumns.foreignKey().name());\n                } else if (pkJoinColumn != null && pkJoinColumn.foreignKey().value() == ConstraintMode.NO_CONSTRAINT) {\n                    key.setForeignKeyName(\"none\");\n                } else if (pkJoinColumn != null && !StringHelper.isEmpty(pkJoinColumn.foreignKey().name())) {\n                    key.setForeignKeyName(pkJoinColumn.foreignKey().name());\n                }\n            }\n            if (onDeleteAnn != null) {\n                key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n            } else {\n                key.setCascadeDeleteEnabled(false);\n            }\n            context.getMetadataCollector().addSecondPass(new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, context));\n            context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(jsc));\n        }\n        if (isInheritanceRoot) {\n            if (discriminatorColumn != null) {\n                if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                    bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                    entityBinder.bindDiscriminatorValue();\n                }\n            }\n        }\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (isInheritanceRoot) {\n            if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    }\n    if (onDeleteAnn != null && !onDeleteAppropriate) {\n        LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n    }\n    HashMap<String, IdentifierGeneratorDefinition> classGenerators = buildLocalGenerators(clazzToProcess, context);\n    final InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE && inheritanceState.hasParents();\n    Set<String> idPropertiesIfIdClass = new HashSet<String>();\n    boolean isIdClass = mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, context);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() > 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, context, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass = (RootClass) persistentClass;\n        context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    context.getMetadataCollector().addEntityBinding(persistentClass);\n    context.getMetadataCollector().addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n    entityBinder.processComplementaryTableDefinitions(tabAnn);\n}"
    },
    {
      "commit": "2ea122aedd0c32e5ab1c68e90dd8dd4ed33d2021",
      "startLine": 125,
      "endLine": 140,
      "methodCode": "public static void bindClass(XClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, MetadataBuildingContext context) throws MappingException {\n    if (clazzToProcess.isAnnotationPresent(Entity.class) && clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n    }\n    InheritanceState inheritanceState = inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType = context.getMetadataCollector().getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, context);\n        bindTypeDefs(clazzToProcess, context);\n        bindFilterDefs(clazzToProcess, context);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    if (LOG.isDebugEnabled()) {\n        LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n    }\n    PersistentClass superEntity = getSuperEntity(clazzToProcess, inheritanceStatePerClass, context, inheritanceState);\n    PersistentClass persistentClass = makePersistentClass(inheritanceState, superEntity, context);\n    Entity entityAnn = clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    EntityBinder entityBinder = new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, context);\n    entityBinder.setInheritanceState(inheritanceState);\n    bindQueries(clazzToProcess, context);\n    bindFilterDefs(clazzToProcess, context);\n    bindTypeDefs(clazzToProcess, context);\n    bindFetchProfiles(clazzToProcess, context);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, context);\n    String schema = \"\";\n    String table = \"\";\n    String catalog = \"\";\n    List<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n    javax.persistence.Table tabAnn = null;\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        tabAnn = clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table = tabAnn.name();\n        schema = tabAnn.schema();\n        catalog = tabAnn.catalog();\n        uniqueConstraints = TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(clazzToProcess, context, inheritanceState, superEntity);\n    final Ejb3DiscriminatorColumn discriminatorColumn;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        discriminatorColumn = processSingleTableDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n    } else if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n        discriminatorColumn = processJoinedDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n    } else {\n        discriminatorColumn = null;\n    }\n    entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n    entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n    entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n    entityBinder.setCache(determineCacheSettings(clazzToProcess, context));\n    entityBinder.setNaturalIdCache(clazzToProcess, clazzToProcess.getAnnotation(NaturalIdCache.class));\n    bindFilters(clazzToProcess, entityBinder, context);\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn = clazzToProcess.getAnnotation(Check.class);\n        String constraints = checkAnn == null ? null : checkAnn.constraints();\n        EntityTableXref denormalizedTableXref = inheritanceState.hasDenormalizedTable() ? context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()) : null;\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, denormalizedTableXref);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            LOG.invalidTableAnnotation(clazzToProcess.getName());\n        }\n        if (inheritanceState.getType() == InheritanceType.SINGLE_TABLE) {\n            entityBinder.bindTableForDiscriminatedSubclass(context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()));\n        }\n    }\n    PropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, context, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn = clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate = false;\n    final boolean isInheritanceRoot = !inheritanceState.hasParents();\n    final boolean hasSubclasses = inheritanceState.hasSiblings();\n    if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            onDeleteAppropriate = true;\n            final JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n            SimpleValue key = new DependantValue(context.getMetadataCollector(), jsc.getTable(), jsc.getIdentifier());\n            jsc.setKey(key);\n            ForeignKey fk = clazzToProcess.getAnnotation(ForeignKey.class);\n            if (fk != null && !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n                key.setForeignKeyName(fk.name());\n            } else {\n                final PrimaryKeyJoinColumn pkJoinColumn = clazzToProcess.getAnnotation(PrimaryKeyJoinColumn.class);\n                if (pkJoinColumn != null && pkJoinColumn.foreignKey() != null && !StringHelper.isEmpty(pkJoinColumn.foreignKey().name())) {\n                    key.setForeignKeyName(pkJoinColumn.foreignKey().name());\n                }\n            }\n            if (onDeleteAnn != null) {\n                key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n            } else {\n                key.setCascadeDeleteEnabled(false);\n            }\n            context.getMetadataCollector().addSecondPass(new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, context));\n            context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(jsc));\n        }\n        if (isInheritanceRoot) {\n            if (discriminatorColumn != null) {\n                if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                    bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                    entityBinder.bindDiscriminatorValue();\n                }\n            }\n        }\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (isInheritanceRoot) {\n            if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    }\n    if (onDeleteAnn != null && !onDeleteAppropriate) {\n        LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n    }\n    HashMap<String, IdentifierGeneratorDefinition> classGenerators = buildLocalGenerators(clazzToProcess, context);\n    final InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE && inheritanceState.hasParents();\n    Set<String> idPropertiesIfIdClass = new HashSet<String>();\n    boolean isIdClass = mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, context);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() > 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, context, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass = (RootClass) persistentClass;\n        context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    context.getMetadataCollector().addEntityBinding(persistentClass);\n    context.getMetadataCollector().addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n    entityBinder.processComplementaryTableDefinitions(tabAnn);\n}"
    },
    {
      "commit": "87e3f0fd28d7229b0a35032292ff32f542c22010",
      "startLine": 120,
      "endLine": 135,
      "methodCode": "public static void bindClass(XClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, MetadataBuildingContext context) throws MappingException {\n    if (clazzToProcess.isAnnotationPresent(Entity.class) && clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n    }\n    InheritanceState inheritanceState = inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType = context.getMetadataCollector().getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, context);\n        bindTypeDefs(clazzToProcess, context);\n        bindFilterDefs(clazzToProcess, context);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    if (LOG.isDebugEnabled()) {\n        LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n    }\n    PersistentClass superEntity = getSuperEntity(clazzToProcess, inheritanceStatePerClass, context, inheritanceState);\n    PersistentClass persistentClass = makePersistentClass(inheritanceState, superEntity, context);\n    Entity entityAnn = clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    EntityBinder entityBinder = new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, context);\n    entityBinder.setInheritanceState(inheritanceState);\n    bindQueries(clazzToProcess, context);\n    bindFilterDefs(clazzToProcess, context);\n    bindTypeDefs(clazzToProcess, context);\n    bindFetchProfiles(clazzToProcess, context);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, context);\n    String schema = \"\";\n    String table = \"\";\n    String catalog = \"\";\n    List<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n    javax.persistence.Table tabAnn = null;\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        tabAnn = clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table = tabAnn.name();\n        schema = tabAnn.schema();\n        catalog = tabAnn.catalog();\n        uniqueConstraints = TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(clazzToProcess, context, inheritanceState, superEntity);\n    final Ejb3DiscriminatorColumn discriminatorColumn;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        discriminatorColumn = processSingleTableDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n    } else if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n        discriminatorColumn = processJoinedDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n    } else {\n        discriminatorColumn = null;\n    }\n    entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n    entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n    entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n    entityBinder.setCache(determineCacheSettings(clazzToProcess, context));\n    entityBinder.setNaturalIdCache(clazzToProcess, clazzToProcess.getAnnotation(NaturalIdCache.class));\n    bindFilters(clazzToProcess, entityBinder, context);\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn = clazzToProcess.getAnnotation(Check.class);\n        String constraints = checkAnn == null ? null : checkAnn.constraints();\n        EntityTableXref denormalizedTableXref = inheritanceState.hasDenormalizedTable() ? context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()) : null;\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, denormalizedTableXref);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            LOG.invalidTableAnnotation(clazzToProcess.getName());\n        }\n        if (inheritanceState.getType() == InheritanceType.SINGLE_TABLE) {\n            entityBinder.bindTableForDiscriminatedSubclass(context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()));\n        }\n    }\n    PropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, context, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn = clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate = false;\n    final boolean isInheritanceRoot = !inheritanceState.hasParents();\n    final boolean hasSubclasses = inheritanceState.hasSiblings();\n    if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            onDeleteAppropriate = true;\n            final JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n            SimpleValue key = new DependantValue(context.getMetadataCollector(), jsc.getTable(), jsc.getIdentifier());\n            jsc.setKey(key);\n            ForeignKey fk = clazzToProcess.getAnnotation(ForeignKey.class);\n            if (fk != null && !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n                key.setForeignKeyName(fk.name());\n            }\n            if (onDeleteAnn != null) {\n                key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n            } else {\n                key.setCascadeDeleteEnabled(false);\n            }\n            context.getMetadataCollector().addSecondPass(new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, context));\n            context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(jsc));\n        }\n        if (isInheritanceRoot) {\n            if (discriminatorColumn != null) {\n                if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                    bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                    entityBinder.bindDiscriminatorValue();\n                }\n            }\n        }\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (isInheritanceRoot) {\n            if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    }\n    if (onDeleteAnn != null && !onDeleteAppropriate) {\n        LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n    }\n    HashMap<String, IdentifierGeneratorDefinition> classGenerators = buildLocalGenerators(clazzToProcess, context);\n    final InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE && inheritanceState.hasParents();\n    Set<String> idPropertiesIfIdClass = new HashSet<String>();\n    boolean isIdClass = mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, context);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() > 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, context, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass = (RootClass) persistentClass;\n        context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    context.getMetadataCollector().addEntityBinding(persistentClass);\n    context.getMetadataCollector().addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n    entityBinder.processComplementaryTableDefinitions(tabAnn);\n}"
    },
    {
      "commit": "9e063ffa2577f06d98a9e912bb16d20424df8d6d",
      "startLine": 120,
      "endLine": 135,
      "methodCode": "public static void bindClass(XClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, MetadataBuildingContext context) throws MappingException {\n    if (clazzToProcess.isAnnotationPresent(Entity.class) && clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n    }\n    InheritanceState inheritanceState = inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType = context.getMetadataCollector().getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, context);\n        bindTypeDefs(clazzToProcess, context);\n        bindFilterDefs(clazzToProcess, context);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    if (LOG.isDebugEnabled()) {\n        LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n    }\n    PersistentClass superEntity = getSuperEntity(clazzToProcess, inheritanceStatePerClass, context, inheritanceState);\n    PersistentClass persistentClass = makePersistentClass(inheritanceState, superEntity, context);\n    Entity entityAnn = clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    EntityBinder entityBinder = new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, context);\n    entityBinder.setInheritanceState(inheritanceState);\n    bindQueries(clazzToProcess, context);\n    bindFilterDefs(clazzToProcess, context);\n    bindTypeDefs(clazzToProcess, context);\n    bindFetchProfiles(clazzToProcess, context);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, context);\n    String schema = \"\";\n    String table = \"\";\n    String catalog = \"\";\n    List<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n    javax.persistence.Table tabAnn = null;\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        tabAnn = clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table = tabAnn.name();\n        schema = tabAnn.schema();\n        catalog = tabAnn.catalog();\n        uniqueConstraints = TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(clazzToProcess, context, inheritanceState, superEntity);\n    final Ejb3DiscriminatorColumn discriminatorColumn;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        discriminatorColumn = processSingleTableDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n    } else if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n        discriminatorColumn = processJoinedDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n    } else {\n        discriminatorColumn = null;\n    }\n    entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n    entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n    entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n    entityBinder.setCache(determineCacheSettings(clazzToProcess, context));\n    entityBinder.setNaturalIdCache(clazzToProcess, clazzToProcess.getAnnotation(NaturalIdCache.class));\n    bindFilters(clazzToProcess, entityBinder, context);\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn = clazzToProcess.getAnnotation(Check.class);\n        String constraints = checkAnn == null ? null : checkAnn.constraints();\n        EntityTableXref denormalizedTableXref = inheritanceState.hasDenormalizedTable() ? context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()) : null;\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, denormalizedTableXref);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            LOG.invalidTableAnnotation(clazzToProcess.getName());\n        }\n        if (inheritanceState.getType() == InheritanceType.SINGLE_TABLE) {\n            entityBinder.bindTableForDiscriminatedSubclass(context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()));\n        }\n    }\n    PropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, context, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn = clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate = false;\n    final boolean isInheritanceRoot = !inheritanceState.hasParents();\n    final boolean hasSubclasses = inheritanceState.hasSiblings();\n    if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            onDeleteAppropriate = true;\n            final JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n            SimpleValue key = new DependantValue(context.getMetadataCollector(), jsc.getTable(), jsc.getIdentifier());\n            jsc.setKey(key);\n            ForeignKey fk = clazzToProcess.getAnnotation(ForeignKey.class);\n            if (fk != null && !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n                key.setForeignKeyName(fk.name());\n            }\n            if (onDeleteAnn != null) {\n                key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n            } else {\n                key.setCascadeDeleteEnabled(false);\n            }\n            context.getMetadataCollector().addSecondPass(new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, context));\n            context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(jsc));\n        }\n        if (isInheritanceRoot) {\n            if (discriminatorColumn != null) {\n                if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                    bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                    entityBinder.bindDiscriminatorValue();\n                }\n            }\n        }\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (isInheritanceRoot) {\n            if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    }\n    if (onDeleteAnn != null && !onDeleteAppropriate) {\n        LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n    }\n    HashMap<String, IdentifierGeneratorDefinition> classGenerators = buildLocalGenerators(clazzToProcess, context);\n    final InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE && inheritanceState.hasParents();\n    Set<String> idPropertiesIfIdClass = new HashSet<String>();\n    boolean isIdClass = mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, context);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() > 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, context, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass = (RootClass) persistentClass;\n        context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    context.getMetadataCollector().addEntityBinding(persistentClass);\n    context.getMetadataCollector().addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n    entityBinder.processComplementaryTableDefinitions(tabAnn);\n}"
    },
    {
      "commit": "9caca0ce37d5a2763d476c6fa2471addcca710ca",
      "startLine": 120,
      "endLine": 135,
      "methodCode": "public static void bindClass(XClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, MetadataBuildingContext context) throws MappingException {\n    if (clazzToProcess.isAnnotationPresent(Entity.class) && clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n    }\n    InheritanceState inheritanceState = inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType = context.getMetadataCollector().getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, context);\n        bindTypeDefs(clazzToProcess, context);\n        bindFilterDefs(clazzToProcess, context);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    if (LOG.isDebugEnabled()) {\n        LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n    }\n    PersistentClass superEntity = getSuperEntity(clazzToProcess, inheritanceStatePerClass, context, inheritanceState);\n    PersistentClass persistentClass = makePersistentClass(inheritanceState, superEntity);\n    Entity entityAnn = clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    EntityBinder entityBinder = new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, context);\n    entityBinder.setInheritanceState(inheritanceState);\n    bindQueries(clazzToProcess, context);\n    bindFilterDefs(clazzToProcess, context);\n    bindTypeDefs(clazzToProcess, context);\n    bindFetchProfiles(clazzToProcess, context);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, context);\n    String schema = \"\";\n    String table = \"\";\n    String catalog = \"\";\n    List<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n    javax.persistence.Table tabAnn = null;\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        tabAnn = clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table = tabAnn.name();\n        schema = tabAnn.schema();\n        catalog = tabAnn.catalog();\n        uniqueConstraints = TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(clazzToProcess, context, inheritanceState, superEntity);\n    final Ejb3DiscriminatorColumn discriminatorColumn;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        discriminatorColumn = processSingleTableDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n    } else if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n        discriminatorColumn = processJoinedDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n    } else {\n        discriminatorColumn = null;\n    }\n    entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n    entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n    entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n    entityBinder.setCache(determineCacheSettings(clazzToProcess, context));\n    entityBinder.setNaturalIdCache(clazzToProcess, clazzToProcess.getAnnotation(NaturalIdCache.class));\n    bindFilters(clazzToProcess, entityBinder, context);\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn = clazzToProcess.getAnnotation(Check.class);\n        String constraints = checkAnn == null ? null : checkAnn.constraints();\n        EntityTableXref denormalizedTableXref = inheritanceState.hasDenormalizedTable() ? context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()) : null;\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, denormalizedTableXref);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            LOG.invalidTableAnnotation(clazzToProcess.getName());\n        }\n        if (inheritanceState.getType() == InheritanceType.SINGLE_TABLE) {\n            entityBinder.bindTableForDiscriminatedSubclass(context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()));\n        }\n    }\n    PropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, context, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn = clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate = false;\n    final boolean isInheritanceRoot = !inheritanceState.hasParents();\n    final boolean hasSubclasses = inheritanceState.hasSiblings();\n    if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            onDeleteAppropriate = true;\n            final JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n            SimpleValue key = new DependantValue(context.getMetadataCollector(), jsc.getTable(), jsc.getIdentifier());\n            jsc.setKey(key);\n            ForeignKey fk = clazzToProcess.getAnnotation(ForeignKey.class);\n            if (fk != null && !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n                key.setForeignKeyName(fk.name());\n            }\n            if (onDeleteAnn != null) {\n                key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n            } else {\n                key.setCascadeDeleteEnabled(false);\n            }\n            context.getMetadataCollector().addSecondPass(new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, context));\n            context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(jsc));\n        }\n        if (isInheritanceRoot) {\n            if (discriminatorColumn != null) {\n                if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                    bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                    entityBinder.bindDiscriminatorValue();\n                }\n            }\n        }\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (isInheritanceRoot) {\n            if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    }\n    if (onDeleteAnn != null && !onDeleteAppropriate) {\n        LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n    }\n    HashMap<String, IdentifierGeneratorDefinition> classGenerators = buildLocalGenerators(clazzToProcess, context);\n    final InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE && inheritanceState.hasParents();\n    Set<String> idPropertiesIfIdClass = new HashSet<String>();\n    boolean isIdClass = mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, context);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() > 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, context, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass = (RootClass) persistentClass;\n        context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    context.getMetadataCollector().addEntityBinding(persistentClass);\n    context.getMetadataCollector().addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n    entityBinder.processComplementaryTableDefinitions(tabAnn);\n}"
    },
    {
      "commit": "5329bba1ea724eabf5783c71e5127b8f84ad0fcc",
      "startLine": 115,
      "endLine": 130,
      "methodCode": "public static void bindClass(XClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, Mappings mappings) throws MappingException {\n    if (clazzToProcess.isAnnotationPresent(Entity.class) && clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n    }\n    InheritanceState inheritanceState = inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType = mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    if (LOG.isDebugEnabled()) {\n        LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n    }\n    PersistentClass superEntity = getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n    PersistentClass persistentClass = makePersistentClass(inheritanceState, superEntity);\n    Entity entityAnn = clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    EntityBinder entityBinder = new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setInheritanceState(inheritanceState);\n    bindQueries(clazzToProcess, mappings);\n    bindFilterDefs(clazzToProcess, mappings);\n    bindTypeDefs(clazzToProcess, mappings);\n    bindFetchProfiles(clazzToProcess, mappings);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n    String schema = \"\";\n    String table = \"\";\n    String catalog = \"\";\n    List<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n    javax.persistence.Table tabAnn = null;\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        tabAnn = clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table = tabAnn.name();\n        schema = tabAnn.schema();\n        catalog = tabAnn.catalog();\n        uniqueConstraints = TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n    final Ejb3DiscriminatorColumn discriminatorColumn;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        discriminatorColumn = processSingleTableDiscriminatorProperties(clazzToProcess, mappings, inheritanceState, entityBinder);\n    } else if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n        discriminatorColumn = processJoinedDiscriminatorProperties(clazzToProcess, mappings, inheritanceState, entityBinder);\n    } else {\n        discriminatorColumn = null;\n    }\n    entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n    entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n    entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n    entityBinder.setCache(determineCacheSettings(clazzToProcess, mappings));\n    entityBinder.setNaturalIdCache(clazzToProcess, clazzToProcess.getAnnotation(NaturalIdCache.class));\n    bindFilters(clazzToProcess, entityBinder, mappings);\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn = clazzToProcess.getAnnotation(Check.class);\n        String constraints = checkAnn == null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else if (clazzToProcess.isAnnotationPresent(Table.class)) {\n        LOG.invalidTableAnnotation(clazzToProcess.getName());\n    }\n    PropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn = clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate = false;\n    final boolean isInheritanceRoot = !inheritanceState.hasParents();\n    final boolean hasSubclasses = inheritanceState.hasSiblings();\n    if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            onDeleteAppropriate = true;\n            final JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n            SimpleValue key = new DependantValue(mappings, jsc.getTable(), jsc.getIdentifier());\n            jsc.setKey(key);\n            ForeignKey fk = clazzToProcess.getAnnotation(ForeignKey.class);\n            if (fk != null && !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n                key.setForeignKeyName(fk.name());\n            }\n            if (onDeleteAnn != null) {\n                key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n            } else {\n                key.setCascadeDeleteEnabled(false);\n            }\n            SecondPass sp = new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n            mappings.addSecondPass(sp);\n            mappings.addSecondPass(new CreateKeySecondPass(jsc));\n        }\n        if (isInheritanceRoot) {\n            if (discriminatorColumn != null) {\n                if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                    bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, mappings);\n                    entityBinder.bindDiscriminatorValue();\n                }\n            }\n        }\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (isInheritanceRoot) {\n            if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, mappings);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    }\n    if (onDeleteAnn != null && !onDeleteAppropriate) {\n        LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n    }\n    HashMap<String, IdGenerator> classGenerators = buildLocalGenerators(clazzToProcess, mappings);\n    final InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE && inheritanceState.hasParents();\n    Set<String> idPropertiesIfIdClass = new HashSet<String>();\n    boolean isIdClass = mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() > 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass = (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n    entityBinder.processComplementaryTableDefinitions(tabAnn);\n}"
    },
    {
      "commit": "1d9b7a06a52b56b84844513d97c535eb00d0ed8a",
      "startLine": 99,
      "endLine": 114,
      "methodCode": "public static void bindClass(XClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, Mappings mappings) throws MappingException {\n    if (clazzToProcess.isAnnotationPresent(Entity.class) && clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n    }\n    InheritanceState inheritanceState = inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType = mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    if (LOG.isDebugEnabled()) {\n        LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n    }\n    PersistentClass superEntity = getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n    PersistentClass persistentClass = makePersistentClass(inheritanceState, superEntity);\n    Entity entityAnn = clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    EntityBinder entityBinder = new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setInheritanceState(inheritanceState);\n    bindQueries(clazzToProcess, mappings);\n    bindFilterDefs(clazzToProcess, mappings);\n    bindTypeDefs(clazzToProcess, mappings);\n    bindFetchProfiles(clazzToProcess, mappings);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n    String schema = \"\";\n    String table = \"\";\n    String catalog = \"\";\n    List<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n    javax.persistence.Table tabAnn = null;\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        tabAnn = clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table = tabAnn.name();\n        schema = tabAnn.schema();\n        catalog = tabAnn.catalog();\n        uniqueConstraints = TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n    Ejb3DiscriminatorColumn discriminatorColumn = null;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        discriminatorColumn = processDiscriminatorProperties(clazzToProcess, mappings, inheritanceState, entityBinder);\n    }\n    entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n    entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n    entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n    entityBinder.setCache(determineCacheSettings(clazzToProcess, mappings));\n    entityBinder.setNaturalIdCache(clazzToProcess, clazzToProcess.getAnnotation(NaturalIdCache.class));\n    bindFilters(clazzToProcess, entityBinder, mappings);\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn = clazzToProcess.getAnnotation(Check.class);\n        String constraints = checkAnn == null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else if (clazzToProcess.isAnnotationPresent(Table.class)) {\n        LOG.invalidTableAnnotation(clazzToProcess.getName());\n    }\n    PropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn = clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate = false;\n    if (InheritanceType.JOINED.equals(inheritanceState.getType()) && inheritanceState.hasParents()) {\n        onDeleteAppropriate = true;\n        final JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n        SimpleValue key = new DependantValue(mappings, jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk = clazzToProcess.getAnnotation(ForeignKey.class);\n        if (fk != null && !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn != null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp = new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (!inheritanceState.hasParents()) {\n            if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, mappings);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n    }\n    if (onDeleteAnn != null && !onDeleteAppropriate)\n        LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n    HashMap<String, IdGenerator> classGenerators = buildLocalGenerators(clazzToProcess, mappings);\n    final InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE && inheritanceState.hasParents();\n    Set<String> idPropertiesIfIdClass = new HashSet<String>();\n    boolean isIdClass = mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() > 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass = (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n    entityBinder.processComplementaryTableDefinitions(tabAnn);\n}"
    },
    {
      "commit": "09547a9051dd0ed851d8d6c5bd90841a93db2604",
      "startLine": 98,
      "endLine": 112,
      "methodCode": "public static void bindClass(XClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, Mappings mappings) throws MappingException {\n    if (clazzToProcess.isAnnotationPresent(Entity.class) && clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n    }\n    InheritanceState inheritanceState = inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType = mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    if (LOG.isDebugEnabled()) {\n        LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n    }\n    PersistentClass superEntity = getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n    PersistentClass persistentClass = makePersistentClass(inheritanceState, superEntity);\n    Entity entityAnn = clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    EntityBinder entityBinder = new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setInheritanceState(inheritanceState);\n    bindQueries(clazzToProcess, mappings);\n    bindFilterDefs(clazzToProcess, mappings);\n    bindTypeDefs(clazzToProcess, mappings);\n    bindFetchProfiles(clazzToProcess, mappings);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n    String schema = \"\";\n    String table = \"\";\n    String catalog = \"\";\n    List<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn = clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table = tabAnn.name();\n        schema = tabAnn.schema();\n        catalog = tabAnn.catalog();\n        uniqueConstraints = TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n    Ejb3DiscriminatorColumn discriminatorColumn = null;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        discriminatorColumn = processDiscriminatorProperties(clazzToProcess, mappings, inheritanceState, entityBinder);\n    }\n    entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n    entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n    entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n    entityBinder.setCache(determineCacheSettings(clazzToProcess, mappings));\n    entityBinder.setNaturalIdCache(clazzToProcess, clazzToProcess.getAnnotation(NaturalIdCache.class));\n    bindFilters(clazzToProcess, entityBinder, mappings);\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn = clazzToProcess.getAnnotation(Check.class);\n        String constraints = checkAnn == null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else if (clazzToProcess.isAnnotationPresent(Table.class)) {\n        LOG.invalidTableAnnotation(clazzToProcess.getName());\n    }\n    PropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn = clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate = false;\n    if (InheritanceType.JOINED.equals(inheritanceState.getType()) && inheritanceState.hasParents()) {\n        onDeleteAppropriate = true;\n        final JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n        SimpleValue key = new DependantValue(mappings, jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk = clazzToProcess.getAnnotation(ForeignKey.class);\n        if (fk != null && !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn != null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp = new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (!inheritanceState.hasParents()) {\n            if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, mappings);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n    }\n    if (onDeleteAnn != null && !onDeleteAppropriate)\n        LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n    HashMap<String, IdGenerator> classGenerators = buildLocalGenerators(clazzToProcess, mappings);\n    final InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE && inheritanceState.hasParents();\n    Set<String> idPropertiesIfIdClass = new HashSet<String>();\n    boolean isIdClass = mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() > 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass = (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n}"
    },
    {
      "commit": "1569e6194b45038a210984d73d25079dd1482b3f",
      "startLine": 100,
      "endLine": 114,
      "methodCode": "public static void bindClass(XClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, Mappings mappings) throws MappingException {\n    if (clazzToProcess.isAnnotationPresent(Entity.class) && clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n    }\n    InheritanceState inheritanceState = inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType = mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    if (LOG.isDebugEnabled()) {\n        LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n    }\n    PersistentClass superEntity = getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n    PersistentClass persistentClass = makePersistentClass(inheritanceState, superEntity);\n    Entity entityAnn = clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    EntityBinder entityBinder = new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setInheritanceState(inheritanceState);\n    bindQueries(clazzToProcess, mappings);\n    bindFilterDefs(clazzToProcess, mappings);\n    bindTypeDefs(clazzToProcess, mappings);\n    bindFetchProfiles(clazzToProcess, mappings);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n    String schema = \"\";\n    String table = \"\";\n    String catalog = \"\";\n    List<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn = clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table = tabAnn.name();\n        schema = tabAnn.schema();\n        catalog = tabAnn.catalog();\n        uniqueConstraints = TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n    Ejb3DiscriminatorColumn discriminatorColumn = null;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        discriminatorColumn = processDiscriminatorProperties(clazzToProcess, mappings, inheritanceState, entityBinder);\n    }\n    entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n    entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n    entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n    entityBinder.setCache(determineCacheSettings(clazzToProcess, mappings));\n    entityBinder.setNaturalIdCache(clazzToProcess, clazzToProcess.getAnnotation(NaturalIdCache.class));\n    if (!inheritanceState.hasParents()) {\n        bindFilters(clazzToProcess, entityBinder, mappings);\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn = clazzToProcess.getAnnotation(Check.class);\n        String constraints = checkAnn == null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else if (clazzToProcess.isAnnotationPresent(Table.class)) {\n        LOG.invalidTableAnnotation(clazzToProcess.getName());\n    }\n    PropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn = clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate = false;\n    if (InheritanceType.JOINED.equals(inheritanceState.getType()) && inheritanceState.hasParents()) {\n        onDeleteAppropriate = true;\n        final JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n        SimpleValue key = new DependantValue(mappings, jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk = clazzToProcess.getAnnotation(ForeignKey.class);\n        if (fk != null && !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn != null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp = new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (!inheritanceState.hasParents()) {\n            if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, mappings);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n    }\n    if (onDeleteAnn != null && !onDeleteAppropriate)\n        LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n    HashMap<String, IdGenerator> classGenerators = buildLocalGenerators(clazzToProcess, mappings);\n    final InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE && inheritanceState.hasParents();\n    Set<String> idPropertiesIfIdClass = new HashSet<String>();\n    boolean isIdClass = mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() > 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass = (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n}"
    },
    {
      "commit": "c47352058541e14e0b80d38f94c65d939d5394f5",
      "startLine": 100,
      "endLine": 114,
      "methodCode": "public static void bindClass(XClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, Mappings mappings) throws MappingException {\n    if (clazzToProcess.isAnnotationPresent(Entity.class) && clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n    }\n    InheritanceState inheritanceState = inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType = mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    if (LOG.isDebugEnabled()) {\n        LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n    }\n    PersistentClass superEntity = getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n    PersistentClass persistentClass = makePersistentClass(inheritanceState, superEntity);\n    Entity entityAnn = clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    EntityBinder entityBinder = new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setInheritanceState(inheritanceState);\n    bindQueries(clazzToProcess, mappings);\n    bindFilterDefs(clazzToProcess, mappings);\n    bindTypeDefs(clazzToProcess, mappings);\n    bindFetchProfiles(clazzToProcess, mappings);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n    String schema = \"\";\n    String table = \"\";\n    String catalog = \"\";\n    List<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn = clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table = tabAnn.name();\n        schema = tabAnn.schema();\n        catalog = tabAnn.catalog();\n        uniqueConstraints = TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n    Ejb3DiscriminatorColumn discriminatorColumn = null;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        discriminatorColumn = processDiscriminatorProperties(clazzToProcess, mappings, inheritanceState, entityBinder);\n    }\n    entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n    entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n    entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n    entityBinder.setCache(determineCacheSettings(clazzToProcess, mappings));\n    entityBinder.setNaturalIdCache(clazzToProcess.getAnnotation(NaturalIdCache.class));\n    if (!inheritanceState.hasParents()) {\n        bindFilters(clazzToProcess, entityBinder, mappings);\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn = clazzToProcess.getAnnotation(Check.class);\n        String constraints = checkAnn == null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else if (clazzToProcess.isAnnotationPresent(Table.class)) {\n        LOG.invalidTableAnnotation(clazzToProcess.getName());\n    }\n    PropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn = clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate = false;\n    if (InheritanceType.JOINED.equals(inheritanceState.getType()) && inheritanceState.hasParents()) {\n        onDeleteAppropriate = true;\n        final JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n        SimpleValue key = new DependantValue(mappings, jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk = clazzToProcess.getAnnotation(ForeignKey.class);\n        if (fk != null && !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn != null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp = new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (!inheritanceState.hasParents()) {\n            if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, mappings);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n    }\n    if (onDeleteAnn != null && !onDeleteAppropriate)\n        LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n    HashMap<String, IdGenerator> classGenerators = buildLocalGenerators(clazzToProcess, mappings);\n    final InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE && inheritanceState.hasParents();\n    Set<String> idPropertiesIfIdClass = new HashSet<String>();\n    boolean isIdClass = mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() > 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass = (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n}"
    },
    {
      "commit": "129c0f13482b99e2705f0e234b6bc0572a95c271",
      "startLine": 99,
      "endLine": 113,
      "methodCode": "public static void bindClass(XClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, Mappings mappings) throws MappingException {\n    if (clazzToProcess.isAnnotationPresent(Entity.class) && clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n    }\n    InheritanceState inheritanceState = inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType = mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    if (LOG.isDebugEnabled()) {\n        LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n    }\n    PersistentClass superEntity = getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n    PersistentClass persistentClass = makePersistentClass(inheritanceState, superEntity);\n    Entity entityAnn = clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    EntityBinder entityBinder = new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setInheritanceState(inheritanceState);\n    bindQueries(clazzToProcess, mappings);\n    bindFilterDefs(clazzToProcess, mappings);\n    bindTypeDefs(clazzToProcess, mappings);\n    bindFetchProfiles(clazzToProcess, mappings);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n    String schema = \"\";\n    String table = \"\";\n    String catalog = \"\";\n    List<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn = clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table = tabAnn.name();\n        schema = tabAnn.schema();\n        catalog = tabAnn.catalog();\n        uniqueConstraints = TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n    Ejb3DiscriminatorColumn discriminatorColumn = null;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        discriminatorColumn = processDiscriminatorProperties(clazzToProcess, mappings, inheritanceState, entityBinder);\n    }\n    entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n    entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n    entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n    entityBinder.setCache(determineCacheSettings(clazzToProcess, mappings));\n    if (!inheritanceState.hasParents()) {\n        bindFilters(clazzToProcess, entityBinder, mappings);\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn = clazzToProcess.getAnnotation(Check.class);\n        String constraints = checkAnn == null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else if (clazzToProcess.isAnnotationPresent(Table.class)) {\n        LOG.invalidTableAnnotation(clazzToProcess.getName());\n    }\n    PropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn = clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate = false;\n    if (InheritanceType.JOINED.equals(inheritanceState.getType()) && inheritanceState.hasParents()) {\n        onDeleteAppropriate = true;\n        final JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n        SimpleValue key = new DependantValue(mappings, jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk = clazzToProcess.getAnnotation(ForeignKey.class);\n        if (fk != null && !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn != null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp = new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (!inheritanceState.hasParents()) {\n            if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, mappings);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n    }\n    if (onDeleteAnn != null && !onDeleteAppropriate)\n        LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n    HashMap<String, IdGenerator> classGenerators = buildLocalGenerators(clazzToProcess, mappings);\n    final InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE && inheritanceState.hasParents();\n    Set<String> idPropertiesIfIdClass = new HashSet<String>();\n    boolean isIdClass = mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() > 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass = (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n}"
    },
    {
      "commit": "a351c520205d18f18bc1c47091b4a62629f19de1",
      "startLine": 96,
      "endLine": 110,
      "methodCode": "public static void bindClass(XClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, Mappings mappings) throws MappingException {\n    if (clazzToProcess.isAnnotationPresent(Entity.class) && clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n    }\n    InheritanceState inheritanceState = inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType = mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n    PersistentClass superEntity = getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n    PersistentClass persistentClass = makePersistentClass(inheritanceState, superEntity);\n    Entity entityAnn = clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    EntityBinder entityBinder = new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setInheritanceState(inheritanceState);\n    bindQueries(clazzToProcess, mappings);\n    bindFilterDefs(clazzToProcess, mappings);\n    bindTypeDefs(clazzToProcess, mappings);\n    bindFetchProfiles(clazzToProcess, mappings);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n    String schema = \"\";\n    String table = \"\";\n    String catalog = \"\";\n    List<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn = clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table = tabAnn.name();\n        schema = tabAnn.schema();\n        catalog = tabAnn.catalog();\n        uniqueConstraints = TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n    Ejb3DiscriminatorColumn discriminatorColumn = null;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        discriminatorColumn = processDiscriminatorProperties(clazzToProcess, mappings, inheritanceState, entityBinder);\n    }\n    entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n    entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n    entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n    entityBinder.setCache(determineCacheSettings(clazzToProcess, mappings));\n    if (!inheritanceState.hasParents()) {\n        bindFilters(clazzToProcess, entityBinder, mappings);\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn = clazzToProcess.getAnnotation(Check.class);\n        String constraints = checkAnn == null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else if (clazzToProcess.isAnnotationPresent(Table.class))\n        LOG.invalidTableAnnotation(clazzToProcess.getName());\n    PropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn = clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate = false;\n    if (InheritanceType.JOINED.equals(inheritanceState.getType()) && inheritanceState.hasParents()) {\n        onDeleteAppropriate = true;\n        final JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n        SimpleValue key = new DependantValue(mappings, jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk = clazzToProcess.getAnnotation(ForeignKey.class);\n        if (fk != null && !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn != null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp = new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (!inheritanceState.hasParents()) {\n            if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, mappings);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n    }\n    if (onDeleteAnn != null && !onDeleteAppropriate)\n        LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n    HashMap<String, IdGenerator> classGenerators = buildLocalGenerators(clazzToProcess, mappings);\n    final InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE && inheritanceState.hasParents();\n    Set<String> idPropertiesIfIdClass = new HashSet<String>();\n    boolean isIdClass = mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() > 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass = (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n}"
    },
    {
      "commit": "ad17f89c4c29f0327c843cf5265e156d65743ab1",
      "startLine": 108,
      "endLine": 122,
      "methodCode": "public static void bindClass(XClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, Mappings mappings) throws MappingException {\n    if (clazzToProcess.isAnnotationPresent(Entity.class) && clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n    }\n    InheritanceState inheritanceState = inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType = mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n    PersistentClass superEntity = getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n    PersistentClass persistentClass = makePersistentClass(inheritanceState, superEntity);\n    Entity entityAnn = clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    EntityBinder entityBinder = new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setInheritanceState(inheritanceState);\n    bindQueries(clazzToProcess, mappings);\n    bindFilterDefs(clazzToProcess, mappings);\n    bindTypeDefs(clazzToProcess, mappings);\n    bindFetchProfiles(clazzToProcess, mappings);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n    String schema = \"\";\n    String table = \"\";\n    String catalog = \"\";\n    List<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn = clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table = tabAnn.name();\n        schema = tabAnn.schema();\n        catalog = tabAnn.catalog();\n        uniqueConstraints = TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n    Ejb3DiscriminatorColumn discriminatorColumn = null;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        discriminatorColumn = processDiscriminatorProperties(clazzToProcess, mappings, inheritanceState, entityBinder);\n    }\n    entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n    entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n    entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n    entityBinder.setCache(determineCacheSettings(clazzToProcess, mappings));\n    if (!inheritanceState.hasParents()) {\n        bindFilters(clazzToProcess, entityBinder, mappings);\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn = clazzToProcess.getAnnotation(Check.class);\n        String constraints = checkAnn == null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else if (clazzToProcess.isAnnotationPresent(Table.class))\n        LOG.invalidTableAnnotation(clazzToProcess.getName());\n    PropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn = clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate = false;\n    if (InheritanceType.JOINED.equals(inheritanceState.getType()) && inheritanceState.hasParents()) {\n        onDeleteAppropriate = true;\n        final JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n        if (persistentClass.getEntityPersisterClass() == null) {\n            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n        }\n        SimpleValue key = new DependantValue(mappings, jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk = clazzToProcess.getAnnotation(ForeignKey.class);\n        if (fk != null && !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn != null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp = new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() == null) {\n                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n            }\n        } else {\n            if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, mappings);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() == null) {\n                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n            }\n        }\n    }\n    if (onDeleteAnn != null && !onDeleteAppropriate)\n        LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n    HashMap<String, IdGenerator> classGenerators = buildLocalGenerators(clazzToProcess, mappings);\n    final InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE && inheritanceState.hasParents();\n    Set<String> idPropertiesIfIdClass = new HashSet<String>();\n    boolean isIdClass = mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() > 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass = (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n}"
    },
    {
      "commit": "a9b1425f3f07021dae556e710b2bdfdc3812661b",
      "startLine": 108,
      "endLine": 122,
      "methodCode": "public static void bindClass(XClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, Mappings mappings) throws MappingException {\n    if (clazzToProcess.isAnnotationPresent(Entity.class) && clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n    }\n    InheritanceState inheritanceState = inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType = mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    LOG.bindingEntityFromClass(clazzToProcess.getName());\n    PersistentClass superEntity = getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n    PersistentClass persistentClass = makePersistentClass(inheritanceState, superEntity);\n    Entity entityAnn = clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    EntityBinder entityBinder = new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setInheritanceState(inheritanceState);\n    bindQueries(clazzToProcess, mappings);\n    bindFilterDefs(clazzToProcess, mappings);\n    bindTypeDefs(clazzToProcess, mappings);\n    bindFetchProfiles(clazzToProcess, mappings);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n    String schema = \"\";\n    String table = \"\";\n    String catalog = \"\";\n    List<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn = clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table = tabAnn.name();\n        schema = tabAnn.schema();\n        catalog = tabAnn.catalog();\n        uniqueConstraints = TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n    Ejb3DiscriminatorColumn discriminatorColumn = null;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        discriminatorColumn = processDiscriminatorProperties(clazzToProcess, mappings, inheritanceState, entityBinder);\n    }\n    entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n    entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n    entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n    entityBinder.setCache(determineCacheSettings(clazzToProcess, mappings));\n    if (!inheritanceState.hasParents()) {\n        bindFilters(clazzToProcess, entityBinder, mappings);\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn = clazzToProcess.getAnnotation(Check.class);\n        String constraints = checkAnn == null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else if (clazzToProcess.isAnnotationPresent(Table.class))\n        LOG.invalidTableAnnotation(clazzToProcess.getName());\n    PropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn = clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate = false;\n    if (InheritanceType.JOINED.equals(inheritanceState.getType()) && inheritanceState.hasParents()) {\n        onDeleteAppropriate = true;\n        final JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n        if (persistentClass.getEntityPersisterClass() == null) {\n            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n        }\n        SimpleValue key = new DependantValue(mappings, jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk = clazzToProcess.getAnnotation(ForeignKey.class);\n        if (fk != null && !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn != null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp = new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() == null) {\n                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n            }\n        } else {\n            if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, mappings);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() == null) {\n                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n            }\n        }\n    }\n    if (onDeleteAnn != null && !onDeleteAppropriate)\n        LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n    HashMap<String, IdGenerator> classGenerators = buildLocalGenerators(clazzToProcess, mappings);\n    final InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE && inheritanceState.hasParents();\n    Set<String> idPropertiesIfIdClass = new HashSet<String>();\n    boolean isIdClass = mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() > 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass = (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n}"
    },
    {
      "commit": "34c2839dccef33a8f3abb4eaf3192c1e1d9e1814",
      "startLine": 112,
      "endLine": 126,
      "methodCode": "public static void bindClass(XClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, Mappings mappings) throws MappingException {\n    if (clazzToProcess.isAnnotationPresent(Entity.class) && clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n    }\n    InheritanceState inheritanceState = inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType = mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n    PersistentClass superEntity = getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n    PersistentClass persistentClass = makePersistentClass(inheritanceState, superEntity);\n    Entity entityAnn = clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    EntityBinder entityBinder = new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setInheritanceState(inheritanceState);\n    bindQueries(clazzToProcess, mappings);\n    bindFilterDefs(clazzToProcess, mappings);\n    bindTypeDefs(clazzToProcess, mappings);\n    bindFetchProfiles(clazzToProcess, mappings);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n    String schema = \"\";\n    String table = \"\";\n    String catalog = \"\";\n    List<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn = clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table = tabAnn.name();\n        schema = tabAnn.schema();\n        catalog = tabAnn.catalog();\n        uniqueConstraints = TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n    Ejb3DiscriminatorColumn discriminatorColumn = null;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        discriminatorColumn = processDiscriminatorProperties(clazzToProcess, mappings, inheritanceState, entityBinder);\n    }\n    entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n    entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n    entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n    entityBinder.setCache(determineCacheSettings(clazzToProcess, mappings));\n    if (!inheritanceState.hasParents()) {\n        bindFilters(clazzToProcess, entityBinder, mappings);\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn = clazzToProcess.getAnnotation(Check.class);\n        String constraints = checkAnn == null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n        }\n    }\n    PropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn = clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate = false;\n    if (InheritanceType.JOINED.equals(inheritanceState.getType()) && inheritanceState.hasParents()) {\n        onDeleteAppropriate = true;\n        final JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n        if (persistentClass.getEntityPersisterClass() == null) {\n            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n        }\n        SimpleValue key = new DependantValue(mappings, jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk = clazzToProcess.getAnnotation(ForeignKey.class);\n        if (fk != null && !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn != null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp = new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() == null) {\n                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n            }\n        } else {\n            if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, mappings);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() == null) {\n                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n            }\n        }\n    }\n    if (onDeleteAnn != null && !onDeleteAppropriate) {\n        log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n    }\n    HashMap<String, IdGenerator> classGenerators = buildLocalGenerators(clazzToProcess, mappings);\n    final InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE && inheritanceState.hasParents();\n    Set<String> idPropertiesIfIdClass = new HashSet<String>();\n    boolean isIdClass = mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() > 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass = (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n}"
    },
    {
      "commit": "bf7607e24495af5133165ae6ed6b85feecf59148",
      "startLine": 112,
      "endLine": 126,
      "methodCode": "public static void bindClass(XClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, Mappings mappings) throws MappingException {\n    if (clazzToProcess.isAnnotationPresent(Entity.class) && clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n    }\n    InheritanceState inheritanceState = inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType = mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n    PersistentClass superEntity = getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n    PersistentClass persistentClass = makePersistentClass(inheritanceState, superEntity);\n    Entity entityAnn = clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    EntityBinder entityBinder = new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setInheritanceState(inheritanceState);\n    bindQueries(clazzToProcess, mappings);\n    bindFilterDefs(clazzToProcess, mappings);\n    bindTypeDefs(clazzToProcess, mappings);\n    bindFetchProfiles(clazzToProcess, mappings);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n    String schema = \"\";\n    String table = \"\";\n    String catalog = \"\";\n    List<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn = clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table = tabAnn.name();\n        schema = tabAnn.schema();\n        catalog = tabAnn.catalog();\n        uniqueConstraints = TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n    Ejb3DiscriminatorColumn discriminatorColumn = null;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        discriminatorColumn = processDiscriminatorProperties(clazzToProcess, mappings, inheritanceState, entityBinder);\n    }\n    entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n    entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n    entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n    entityBinder.setCache(determineCacheSettings(clazzToProcess, mappings));\n    if (!inheritanceState.hasParents()) {\n        bindFilters(clazzToProcess, entityBinder, mappings);\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn = clazzToProcess.getAnnotation(Check.class);\n        String constraints = checkAnn == null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n        }\n    }\n    PropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn = clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate = false;\n    if (InheritanceType.JOINED.equals(inheritanceState.getType()) && inheritanceState.hasParents()) {\n        onDeleteAppropriate = true;\n        final JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n        if (persistentClass.getEntityPersisterClass() == null) {\n            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n        }\n        SimpleValue key = new DependantValue(mappings, jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk = clazzToProcess.getAnnotation(ForeignKey.class);\n        if (fk != null && !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn != null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp = new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() == null) {\n                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n            }\n        } else {\n            if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, mappings);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() == null) {\n                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n            }\n        }\n    }\n    if (onDeleteAnn != null && !onDeleteAppropriate) {\n        log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n    }\n    HashMap<String, IdGenerator> classGenerators = buildLocalGenerators(clazzToProcess, mappings);\n    final InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE && inheritanceState.hasParents();\n    Set<String> idPropertiesIfIdClass = new HashSet<String>();\n    boolean isIdClass = mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() > 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass = (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n}"
    },
    {
      "commit": "e14f58de29eb5f8a3de7480dbd8bc10fcc9e6185",
      "startLine": 127,
      "endLine": 141,
      "methodCode": "public static void bindClass(XClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, Mappings mappings) throws MappingException {\n    if (clazzToProcess.isAnnotationPresent(Entity.class) && clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n    }\n    InheritanceState inheritanceState = inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType = mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n    PersistentClass superEntity = getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n    bindQueries(clazzToProcess, mappings);\n    bindFilterDefs(clazzToProcess, mappings);\n    bindTypeDefs(clazzToProcess, mappings);\n    bindFetchProfiles(clazzToProcess, mappings);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n    String schema = \"\";\n    String table = \"\";\n    String catalog = \"\";\n    List<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn = clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table = tabAnn.name();\n        schema = tabAnn.schema();\n        catalog = tabAnn.catalog();\n        uniqueConstraints = TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n    Ejb3DiscriminatorColumn discriminatorColumn = null;\n    String discrimValue = null;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        javax.persistence.DiscriminatorColumn discAnn = clazzToProcess.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n        DiscriminatorType discriminatorType = discAnn != null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n        org.hibernate.annotations.DiscriminatorFormula discFormulaAnn = clazzToProcess.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n        if (!inheritanceState.hasParents()) {\n            discriminatorColumn = Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n        }\n        if (discAnn != null && inheritanceState.hasParents()) {\n            log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n        }\n        discrimValue = clazzToProcess.isAnnotationPresent(DiscriminatorValue.class) ? clazzToProcess.getAnnotation(DiscriminatorValue.class).value() : null;\n    }\n    PersistentClass persistentClass = makePersistentClass(inheritanceState, superEntity);\n    Proxy proxyAnn = clazzToProcess.getAnnotation(Proxy.class);\n    BatchSize sizeAnn = clazzToProcess.getAnnotation(BatchSize.class);\n    Where whereAnn = clazzToProcess.getAnnotation(Where.class);\n    Entity entityAnn = clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    Cache cacheAnn = determineCacheSettings(clazzToProcess, mappings);\n    EntityBinder entityBinder = new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setDiscriminatorValue(discrimValue);\n    entityBinder.setBatchSize(sizeAnn);\n    entityBinder.setProxy(proxyAnn);\n    entityBinder.setWhere(whereAnn);\n    entityBinder.setCache(cacheAnn);\n    entityBinder.setInheritanceState(inheritanceState);\n    if (!inheritanceState.hasParents()) {\n        bindFilters(clazzToProcess, entityBinder, mappings);\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn = clazzToProcess.getAnnotation(Check.class);\n        String constraints = checkAnn == null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n        }\n    }\n    PropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn = clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate = false;\n    if (InheritanceType.JOINED.equals(inheritanceState.getType()) && inheritanceState.hasParents()) {\n        onDeleteAppropriate = true;\n        final JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n        if (persistentClass.getEntityPersisterClass() == null) {\n            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n        }\n        SimpleValue key = new DependantValue(mappings, jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk = clazzToProcess.getAnnotation(ForeignKey.class);\n        if (fk != null && !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn != null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp = new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() == null) {\n                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n            }\n        } else {\n            if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, mappings);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() == null) {\n                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n            }\n        }\n    }\n    if (onDeleteAnn != null && !onDeleteAppropriate) {\n        log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n    }\n    HashMap<String, IdGenerator> classGenerators = buildLocalGenerators(clazzToProcess, mappings);\n    final InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE && inheritanceState.hasParents();\n    Set<String> idPropertiesIfIdClass = new HashSet<String>();\n    boolean isIdClass = mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() > 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass = (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n}"
    },
    {
      "commit": "f0f82e4f1ba7416ef010d5d71914a2bbde7fc22f",
      "startLine": 127,
      "endLine": 141,
      "methodCode": "public static void bindClass(XClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, Mappings mappings) throws MappingException {\n    if (clazzToProcess.isAnnotationPresent(Entity.class) && clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n    }\n    InheritanceState inheritanceState = inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType = mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n    PersistentClass superEntity = getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n    bindQueries(clazzToProcess, mappings);\n    bindFilterDefs(clazzToProcess, mappings);\n    bindTypeDefs(clazzToProcess, mappings);\n    bindFetchProfiles(clazzToProcess, mappings);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n    String schema = \"\";\n    String table = \"\";\n    String catalog = \"\";\n    List<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn = clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table = tabAnn.name();\n        schema = tabAnn.schema();\n        catalog = tabAnn.catalog();\n        uniqueConstraints = TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n    Ejb3DiscriminatorColumn discriminatorColumn = null;\n    String discrimValue = null;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        javax.persistence.DiscriminatorColumn discAnn = clazzToProcess.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n        DiscriminatorType discriminatorType = discAnn != null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n        org.hibernate.annotations.DiscriminatorFormula discFormulaAnn = clazzToProcess.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n        if (!inheritanceState.hasParents()) {\n            discriminatorColumn = Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n        }\n        if (discAnn != null && inheritanceState.hasParents()) {\n            log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n        }\n        discrimValue = clazzToProcess.isAnnotationPresent(DiscriminatorValue.class) ? clazzToProcess.getAnnotation(DiscriminatorValue.class).value() : null;\n    }\n    PersistentClass persistentClass = makePersistentClass(inheritanceState, superEntity);\n    Proxy proxyAnn = clazzToProcess.getAnnotation(Proxy.class);\n    BatchSize sizeAnn = clazzToProcess.getAnnotation(BatchSize.class);\n    Where whereAnn = clazzToProcess.getAnnotation(Where.class);\n    Entity entityAnn = clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    Cache cacheAnn = determineCacheSettings(clazzToProcess, mappings);\n    EntityBinder entityBinder = new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setDiscriminatorValue(discrimValue);\n    entityBinder.setBatchSize(sizeAnn);\n    entityBinder.setProxy(proxyAnn);\n    entityBinder.setWhere(whereAnn);\n    entityBinder.setCache(cacheAnn);\n    entityBinder.setInheritanceState(inheritanceState);\n    if (!inheritanceState.hasParents()) {\n        bindFilters(clazzToProcess, entityBinder, mappings);\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn = clazzToProcess.getAnnotation(Check.class);\n        String constraints = checkAnn == null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n        }\n    }\n    PropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn = clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate = false;\n    if (InheritanceType.JOINED.equals(inheritanceState.getType()) && inheritanceState.hasParents()) {\n        onDeleteAppropriate = true;\n        final JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n        if (persistentClass.getEntityPersisterClass() == null) {\n            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n        }\n        SimpleValue key = new DependantValue(mappings, jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk = clazzToProcess.getAnnotation(ForeignKey.class);\n        if (fk != null && !BinderHelper.isDefault(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn != null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp = new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() == null) {\n                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n            }\n        } else {\n            if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, mappings);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() == null) {\n                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n            }\n        }\n    }\n    if (onDeleteAnn != null && !onDeleteAppropriate) {\n        log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n    }\n    HashMap<String, IdGenerator> classGenerators = buildLocalGenerators(clazzToProcess, mappings);\n    final InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE && inheritanceState.hasParents();\n    Set<String> idPropertiesIfIdClass = new HashSet<String>();\n    boolean isIdClass = mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() > 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass = (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n}"
    },
    {
      "commit": "1ca2bc19a5f667e10f9a2c2b10320b9c40921563",
      "startLine": 127,
      "endLine": 141,
      "methodCode": "public static void bindClass(XClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n    if (clazzToProcess.isAnnotationPresent(Entity.class) && clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n    }\n    InheritanceState inheritanceState = inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType = mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n    PersistentClass superEntity = getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n    bindQueries(clazzToProcess, mappings);\n    bindFilterDefs(clazzToProcess, mappings);\n    bindTypeDefs(clazzToProcess, mappings);\n    bindFetchProfiles(clazzToProcess, mappings);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n    String schema = \"\";\n    String table = \"\";\n    String catalog = \"\";\n    List<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn = clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table = tabAnn.name();\n        schema = tabAnn.schema();\n        catalog = tabAnn.catalog();\n        uniqueConstraints = TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n    Ejb3DiscriminatorColumn discriminatorColumn = null;\n    String discrimValue = null;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        javax.persistence.DiscriminatorColumn discAnn = clazzToProcess.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n        DiscriminatorType discriminatorType = discAnn != null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n        org.hibernate.annotations.DiscriminatorFormula discFormulaAnn = clazzToProcess.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n        if (!inheritanceState.hasParents()) {\n            discriminatorColumn = Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n        }\n        if (discAnn != null && inheritanceState.hasParents()) {\n            log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n        }\n        discrimValue = clazzToProcess.isAnnotationPresent(DiscriminatorValue.class) ? clazzToProcess.getAnnotation(DiscriminatorValue.class).value() : null;\n    }\n    PersistentClass persistentClass = makePersistentClass(inheritanceState, superEntity);\n    Proxy proxyAnn = clazzToProcess.getAnnotation(Proxy.class);\n    BatchSize sizeAnn = clazzToProcess.getAnnotation(BatchSize.class);\n    Where whereAnn = clazzToProcess.getAnnotation(Where.class);\n    Entity entityAnn = clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    Cache cacheAnn = determineCacheSettings(clazzToProcess, mappings);\n    EntityBinder entityBinder = new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setDiscriminatorValue(discrimValue);\n    entityBinder.setBatchSize(sizeAnn);\n    entityBinder.setProxy(proxyAnn);\n    entityBinder.setWhere(whereAnn);\n    entityBinder.setCache(cacheAnn);\n    entityBinder.setInheritanceState(inheritanceState);\n    if (!inheritanceState.hasParents()) {\n        bindFilters(clazzToProcess, entityBinder, mappings);\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn = clazzToProcess.getAnnotation(Check.class);\n        String constraints = checkAnn == null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n        }\n    }\n    PropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn = clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate = false;\n    if (InheritanceType.JOINED.equals(inheritanceState.getType()) && inheritanceState.hasParents()) {\n        onDeleteAppropriate = true;\n        final JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n        if (persistentClass.getEntityPersisterClass() == null) {\n            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n        }\n        SimpleValue key = new DependantValue(mappings, jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk = clazzToProcess.getAnnotation(ForeignKey.class);\n        if (fk != null && !BinderHelper.isDefault(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn != null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp = new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() == null) {\n                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n            }\n        } else {\n            if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, mappings);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() == null) {\n                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n            }\n        }\n    }\n    if (onDeleteAnn != null && !onDeleteAppropriate) {\n        log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n    }\n    HashMap<String, IdGenerator> classGenerators = buildLocalGenerators(clazzToProcess, mappings);\n    final InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE && inheritanceState.hasParents();\n    Set<String> idPropertiesIfIdClass = new HashSet<String>();\n    boolean isIdClass = mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() > 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass = (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n}"
    },
    {
      "commit": "421789ddcd906e806bf901fea9d9e713daebd51a",
      "startLine": 127,
      "endLine": 141,
      "methodCode": "public static void bindClass(XClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n    if (clazzToProcess.isAnnotationPresent(Entity.class) && clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n    }\n    InheritanceState inheritanceState = inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType = mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n    PersistentClass superEntity = getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n    bindQueries(clazzToProcess, mappings);\n    bindFilterDefs(clazzToProcess, mappings);\n    bindTypeDefs(clazzToProcess, mappings);\n    bindFetchProfiles(clazzToProcess, mappings);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n    String schema = \"\";\n    String table = \"\";\n    String catalog = \"\";\n    List<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn = clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table = tabAnn.name();\n        schema = tabAnn.schema();\n        catalog = tabAnn.catalog();\n        uniqueConstraints = TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n    Ejb3DiscriminatorColumn discriminatorColumn = null;\n    String discrimValue = null;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        javax.persistence.DiscriminatorColumn discAnn = clazzToProcess.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n        DiscriminatorType discriminatorType = discAnn != null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n        org.hibernate.annotations.DiscriminatorFormula discFormulaAnn = clazzToProcess.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n        if (!inheritanceState.hasParents()) {\n            discriminatorColumn = Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n        }\n        if (discAnn != null && inheritanceState.hasParents()) {\n            log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n        }\n        discrimValue = clazzToProcess.isAnnotationPresent(DiscriminatorValue.class) ? clazzToProcess.getAnnotation(DiscriminatorValue.class).value() : null;\n    }\n    PersistentClass persistentClass = makePersistentClass(inheritanceState, superEntity);\n    Proxy proxyAnn = clazzToProcess.getAnnotation(Proxy.class);\n    BatchSize sizeAnn = clazzToProcess.getAnnotation(BatchSize.class);\n    Where whereAnn = clazzToProcess.getAnnotation(Where.class);\n    Entity entityAnn = clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    Cache cacheAnn = determineCacheSettings(clazzToProcess, mappings);\n    EntityBinder entityBinder = new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setDiscriminatorValue(discrimValue);\n    entityBinder.setBatchSize(sizeAnn);\n    entityBinder.setProxy(proxyAnn);\n    entityBinder.setWhere(whereAnn);\n    entityBinder.setCache(cacheAnn);\n    entityBinder.setInheritanceState(inheritanceState);\n    if (!inheritanceState.hasParents()) {\n        bindFilters(clazzToProcess, entityBinder, mappings);\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn = clazzToProcess.getAnnotation(Check.class);\n        String constraints = checkAnn == null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n        }\n    }\n    PropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn = clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate = false;\n    if (InheritanceType.JOINED.equals(inheritanceState.getType()) && inheritanceState.hasParents()) {\n        onDeleteAppropriate = true;\n        final JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n        if (persistentClass.getEntityPersisterClass() == null) {\n            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n        }\n        SimpleValue key = new DependantValue(mappings, jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk = clazzToProcess.getAnnotation(ForeignKey.class);\n        if (fk != null && !BinderHelper.isDefault(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn != null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp = new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() == null) {\n                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n            }\n        } else {\n            if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, mappings);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() == null) {\n                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n            }\n        }\n    }\n    if (onDeleteAnn != null && !onDeleteAppropriate) {\n        log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n    }\n    HashMap<String, IdGenerator> classGenerators = buildLocalGenerators(clazzToProcess, mappings);\n    final InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE && inheritanceState.hasParents();\n    Set<String> idPropertiesIfIdClass = new HashSet<String>();\n    boolean isIdClass = mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() > 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass = (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n}"
    },
    {
      "commit": "422ecc653a7d78ee0464478750a076710b697849",
      "startLine": 127,
      "endLine": 141,
      "methodCode": "public static void bindClass(XClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n    if (clazzToProcess.isAnnotationPresent(Entity.class) && clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n    }\n    InheritanceState inheritanceState = inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType = mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n    PersistentClass superEntity = getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n    bindQueries(clazzToProcess, mappings);\n    bindFilterDefs(clazzToProcess, mappings);\n    bindTypeDefs(clazzToProcess, mappings);\n    bindFetchProfiles(clazzToProcess, mappings);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n    String schema = \"\";\n    String table = \"\";\n    String catalog = \"\";\n    List<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn = clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table = tabAnn.name();\n        schema = tabAnn.schema();\n        catalog = tabAnn.catalog();\n        uniqueConstraints = TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n    Ejb3DiscriminatorColumn discriminatorColumn = null;\n    String discrimValue = null;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        javax.persistence.DiscriminatorColumn discAnn = clazzToProcess.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n        DiscriminatorType discriminatorType = discAnn != null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n        org.hibernate.annotations.DiscriminatorFormula discFormulaAnn = clazzToProcess.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n        if (!inheritanceState.hasParents()) {\n            discriminatorColumn = Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n        }\n        if (discAnn != null && inheritanceState.hasParents()) {\n            log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n        }\n        discrimValue = clazzToProcess.isAnnotationPresent(DiscriminatorValue.class) ? clazzToProcess.getAnnotation(DiscriminatorValue.class).value() : null;\n    }\n    PersistentClass persistentClass = makePersistentClass(inheritanceState, superEntity);\n    Proxy proxyAnn = clazzToProcess.getAnnotation(Proxy.class);\n    BatchSize sizeAnn = clazzToProcess.getAnnotation(BatchSize.class);\n    Where whereAnn = clazzToProcess.getAnnotation(Where.class);\n    Entity entityAnn = clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    Cache cacheAnn = determineCacheSettings(clazzToProcess, mappings);\n    EntityBinder entityBinder = new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setDiscriminatorValue(discrimValue);\n    entityBinder.setBatchSize(sizeAnn);\n    entityBinder.setProxy(proxyAnn);\n    entityBinder.setWhere(whereAnn);\n    entityBinder.setCache(cacheAnn);\n    entityBinder.setInheritanceState(inheritanceState);\n    if (!inheritanceState.hasParents()) {\n        bindFilters(clazzToProcess, entityBinder, mappings);\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn = clazzToProcess.getAnnotation(Check.class);\n        String constraints = checkAnn == null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n        }\n    }\n    PropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn = clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate = false;\n    if (InheritanceType.JOINED.equals(inheritanceState.getType()) && inheritanceState.hasParents()) {\n        onDeleteAppropriate = true;\n        final JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n        if (persistentClass.getEntityPersisterClass() == null) {\n            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n        }\n        SimpleValue key = new DependantValue(jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk = clazzToProcess.getAnnotation(ForeignKey.class);\n        if (fk != null && !BinderHelper.isDefault(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn != null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp = new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() == null) {\n                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n            }\n        } else {\n            if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() == null) {\n                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n            }\n        }\n    }\n    if (onDeleteAnn != null && !onDeleteAppropriate) {\n        log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n    }\n    HashMap<String, IdGenerator> classGenerators = buildLocalGenerators(clazzToProcess, mappings);\n    final InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE && inheritanceState.hasParents();\n    Set<String> idPropertiesIfIdClass = new HashSet<String>();\n    boolean isIdClass = mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() > 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass = (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n}"
    },
    {
      "commit": "153ad753e19b1f71665e6cfcbd903fb1ced889db",
      "startLine": 124,
      "endLine": 138,
      "methodCode": "public static void bindClass(XClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n    InheritanceState inheritanceState = inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType = mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n    PersistentClass superEntity = getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n    bindQueries(clazzToProcess, mappings);\n    bindFilterDefs(clazzToProcess, mappings);\n    bindTypeDefs(clazzToProcess, mappings);\n    bindFetchProfiles(clazzToProcess, mappings);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n    String schema = \"\";\n    String table = \"\";\n    String catalog = \"\";\n    List<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn = clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table = tabAnn.name();\n        schema = tabAnn.schema();\n        catalog = tabAnn.catalog();\n        uniqueConstraints = TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n    Ejb3DiscriminatorColumn discriminatorColumn = null;\n    String discrimValue = null;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        javax.persistence.DiscriminatorColumn discAnn = clazzToProcess.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n        DiscriminatorType discriminatorType = discAnn != null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n        org.hibernate.annotations.DiscriminatorFormula discFormulaAnn = clazzToProcess.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n        if (!inheritanceState.hasParents()) {\n            discriminatorColumn = Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n        }\n        if (discAnn != null && inheritanceState.hasParents()) {\n            log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n        }\n        discrimValue = clazzToProcess.isAnnotationPresent(DiscriminatorValue.class) ? clazzToProcess.getAnnotation(DiscriminatorValue.class).value() : null;\n    }\n    PersistentClass persistentClass = makePersistentClass(inheritanceState, superEntity);\n    Proxy proxyAnn = clazzToProcess.getAnnotation(Proxy.class);\n    BatchSize sizeAnn = clazzToProcess.getAnnotation(BatchSize.class);\n    Where whereAnn = clazzToProcess.getAnnotation(Where.class);\n    Entity entityAnn = clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    Cache cacheAnn = determineCacheSettings(clazzToProcess, mappings);\n    EntityBinder entityBinder = new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setDiscriminatorValue(discrimValue);\n    entityBinder.setBatchSize(sizeAnn);\n    entityBinder.setProxy(proxyAnn);\n    entityBinder.setWhere(whereAnn);\n    entityBinder.setCache(cacheAnn);\n    entityBinder.setInheritanceState(inheritanceState);\n    if (!inheritanceState.hasParents()) {\n        bindFilters(clazzToProcess, entityBinder, mappings);\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn = clazzToProcess.getAnnotation(Check.class);\n        String constraints = checkAnn == null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n        }\n    }\n    PropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn = clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate = false;\n    if (InheritanceType.JOINED.equals(inheritanceState.getType()) && inheritanceState.hasParents()) {\n        onDeleteAppropriate = true;\n        final JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n        if (persistentClass.getEntityPersisterClass() == null) {\n            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n        }\n        SimpleValue key = new DependantValue(jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk = clazzToProcess.getAnnotation(ForeignKey.class);\n        if (fk != null && !BinderHelper.isDefault(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn != null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp = new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() == null) {\n                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n            }\n        } else {\n            if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() == null) {\n                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n            }\n        }\n    }\n    if (onDeleteAnn != null && !onDeleteAppropriate) {\n        log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n    }\n    HashMap<String, IdGenerator> classGenerators = buildLocalGenerators(clazzToProcess, mappings);\n    final InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE && inheritanceState.hasParents();\n    Set<String> idPropertiesIfIdClass = new HashSet<String>();\n    boolean isIdClass = mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() > 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass = (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n}"
    },
    {
      "commit": "8478d5b44b6c8d72b386d7a1a2841bfe7b37fb08",
      "startLine": 123,
      "endLine": 137,
      "methodCode": "public static void bindClass(XClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n    InheritanceState inheritanceState = inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType = mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n    PersistentClass superEntity = getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n    bindQueries(clazzToProcess, mappings);\n    bindFilterDefs(clazzToProcess, mappings);\n    bindTypeDefs(clazzToProcess, mappings);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n    String schema = \"\";\n    String table = \"\";\n    String catalog = \"\";\n    List<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn = clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table = tabAnn.name();\n        schema = tabAnn.schema();\n        catalog = tabAnn.catalog();\n        uniqueConstraints = TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n    Ejb3DiscriminatorColumn discriminatorColumn = null;\n    String discrimValue = null;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        javax.persistence.DiscriminatorColumn discAnn = clazzToProcess.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n        DiscriminatorType discriminatorType = discAnn != null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n        org.hibernate.annotations.DiscriminatorFormula discFormulaAnn = clazzToProcess.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n        if (!inheritanceState.hasParents()) {\n            discriminatorColumn = Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n        }\n        if (discAnn != null && inheritanceState.hasParents()) {\n            log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n        }\n        discrimValue = clazzToProcess.isAnnotationPresent(DiscriminatorValue.class) ? clazzToProcess.getAnnotation(DiscriminatorValue.class).value() : null;\n    }\n    PersistentClass persistentClass = makePersistentClass(inheritanceState, superEntity);\n    Proxy proxyAnn = clazzToProcess.getAnnotation(Proxy.class);\n    BatchSize sizeAnn = clazzToProcess.getAnnotation(BatchSize.class);\n    Where whereAnn = clazzToProcess.getAnnotation(Where.class);\n    Entity entityAnn = clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    Cache cacheAnn = determineCacheSettings(clazzToProcess, mappings);\n    EntityBinder entityBinder = new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setDiscriminatorValue(discrimValue);\n    entityBinder.setBatchSize(sizeAnn);\n    entityBinder.setProxy(proxyAnn);\n    entityBinder.setWhere(whereAnn);\n    entityBinder.setCache(cacheAnn);\n    entityBinder.setInheritanceState(inheritanceState);\n    if (!inheritanceState.hasParents()) {\n        bindFilters(clazzToProcess, entityBinder, mappings);\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn = clazzToProcess.getAnnotation(Check.class);\n        String constraints = checkAnn == null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n        }\n    }\n    PropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn = clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate = false;\n    if (InheritanceType.JOINED.equals(inheritanceState.getType()) && inheritanceState.hasParents()) {\n        onDeleteAppropriate = true;\n        final JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n        if (persistentClass.getEntityPersisterClass() == null) {\n            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n        }\n        SimpleValue key = new DependantValue(jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk = clazzToProcess.getAnnotation(ForeignKey.class);\n        if (fk != null && !BinderHelper.isDefault(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn != null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp = new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() == null) {\n                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n            }\n        } else {\n            if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() == null) {\n                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n            }\n        }\n    }\n    if (onDeleteAnn != null && !onDeleteAppropriate) {\n        log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n    }\n    HashMap<String, IdGenerator> classGenerators = buildLocalGenerators(clazzToProcess, mappings);\n    final InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE && inheritanceState.hasParents();\n    Set<String> idPropertiesIfIdClass = new HashSet<String>();\n    boolean isIdClass = mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() > 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass = (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n}"
    },
    {
      "commit": "252299cfee96892b71b3bd3e200181089e350e27",
      "startLine": 124,
      "endLine": 190,
      "methodCode": "public static void bindClass(XClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n    InheritanceState inheritanceState = inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType = mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n    PersistentClass superEntity = getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n    bindQueries(clazzToProcess, mappings);\n    bindFilterDefs(clazzToProcess, mappings);\n    bindTypeDefs(clazzToProcess, mappings);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n    String schema = \"\";\n    String table = \"\";\n    String catalog = \"\";\n    List<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn = clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table = tabAnn.name();\n        schema = tabAnn.schema();\n        catalog = tabAnn.catalog();\n        uniqueConstraints = TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n    Ejb3DiscriminatorColumn discriminatorColumn = null;\n    String discrimValue = null;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        javax.persistence.DiscriminatorColumn discAnn = clazzToProcess.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n        DiscriminatorType discriminatorType = discAnn != null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n        org.hibernate.annotations.DiscriminatorFormula discFormulaAnn = clazzToProcess.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n        if (!inheritanceState.hasParents()) {\n            discriminatorColumn = Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n        }\n        if (discAnn != null && inheritanceState.hasParents()) {\n            log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n        }\n        discrimValue = clazzToProcess.isAnnotationPresent(DiscriminatorValue.class) ? clazzToProcess.getAnnotation(DiscriminatorValue.class).value() : null;\n    }\n    PersistentClass persistentClass = makePersistentClass(inheritanceState, superEntity);\n    Proxy proxyAnn = clazzToProcess.getAnnotation(Proxy.class);\n    BatchSize sizeAnn = clazzToProcess.getAnnotation(BatchSize.class);\n    Where whereAnn = clazzToProcess.getAnnotation(Where.class);\n    Entity entityAnn = clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    Cache cacheAnn = determineCacheSettings(clazzToProcess, mappings);\n    EntityBinder entityBinder = new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setDiscriminatorValue(discrimValue);\n    entityBinder.setBatchSize(sizeAnn);\n    entityBinder.setProxy(proxyAnn);\n    entityBinder.setWhere(whereAnn);\n    entityBinder.setCache(cacheAnn);\n    entityBinder.setInheritanceState(inheritanceState);\n    if (!inheritanceState.hasParents()) {\n        bindFilters(clazzToProcess, entityBinder, mappings);\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn = clazzToProcess.getAnnotation(Check.class);\n        String constraints = checkAnn == null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n        }\n    }\n    PropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn = clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate = false;\n    if (InheritanceType.JOINED.equals(inheritanceState.getType()) && inheritanceState.hasParents()) {\n        onDeleteAppropriate = true;\n        final JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n        if (persistentClass.getEntityPersisterClass() == null) {\n            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n        }\n        SimpleValue key = new DependantValue(jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk = clazzToProcess.getAnnotation(ForeignKey.class);\n        if (fk != null && !BinderHelper.isDefault(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn != null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp = new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() == null) {\n                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n            }\n        } else {\n            if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() == null) {\n                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n            }\n        }\n    }\n    if (onDeleteAnn != null && !onDeleteAppropriate) {\n        log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n    }\n    HashMap<String, IdGenerator> classGenerators = buildLocalGenerators(clazzToProcess, mappings);\n    final InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE && inheritanceState.hasParents();\n    Set<String> idProperties = new HashSet<String>();\n    XClass classWithIdClass = inheritanceState.getClassWithIdClass(false);\n    if (classWithIdClass != null) {\n        IdClass idClass = classWithIdClass.getAnnotation(IdClass.class);\n        XClass compositeClass = mappings.getReflectionManager().toXClass(idClass.value());\n        boolean isComponent = true;\n        AccessType propertyAccessor = entityBinder.getPropertyAccessor(compositeClass);\n        String generatorType = \"assigned\";\n        String generator = BinderHelper.ANNOTATION_STRING_DEFAULT;\n        PropertyData inferredData = new PropertyPreloadedData(entityBinder.getPropertyAccessType(), \"id\", compositeClass);\n        PropertyData baseInferredData = new PropertyPreloadedData(entityBinder.getPropertyAccessType(), \"id\", classWithIdClass);\n        HashMap<String, IdGenerator> localGenerators = new HashMap<String, IdGenerator>();\n        boolean ignoreIdAnnotations = entityBinder.isIgnoreIdAnnotations();\n        entityBinder.setIgnoreIdAnnotations(true);\n        propertyHolder.setInIdClass(true);\n        bindId(generatorType, generator, inferredData, baseInferredData, null, propertyHolder, localGenerators, isComponent, propertyAccessor, entityBinder, true, false, mappings, inheritanceStatePerClass);\n        propertyHolder.setInIdClass(null);\n        inferredData = new PropertyPreloadedData(propertyAccessor, \"_identifierMapper\", compositeClass);\n        Component mapper = fillComponent(propertyHolder, inferredData, baseInferredData, propertyAccessor, false, entityBinder, true, true, false, mappings, inheritanceStatePerClass);\n        entityBinder.setIgnoreIdAnnotations(ignoreIdAnnotations);\n        persistentClass.setIdentifierMapper(mapper);\n        final org.hibernate.mapping.MappedSuperclass superclass = BinderHelper.getMappedSuperclassOrNull(inferredData.getDeclaringClass(), inheritanceStatePerClass, mappings);\n        if (superclass != null) {\n            superclass.setDeclaredIdentifierMapper(mapper);\n        } else {\n            persistentClass.setDeclaredIdentifierMapper(mapper);\n        }\n        Property property = new Property();\n        property.setName(\"_identifierMapper\");\n        property.setNodeName(\"id\");\n        property.setUpdateable(false);\n        property.setInsertable(false);\n        property.setValue(mapper);\n        property.setPropertyAccessorName(\"embedded\");\n        persistentClass.addProperty(property);\n        entityBinder.setIgnoreIdAnnotations(true);\n        Iterator properties = mapper.getPropertyIterator();\n        while (properties.hasNext()) {\n            idProperties.add(((Property) properties.next()).getName());\n        }\n    } else {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() > 1);\n    }\n    Set<String> missingIdProperties = new HashSet<String>(idProperties);\n    for (PropertyData propertyAnnotatedElement : elementsToProcess.getElements()) {\n        String propertyName = propertyAnnotatedElement.getPropertyName();\n        if (!idProperties.contains(propertyName)) {\n            processElementAnnotations(propertyHolder, subclassAndSingleTableStrategy ? Nullability.FORCED_NULL : Nullability.NO_CONSTRAINT, propertyAnnotatedElement.getProperty(), propertyAnnotatedElement, classGenerators, entityBinder, false, false, false, mappings, inheritanceStatePerClass);\n        } else {\n            missingIdProperties.remove(propertyName);\n        }\n    }\n    if (missingIdProperties.size() != 0) {\n        StringBuilder missings = new StringBuilder();\n        for (String property : missingIdProperties) {\n            missings.append(property).append(\", \");\n        }\n        throw new AnnotationException(\"Unable to find properties (\" + missings.substring(0, missings.length() - 2) + \") in entity annotated with @IdClass:\" + persistentClass.getEntityName());\n    }\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass = (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n}"
    },
    {
      "commit": "5ee9ba361c96c29b06542720cb8b01e1034d8544",
      "startLine": 124,
      "endLine": 188,
      "methodCode": "public static void bindClass(XClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n    InheritanceState inheritanceState = inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType = mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n    PersistentClass superEntity = getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n    bindQueries(clazzToProcess, mappings);\n    bindFilterDefs(clazzToProcess, mappings);\n    bindTypeDefs(clazzToProcess, mappings);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n    String schema = \"\";\n    String table = \"\";\n    String catalog = \"\";\n    List<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn = clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table = tabAnn.name();\n        schema = tabAnn.schema();\n        catalog = tabAnn.catalog();\n        uniqueConstraints = TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n    Ejb3DiscriminatorColumn discriminatorColumn = null;\n    String discrimValue = null;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        javax.persistence.DiscriminatorColumn discAnn = clazzToProcess.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n        DiscriminatorType discriminatorType = discAnn != null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n        org.hibernate.annotations.DiscriminatorFormula discFormulaAnn = clazzToProcess.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n        if (!inheritanceState.hasParents()) {\n            discriminatorColumn = Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n        }\n        if (discAnn != null && inheritanceState.hasParents()) {\n            log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n        }\n        discrimValue = clazzToProcess.isAnnotationPresent(DiscriminatorValue.class) ? clazzToProcess.getAnnotation(DiscriminatorValue.class).value() : null;\n    }\n    PersistentClass persistentClass = makePersistentClass(inheritanceState, superEntity);\n    Proxy proxyAnn = clazzToProcess.getAnnotation(Proxy.class);\n    BatchSize sizeAnn = clazzToProcess.getAnnotation(BatchSize.class);\n    Where whereAnn = clazzToProcess.getAnnotation(Where.class);\n    Entity entityAnn = clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    Cache cacheAnn = determineCacheSettings(clazzToProcess, mappings);\n    EntityBinder entityBinder = new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setDiscriminatorValue(discrimValue);\n    entityBinder.setBatchSize(sizeAnn);\n    entityBinder.setProxy(proxyAnn);\n    entityBinder.setWhere(whereAnn);\n    entityBinder.setCache(cacheAnn);\n    entityBinder.setInheritanceState(inheritanceState);\n    if (!inheritanceState.hasParents()) {\n        bindFilters(clazzToProcess, entityBinder, mappings);\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn = clazzToProcess.getAnnotation(Check.class);\n        String constraints = checkAnn == null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n        }\n    }\n    PropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn = clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate = false;\n    if (InheritanceType.JOINED.equals(inheritanceState.getType()) && inheritanceState.hasParents()) {\n        onDeleteAppropriate = true;\n        final JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n        if (persistentClass.getEntityPersisterClass() == null) {\n            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n        }\n        SimpleValue key = new DependantValue(jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk = clazzToProcess.getAnnotation(ForeignKey.class);\n        if (fk != null && !BinderHelper.isDefault(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn != null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp = new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() == null) {\n                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n            }\n        } else {\n            if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() == null) {\n                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n            }\n        }\n    }\n    if (onDeleteAnn != null && !onDeleteAppropriate) {\n        log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n    }\n    HashMap<String, IdGenerator> classGenerators = buildLocalGenerators(clazzToProcess, mappings);\n    final InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE && inheritanceState.hasParents();\n    Set<String> idProperties = new HashSet<String>();\n    XClass classWithIdClass = inheritanceState.getClassWithIdClass(false);\n    if (classWithIdClass != null) {\n        IdClass idClass = classWithIdClass.getAnnotation(IdClass.class);\n        XClass compositeClass = mappings.getReflectionManager().toXClass(idClass.value());\n        boolean isComponent = true;\n        AccessType propertyAccessor = entityBinder.getPropertyAccessor(compositeClass);\n        String generatorType = \"assigned\";\n        String generator = BinderHelper.ANNOTATION_STRING_DEFAULT;\n        PropertyData inferredData = new PropertyPreloadedData(entityBinder.getPropertyAccessType(), \"id\", compositeClass);\n        PropertyData baseInferredData = new PropertyPreloadedData(entityBinder.getPropertyAccessType(), \"id\", classWithIdClass);\n        HashMap<String, IdGenerator> localGenerators = new HashMap<String, IdGenerator>();\n        boolean ignoreIdAnnotations = entityBinder.isIgnoreIdAnnotations();\n        entityBinder.setIgnoreIdAnnotations(true);\n        bindId(generatorType, generator, inferredData, baseInferredData, null, propertyHolder, localGenerators, isComponent, propertyAccessor, entityBinder, true, false, mappings, inheritanceStatePerClass);\n        inferredData = new PropertyPreloadedData(propertyAccessor, \"_identifierMapper\", compositeClass);\n        Component mapper = fillComponent(propertyHolder, inferredData, baseInferredData, propertyAccessor, false, entityBinder, true, true, false, mappings, inheritanceStatePerClass);\n        entityBinder.setIgnoreIdAnnotations(ignoreIdAnnotations);\n        persistentClass.setIdentifierMapper(mapper);\n        final org.hibernate.mapping.MappedSuperclass superclass = BinderHelper.getMappedSuperclassOrNull(inferredData.getDeclaringClass(), inheritanceStatePerClass, mappings);\n        if (superclass != null) {\n            superclass.setDeclaredIdentifierMapper(mapper);\n        } else {\n            persistentClass.setDeclaredIdentifierMapper(mapper);\n        }\n        Property property = new Property();\n        property.setName(\"_identifierMapper\");\n        property.setNodeName(\"id\");\n        property.setUpdateable(false);\n        property.setInsertable(false);\n        property.setValue(mapper);\n        property.setPropertyAccessorName(\"embedded\");\n        persistentClass.addProperty(property);\n        entityBinder.setIgnoreIdAnnotations(true);\n        Iterator properties = mapper.getPropertyIterator();\n        while (properties.hasNext()) {\n            idProperties.add(((Property) properties.next()).getName());\n        }\n    } else {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() > 1);\n    }\n    Set<String> missingIdProperties = new HashSet<String>(idProperties);\n    for (PropertyData propertyAnnotatedElement : elementsToProcess.getElements()) {\n        String propertyName = propertyAnnotatedElement.getPropertyName();\n        if (!idProperties.contains(propertyName)) {\n            processElementAnnotations(propertyHolder, subclassAndSingleTableStrategy ? Nullability.FORCED_NULL : Nullability.NO_CONSTRAINT, propertyAnnotatedElement.getProperty(), propertyAnnotatedElement, classGenerators, entityBinder, false, false, false, mappings, inheritanceStatePerClass);\n        } else {\n            missingIdProperties.remove(propertyName);\n        }\n    }\n    if (missingIdProperties.size() != 0) {\n        StringBuilder missings = new StringBuilder();\n        for (String property : missingIdProperties) {\n            missings.append(property).append(\", \");\n        }\n        throw new AnnotationException(\"Unable to find properties (\" + missings.substring(0, missings.length() - 2) + \") in entity annotated with @IdClass:\" + persistentClass.getEntityName());\n    }\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass = (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n}"
    },
    {
      "commit": "d00f7efb308fab613b4918f9b8831f07602c6bd0",
      "startLine": 135,
      "endLine": 198,
      "methodCode": "public static void bindClass(XClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n    InheritanceState inheritanceState = inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType = mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n    PersistentClass superEntity = getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n    bindQueries(clazzToProcess, mappings);\n    bindFilterDefs(clazzToProcess, mappings);\n    bindTypeDefs(clazzToProcess, mappings);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n    String schema = \"\";\n    String table = \"\";\n    String catalog = \"\";\n    List<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn = clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table = tabAnn.name();\n        schema = tabAnn.schema();\n        catalog = tabAnn.catalog();\n        uniqueConstraints = TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n    Ejb3DiscriminatorColumn discriminatorColumn = null;\n    String discrimValue = null;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        javax.persistence.DiscriminatorColumn discAnn = clazzToProcess.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n        DiscriminatorType discriminatorType = discAnn != null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n        org.hibernate.annotations.DiscriminatorFormula discFormulaAnn = clazzToProcess.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n        if (!inheritanceState.hasParents()) {\n            discriminatorColumn = Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n        }\n        if (discAnn != null && inheritanceState.hasParents()) {\n            log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n        }\n        discrimValue = clazzToProcess.isAnnotationPresent(DiscriminatorValue.class) ? clazzToProcess.getAnnotation(DiscriminatorValue.class).value() : null;\n    }\n    PersistentClass persistentClass = makePersistentClass(inheritanceState, superEntity);\n    Proxy proxyAnn = clazzToProcess.getAnnotation(Proxy.class);\n    BatchSize sizeAnn = clazzToProcess.getAnnotation(BatchSize.class);\n    Where whereAnn = clazzToProcess.getAnnotation(Where.class);\n    Entity entityAnn = clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    Cache cacheAnn = determineCacheSettings(clazzToProcess, mappings);\n    EntityBinder entityBinder = new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setDiscriminatorValue(discrimValue);\n    entityBinder.setBatchSize(sizeAnn);\n    entityBinder.setProxy(proxyAnn);\n    entityBinder.setWhere(whereAnn);\n    entityBinder.setCache(cacheAnn);\n    entityBinder.setInheritanceState(inheritanceState);\n    if (!inheritanceState.hasParents()) {\n        bindFilters(clazzToProcess, entityBinder, mappings);\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn = clazzToProcess.getAnnotation(Check.class);\n        String constraints = checkAnn == null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n        }\n    }\n    PropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn = clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate = false;\n    if (InheritanceType.JOINED.equals(inheritanceState.getType()) && inheritanceState.hasParents()) {\n        onDeleteAppropriate = true;\n        final JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n        if (persistentClass.getEntityPersisterClass() == null) {\n            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n        }\n        SimpleValue key = new DependantValue(jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk = clazzToProcess.getAnnotation(ForeignKey.class);\n        if (fk != null && !BinderHelper.isDefault(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn != null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp = new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() == null) {\n                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n            }\n        } else {\n            if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() == null) {\n                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n            }\n        }\n    }\n    if (onDeleteAnn != null && !onDeleteAppropriate) {\n        log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n    }\n    HashMap<String, IdGenerator> classGenerators = buildLocalGenerators(clazzToProcess, mappings);\n    final ElementsToProcess elementsToProcess = getElementsToProcess(persistentClass, clazzToProcess, inheritanceStatePerClass, entityBinder, mappings);\n    final boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE && inheritanceState.hasParents();\n    Set<String> idProperties = new HashSet<String>();\n    IdClass idClass = null;\n    XClass current = null;\n    if (!inheritanceState.hasParents()) {\n        InheritanceState state = inheritanceState;\n        do {\n            current = state.getClazz();\n            if (current.isAnnotationPresent(IdClass.class)) {\n                idClass = current.getAnnotation(IdClass.class);\n                break;\n            }\n            state = InheritanceState.getSuperclassInheritanceState(current, inheritanceStatePerClass);\n        } while (state != null);\n    }\n    if (idClass != null) {\n        XClass compositeClass = mappings.getReflectionManager().toXClass(idClass.value());\n        boolean isComponent = true;\n        AccessType propertyAccessor = entityBinder.getPropertyAccessor(compositeClass);\n        String generatorType = \"assigned\";\n        String generator = BinderHelper.ANNOTATION_STRING_DEFAULT;\n        PropertyData inferredData = new PropertyPreloadedData(entityBinder.getPropertyAccessType(), \"id\", compositeClass);\n        PropertyData baseInferredData = new PropertyPreloadedData(entityBinder.getPropertyAccessType(), \"id\", current);\n        HashMap<String, IdGenerator> localGenerators = new HashMap<String, IdGenerator>();\n        boolean ignoreIdAnnotations = entityBinder.isIgnoreIdAnnotations();\n        entityBinder.setIgnoreIdAnnotations(true);\n        bindId(generatorType, generator, inferredData, baseInferredData, null, propertyHolder, localGenerators, isComponent, propertyAccessor, entityBinder, true, false, mappings, inheritanceStatePerClass);\n        inferredData = new PropertyPreloadedData(propertyAccessor, \"_identifierMapper\", compositeClass);\n        Component mapper = fillComponent(propertyHolder, inferredData, baseInferredData, propertyAccessor, false, entityBinder, true, true, false, mappings, inheritanceStatePerClass);\n        entityBinder.setIgnoreIdAnnotations(ignoreIdAnnotations);\n        persistentClass.setIdentifierMapper(mapper);\n        final org.hibernate.mapping.MappedSuperclass superclass = BinderHelper.getMappedSuperclassOrNull(inferredData.getDeclaringClass(), inheritanceStatePerClass, mappings);\n        if (superclass != null) {\n            superclass.setDeclaredIdentifierMapper(mapper);\n        } else {\n            persistentClass.setDeclaredIdentifierMapper(mapper);\n        }\n        Property property = new Property();\n        property.setName(\"_identifierMapper\");\n        property.setNodeName(\"id\");\n        property.setUpdateable(false);\n        property.setInsertable(false);\n        property.setValue(mapper);\n        property.setPropertyAccessorName(\"embedded\");\n        persistentClass.addProperty(property);\n        entityBinder.setIgnoreIdAnnotations(true);\n        Iterator properties = mapper.getPropertyIterator();\n        while (properties.hasNext()) {\n            idProperties.add(((Property) properties.next()).getName());\n        }\n    } else {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() > 1);\n    }\n    Set<String> missingIdProperties = new HashSet<String>(idProperties);\n    for (PropertyData propertyAnnotatedElement : elementsToProcess.getElements()) {\n        String propertyName = propertyAnnotatedElement.getPropertyName();\n        if (!idProperties.contains(propertyName)) {\n            processElementAnnotations(propertyHolder, subclassAndSingleTableStrategy ? Nullability.FORCED_NULL : Nullability.NO_CONSTRAINT, propertyAnnotatedElement.getProperty(), propertyAnnotatedElement, classGenerators, entityBinder, false, false, false, mappings, inheritanceStatePerClass);\n        } else {\n            missingIdProperties.remove(propertyName);\n        }\n    }\n    if (missingIdProperties.size() != 0) {\n        StringBuilder missings = new StringBuilder();\n        for (String property : missingIdProperties) {\n            missings.append(property).append(\", \");\n        }\n        throw new AnnotationException(\"Unable to find properties (\" + missings.substring(0, missings.length() - 2) + \") in entity annotated with @IdClass:\" + persistentClass.getEntityName());\n    }\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass = (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n}"
    },
    {
      "commit": "d24ed1a1d39c1458d020a27a504a46e76dfe2e26",
      "startLine": 135,
      "endLine": 196,
      "methodCode": "public static void bindClass(XClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n    InheritanceState inheritanceState = inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType = mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n    PersistentClass superEntity = getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n    bindQueries(clazzToProcess, mappings);\n    bindFilterDefs(clazzToProcess, mappings);\n    bindTypeDefs(clazzToProcess, mappings);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n    String schema = \"\";\n    String table = \"\";\n    String catalog = \"\";\n    List<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn = clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table = tabAnn.name();\n        schema = tabAnn.schema();\n        catalog = tabAnn.catalog();\n        uniqueConstraints = TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n    Ejb3DiscriminatorColumn discriminatorColumn = null;\n    String discrimValue = null;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        javax.persistence.DiscriminatorColumn discAnn = clazzToProcess.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n        DiscriminatorType discriminatorType = discAnn != null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n        org.hibernate.annotations.DiscriminatorFormula discFormulaAnn = clazzToProcess.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n        if (!inheritanceState.hasParents()) {\n            discriminatorColumn = Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n        }\n        if (discAnn != null && inheritanceState.hasParents()) {\n            log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n        }\n        discrimValue = clazzToProcess.isAnnotationPresent(DiscriminatorValue.class) ? clazzToProcess.getAnnotation(DiscriminatorValue.class).value() : null;\n    }\n    PersistentClass persistentClass = makePersistentClass(inheritanceState, superEntity);\n    Proxy proxyAnn = clazzToProcess.getAnnotation(Proxy.class);\n    BatchSize sizeAnn = clazzToProcess.getAnnotation(BatchSize.class);\n    Where whereAnn = clazzToProcess.getAnnotation(Where.class);\n    Entity entityAnn = clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    Cache cacheAnn = determineCacheSettings(clazzToProcess, mappings);\n    EntityBinder entityBinder = new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setDiscriminatorValue(discrimValue);\n    entityBinder.setBatchSize(sizeAnn);\n    entityBinder.setProxy(proxyAnn);\n    entityBinder.setWhere(whereAnn);\n    entityBinder.setCache(cacheAnn);\n    entityBinder.setInheritanceState(inheritanceState);\n    if (!inheritanceState.hasParents()) {\n        bindFilters(clazzToProcess, entityBinder, mappings);\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn = clazzToProcess.getAnnotation(Check.class);\n        String constraints = checkAnn == null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n        }\n    }\n    PropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn = clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate = false;\n    if (InheritanceType.JOINED.equals(inheritanceState.getType()) && inheritanceState.hasParents()) {\n        onDeleteAppropriate = true;\n        final JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n        if (persistentClass.getEntityPersisterClass() == null) {\n            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n        }\n        SimpleValue key = new DependantValue(jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk = clazzToProcess.getAnnotation(ForeignKey.class);\n        if (fk != null && !BinderHelper.isDefault(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn != null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp = new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() == null) {\n                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n            }\n        } else {\n            if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() == null) {\n                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n            }\n        }\n    }\n    if (onDeleteAnn != null && !onDeleteAppropriate) {\n        log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n    }\n    HashMap<String, IdGenerator> classGenerators = buildLocalGenerators(clazzToProcess, mappings);\n    List<PropertyData> elements = getElementsToProcess(persistentClass, clazzToProcess, inheritanceStatePerClass, entityBinder, mappings);\n    final boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE && inheritanceState.hasParents();\n    Set<String> idProperties = new HashSet<String>();\n    IdClass idClass = null;\n    XClass current = null;\n    if (!inheritanceState.hasParents()) {\n        InheritanceState state = inheritanceState;\n        do {\n            current = state.getClazz();\n            if (current.isAnnotationPresent(IdClass.class)) {\n                idClass = current.getAnnotation(IdClass.class);\n                break;\n            }\n            state = InheritanceState.getSuperclassInheritanceState(current, inheritanceStatePerClass);\n        } while (state != null);\n    }\n    if (idClass != null) {\n        XClass compositeClass = mappings.getReflectionManager().toXClass(idClass.value());\n        boolean isComponent = true;\n        AccessType propertyAccessor = entityBinder.getPropertyAccessor(compositeClass);\n        String generatorType = \"assigned\";\n        String generator = BinderHelper.ANNOTATION_STRING_DEFAULT;\n        PropertyData inferredData = new PropertyPreloadedData(entityBinder.getPropertyAccessType(), \"id\", compositeClass);\n        PropertyData baseInferredData = new PropertyPreloadedData(entityBinder.getPropertyAccessType(), \"id\", current);\n        HashMap<String, IdGenerator> localGenerators = new HashMap<String, IdGenerator>();\n        boolean ignoreIdAnnotations = entityBinder.isIgnoreIdAnnotations();\n        entityBinder.setIgnoreIdAnnotations(true);\n        bindId(generatorType, generator, inferredData, baseInferredData, null, propertyHolder, localGenerators, isComponent, propertyAccessor, entityBinder, true, false, mappings, inheritanceStatePerClass);\n        inferredData = new PropertyPreloadedData(propertyAccessor, \"_identifierMapper\", compositeClass);\n        Component mapper = fillComponent(propertyHolder, inferredData, baseInferredData, propertyAccessor, false, entityBinder, true, true, false, mappings, inheritanceStatePerClass);\n        entityBinder.setIgnoreIdAnnotations(ignoreIdAnnotations);\n        persistentClass.setIdentifierMapper(mapper);\n        final org.hibernate.mapping.MappedSuperclass superclass = BinderHelper.getMappedSuperclassOrNull(inferredData.getDeclaringClass(), inheritanceStatePerClass, mappings);\n        if (superclass != null) {\n            superclass.setDeclaredIdentifierMapper(mapper);\n        } else {\n            persistentClass.setDeclaredIdentifierMapper(mapper);\n        }\n        Property property = new Property();\n        property.setName(\"_identifierMapper\");\n        property.setNodeName(\"id\");\n        property.setUpdateable(false);\n        property.setInsertable(false);\n        property.setValue(mapper);\n        property.setPropertyAccessorName(\"embedded\");\n        persistentClass.addProperty(property);\n        entityBinder.setIgnoreIdAnnotations(true);\n        Iterator properties = mapper.getPropertyIterator();\n        while (properties.hasNext()) {\n            idProperties.add(((Property) properties.next()).getName());\n        }\n    }\n    Set<String> missingIdProperties = new HashSet<String>(idProperties);\n    for (PropertyData propertyAnnotatedElement : elements) {\n        String propertyName = propertyAnnotatedElement.getPropertyName();\n        if (!idProperties.contains(propertyName)) {\n            processElementAnnotations(propertyHolder, subclassAndSingleTableStrategy ? Nullability.FORCED_NULL : Nullability.NO_CONSTRAINT, propertyAnnotatedElement.getProperty(), propertyAnnotatedElement, classGenerators, entityBinder, false, false, false, mappings, inheritanceStatePerClass);\n        } else {\n            missingIdProperties.remove(propertyName);\n        }\n    }\n    if (missingIdProperties.size() != 0) {\n        StringBuilder missings = new StringBuilder();\n        for (String property : missingIdProperties) {\n            missings.append(property).append(\", \");\n        }\n        throw new AnnotationException(\"Unable to find properties (\" + missings.substring(0, missings.length() - 2) + \") in entity annotated with @IdClass:\" + persistentClass.getEntityName());\n    }\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass = (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n}"
    },
    {
      "commit": "2dd470af1f453e54643d55b2c81ec5a7324952b1",
      "startLine": 135,
      "endLine": 196,
      "methodCode": "public static void bindClass(XClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n    InheritanceState inheritanceState = inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType = mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n    PersistentClass superEntity = getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n    bindQueries(clazzToProcess, mappings);\n    bindFilterDefs(clazzToProcess, mappings);\n    bindTypeDefs(clazzToProcess, mappings);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n    String schema = \"\";\n    String table = \"\";\n    String catalog = \"\";\n    List<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn = clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table = tabAnn.name();\n        schema = tabAnn.schema();\n        catalog = tabAnn.catalog();\n        uniqueConstraints = TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n    Ejb3DiscriminatorColumn discriminatorColumn = null;\n    String discrimValue = null;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        javax.persistence.DiscriminatorColumn discAnn = clazzToProcess.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n        DiscriminatorType discriminatorType = discAnn != null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n        org.hibernate.annotations.DiscriminatorFormula discFormulaAnn = clazzToProcess.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n        if (!inheritanceState.hasParents()) {\n            discriminatorColumn = Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n        }\n        if (discAnn != null && inheritanceState.hasParents()) {\n            log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n        }\n        discrimValue = clazzToProcess.isAnnotationPresent(DiscriminatorValue.class) ? clazzToProcess.getAnnotation(DiscriminatorValue.class).value() : null;\n    }\n    PersistentClass persistentClass = makePersistentClass(inheritanceState, superEntity);\n    Proxy proxyAnn = clazzToProcess.getAnnotation(Proxy.class);\n    BatchSize sizeAnn = clazzToProcess.getAnnotation(BatchSize.class);\n    Where whereAnn = clazzToProcess.getAnnotation(Where.class);\n    Entity entityAnn = clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    org.hibernate.annotations.Cache cacheAnn = clazzToProcess.getAnnotation(org.hibernate.annotations.Cache.class);\n    EntityBinder entityBinder = new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setDiscriminatorValue(discrimValue);\n    entityBinder.setBatchSize(sizeAnn);\n    entityBinder.setProxy(proxyAnn);\n    entityBinder.setWhere(whereAnn);\n    entityBinder.setCache(cacheAnn);\n    entityBinder.setInheritanceState(inheritanceState);\n    if (!inheritanceState.hasParents()) {\n        bindFilters(clazzToProcess, entityBinder, mappings);\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn = clazzToProcess.getAnnotation(Check.class);\n        String constraints = checkAnn == null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n        }\n    }\n    PropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn = clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate = false;\n    if (InheritanceType.JOINED.equals(inheritanceState.getType()) && inheritanceState.hasParents()) {\n        onDeleteAppropriate = true;\n        final JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n        if (persistentClass.getEntityPersisterClass() == null) {\n            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n        }\n        SimpleValue key = new DependantValue(jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk = clazzToProcess.getAnnotation(ForeignKey.class);\n        if (fk != null && !BinderHelper.isDefault(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn != null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp = new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() == null) {\n                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n            }\n        } else {\n            if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() == null) {\n                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n            }\n        }\n    }\n    if (onDeleteAnn != null && !onDeleteAppropriate) {\n        log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n    }\n    HashMap<String, IdGenerator> classGenerators = buildLocalGenerators(clazzToProcess, mappings);\n    List<PropertyData> elements = getElementsToProcess(persistentClass, clazzToProcess, inheritanceStatePerClass, entityBinder, mappings);\n    final boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE && inheritanceState.hasParents();\n    Set<String> idProperties = new HashSet<String>();\n    IdClass idClass = null;\n    XClass current = null;\n    if (!inheritanceState.hasParents()) {\n        InheritanceState state = inheritanceState;\n        do {\n            current = state.getClazz();\n            if (current.isAnnotationPresent(IdClass.class)) {\n                idClass = current.getAnnotation(IdClass.class);\n                break;\n            }\n            state = InheritanceState.getSuperclassInheritanceState(current, inheritanceStatePerClass);\n        } while (state != null);\n    }\n    if (idClass != null) {\n        XClass compositeClass = mappings.getReflectionManager().toXClass(idClass.value());\n        boolean isComponent = true;\n        AccessType propertyAccessor = entityBinder.getPropertyAccessor(compositeClass);\n        String generatorType = \"assigned\";\n        String generator = BinderHelper.ANNOTATION_STRING_DEFAULT;\n        PropertyData inferredData = new PropertyPreloadedData(entityBinder.getPropertyAccessType(), \"id\", compositeClass);\n        PropertyData baseInferredData = new PropertyPreloadedData(entityBinder.getPropertyAccessType(), \"id\", current);\n        HashMap<String, IdGenerator> localGenerators = new HashMap<String, IdGenerator>();\n        boolean ignoreIdAnnotations = entityBinder.isIgnoreIdAnnotations();\n        entityBinder.setIgnoreIdAnnotations(true);\n        bindId(generatorType, generator, inferredData, baseInferredData, null, propertyHolder, localGenerators, isComponent, propertyAccessor, entityBinder, true, false, mappings, inheritanceStatePerClass);\n        inferredData = new PropertyPreloadedData(propertyAccessor, \"_identifierMapper\", compositeClass);\n        Component mapper = fillComponent(propertyHolder, inferredData, baseInferredData, propertyAccessor, false, entityBinder, true, true, false, mappings, inheritanceStatePerClass);\n        entityBinder.setIgnoreIdAnnotations(ignoreIdAnnotations);\n        persistentClass.setIdentifierMapper(mapper);\n        final org.hibernate.mapping.MappedSuperclass superclass = BinderHelper.getMappedSuperclassOrNull(inferredData.getDeclaringClass(), inheritanceStatePerClass, mappings);\n        if (superclass != null) {\n            superclass.setDeclaredIdentifierMapper(mapper);\n        } else {\n            persistentClass.setDeclaredIdentifierMapper(mapper);\n        }\n        Property property = new Property();\n        property.setName(\"_identifierMapper\");\n        property.setNodeName(\"id\");\n        property.setUpdateable(false);\n        property.setInsertable(false);\n        property.setValue(mapper);\n        property.setPropertyAccessorName(\"embedded\");\n        persistentClass.addProperty(property);\n        entityBinder.setIgnoreIdAnnotations(true);\n        Iterator properties = mapper.getPropertyIterator();\n        while (properties.hasNext()) {\n            idProperties.add(((Property) properties.next()).getName());\n        }\n    }\n    Set<String> missingIdProperties = new HashSet<String>(idProperties);\n    for (PropertyData propertyAnnotatedElement : elements) {\n        String propertyName = propertyAnnotatedElement.getPropertyName();\n        if (!idProperties.contains(propertyName)) {\n            processElementAnnotations(propertyHolder, subclassAndSingleTableStrategy ? Nullability.FORCED_NULL : Nullability.NO_CONSTRAINT, propertyAnnotatedElement.getProperty(), propertyAnnotatedElement, classGenerators, entityBinder, false, false, false, mappings, inheritanceStatePerClass);\n        } else {\n            missingIdProperties.remove(propertyName);\n        }\n    }\n    if (missingIdProperties.size() != 0) {\n        StringBuilder missings = new StringBuilder();\n        for (String property : missingIdProperties) {\n            missings.append(property).append(\", \");\n        }\n        throw new AnnotationException(\"Unable to find properties (\" + missings.substring(0, missings.length() - 2) + \") in entity annotated with @IdClass:\" + persistentClass.getEntityName());\n    }\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass = (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n}"
    },
    {
      "commit": "4a9d8dcf0b054d4dc769b463145c1fdecede6e09",
      "startLine": 138,
      "endLine": 199,
      "methodCode": "public static void bindClass(XClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n    InheritanceState inheritanceState = inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType = mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n    PersistentClass superEntity = getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n    bindQueries(clazzToProcess, mappings);\n    bindFilterDefs(clazzToProcess, mappings);\n    bindTypeDefs(clazzToProcess, mappings);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n    String schema = \"\";\n    String table = \"\";\n    String catalog = \"\";\n    List<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn = clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table = tabAnn.name();\n        schema = tabAnn.schema();\n        catalog = tabAnn.catalog();\n        uniqueConstraints = TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n    Ejb3DiscriminatorColumn discriminatorColumn = null;\n    String discrimValue = null;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        javax.persistence.DiscriminatorColumn discAnn = clazzToProcess.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n        DiscriminatorType discriminatorType = discAnn != null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n        org.hibernate.annotations.DiscriminatorFormula discFormulaAnn = clazzToProcess.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n        if (!inheritanceState.hasParents()) {\n            discriminatorColumn = Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n        }\n        if (discAnn != null && inheritanceState.hasParents()) {\n            log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n        }\n        discrimValue = clazzToProcess.isAnnotationPresent(DiscriminatorValue.class) ? clazzToProcess.getAnnotation(DiscriminatorValue.class).value() : null;\n    }\n    PersistentClass persistentClass = makePersistentClass(inheritanceState, superEntity);\n    Proxy proxyAnn = clazzToProcess.getAnnotation(Proxy.class);\n    BatchSize sizeAnn = clazzToProcess.getAnnotation(BatchSize.class);\n    Where whereAnn = clazzToProcess.getAnnotation(Where.class);\n    Entity entityAnn = clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    org.hibernate.annotations.Cache cacheAnn = clazzToProcess.getAnnotation(org.hibernate.annotations.Cache.class);\n    EntityBinder entityBinder = new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setDiscriminatorValue(discrimValue);\n    entityBinder.setBatchSize(sizeAnn);\n    entityBinder.setProxy(proxyAnn);\n    entityBinder.setWhere(whereAnn);\n    entityBinder.setCache(cacheAnn);\n    entityBinder.setInheritanceState(inheritanceState);\n    if (!inheritanceState.hasParents()) {\n        bindFilters(clazzToProcess, entityBinder, mappings);\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn = clazzToProcess.getAnnotation(Check.class);\n        String constraints = checkAnn == null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n        }\n    }\n    PropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn = clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate = false;\n    if (InheritanceType.JOINED.equals(inheritanceState.getType()) && inheritanceState.hasParents()) {\n        onDeleteAppropriate = true;\n        final JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n        if (persistentClass.getEntityPersisterClass() == null) {\n            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n        }\n        SimpleValue key = new DependantValue(jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk = clazzToProcess.getAnnotation(ForeignKey.class);\n        if (fk != null && !BinderHelper.isDefault(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn != null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp = new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() == null) {\n                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n            }\n        } else {\n            if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() == null) {\n                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n            }\n        }\n    }\n    if (onDeleteAnn != null && !onDeleteAppropriate) {\n        log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n    }\n    HashMap<String, IdGenerator> classGenerators = buildLocalGenerators(clazzToProcess, mappings);\n    List<PropertyData> elements = getElementsToProcess(persistentClass, clazzToProcess, inheritanceStatePerClass, entityBinder, mappings);\n    if (elements == null) {\n        throw new AnnotationException(\"No identifier specified for entity: \" + propertyHolder.getEntityName());\n    }\n    final boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE && inheritanceState.hasParents();\n    Set<String> idProperties = new HashSet<String>();\n    IdClass idClass = null;\n    XClass current = null;\n    if (!inheritanceState.hasParents()) {\n        InheritanceState state = inheritanceState;\n        do {\n            current = state.getClazz();\n            if (current.isAnnotationPresent(IdClass.class)) {\n                idClass = current.getAnnotation(IdClass.class);\n                break;\n            }\n            state = InheritanceState.getSuperclassInheritanceState(current, inheritanceStatePerClass, mappings.getReflectionManager());\n        } while (state != null);\n    }\n    if (idClass != null) {\n        XClass compositeClass = mappings.getReflectionManager().toXClass(idClass.value());\n        boolean isComponent = true;\n        AccessType propertyAccessor = entityBinder.getPropertyAccessor(compositeClass);\n        String generatorType = \"assigned\";\n        String generator = BinderHelper.ANNOTATION_STRING_DEFAULT;\n        PropertyData inferredData = new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", compositeClass);\n        PropertyData baseInferredData = new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", current);\n        HashMap<String, IdGenerator> localGenerators = new HashMap<String, IdGenerator>();\n        boolean ignoreIdAnnotations = entityBinder.isIgnoreIdAnnotations();\n        entityBinder.setIgnoreIdAnnotations(true);\n        bindId(generatorType, generator, inferredData, baseInferredData, null, propertyHolder, localGenerators, isComponent, propertyAccessor, entityBinder, true, false, mappings, inheritanceStatePerClass);\n        inferredData = new PropertyPreloadedData(propertyAccessor, \"_identifierMapper\", compositeClass);\n        Component mapper = fillComponent(propertyHolder, inferredData, baseInferredData, propertyAccessor, false, entityBinder, true, true, false, mappings, inheritanceStatePerClass);\n        entityBinder.setIgnoreIdAnnotations(ignoreIdAnnotations);\n        persistentClass.setIdentifierMapper(mapper);\n        final org.hibernate.mapping.MappedSuperclass superclass = BinderHelper.getMappedSuperclassOrNull(inferredData.getDeclaringClass(), inheritanceStatePerClass, mappings);\n        if (superclass != null) {\n            superclass.setDeclaredIdentifierMapper(mapper);\n        } else {\n            persistentClass.setDeclaredIdentifierMapper(mapper);\n        }\n        Property property = new Property();\n        property.setName(\"_identifierMapper\");\n        property.setNodeName(\"id\");\n        property.setUpdateable(false);\n        property.setInsertable(false);\n        property.setValue(mapper);\n        property.setPropertyAccessorName(\"embedded\");\n        persistentClass.addProperty(property);\n        entityBinder.setIgnoreIdAnnotations(true);\n        Iterator properties = mapper.getPropertyIterator();\n        while (properties.hasNext()) {\n            idProperties.add(((Property) properties.next()).getName());\n        }\n    }\n    Set<String> missingIdProperties = new HashSet<String>(idProperties);\n    for (PropertyData propertyAnnotatedElement : elements) {\n        String propertyName = propertyAnnotatedElement.getPropertyName();\n        if (!idProperties.contains(propertyName)) {\n            processElementAnnotations(propertyHolder, subclassAndSingleTableStrategy ? Nullability.FORCED_NULL : Nullability.NO_CONSTRAINT, propertyAnnotatedElement.getProperty(), propertyAnnotatedElement, classGenerators, entityBinder, false, false, false, mappings, inheritanceStatePerClass);\n        } else {\n            missingIdProperties.remove(propertyName);\n        }\n    }\n    if (missingIdProperties.size() != 0) {\n        StringBuilder missings = new StringBuilder();\n        for (String property : missingIdProperties) {\n            missings.append(property).append(\", \");\n        }\n        throw new AnnotationException(\"Unable to find properties (\" + missings.substring(0, missings.length() - 2) + \") in entity annotated with @IdClass:\" + persistentClass.getEntityName());\n    }\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass = (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n}"
    },
    {
      "commit": "025b3cc14180d0459856bc45a6cac7acce3e1265",
      "startLine": 138,
      "endLine": 200,
      "methodCode": "public static void bindClass(XClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n    InheritanceState inheritanceState = inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType = mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n    PersistentClass superEntity = getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n    bindQueries(clazzToProcess, mappings);\n    bindFilterDefs(clazzToProcess, mappings);\n    bindTypeDefs(clazzToProcess, mappings);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n    String schema = \"\";\n    String table = \"\";\n    String catalog = \"\";\n    List<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn = clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table = tabAnn.name();\n        schema = tabAnn.schema();\n        catalog = tabAnn.catalog();\n        uniqueConstraints = TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n    Ejb3DiscriminatorColumn discriminatorColumn = null;\n    String discrimValue = null;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        javax.persistence.DiscriminatorColumn discAnn = clazzToProcess.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n        DiscriminatorType discriminatorType = discAnn != null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n        org.hibernate.annotations.DiscriminatorFormula discFormulaAnn = clazzToProcess.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n        if (!inheritanceState.hasParents()) {\n            discriminatorColumn = Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n        }\n        if (discAnn != null && inheritanceState.hasParents()) {\n            log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n        }\n        discrimValue = clazzToProcess.isAnnotationPresent(DiscriminatorValue.class) ? clazzToProcess.getAnnotation(DiscriminatorValue.class).value() : null;\n    }\n    PersistentClass persistentClass = makePersistentClass(inheritanceState, superEntity);\n    Proxy proxyAnn = clazzToProcess.getAnnotation(Proxy.class);\n    BatchSize sizeAnn = clazzToProcess.getAnnotation(BatchSize.class);\n    Where whereAnn = clazzToProcess.getAnnotation(Where.class);\n    Entity entityAnn = clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    org.hibernate.annotations.Cache cacheAnn = clazzToProcess.getAnnotation(org.hibernate.annotations.Cache.class);\n    EntityBinder entityBinder = new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setDiscriminatorValue(discrimValue);\n    entityBinder.setBatchSize(sizeAnn);\n    entityBinder.setProxy(proxyAnn);\n    entityBinder.setWhere(whereAnn);\n    entityBinder.setCache(cacheAnn);\n    entityBinder.setInheritanceState(inheritanceState);\n    if (!inheritanceState.hasParents()) {\n        bindFilters(clazzToProcess, entityBinder, mappings);\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn = clazzToProcess.getAnnotation(Check.class);\n        String constraints = checkAnn == null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n        }\n    }\n    PropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn = clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate = false;\n    if (InheritanceType.JOINED.equals(inheritanceState.getType()) && inheritanceState.hasParents()) {\n        onDeleteAppropriate = true;\n        final JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n        if (persistentClass.getEntityPersisterClass() == null) {\n            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n        }\n        SimpleValue key = new DependantValue(jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk = clazzToProcess.getAnnotation(ForeignKey.class);\n        if (fk != null && !BinderHelper.isDefault(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn != null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp = new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() == null) {\n                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n            }\n        } else {\n            if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() == null) {\n                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n            }\n        }\n    }\n    if (onDeleteAnn != null && !onDeleteAppropriate) {\n        log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n    }\n    HashMap<String, IdGenerator> classGenerators = buildLocalGenerators(clazzToProcess, mappings);\n    List<PropertyData> elements = getElementsToProcess(persistentClass, clazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings);\n    if (elements == null) {\n        throw new AnnotationException(\"No identifier specified for entity: \" + propertyHolder.getEntityName());\n    }\n    final boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE && inheritanceState.hasParents();\n    Set<String> idProperties = new HashSet<String>();\n    IdClass idClass = null;\n    XClass current = null;\n    if (!inheritanceState.hasParents()) {\n        InheritanceState state = inheritanceState;\n        do {\n            current = state.getClazz();\n            if (current.isAnnotationPresent(IdClass.class)) {\n                idClass = current.getAnnotation(IdClass.class);\n                break;\n            }\n            state = InheritanceState.getSuperclassInheritanceState(current, inheritanceStatePerClass, mappings.getReflectionManager());\n        } while (state != null);\n    }\n    if (idClass != null) {\n        XClass compositeClass = mappings.getReflectionManager().toXClass(idClass.value());\n        boolean isComponent = true;\n        boolean propertyAnnotated = entityBinder.isPropertyAnnotated(compositeClass);\n        String propertyAccessor = entityBinder.getPropertyAccessor(compositeClass);\n        String generatorType = \"assigned\";\n        String generator = BinderHelper.ANNOTATION_STRING_DEFAULT;\n        PropertyData inferredData = new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", compositeClass);\n        PropertyData baseInferredData = new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", current);\n        HashMap<String, IdGenerator> localGenerators = new HashMap<String, IdGenerator>();\n        boolean ignoreIdAnnotations = entityBinder.isIgnoreIdAnnotations();\n        entityBinder.setIgnoreIdAnnotations(true);\n        bindId(generatorType, generator, inferredData, baseInferredData, null, propertyHolder, localGenerators, isComponent, propertyAnnotated, propertyAccessor, entityBinder, true, false, mappings, inheritanceStatePerClass);\n        inferredData = new PropertyPreloadedData(propertyAccessor, \"_identifierMapper\", compositeClass);\n        Component mapper = fillComponent(propertyHolder, inferredData, baseInferredData, propertyAnnotated, propertyAccessor, false, entityBinder, true, true, false, mappings, inheritanceStatePerClass);\n        entityBinder.setIgnoreIdAnnotations(ignoreIdAnnotations);\n        persistentClass.setIdentifierMapper(mapper);\n        final org.hibernate.mapping.MappedSuperclass superclass = BinderHelper.getMappedSuperclassOrNull(inferredData.getDeclaringClass(), inheritanceStatePerClass, mappings);\n        if (superclass != null) {\n            superclass.setDeclaredIdentifierMapper(mapper);\n        } else {\n            persistentClass.setDeclaredIdentifierMapper(mapper);\n        }\n        Property property = new Property();\n        property.setName(\"_identifierMapper\");\n        property.setNodeName(\"id\");\n        property.setUpdateable(false);\n        property.setInsertable(false);\n        property.setValue(mapper);\n        property.setPropertyAccessorName(\"embedded\");\n        persistentClass.addProperty(property);\n        entityBinder.setIgnoreIdAnnotations(true);\n        Iterator properties = mapper.getPropertyIterator();\n        while (properties.hasNext()) {\n            idProperties.add(((Property) properties.next()).getName());\n        }\n    }\n    Set<String> missingIdProperties = new HashSet<String>(idProperties);\n    for (PropertyData propertyAnnotatedElement : elements) {\n        String propertyName = propertyAnnotatedElement.getPropertyName();\n        if (!idProperties.contains(propertyName)) {\n            processElementAnnotations(propertyHolder, subclassAndSingleTableStrategy ? Nullability.FORCED_NULL : Nullability.NO_CONSTRAINT, propertyAnnotatedElement.getProperty(), propertyAnnotatedElement, classGenerators, entityBinder, false, false, false, mappings, inheritanceStatePerClass);\n        } else {\n            missingIdProperties.remove(propertyName);\n        }\n    }\n    if (missingIdProperties.size() != 0) {\n        StringBuilder missings = new StringBuilder();\n        for (String property : missingIdProperties) {\n            missings.append(property).append(\", \");\n        }\n        throw new AnnotationException(\"Unable to find properties (\" + missings.substring(0, missings.length() - 2) + \") in entity annotated with @IdClass:\" + persistentClass.getEntityName());\n    }\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass = (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n}"
    },
    {
      "commit": "a2bf14ae7c2ed7b2b0a6eb558dad08bcfc69c489",
      "startLine": 187,
      "endLine": 249,
      "methodCode": "public static void bindClass(XClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n    InheritanceState inheritanceState = inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType = mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType) || AnnotatedClassType.NONE.equals(classType) || AnnotatedClassType.EMBEDDABLE.equals(classType)) {\n        if (AnnotatedClassType.NONE.equals(classType) && clazzToProcess.isAnnotationPresent(org.hibernate.annotations.Entity.class)) {\n            log.warn(\"Class annotated @org.hibernate.annotations.Entity but not javax.persistence.Entity \" + \"(most likely a user error): {}\", clazzToProcess.getName());\n        }\n        return;\n    }\n    if (!classType.equals(AnnotatedClassType.ENTITY)) {\n        throw new AnnotationException(\"Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: \" + clazzToProcess.getName());\n    }\n    XAnnotatedElement annotatedClass = clazzToProcess;\n    log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n    final ReflectionManager reflectionManager = mappings.getReflectionManager();\n    InheritanceState superEntityState = InheritanceState.getSuperEntityInheritanceState(clazzToProcess, inheritanceStatePerClass, reflectionManager);\n    PersistentClass superEntity = superEntityState != null ? mappings.getClass(superEntityState.clazz.getName()) : null;\n    if (superEntity == null) {\n        if (inheritanceState.hasParents) {\n            throw new AssertionFailure(\"Subclass has to be binded after it's mother class: \" + superEntityState.clazz.getName());\n        }\n    }\n    bindQueries(annotatedClass, mappings);\n    bindFilterDefs(annotatedClass, mappings);\n    bindTypeDefs(annotatedClass, mappings);\n    BinderHelper.bindAnyMetaDefs(annotatedClass, mappings);\n    String schema = \"\";\n    String table = \"\";\n    String catalog = \"\";\n    String discrimValue = null;\n    List<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n    Ejb3DiscriminatorColumn discriminatorColumn = null;\n    Ejb3JoinColumn[] inheritanceJoinedColumns = null;\n    if (annotatedClass.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn = annotatedClass.getAnnotation(javax.persistence.Table.class);\n        table = tabAnn.name();\n        schema = tabAnn.schema();\n        catalog = tabAnn.catalog();\n        uniqueConstraints = TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    final boolean hasJoinedColumns = inheritanceState.hasParents && InheritanceType.JOINED.equals(inheritanceState.type);\n    if (hasJoinedColumns) {\n        PrimaryKeyJoinColumns jcsAnn = annotatedClass.getAnnotation(PrimaryKeyJoinColumns.class);\n        boolean explicitInheritanceJoinedColumns = jcsAnn != null && jcsAnn.value().length != 0;\n        if (explicitInheritanceJoinedColumns) {\n            int nbrOfInhJoinedColumns = jcsAnn.value().length;\n            PrimaryKeyJoinColumn jcAnn;\n            inheritanceJoinedColumns = new Ejb3JoinColumn[nbrOfInhJoinedColumns];\n            for (int colIndex = 0; colIndex < nbrOfInhJoinedColumns; colIndex++) {\n                jcAnn = jcsAnn.value()[colIndex];\n                inheritanceJoinedColumns[colIndex] = Ejb3JoinColumn.buildJoinColumn(jcAnn, null, superEntity.getIdentifier(), (Map<String, Join>) null, (PropertyHolder) null, mappings);\n            }\n        } else {\n            PrimaryKeyJoinColumn jcAnn = annotatedClass.getAnnotation(PrimaryKeyJoinColumn.class);\n            inheritanceJoinedColumns = new Ejb3JoinColumn[1];\n            inheritanceJoinedColumns[0] = Ejb3JoinColumn.buildJoinColumn(jcAnn, null, superEntity.getIdentifier(), (Map<String, Join>) null, (PropertyHolder) null, mappings);\n        }\n        log.debug(\"Subclass joined column(s) created\");\n    } else {\n        if (annotatedClass.isAnnotationPresent(javax.persistence.PrimaryKeyJoinColumns.class) || annotatedClass.isAnnotationPresent(javax.persistence.PrimaryKeyJoinColumn.class)) {\n            log.warn(\"Root entity should not hold an PrimaryKeyJoinColum(s), will be ignored\");\n        }\n    }\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n        javax.persistence.DiscriminatorColumn discAnn = annotatedClass.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n        DiscriminatorType discriminatorType = discAnn != null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n        org.hibernate.annotations.DiscriminatorFormula discFormulaAnn = annotatedClass.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n        if (!inheritanceState.hasParents) {\n            discriminatorColumn = Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n        }\n        if (discAnn != null && inheritanceState.hasParents) {\n            log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n        }\n        discrimValue = annotatedClass.isAnnotationPresent(DiscriminatorValue.class) ? annotatedClass.getAnnotation(DiscriminatorValue.class).value() : null;\n    }\n    PersistentClass persistentClass;\n    if (!inheritanceState.hasParents) {\n        persistentClass = new RootClass();\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n        persistentClass = new SingleTableSubclass(superEntity);\n    } else if (InheritanceType.JOINED.equals(inheritanceState.type)) {\n        persistentClass = new JoinedSubclass(superEntity);\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.type)) {\n        persistentClass = new UnionSubclass(superEntity);\n    } else {\n        throw new AssertionFailure(\"Unknown inheritance type: \" + inheritanceState.type);\n    }\n    Proxy proxyAnn = annotatedClass.getAnnotation(Proxy.class);\n    BatchSize sizeAnn = annotatedClass.getAnnotation(BatchSize.class);\n    Where whereAnn = annotatedClass.getAnnotation(Where.class);\n    Entity entityAnn = annotatedClass.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn = annotatedClass.getAnnotation(org.hibernate.annotations.Entity.class);\n    org.hibernate.annotations.Cache cacheAnn = annotatedClass.getAnnotation(org.hibernate.annotations.Cache.class);\n    EntityBinder entityBinder = new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setDiscriminatorValue(discrimValue);\n    entityBinder.setBatchSize(sizeAnn);\n    entityBinder.setProxy(proxyAnn);\n    entityBinder.setWhere(whereAnn);\n    entityBinder.setCache(cacheAnn);\n    entityBinder.setInheritanceState(inheritanceState);\n    if (!inheritanceState.hasParents) {\n        bindFilters(clazzToProcess, entityBinder, mappings);\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn = annotatedClass.getAnnotation(Check.class);\n        String constraints = checkAnn == null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else {\n        if (annotatedClass.isAnnotationPresent(Table.class)) {\n            log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n        }\n    }\n    PropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn = annotatedClass.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn = annotatedClass.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn = annotatedClass.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate = false;\n    if (InheritanceType.JOINED.equals(inheritanceState.type) && inheritanceState.hasParents) {\n        onDeleteAppropriate = true;\n        final JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n        if (persistentClass.getEntityPersisterClass() == null) {\n            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n        }\n        SimpleValue key = new DependantValue(jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk = annotatedClass.getAnnotation(ForeignKey.class);\n        if (fk != null && !BinderHelper.isDefault(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn != null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp = new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n        if (inheritanceState.hasParents) {\n            if (persistentClass.getEntityPersisterClass() == null) {\n                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n            }\n        } else {\n            if (inheritanceState.hasSons || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.type)) {\n        if (inheritanceState.hasParents) {\n            if (persistentClass.getEntityPersisterClass() == null) {\n                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n            }\n        }\n    }\n    if (onDeleteAnn != null && !onDeleteAppropriate) {\n        log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n    }\n    HashMap<String, IdGenerator> classGenerators = buildLocalGenerators(annotatedClass, mappings);\n    List<PropertyData> elements = getElementsToProcess(persistentClass, clazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings);\n    if (elements == null) {\n        throw new AnnotationException(\"No identifier specified for entity: \" + propertyHolder.getEntityName());\n    }\n    final boolean subclassAndSingleTableStrategy = inheritanceState.type == InheritanceType.SINGLE_TABLE && inheritanceState.hasParents;\n    Set<String> idProperties = new HashSet<String>();\n    IdClass idClass = null;\n    XClass current = null;\n    if (!inheritanceState.hasParents) {\n        current = inheritanceState.clazz;\n        InheritanceState state = inheritanceState;\n        do {\n            current = state.clazz;\n            if (current.isAnnotationPresent(IdClass.class)) {\n                idClass = current.getAnnotation(IdClass.class);\n                break;\n            }\n            state = InheritanceState.getSuperclassInheritanceState(current, inheritanceStatePerClass, reflectionManager);\n        } while (state != null);\n    }\n    if (idClass != null) {\n        XClass compositeClass = reflectionManager.toXClass(idClass.value());\n        boolean isComponent = true;\n        boolean propertyAnnotated = entityBinder.isPropertyAnnotated(compositeClass);\n        String propertyAccessor = entityBinder.getPropertyAccessor(compositeClass);\n        String generatorType = \"assigned\";\n        String generator = BinderHelper.ANNOTATION_STRING_DEFAULT;\n        PropertyData inferredData = new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", compositeClass);\n        PropertyData baseInferredData = new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", current);\n        HashMap<String, IdGenerator> localGenerators = new HashMap<String, IdGenerator>();\n        boolean ignoreIdAnnotations = entityBinder.isIgnoreIdAnnotations();\n        entityBinder.setIgnoreIdAnnotations(true);\n        bindId(generatorType, generator, inferredData, baseInferredData, null, propertyHolder, localGenerators, isComponent, propertyAnnotated, propertyAccessor, entityBinder, true, false, mappings, inheritanceStatePerClass);\n        inferredData = new PropertyPreloadedData(propertyAccessor, \"_identifierMapper\", compositeClass);\n        Component mapper = fillComponent(propertyHolder, inferredData, baseInferredData, propertyAnnotated, propertyAccessor, false, entityBinder, true, true, false, mappings, inheritanceStatePerClass);\n        entityBinder.setIgnoreIdAnnotations(ignoreIdAnnotations);\n        persistentClass.setIdentifierMapper(mapper);\n        final org.hibernate.mapping.MappedSuperclass superclass = BinderHelper.getMappedSuperclassOrNull(inferredData.getDeclaringClass(), inheritanceStatePerClass, mappings);\n        if (superclass != null) {\n            superclass.setDeclaredIdentifierMapper(mapper);\n        } else {\n            persistentClass.setDeclaredIdentifierMapper(mapper);\n        }\n        Property property = new Property();\n        property.setName(\"_identifierMapper\");\n        property.setNodeName(\"id\");\n        property.setUpdateable(false);\n        property.setInsertable(false);\n        property.setValue(mapper);\n        property.setPropertyAccessorName(\"embedded\");\n        persistentClass.addProperty(property);\n        entityBinder.setIgnoreIdAnnotations(true);\n        Iterator properties = mapper.getPropertyIterator();\n        while (properties.hasNext()) {\n            idProperties.add(((Property) properties.next()).getName());\n        }\n    }\n    Set<String> missingIdProperties = new HashSet<String>(idProperties);\n    for (PropertyData propertyAnnotatedElement : elements) {\n        String propertyName = propertyAnnotatedElement.getPropertyName();\n        if (!idProperties.contains(propertyName)) {\n            processElementAnnotations(propertyHolder, subclassAndSingleTableStrategy ? Nullability.FORCED_NULL : Nullability.NO_CONSTRAINT, propertyAnnotatedElement.getProperty(), propertyAnnotatedElement, classGenerators, entityBinder, false, false, false, mappings, inheritanceStatePerClass);\n        } else {\n            missingIdProperties.remove(propertyName);\n        }\n    }\n    if (missingIdProperties.size() != 0) {\n        StringBuilder missings = new StringBuilder();\n        for (String property : missingIdProperties) {\n            missings.append(property).append(\", \");\n        }\n        throw new AnnotationException(\"Unable to find properties (\" + missings.substring(0, missings.length() - 2) + \") in entity annotated with @IdClass:\" + persistentClass.getEntityName());\n    }\n    if (!inheritanceState.hasParents) {\n        final RootClass rootClass = (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, annotatedClass));\n    entityBinder.processComplementaryTableDefinitions(annotatedClass.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(annotatedClass.getAnnotation(org.hibernate.annotations.Tables.class));\n}"
    },
    {
      "commit": "fb9bdb7f387a4c8e100e2a8109e3c9b8706f4fed",
      "startLine": 187,
      "endLine": 249,
      "methodCode": "public static void bindClass(XClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n    InheritanceState inheritanceState = inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType = mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType) || AnnotatedClassType.NONE.equals(classType) || AnnotatedClassType.EMBEDDABLE.equals(classType)) {\n        if (AnnotatedClassType.NONE.equals(classType) && clazzToProcess.isAnnotationPresent(org.hibernate.annotations.Entity.class)) {\n            log.warn(\"Class annotated @org.hibernate.annotations.Entity but not javax.persistence.Entity \" + \"(most likely a user error): {}\", clazzToProcess.getName());\n        }\n        return;\n    }\n    if (!classType.equals(AnnotatedClassType.ENTITY)) {\n        throw new AnnotationException(\"Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: \" + clazzToProcess.getName());\n    }\n    XAnnotatedElement annotatedClass = clazzToProcess;\n    log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n    final ReflectionManager reflectionManager = mappings.getReflectionManager();\n    InheritanceState superEntityState = InheritanceState.getSuperEntityInheritanceState(clazzToProcess, inheritanceStatePerClass, reflectionManager);\n    PersistentClass superEntity = superEntityState != null ? mappings.getClass(superEntityState.clazz.getName()) : null;\n    if (superEntity == null) {\n        if (inheritanceState.hasParents) {\n            throw new AssertionFailure(\"Subclass has to be binded after it's mother class: \" + superEntityState.clazz.getName());\n        }\n    }\n    bindQueries(annotatedClass, mappings);\n    bindFilterDefs(annotatedClass, mappings);\n    bindTypeDefs(annotatedClass, mappings);\n    BinderHelper.bindAnyMetaDefs(annotatedClass, mappings);\n    String schema = \"\";\n    String table = \"\";\n    String catalog = \"\";\n    String discrimValue = null;\n    List<String[]> uniqueConstraints = new ArrayList<String[]>();\n    Ejb3DiscriminatorColumn discriminatorColumn = null;\n    Ejb3JoinColumn[] inheritanceJoinedColumns = null;\n    if (annotatedClass.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn = annotatedClass.getAnnotation(javax.persistence.Table.class);\n        table = tabAnn.name();\n        schema = tabAnn.schema();\n        catalog = tabAnn.catalog();\n        uniqueConstraints = TableBinder.buildUniqueConstraints(tabAnn.uniqueConstraints());\n    }\n    final boolean hasJoinedColumns = inheritanceState.hasParents && InheritanceType.JOINED.equals(inheritanceState.type);\n    if (hasJoinedColumns) {\n        PrimaryKeyJoinColumns jcsAnn = annotatedClass.getAnnotation(PrimaryKeyJoinColumns.class);\n        boolean explicitInheritanceJoinedColumns = jcsAnn != null && jcsAnn.value().length != 0;\n        if (explicitInheritanceJoinedColumns) {\n            int nbrOfInhJoinedColumns = jcsAnn.value().length;\n            PrimaryKeyJoinColumn jcAnn;\n            inheritanceJoinedColumns = new Ejb3JoinColumn[nbrOfInhJoinedColumns];\n            for (int colIndex = 0; colIndex < nbrOfInhJoinedColumns; colIndex++) {\n                jcAnn = jcsAnn.value()[colIndex];\n                inheritanceJoinedColumns[colIndex] = Ejb3JoinColumn.buildJoinColumn(jcAnn, null, superEntity.getIdentifier(), (Map<String, Join>) null, (PropertyHolder) null, mappings);\n            }\n        } else {\n            PrimaryKeyJoinColumn jcAnn = annotatedClass.getAnnotation(PrimaryKeyJoinColumn.class);\n            inheritanceJoinedColumns = new Ejb3JoinColumn[1];\n            inheritanceJoinedColumns[0] = Ejb3JoinColumn.buildJoinColumn(jcAnn, null, superEntity.getIdentifier(), (Map<String, Join>) null, (PropertyHolder) null, mappings);\n        }\n        log.debug(\"Subclass joined column(s) created\");\n    } else {\n        if (annotatedClass.isAnnotationPresent(javax.persistence.PrimaryKeyJoinColumns.class) || annotatedClass.isAnnotationPresent(javax.persistence.PrimaryKeyJoinColumn.class)) {\n            log.warn(\"Root entity should not hold an PrimaryKeyJoinColum(s), will be ignored\");\n        }\n    }\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n        javax.persistence.DiscriminatorColumn discAnn = annotatedClass.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n        DiscriminatorType discriminatorType = discAnn != null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n        org.hibernate.annotations.DiscriminatorFormula discFormulaAnn = annotatedClass.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n        if (!inheritanceState.hasParents) {\n            discriminatorColumn = Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n        }\n        if (discAnn != null && inheritanceState.hasParents) {\n            log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n        }\n        discrimValue = annotatedClass.isAnnotationPresent(DiscriminatorValue.class) ? annotatedClass.getAnnotation(DiscriminatorValue.class).value() : null;\n    }\n    PersistentClass persistentClass;\n    if (!inheritanceState.hasParents) {\n        persistentClass = new RootClass();\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n        persistentClass = new SingleTableSubclass(superEntity);\n    } else if (InheritanceType.JOINED.equals(inheritanceState.type)) {\n        persistentClass = new JoinedSubclass(superEntity);\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.type)) {\n        persistentClass = new UnionSubclass(superEntity);\n    } else {\n        throw new AssertionFailure(\"Unknown inheritance type: \" + inheritanceState.type);\n    }\n    Proxy proxyAnn = annotatedClass.getAnnotation(Proxy.class);\n    BatchSize sizeAnn = annotatedClass.getAnnotation(BatchSize.class);\n    Where whereAnn = annotatedClass.getAnnotation(Where.class);\n    Entity entityAnn = annotatedClass.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn = annotatedClass.getAnnotation(org.hibernate.annotations.Entity.class);\n    org.hibernate.annotations.Cache cacheAnn = annotatedClass.getAnnotation(org.hibernate.annotations.Cache.class);\n    EntityBinder entityBinder = new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setDiscriminatorValue(discrimValue);\n    entityBinder.setBatchSize(sizeAnn);\n    entityBinder.setProxy(proxyAnn);\n    entityBinder.setWhere(whereAnn);\n    entityBinder.setCache(cacheAnn);\n    entityBinder.setInheritanceState(inheritanceState);\n    if (!inheritanceState.hasParents) {\n        bindFilters(clazzToProcess, entityBinder, mappings);\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn = annotatedClass.getAnnotation(Check.class);\n        String constraints = checkAnn == null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else {\n        if (annotatedClass.isAnnotationPresent(Table.class)) {\n            log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n        }\n    }\n    PropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn = annotatedClass.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn = annotatedClass.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn = annotatedClass.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate = false;\n    if (InheritanceType.JOINED.equals(inheritanceState.type) && inheritanceState.hasParents) {\n        onDeleteAppropriate = true;\n        final JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n        if (persistentClass.getEntityPersisterClass() == null) {\n            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n        }\n        SimpleValue key = new DependantValue(jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk = annotatedClass.getAnnotation(ForeignKey.class);\n        if (fk != null && !BinderHelper.isDefault(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn != null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp = new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n        if (inheritanceState.hasParents) {\n            if (persistentClass.getEntityPersisterClass() == null) {\n                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n            }\n        } else {\n            if (inheritanceState.hasSons || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.type)) {\n        if (inheritanceState.hasParents) {\n            if (persistentClass.getEntityPersisterClass() == null) {\n                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n            }\n        }\n    }\n    if (onDeleteAnn != null && !onDeleteAppropriate) {\n        log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n    }\n    HashMap<String, IdGenerator> classGenerators = buildLocalGenerators(annotatedClass, mappings);\n    List<PropertyData> elements = getElementsToProcess(persistentClass, clazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings);\n    if (elements == null) {\n        throw new AnnotationException(\"No identifier specified for entity: \" + propertyHolder.getEntityName());\n    }\n    final boolean subclassAndSingleTableStrategy = inheritanceState.type == InheritanceType.SINGLE_TABLE && inheritanceState.hasParents;\n    Set<String> idProperties = new HashSet<String>();\n    IdClass idClass = null;\n    XClass current = null;\n    if (!inheritanceState.hasParents) {\n        current = inheritanceState.clazz;\n        InheritanceState state = inheritanceState;\n        do {\n            current = state.clazz;\n            if (current.isAnnotationPresent(IdClass.class)) {\n                idClass = current.getAnnotation(IdClass.class);\n                break;\n            }\n            state = InheritanceState.getSuperclassInheritanceState(current, inheritanceStatePerClass, reflectionManager);\n        } while (state != null);\n    }\n    if (idClass != null) {\n        XClass compositeClass = reflectionManager.toXClass(idClass.value());\n        boolean isComponent = true;\n        boolean propertyAnnotated = entityBinder.isPropertyAnnotated(compositeClass);\n        String propertyAccessor = entityBinder.getPropertyAccessor(compositeClass);\n        String generatorType = \"assigned\";\n        String generator = BinderHelper.ANNOTATION_STRING_DEFAULT;\n        PropertyData inferredData = new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", compositeClass);\n        PropertyData baseInferredData = new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", current);\n        HashMap<String, IdGenerator> localGenerators = new HashMap<String, IdGenerator>();\n        boolean ignoreIdAnnotations = entityBinder.isIgnoreIdAnnotations();\n        entityBinder.setIgnoreIdAnnotations(true);\n        bindId(generatorType, generator, inferredData, baseInferredData, null, propertyHolder, localGenerators, isComponent, propertyAnnotated, propertyAccessor, entityBinder, true, false, mappings, inheritanceStatePerClass);\n        inferredData = new PropertyPreloadedData(propertyAccessor, \"_identifierMapper\", compositeClass);\n        Component mapper = fillComponent(propertyHolder, inferredData, baseInferredData, propertyAnnotated, propertyAccessor, false, entityBinder, true, true, false, mappings, inheritanceStatePerClass);\n        entityBinder.setIgnoreIdAnnotations(ignoreIdAnnotations);\n        persistentClass.setIdentifierMapper(mapper);\n        final org.hibernate.mapping.MappedSuperclass superclass = BinderHelper.getMappedSuperclassOrNull(inferredData.getDeclaringClass(), inheritanceStatePerClass, mappings);\n        if (superclass != null) {\n            superclass.setDeclaredIdentifierMapper(mapper);\n        } else {\n            persistentClass.setDeclaredIdentifierMapper(mapper);\n        }\n        Property property = new Property();\n        property.setName(\"_identifierMapper\");\n        property.setNodeName(\"id\");\n        property.setUpdateable(false);\n        property.setInsertable(false);\n        property.setValue(mapper);\n        property.setPropertyAccessorName(\"embedded\");\n        persistentClass.addProperty(property);\n        entityBinder.setIgnoreIdAnnotations(true);\n        Iterator properties = mapper.getPropertyIterator();\n        while (properties.hasNext()) {\n            idProperties.add(((Property) properties.next()).getName());\n        }\n    }\n    Set<String> missingIdProperties = new HashSet<String>(idProperties);\n    for (PropertyData propertyAnnotatedElement : elements) {\n        String propertyName = propertyAnnotatedElement.getPropertyName();\n        if (!idProperties.contains(propertyName)) {\n            processElementAnnotations(propertyHolder, subclassAndSingleTableStrategy ? Nullability.FORCED_NULL : Nullability.NO_CONSTRAINT, propertyAnnotatedElement.getProperty(), propertyAnnotatedElement, classGenerators, entityBinder, false, false, false, mappings, inheritanceStatePerClass);\n        } else {\n            missingIdProperties.remove(propertyName);\n        }\n    }\n    if (missingIdProperties.size() != 0) {\n        StringBuilder missings = new StringBuilder();\n        for (String property : missingIdProperties) {\n            missings.append(property).append(\", \");\n        }\n        throw new AnnotationException(\"Unable to find properties (\" + missings.substring(0, missings.length() - 2) + \") in entity annotated with @IdClass:\" + persistentClass.getEntityName());\n    }\n    if (!inheritanceState.hasParents) {\n        final RootClass rootClass = (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, annotatedClass));\n    entityBinder.processComplementaryTableDefinitions(annotatedClass.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(annotatedClass.getAnnotation(org.hibernate.annotations.Tables.class));\n}"
    },
    {
      "commit": "c7c6981a558e35f01ff8d27938e98aa83896765c",
      "startLine": 187,
      "endLine": 243,
      "methodCode": "public static void bindClass(XClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n    InheritanceState inheritanceState = inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType = mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType) || AnnotatedClassType.NONE.equals(classType) || AnnotatedClassType.EMBEDDABLE.equals(classType)) {\n        if (AnnotatedClassType.NONE.equals(classType) && clazzToProcess.isAnnotationPresent(org.hibernate.annotations.Entity.class)) {\n            log.warn(\"Class annotated @org.hibernate.annotations.Entity but not javax.persistence.Entity \" + \"(most likely a user error): {}\", clazzToProcess.getName());\n        }\n        return;\n    }\n    if (!classType.equals(AnnotatedClassType.ENTITY)) {\n        throw new AnnotationException(\"Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: \" + clazzToProcess.getName());\n    }\n    XAnnotatedElement annotatedClass = clazzToProcess;\n    log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n    final ReflectionManager reflectionManager = mappings.getReflectionManager();\n    InheritanceState superEntityState = InheritanceState.getSuperEntityInheritanceState(clazzToProcess, inheritanceStatePerClass, reflectionManager);\n    PersistentClass superEntity = superEntityState != null ? mappings.getClass(superEntityState.clazz.getName()) : null;\n    if (superEntity == null) {\n        if (inheritanceState.hasParents) {\n            throw new AssertionFailure(\"Subclass has to be binded after it's mother class: \" + superEntityState.clazz.getName());\n        }\n    }\n    bindQueries(annotatedClass, mappings);\n    bindFilterDefs(annotatedClass, mappings);\n    bindTypeDefs(annotatedClass, mappings);\n    BinderHelper.bindAnyMetaDefs(annotatedClass, mappings);\n    String schema = \"\";\n    String table = \"\";\n    String catalog = \"\";\n    String discrimValue = null;\n    List<String[]> uniqueConstraints = new ArrayList<String[]>();\n    Ejb3DiscriminatorColumn discriminatorColumn = null;\n    Ejb3JoinColumn[] inheritanceJoinedColumns = null;\n    if (annotatedClass.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn = annotatedClass.getAnnotation(javax.persistence.Table.class);\n        table = tabAnn.name();\n        schema = tabAnn.schema();\n        catalog = tabAnn.catalog();\n        uniqueConstraints = TableBinder.buildUniqueConstraints(tabAnn.uniqueConstraints());\n    }\n    final boolean hasJoinedColumns = inheritanceState.hasParents && InheritanceType.JOINED.equals(inheritanceState.type);\n    if (hasJoinedColumns) {\n        PrimaryKeyJoinColumns jcsAnn = annotatedClass.getAnnotation(PrimaryKeyJoinColumns.class);\n        boolean explicitInheritanceJoinedColumns = jcsAnn != null && jcsAnn.value().length != 0;\n        if (explicitInheritanceJoinedColumns) {\n            int nbrOfInhJoinedColumns = jcsAnn.value().length;\n            PrimaryKeyJoinColumn jcAnn;\n            inheritanceJoinedColumns = new Ejb3JoinColumn[nbrOfInhJoinedColumns];\n            for (int colIndex = 0; colIndex < nbrOfInhJoinedColumns; colIndex++) {\n                jcAnn = jcsAnn.value()[colIndex];\n                inheritanceJoinedColumns[colIndex] = Ejb3JoinColumn.buildJoinColumn(jcAnn, null, superEntity.getIdentifier(), (Map<String, Join>) null, (PropertyHolder) null, mappings);\n            }\n        } else {\n            PrimaryKeyJoinColumn jcAnn = annotatedClass.getAnnotation(PrimaryKeyJoinColumn.class);\n            inheritanceJoinedColumns = new Ejb3JoinColumn[1];\n            inheritanceJoinedColumns[0] = Ejb3JoinColumn.buildJoinColumn(jcAnn, null, superEntity.getIdentifier(), (Map<String, Join>) null, (PropertyHolder) null, mappings);\n        }\n        log.debug(\"Subclass joined column(s) created\");\n    } else {\n        if (annotatedClass.isAnnotationPresent(javax.persistence.PrimaryKeyJoinColumns.class) || annotatedClass.isAnnotationPresent(javax.persistence.PrimaryKeyJoinColumn.class)) {\n            log.warn(\"Root entity should not hold an PrimaryKeyJoinColum(s), will be ignored\");\n        }\n    }\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n        javax.persistence.DiscriminatorColumn discAnn = annotatedClass.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n        DiscriminatorType discriminatorType = discAnn != null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n        org.hibernate.annotations.DiscriminatorFormula discFormulaAnn = annotatedClass.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n        if (!inheritanceState.hasParents) {\n            discriminatorColumn = Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n        }\n        if (discAnn != null && inheritanceState.hasParents) {\n            log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n        }\n        discrimValue = annotatedClass.isAnnotationPresent(DiscriminatorValue.class) ? annotatedClass.getAnnotation(DiscriminatorValue.class).value() : null;\n    }\n    PersistentClass persistentClass;\n    if (!inheritanceState.hasParents) {\n        persistentClass = new RootClass();\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n        persistentClass = new SingleTableSubclass(superEntity);\n    } else if (InheritanceType.JOINED.equals(inheritanceState.type)) {\n        persistentClass = new JoinedSubclass(superEntity);\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.type)) {\n        persistentClass = new UnionSubclass(superEntity);\n    } else {\n        throw new AssertionFailure(\"Unknown inheritance type: \" + inheritanceState.type);\n    }\n    Proxy proxyAnn = annotatedClass.getAnnotation(Proxy.class);\n    BatchSize sizeAnn = annotatedClass.getAnnotation(BatchSize.class);\n    Where whereAnn = annotatedClass.getAnnotation(Where.class);\n    Entity entityAnn = annotatedClass.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn = annotatedClass.getAnnotation(org.hibernate.annotations.Entity.class);\n    org.hibernate.annotations.Cache cacheAnn = annotatedClass.getAnnotation(org.hibernate.annotations.Cache.class);\n    EntityBinder entityBinder = new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setDiscriminatorValue(discrimValue);\n    entityBinder.setBatchSize(sizeAnn);\n    entityBinder.setProxy(proxyAnn);\n    entityBinder.setWhere(whereAnn);\n    entityBinder.setCache(cacheAnn);\n    entityBinder.setInheritanceState(inheritanceState);\n    if (!inheritanceState.hasParents) {\n        bindFilters(clazzToProcess, entityBinder, mappings);\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn = annotatedClass.getAnnotation(Check.class);\n        String constraints = checkAnn == null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else {\n        if (annotatedClass.isAnnotationPresent(Table.class)) {\n            log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n        }\n    }\n    PropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn = annotatedClass.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn = annotatedClass.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn = annotatedClass.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate = false;\n    if (InheritanceType.JOINED.equals(inheritanceState.type) && inheritanceState.hasParents) {\n        onDeleteAppropriate = true;\n        final JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n        if (persistentClass.getEntityPersisterClass() == null) {\n            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n        }\n        SimpleValue key = new DependantValue(jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk = annotatedClass.getAnnotation(ForeignKey.class);\n        if (fk != null && !BinderHelper.isDefault(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn != null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp = new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n        if (inheritanceState.hasParents) {\n            if (persistentClass.getEntityPersisterClass() == null) {\n                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n            }\n        } else {\n            if (inheritanceState.hasSons || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.type)) {\n        if (inheritanceState.hasParents) {\n            if (persistentClass.getEntityPersisterClass() == null) {\n                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n            }\n        }\n    }\n    if (onDeleteAnn != null && !onDeleteAppropriate) {\n        log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n    }\n    HashMap<String, IdGenerator> classGenerators = buildLocalGenerators(annotatedClass, mappings);\n    List<PropertyData> elements = getElementsToProcess(persistentClass, clazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings);\n    if (elements == null) {\n        throw new AnnotationException(\"No identifier specified for entity: \" + propertyHolder.getEntityName());\n    }\n    final boolean subclassAndSingleTableStrategy = inheritanceState.type == InheritanceType.SINGLE_TABLE && inheritanceState.hasParents;\n    Set<String> idProperties = new HashSet<String>();\n    IdClass idClass = null;\n    XClass current = null;\n    if (!inheritanceState.hasParents) {\n        current = inheritanceState.clazz;\n        InheritanceState state = inheritanceState;\n        do {\n            current = state.clazz;\n            if (current.isAnnotationPresent(IdClass.class)) {\n                idClass = current.getAnnotation(IdClass.class);\n                break;\n            }\n            state = InheritanceState.getSuperclassInheritanceState(current, inheritanceStatePerClass, reflectionManager);\n        } while (state != null);\n    }\n    if (idClass != null) {\n        XClass compositeClass = reflectionManager.toXClass(idClass.value());\n        boolean isComponent = true;\n        boolean propertyAnnotated = entityBinder.isPropertyAnnotated(compositeClass);\n        String propertyAccessor = entityBinder.getPropertyAccessor(compositeClass);\n        String generatorType = \"assigned\";\n        String generator = BinderHelper.ANNOTATION_STRING_DEFAULT;\n        PropertyData inferredData = new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", compositeClass);\n        PropertyData baseInferredData = new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", current);\n        HashMap<String, IdGenerator> localGenerators = new HashMap<String, IdGenerator>();\n        boolean ignoreIdAnnotations = entityBinder.isIgnoreIdAnnotations();\n        entityBinder.setIgnoreIdAnnotations(true);\n        bindId(generatorType, generator, inferredData, baseInferredData, null, propertyHolder, localGenerators, isComponent, propertyAnnotated, propertyAccessor, entityBinder, true, false, mappings, inheritanceStatePerClass);\n        inferredData = new PropertyPreloadedData(propertyAccessor, \"_identifierMapper\", compositeClass);\n        Component mapper = fillComponent(propertyHolder, inferredData, baseInferredData, propertyAnnotated, propertyAccessor, false, entityBinder, true, true, false, mappings, inheritanceStatePerClass);\n        entityBinder.setIgnoreIdAnnotations(ignoreIdAnnotations);\n        persistentClass.setIdentifierMapper(mapper);\n        Property property = new Property();\n        property.setName(\"_identifierMapper\");\n        property.setNodeName(\"id\");\n        property.setUpdateable(false);\n        property.setInsertable(false);\n        property.setValue(mapper);\n        property.setPropertyAccessorName(\"embedded\");\n        persistentClass.addProperty(property);\n        entityBinder.setIgnoreIdAnnotations(true);\n        Iterator properties = mapper.getPropertyIterator();\n        while (properties.hasNext()) {\n            idProperties.add(((Property) properties.next()).getName());\n        }\n    }\n    Set<String> missingIdProperties = new HashSet<String>(idProperties);\n    for (PropertyData propertyAnnotatedElement : elements) {\n        String propertyName = propertyAnnotatedElement.getPropertyName();\n        if (!idProperties.contains(propertyName)) {\n            processElementAnnotations(propertyHolder, subclassAndSingleTableStrategy ? Nullability.FORCED_NULL : Nullability.NO_CONSTRAINT, propertyAnnotatedElement.getProperty(), propertyAnnotatedElement, classGenerators, entityBinder, false, false, false, mappings, inheritanceStatePerClass);\n        } else {\n            missingIdProperties.remove(propertyName);\n        }\n    }\n    if (missingIdProperties.size() != 0) {\n        StringBuilder missings = new StringBuilder();\n        for (String property : missingIdProperties) {\n            missings.append(property).append(\", \");\n        }\n        throw new AnnotationException(\"Unable to find properties (\" + missings.substring(0, missings.length() - 2) + \") in entity annotated with @IdClass:\" + persistentClass.getEntityName());\n    }\n    if (!inheritanceState.hasParents) {\n        final RootClass rootClass = (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, annotatedClass));\n    entityBinder.processComplementaryTableDefinitions(annotatedClass.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(annotatedClass.getAnnotation(org.hibernate.annotations.Tables.class));\n}"
    },
    {
      "commit": "a1e8d7cb0dcb4bd58fc5d210031bd0fb28196034",
      "startLine": 186,
      "endLine": 242,
      "methodCode": "public static void bindClass(XClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n    InheritanceState inheritanceState = inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType = mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType) || AnnotatedClassType.NONE.equals(classType) || AnnotatedClassType.EMBEDDABLE.equals(classType)) {\n        if (AnnotatedClassType.NONE.equals(classType) && clazzToProcess.isAnnotationPresent(org.hibernate.annotations.Entity.class)) {\n            log.warn(\"Class annotated @org.hibernate.annotations.Entity but not javax.persistence.Entity \" + \"(most likely a user error): {}\", clazzToProcess.getName());\n        }\n        return;\n    }\n    if (!classType.equals(AnnotatedClassType.ENTITY)) {\n        throw new AnnotationException(\"Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: \" + clazzToProcess.getName());\n    }\n    XAnnotatedElement annotatedClass = clazzToProcess;\n    log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n    InheritanceState superEntityState = InheritanceState.getSuperEntityInheritanceState(clazzToProcess, inheritanceStatePerClass, mappings.getReflectionManager());\n    PersistentClass superEntity = superEntityState != null ? mappings.getClass(superEntityState.clazz.getName()) : null;\n    if (superEntity == null) {\n        if (inheritanceState.hasParents) {\n            throw new AssertionFailure(\"Subclass has to be binded after it's mother class: \" + superEntityState.clazz.getName());\n        }\n    }\n    bindQueries(annotatedClass, mappings);\n    bindFilterDefs(annotatedClass, mappings);\n    bindTypeDefs(annotatedClass, mappings);\n    BinderHelper.bindAnyMetaDefs(annotatedClass, mappings);\n    String schema = \"\";\n    String table = \"\";\n    String catalog = \"\";\n    String discrimValue = null;\n    List<String[]> uniqueConstraints = new ArrayList<String[]>();\n    Ejb3DiscriminatorColumn discriminatorColumn = null;\n    Ejb3JoinColumn[] inheritanceJoinedColumns = null;\n    if (annotatedClass.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn = annotatedClass.getAnnotation(javax.persistence.Table.class);\n        table = tabAnn.name();\n        schema = tabAnn.schema();\n        catalog = tabAnn.catalog();\n        uniqueConstraints = TableBinder.buildUniqueConstraints(tabAnn.uniqueConstraints());\n    }\n    final boolean hasJoinedColumns = inheritanceState.hasParents && InheritanceType.JOINED.equals(inheritanceState.type);\n    if (hasJoinedColumns) {\n        PrimaryKeyJoinColumns jcsAnn = annotatedClass.getAnnotation(PrimaryKeyJoinColumns.class);\n        boolean explicitInheritanceJoinedColumns = jcsAnn != null && jcsAnn.value().length != 0;\n        if (explicitInheritanceJoinedColumns) {\n            int nbrOfInhJoinedColumns = jcsAnn.value().length;\n            PrimaryKeyJoinColumn jcAnn;\n            inheritanceJoinedColumns = new Ejb3JoinColumn[nbrOfInhJoinedColumns];\n            for (int colIndex = 0; colIndex < nbrOfInhJoinedColumns; colIndex++) {\n                jcAnn = jcsAnn.value()[colIndex];\n                inheritanceJoinedColumns[colIndex] = Ejb3JoinColumn.buildJoinColumn(jcAnn, null, superEntity.getIdentifier(), (Map<String, Join>) null, (PropertyHolder) null, mappings);\n            }\n        } else {\n            PrimaryKeyJoinColumn jcAnn = annotatedClass.getAnnotation(PrimaryKeyJoinColumn.class);\n            inheritanceJoinedColumns = new Ejb3JoinColumn[1];\n            inheritanceJoinedColumns[0] = Ejb3JoinColumn.buildJoinColumn(jcAnn, null, superEntity.getIdentifier(), (Map<String, Join>) null, (PropertyHolder) null, mappings);\n        }\n        log.debug(\"Subclass joined column(s) created\");\n    } else {\n        if (annotatedClass.isAnnotationPresent(javax.persistence.PrimaryKeyJoinColumns.class) || annotatedClass.isAnnotationPresent(javax.persistence.PrimaryKeyJoinColumn.class)) {\n            log.warn(\"Root entity should not hold an PrimaryKeyJoinColum(s), will be ignored\");\n        }\n    }\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n        javax.persistence.DiscriminatorColumn discAnn = annotatedClass.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n        DiscriminatorType discriminatorType = discAnn != null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n        org.hibernate.annotations.DiscriminatorFormula discFormulaAnn = annotatedClass.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n        if (!inheritanceState.hasParents) {\n            discriminatorColumn = Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n        }\n        if (discAnn != null && inheritanceState.hasParents) {\n            log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n        }\n        discrimValue = annotatedClass.isAnnotationPresent(DiscriminatorValue.class) ? annotatedClass.getAnnotation(DiscriminatorValue.class).value() : null;\n    }\n    PersistentClass persistentClass;\n    if (!inheritanceState.hasParents) {\n        persistentClass = new RootClass();\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n        persistentClass = new SingleTableSubclass(superEntity);\n    } else if (InheritanceType.JOINED.equals(inheritanceState.type)) {\n        persistentClass = new JoinedSubclass(superEntity);\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.type)) {\n        persistentClass = new UnionSubclass(superEntity);\n    } else {\n        throw new AssertionFailure(\"Unknown inheritance type: \" + inheritanceState.type);\n    }\n    Proxy proxyAnn = annotatedClass.getAnnotation(Proxy.class);\n    BatchSize sizeAnn = annotatedClass.getAnnotation(BatchSize.class);\n    Where whereAnn = annotatedClass.getAnnotation(Where.class);\n    Entity entityAnn = annotatedClass.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn = annotatedClass.getAnnotation(org.hibernate.annotations.Entity.class);\n    org.hibernate.annotations.Cache cacheAnn = annotatedClass.getAnnotation(org.hibernate.annotations.Cache.class);\n    EntityBinder entityBinder = new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setDiscriminatorValue(discrimValue);\n    entityBinder.setBatchSize(sizeAnn);\n    entityBinder.setProxy(proxyAnn);\n    entityBinder.setWhere(whereAnn);\n    entityBinder.setCache(cacheAnn);\n    entityBinder.setInheritanceState(inheritanceState);\n    if (!inheritanceState.hasParents) {\n        bindFilters(clazzToProcess, entityBinder, mappings);\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn = annotatedClass.getAnnotation(Check.class);\n        String constraints = checkAnn == null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else {\n        if (annotatedClass.isAnnotationPresent(Table.class)) {\n            log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n        }\n    }\n    PropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings);\n    javax.persistence.SecondaryTable secTabAnn = annotatedClass.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn = annotatedClass.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn = annotatedClass.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate = false;\n    if (InheritanceType.JOINED.equals(inheritanceState.type) && inheritanceState.hasParents) {\n        onDeleteAppropriate = true;\n        final JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n        if (persistentClass.getEntityPersisterClass() == null) {\n            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n        }\n        SimpleValue key = new DependantValue(jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk = annotatedClass.getAnnotation(ForeignKey.class);\n        if (fk != null && !BinderHelper.isDefault(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn != null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp = new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n        if (inheritanceState.hasParents) {\n            if (persistentClass.getEntityPersisterClass() == null) {\n                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n            }\n        } else {\n            if (inheritanceState.hasSons || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.type)) {\n        if (inheritanceState.hasParents) {\n            if (persistentClass.getEntityPersisterClass() == null) {\n                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n            }\n        }\n    }\n    if (onDeleteAnn != null && !onDeleteAppropriate) {\n        log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n    }\n    HashMap<String, IdGenerator> classGenerators = buildLocalGenerators(annotatedClass, mappings);\n    List<PropertyData> elements = getElementsToProcess(clazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings);\n    if (elements == null) {\n        throw new AnnotationException(\"No identifier specified for entity: \" + propertyHolder.getEntityName());\n    }\n    final boolean subclassAndSingleTableStrategy = inheritanceState.type == InheritanceType.SINGLE_TABLE && inheritanceState.hasParents;\n    Set<String> idProperties = new HashSet<String>();\n    IdClass idClass = null;\n    XClass current = null;\n    if (!inheritanceState.hasParents) {\n        current = inheritanceState.clazz;\n        InheritanceState state = inheritanceState;\n        do {\n            current = state.clazz;\n            if (current.isAnnotationPresent(IdClass.class)) {\n                idClass = current.getAnnotation(IdClass.class);\n                break;\n            }\n            state = InheritanceState.getSuperclassInheritanceState(current, inheritanceStatePerClass, mappings.getReflectionManager());\n        } while (state != null);\n    }\n    if (idClass != null) {\n        XClass compositeClass = mappings.getReflectionManager().toXClass(idClass.value());\n        boolean isComponent = true;\n        boolean propertyAnnotated = entityBinder.isPropertyAnnotated(compositeClass);\n        String propertyAccessor = entityBinder.getPropertyAccessor(compositeClass);\n        String generatorType = \"assigned\";\n        String generator = BinderHelper.ANNOTATION_STRING_DEFAULT;\n        PropertyData inferredData = new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", compositeClass);\n        PropertyData baseInferredData = new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", current);\n        HashMap<String, IdGenerator> localGenerators = new HashMap<String, IdGenerator>();\n        boolean ignoreIdAnnotations = entityBinder.isIgnoreIdAnnotations();\n        entityBinder.setIgnoreIdAnnotations(true);\n        bindId(generatorType, generator, inferredData, baseInferredData, null, propertyHolder, localGenerators, isComponent, propertyAnnotated, propertyAccessor, entityBinder, true, false, mappings);\n        inferredData = new PropertyPreloadedData(propertyAccessor, \"_identifierMapper\", compositeClass);\n        Component mapper = fillComponent(propertyHolder, inferredData, baseInferredData, propertyAnnotated, propertyAccessor, false, entityBinder, true, true, false, mappings);\n        entityBinder.setIgnoreIdAnnotations(ignoreIdAnnotations);\n        persistentClass.setIdentifierMapper(mapper);\n        Property property = new Property();\n        property.setName(\"_identifierMapper\");\n        property.setNodeName(\"id\");\n        property.setUpdateable(false);\n        property.setInsertable(false);\n        property.setValue(mapper);\n        property.setPropertyAccessorName(\"embedded\");\n        persistentClass.addProperty(property);\n        entityBinder.setIgnoreIdAnnotations(true);\n        Iterator properties = mapper.getPropertyIterator();\n        while (properties.hasNext()) {\n            idProperties.add(((Property) properties.next()).getName());\n        }\n    }\n    Set<String> missingIdProperties = new HashSet<String>(idProperties);\n    for (PropertyData propertyAnnotatedElement : elements) {\n        String propertyName = propertyAnnotatedElement.getPropertyName();\n        if (!idProperties.contains(propertyName)) {\n            processElementAnnotations(propertyHolder, subclassAndSingleTableStrategy ? Nullability.FORCED_NULL : Nullability.NO_CONSTRAINT, propertyAnnotatedElement.getProperty(), propertyAnnotatedElement, classGenerators, entityBinder, false, false, false, mappings);\n        } else {\n            missingIdProperties.remove(propertyName);\n        }\n    }\n    if (missingIdProperties.size() != 0) {\n        StringBuilder missings = new StringBuilder();\n        for (String property : missingIdProperties) {\n            missings.append(property).append(\", \");\n        }\n        throw new AnnotationException(\"Unable to find properties (\" + missings.substring(0, missings.length() - 2) + \") in entity annotated with @IdClass:\" + persistentClass.getEntityName());\n    }\n    if (!inheritanceState.hasParents) {\n        final RootClass rootClass = (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, annotatedClass));\n    entityBinder.processComplementaryTableDefinitions(annotatedClass.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(annotatedClass.getAnnotation(org.hibernate.annotations.Tables.class));\n}"
    },
    {
      "commit": "2176af11442c702aefa1900cdba4c32e6338b620",
      "startLine": 192,
      "endLine": 248,
      "methodCode": "public static void bindClass(XClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n    InheritanceState inheritanceState = inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType = mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n    }\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType) || AnnotatedClassType.NONE.equals(classType) || AnnotatedClassType.EMBEDDABLE.equals(classType)) {\n        if (AnnotatedClassType.NONE.equals(classType) && clazzToProcess.isAnnotationPresent(org.hibernate.annotations.Entity.class)) {\n            log.warn(\"Class annotated @org.hibernate.annotations.Entity but not javax.persistence.Entity \" + \"(most likely a user error): {}\", clazzToProcess.getName());\n        }\n        return;\n    }\n    if (!classType.equals(AnnotatedClassType.ENTITY)) {\n        throw new AnnotationException(\"Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: \" + clazzToProcess.getName());\n    }\n    XAnnotatedElement annotatedClass = clazzToProcess;\n    log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n    InheritanceState superEntityState = InheritanceState.getSuperEntityInheritanceState(clazzToProcess, inheritanceStatePerClass, mappings.getReflectionManager());\n    PersistentClass superEntity = superEntityState != null ? mappings.getClass(superEntityState.clazz.getName()) : null;\n    if (superEntity == null) {\n        if (inheritanceState.hasParents) {\n            throw new AssertionFailure(\"Subclass has to be binded after it's mother class: \" + superEntityState.clazz.getName());\n        }\n    }\n    bindQueries(annotatedClass, mappings);\n    bindFilterDefs(annotatedClass, mappings);\n    bindTypeDefs(annotatedClass, mappings);\n    BinderHelper.bindAnyMetaDefs(annotatedClass, mappings);\n    String schema = \"\";\n    String table = \"\";\n    String catalog = \"\";\n    String discrimValue = null;\n    List<String[]> uniqueConstraints = new ArrayList<String[]>();\n    Ejb3DiscriminatorColumn discriminatorColumn = null;\n    Ejb3JoinColumn[] inheritanceJoinedColumns = null;\n    if (annotatedClass.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn = annotatedClass.getAnnotation(javax.persistence.Table.class);\n        table = tabAnn.name();\n        schema = tabAnn.schema();\n        catalog = tabAnn.catalog();\n        uniqueConstraints = TableBinder.buildUniqueConstraints(tabAnn.uniqueConstraints());\n    }\n    final boolean hasJoinedColumns = inheritanceState.hasParents && InheritanceType.JOINED.equals(inheritanceState.type);\n    if (hasJoinedColumns) {\n        PrimaryKeyJoinColumns jcsAnn = annotatedClass.getAnnotation(PrimaryKeyJoinColumns.class);\n        boolean explicitInheritanceJoinedColumns = jcsAnn != null && jcsAnn.value().length != 0;\n        if (explicitInheritanceJoinedColumns) {\n            int nbrOfInhJoinedColumns = jcsAnn.value().length;\n            PrimaryKeyJoinColumn jcAnn;\n            inheritanceJoinedColumns = new Ejb3JoinColumn[nbrOfInhJoinedColumns];\n            for (int colIndex = 0; colIndex < nbrOfInhJoinedColumns; colIndex++) {\n                jcAnn = jcsAnn.value()[colIndex];\n                inheritanceJoinedColumns[colIndex] = Ejb3JoinColumn.buildJoinColumn(jcAnn, null, superEntity.getIdentifier(), (Map<String, Join>) null, (PropertyHolder) null, mappings);\n            }\n        } else {\n            PrimaryKeyJoinColumn jcAnn = annotatedClass.getAnnotation(PrimaryKeyJoinColumn.class);\n            inheritanceJoinedColumns = new Ejb3JoinColumn[1];\n            inheritanceJoinedColumns[0] = Ejb3JoinColumn.buildJoinColumn(jcAnn, null, superEntity.getIdentifier(), (Map<String, Join>) null, (PropertyHolder) null, mappings);\n        }\n        log.debug(\"Subclass joined column(s) created\");\n    } else {\n        if (annotatedClass.isAnnotationPresent(javax.persistence.PrimaryKeyJoinColumns.class) || annotatedClass.isAnnotationPresent(javax.persistence.PrimaryKeyJoinColumn.class)) {\n            log.warn(\"Root entity should not hold an PrimaryKeyJoinColum(s), will be ignored\");\n        }\n    }\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n        javax.persistence.DiscriminatorColumn discAnn = annotatedClass.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n        DiscriminatorType discriminatorType = discAnn != null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n        org.hibernate.annotations.DiscriminatorFormula discFormulaAnn = annotatedClass.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n        if (!inheritanceState.hasParents) {\n            discriminatorColumn = Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n        }\n        if (discAnn != null && inheritanceState.hasParents) {\n            log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n        }\n        discrimValue = annotatedClass.isAnnotationPresent(DiscriminatorValue.class) ? annotatedClass.getAnnotation(DiscriminatorValue.class).value() : null;\n    }\n    PersistentClass persistentClass;\n    if (!inheritanceState.hasParents) {\n        persistentClass = new RootClass();\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n        persistentClass = new SingleTableSubclass(superEntity);\n    } else if (InheritanceType.JOINED.equals(inheritanceState.type)) {\n        persistentClass = new JoinedSubclass(superEntity);\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.type)) {\n        persistentClass = new UnionSubclass(superEntity);\n    } else {\n        throw new AssertionFailure(\"Unknown inheritance type: \" + inheritanceState.type);\n    }\n    Proxy proxyAnn = annotatedClass.getAnnotation(Proxy.class);\n    BatchSize sizeAnn = annotatedClass.getAnnotation(BatchSize.class);\n    Where whereAnn = annotatedClass.getAnnotation(Where.class);\n    Entity entityAnn = annotatedClass.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn = annotatedClass.getAnnotation(org.hibernate.annotations.Entity.class);\n    org.hibernate.annotations.Cache cacheAnn = annotatedClass.getAnnotation(org.hibernate.annotations.Cache.class);\n    EntityBinder entityBinder = new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setDiscriminatorValue(discrimValue);\n    entityBinder.setBatchSize(sizeAnn);\n    entityBinder.setProxy(proxyAnn);\n    entityBinder.setWhere(whereAnn);\n    entityBinder.setCache(cacheAnn);\n    entityBinder.setInheritanceState(inheritanceState);\n    Filter filterAnn = annotatedClass.getAnnotation(Filter.class);\n    if (filterAnn != null) {\n        entityBinder.addFilter(filterAnn.name(), filterAnn.condition());\n    }\n    Filters filtersAnn = annotatedClass.getAnnotation(Filters.class);\n    if (filtersAnn != null) {\n        for (Filter filter : filtersAnn.value()) {\n            entityBinder.addFilter(filter.name(), filter.condition());\n        }\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn = annotatedClass.getAnnotation(Check.class);\n        String constraints = checkAnn == null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else {\n        if (annotatedClass.isAnnotationPresent(Table.class)) {\n            log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n        }\n    }\n    PropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings);\n    javax.persistence.SecondaryTable secTabAnn = annotatedClass.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn = annotatedClass.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn = annotatedClass.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate = false;\n    if (InheritanceType.JOINED.equals(inheritanceState.type) && inheritanceState.hasParents) {\n        onDeleteAppropriate = true;\n        final JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n        if (persistentClass.getEntityPersisterClass() == null) {\n            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n        }\n        SimpleValue key = new DependantValue(jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk = annotatedClass.getAnnotation(ForeignKey.class);\n        if (fk != null && !BinderHelper.isDefault(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn != null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp = new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n        if (inheritanceState.hasParents) {\n            if (persistentClass.getEntityPersisterClass() == null) {\n                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n            }\n        } else {\n            if (inheritanceState.hasSons || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.type)) {\n        if (inheritanceState.hasParents) {\n            if (persistentClass.getEntityPersisterClass() == null) {\n                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n            }\n        }\n    }\n    if (onDeleteAnn != null && !onDeleteAppropriate) {\n        log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n    }\n    HashMap<String, IdGenerator> classGenerators = buildLocalGenerators(annotatedClass, mappings);\n    List<PropertyData> elements = getElementsToProcess(clazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings);\n    if (elements == null) {\n        throw new AnnotationException(\"No identifier specified for entity: \" + propertyHolder.getEntityName());\n    }\n    final boolean subclassAndSingleTableStrategy = inheritanceState.type == InheritanceType.SINGLE_TABLE && inheritanceState.hasParents;\n    Set<String> idProperties = new HashSet<String>();\n    IdClass idClass = null;\n    XClass current = null;\n    if (!inheritanceState.hasParents) {\n        current = inheritanceState.clazz;\n        InheritanceState state = inheritanceState;\n        do {\n            current = state.clazz;\n            if (current.isAnnotationPresent(IdClass.class)) {\n                idClass = current.getAnnotation(IdClass.class);\n                break;\n            }\n            state = InheritanceState.getSuperclassInheritanceState(current, inheritanceStatePerClass, mappings.getReflectionManager());\n        } while (state != null);\n    }\n    if (idClass != null) {\n        XClass compositeClass = mappings.getReflectionManager().toXClass(idClass.value());\n        boolean isComponent = true;\n        boolean propertyAnnotated = entityBinder.isPropertyAnnotated(compositeClass);\n        String propertyAccessor = entityBinder.getPropertyAccessor(compositeClass);\n        String generatorType = \"assigned\";\n        String generator = BinderHelper.ANNOTATION_STRING_DEFAULT;\n        PropertyData inferredData = new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", compositeClass);\n        PropertyData baseInferredData = new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", current);\n        HashMap<String, IdGenerator> localGenerators = new HashMap<String, IdGenerator>();\n        boolean ignoreIdAnnotations = entityBinder.isIgnoreIdAnnotations();\n        entityBinder.setIgnoreIdAnnotations(true);\n        bindId(generatorType, generator, inferredData, baseInferredData, null, propertyHolder, localGenerators, isComponent, propertyAnnotated, propertyAccessor, entityBinder, true, false, mappings);\n        inferredData = new PropertyPreloadedData(propertyAccessor, \"_identifierMapper\", compositeClass);\n        Component mapper = fillComponent(propertyHolder, inferredData, baseInferredData, propertyAnnotated, propertyAccessor, false, entityBinder, true, true, false, mappings);\n        entityBinder.setIgnoreIdAnnotations(ignoreIdAnnotations);\n        persistentClass.setIdentifierMapper(mapper);\n        Property property = new Property();\n        property.setName(\"_identifierMapper\");\n        property.setNodeName(\"id\");\n        property.setUpdateable(false);\n        property.setInsertable(false);\n        property.setValue(mapper);\n        property.setPropertyAccessorName(\"embedded\");\n        persistentClass.addProperty(property);\n        entityBinder.setIgnoreIdAnnotations(true);\n        Iterator properties = mapper.getPropertyIterator();\n        while (properties.hasNext()) {\n            idProperties.add(((Property) properties.next()).getName());\n        }\n    }\n    Set<String> missingIdProperties = new HashSet<String>(idProperties);\n    for (PropertyData propertyAnnotatedElement : elements) {\n        String propertyName = propertyAnnotatedElement.getPropertyName();\n        if (!idProperties.contains(propertyName)) {\n            processElementAnnotations(propertyHolder, subclassAndSingleTableStrategy ? Nullability.FORCED_NULL : Nullability.NO_CONSTRAINT, propertyAnnotatedElement.getProperty(), propertyAnnotatedElement, classGenerators, entityBinder, false, false, false, mappings);\n        } else {\n            missingIdProperties.remove(propertyName);\n        }\n    }\n    if (missingIdProperties.size() != 0) {\n        StringBuilder missings = new StringBuilder();\n        for (String property : missingIdProperties) {\n            missings.append(property).append(\", \");\n        }\n        throw new AnnotationException(\"Unable to find properties (\" + missings.substring(0, missings.length() - 2) + \") in entity annotated with @IdClass:\" + persistentClass.getEntityName());\n    }\n    if (!inheritanceState.hasParents) {\n        final RootClass rootClass = (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, annotatedClass));\n    entityBinder.processComplementaryTableDefinitions(annotatedClass.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(annotatedClass.getAnnotation(org.hibernate.annotations.Tables.class));\n}"
    },
    {
      "commit": "8cc9e9d5fd2e13844ed222e144c48f7df4487fa4",
      "startLine": 191,
      "endLine": 246,
      "methodCode": "public static void bindClass(XClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n    InheritanceState inheritanceState = inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType = mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n    }\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType) || AnnotatedClassType.NONE.equals(classType) || AnnotatedClassType.EMBEDDABLE.equals(classType)) {\n        if (AnnotatedClassType.NONE.equals(classType) && clazzToProcess.isAnnotationPresent(org.hibernate.annotations.Entity.class)) {\n            log.warn(\"Class annotated @org.hibernate.annotations.Entity but not javax.persistence.Entity \" + \"(most likely a user error): {}\", clazzToProcess.getName());\n        }\n        return;\n    }\n    if (!classType.equals(AnnotatedClassType.ENTITY)) {\n        throw new AnnotationException(\"Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: \" + clazzToProcess.getName());\n    }\n    XAnnotatedElement annotatedClass = clazzToProcess;\n    log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n    InheritanceState superEntityState = InheritanceState.getSuperEntityInheritanceState(clazzToProcess, inheritanceStatePerClass, mappings.getReflectionManager());\n    PersistentClass superEntity = superEntityState != null ? mappings.getClass(superEntityState.clazz.getName()) : null;\n    if (superEntity == null) {\n        if (inheritanceState.hasParents) {\n            throw new AssertionFailure(\"Subclass has to be binded after it's mother class: \" + superEntityState.clazz.getName());\n        }\n    }\n    bindQueries(annotatedClass, mappings);\n    bindFilterDefs(annotatedClass, mappings);\n    bindTypeDefs(annotatedClass, mappings);\n    BinderHelper.bindAnyMetaDefs(annotatedClass, mappings);\n    String schema = \"\";\n    String table = \"\";\n    String catalog = \"\";\n    String discrimValue = null;\n    List<String[]> uniqueConstraints = new ArrayList<String[]>();\n    Ejb3DiscriminatorColumn discriminatorColumn = null;\n    Ejb3JoinColumn[] inheritanceJoinedColumns = null;\n    if (annotatedClass.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn = annotatedClass.getAnnotation(javax.persistence.Table.class);\n        table = tabAnn.name();\n        schema = tabAnn.schema();\n        catalog = tabAnn.catalog();\n        uniqueConstraints = TableBinder.buildUniqueConstraints(tabAnn.uniqueConstraints());\n    }\n    final boolean hasJoinedColumns = inheritanceState.hasParents && InheritanceType.JOINED.equals(inheritanceState.type);\n    if (hasJoinedColumns) {\n        PrimaryKeyJoinColumns jcsAnn = annotatedClass.getAnnotation(PrimaryKeyJoinColumns.class);\n        boolean explicitInheritanceJoinedColumns = jcsAnn != null && jcsAnn.value().length != 0;\n        if (explicitInheritanceJoinedColumns) {\n            int nbrOfInhJoinedColumns = jcsAnn.value().length;\n            PrimaryKeyJoinColumn jcAnn;\n            inheritanceJoinedColumns = new Ejb3JoinColumn[nbrOfInhJoinedColumns];\n            for (int colIndex = 0; colIndex < nbrOfInhJoinedColumns; colIndex++) {\n                jcAnn = jcsAnn.value()[colIndex];\n                inheritanceJoinedColumns[colIndex] = Ejb3JoinColumn.buildJoinColumn(jcAnn, null, superEntity.getIdentifier(), (Map<String, Join>) null, (PropertyHolder) null, mappings);\n            }\n        } else {\n            PrimaryKeyJoinColumn jcAnn = annotatedClass.getAnnotation(PrimaryKeyJoinColumn.class);\n            inheritanceJoinedColumns = new Ejb3JoinColumn[1];\n            inheritanceJoinedColumns[0] = Ejb3JoinColumn.buildJoinColumn(jcAnn, null, superEntity.getIdentifier(), (Map<String, Join>) null, (PropertyHolder) null, mappings);\n        }\n        log.debug(\"Subclass joined column(s) created\");\n    } else {\n        if (annotatedClass.isAnnotationPresent(javax.persistence.PrimaryKeyJoinColumns.class) || annotatedClass.isAnnotationPresent(javax.persistence.PrimaryKeyJoinColumn.class)) {\n            log.warn(\"Root entity should not hold an PrimaryKeyJoinColum(s), will be ignored\");\n        }\n    }\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n        javax.persistence.DiscriminatorColumn discAnn = annotatedClass.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n        DiscriminatorType discriminatorType = discAnn != null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n        org.hibernate.annotations.DiscriminatorFormula discFormulaAnn = annotatedClass.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n        if (!inheritanceState.hasParents) {\n            discriminatorColumn = Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n        }\n        if (discAnn != null && inheritanceState.hasParents) {\n            log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n        }\n        discrimValue = annotatedClass.isAnnotationPresent(DiscriminatorValue.class) ? annotatedClass.getAnnotation(DiscriminatorValue.class).value() : null;\n    }\n    PersistentClass persistentClass;\n    if (!inheritanceState.hasParents) {\n        persistentClass = new RootClass();\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n        persistentClass = new SingleTableSubclass(superEntity);\n    } else if (InheritanceType.JOINED.equals(inheritanceState.type)) {\n        persistentClass = new JoinedSubclass(superEntity);\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.type)) {\n        persistentClass = new UnionSubclass(superEntity);\n    } else {\n        throw new AssertionFailure(\"Unknown inheritance type: \" + inheritanceState.type);\n    }\n    Proxy proxyAnn = annotatedClass.getAnnotation(Proxy.class);\n    BatchSize sizeAnn = annotatedClass.getAnnotation(BatchSize.class);\n    Where whereAnn = annotatedClass.getAnnotation(Where.class);\n    Entity entityAnn = annotatedClass.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn = annotatedClass.getAnnotation(org.hibernate.annotations.Entity.class);\n    org.hibernate.annotations.Cache cacheAnn = annotatedClass.getAnnotation(org.hibernate.annotations.Cache.class);\n    EntityBinder entityBinder = new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setDiscriminatorValue(discrimValue);\n    entityBinder.setBatchSize(sizeAnn);\n    entityBinder.setProxy(proxyAnn);\n    entityBinder.setWhere(whereAnn);\n    entityBinder.setCache(cacheAnn);\n    entityBinder.setInheritanceState(inheritanceState);\n    Filter filterAnn = annotatedClass.getAnnotation(Filter.class);\n    if (filterAnn != null) {\n        entityBinder.addFilter(filterAnn.name(), filterAnn.condition());\n    }\n    Filters filtersAnn = annotatedClass.getAnnotation(Filters.class);\n    if (filtersAnn != null) {\n        for (Filter filter : filtersAnn.value()) {\n            entityBinder.addFilter(filter.name(), filter.condition());\n        }\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn = annotatedClass.getAnnotation(Check.class);\n        String constraints = checkAnn == null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else {\n        if (annotatedClass.isAnnotationPresent(Table.class)) {\n            log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n        }\n    }\n    PropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings);\n    javax.persistence.SecondaryTable secTabAnn = annotatedClass.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn = annotatedClass.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn = annotatedClass.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate = false;\n    if (InheritanceType.JOINED.equals(inheritanceState.type) && inheritanceState.hasParents) {\n        onDeleteAppropriate = true;\n        final JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n        if (persistentClass.getEntityPersisterClass() == null) {\n            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n        }\n        SimpleValue key = new DependantValue(jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk = annotatedClass.getAnnotation(ForeignKey.class);\n        if (fk != null && !BinderHelper.isDefault(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn != null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp = new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n        if (inheritanceState.hasParents) {\n            if (persistentClass.getEntityPersisterClass() == null) {\n                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n            }\n        } else {\n            if (inheritanceState.hasSons || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.type)) {\n        if (inheritanceState.hasParents) {\n            if (persistentClass.getEntityPersisterClass() == null) {\n                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n            }\n        }\n    }\n    if (onDeleteAnn != null && !onDeleteAppropriate) {\n        log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n    }\n    HashMap<String, IdGenerator> classGenerators = buildLocalGenerators(annotatedClass, mappings);\n    List<PropertyData> elements = getElementsToProcess(clazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings);\n    if (elements == null) {\n        throw new AnnotationException(\"No identifier specified for entity: \" + propertyHolder.getEntityName());\n    }\n    final boolean subclassAndSingleTableStrategy = inheritanceState.type == InheritanceType.SINGLE_TABLE && inheritanceState.hasParents;\n    Set<String> idProperties = new HashSet<String>();\n    IdClass idClass = null;\n    if (!inheritanceState.hasParents) {\n        XClass current = inheritanceState.clazz;\n        InheritanceState state = inheritanceState;\n        do {\n            current = state.clazz;\n            if (current.isAnnotationPresent(IdClass.class)) {\n                idClass = current.getAnnotation(IdClass.class);\n                break;\n            }\n            state = InheritanceState.getSuperclassInheritanceState(current, inheritanceStatePerClass, mappings.getReflectionManager());\n        } while (state != null);\n    }\n    if (idClass != null) {\n        XClass compositeClass = mappings.getReflectionManager().toXClass(idClass.value());\n        boolean isComponent = true;\n        boolean propertyAnnotated = entityBinder.isPropertyAnnotated(compositeClass);\n        String propertyAccessor = entityBinder.getPropertyAccessor(compositeClass);\n        String generatorType = \"assigned\";\n        String generator = BinderHelper.ANNOTATION_STRING_DEFAULT;\n        PropertyData inferredData = new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", compositeClass);\n        HashMap<String, IdGenerator> localGenerators = new HashMap<String, IdGenerator>();\n        boolean ignoreIdAnnotations = entityBinder.isIgnoreIdAnnotations();\n        entityBinder.setIgnoreIdAnnotations(true);\n        bindId(generatorType, generator, inferredData, null, propertyHolder, localGenerators, isComponent, propertyAnnotated, propertyAccessor, entityBinder, true, false, mappings);\n        inferredData = new PropertyPreloadedData(propertyAccessor, \"_identifierMapper\", compositeClass);\n        Component mapper = fillComponent(propertyHolder, inferredData, propertyAnnotated, propertyAccessor, false, entityBinder, true, true, false, mappings);\n        entityBinder.setIgnoreIdAnnotations(ignoreIdAnnotations);\n        persistentClass.setIdentifierMapper(mapper);\n        Property property = new Property();\n        property.setName(\"_identifierMapper\");\n        property.setNodeName(\"id\");\n        property.setUpdateable(false);\n        property.setInsertable(false);\n        property.setValue(mapper);\n        property.setPropertyAccessorName(\"embedded\");\n        persistentClass.addProperty(property);\n        entityBinder.setIgnoreIdAnnotations(true);\n        Iterator properties = mapper.getPropertyIterator();\n        while (properties.hasNext()) {\n            idProperties.add(((Property) properties.next()).getName());\n        }\n    }\n    Set<String> missingIdProperties = new HashSet<String>(idProperties);\n    for (PropertyData propertyAnnotatedElement : elements) {\n        String propertyName = propertyAnnotatedElement.getPropertyName();\n        if (!idProperties.contains(propertyName)) {\n            processElementAnnotations(propertyHolder, subclassAndSingleTableStrategy ? Nullability.FORCED_NULL : Nullability.NO_CONSTRAINT, propertyAnnotatedElement.getProperty(), propertyAnnotatedElement, classGenerators, entityBinder, false, false, false, mappings);\n        } else {\n            missingIdProperties.remove(propertyName);\n        }\n    }\n    if (missingIdProperties.size() != 0) {\n        StringBuilder missings = new StringBuilder();\n        for (String property : missingIdProperties) {\n            missings.append(property).append(\", \");\n        }\n        throw new AnnotationException(\"Unable to find properties (\" + missings.substring(0, missings.length() - 2) + \") in entity annotated with @IdClass:\" + persistentClass.getEntityName());\n    }\n    if (!inheritanceState.hasParents) {\n        final RootClass rootClass = (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, annotatedClass));\n    entityBinder.processComplementaryTableDefinitions(annotatedClass.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(annotatedClass.getAnnotation(org.hibernate.annotations.Tables.class));\n}"
    },
    {
      "commit": "88caf4d9586e988675254c268f4e145d272a9499",
      "startLine": 190,
      "endLine": 245,
      "methodCode": "public static void bindClass(XClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n    InheritanceState inheritanceState = inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType = mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n    }\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType) || AnnotatedClassType.NONE.equals(classType) || AnnotatedClassType.EMBEDDABLE.equals(classType)) {\n        if (AnnotatedClassType.NONE.equals(classType) && clazzToProcess.isAnnotationPresent(org.hibernate.annotations.Entity.class)) {\n            log.warn(\"Class annotated @org.hibernate.annotations.Entity but not javax.persistence.Entity \" + \"(most likely a user error): {}\", clazzToProcess.getName());\n        }\n        return;\n    }\n    if (!classType.equals(AnnotatedClassType.ENTITY)) {\n        throw new AnnotationException(\"Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: \" + clazzToProcess.getName());\n    }\n    XAnnotatedElement annotatedClass = clazzToProcess;\n    log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n    InheritanceState superEntityState = InheritanceState.getSuperEntityInheritanceState(clazzToProcess, inheritanceStatePerClass, mappings.getReflectionManager());\n    PersistentClass superEntity = superEntityState != null ? mappings.getClass(superEntityState.clazz.getName()) : null;\n    if (superEntity == null) {\n        if (inheritanceState.hasParents) {\n            throw new AssertionFailure(\"Subclass has to be binded after it's mother class: \" + superEntityState.clazz.getName());\n        }\n    }\n    bindQueries(annotatedClass, mappings);\n    bindFilterDefs(annotatedClass, mappings);\n    bindTypeDefs(annotatedClass, mappings);\n    BinderHelper.bindAnyMetaDefs(annotatedClass, mappings);\n    String schema = \"\";\n    String table = \"\";\n    String catalog = \"\";\n    String discrimValue = null;\n    List<String[]> uniqueConstraints = new ArrayList<String[]>();\n    Ejb3DiscriminatorColumn discriminatorColumn = null;\n    Ejb3JoinColumn[] inheritanceJoinedColumns = null;\n    if (annotatedClass.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn = annotatedClass.getAnnotation(javax.persistence.Table.class);\n        table = tabAnn.name();\n        schema = tabAnn.schema();\n        catalog = tabAnn.catalog();\n        uniqueConstraints = TableBinder.buildUniqueConstraints(tabAnn.uniqueConstraints());\n    }\n    final boolean hasJoinedColumns = inheritanceState.hasParents && InheritanceType.JOINED.equals(inheritanceState.type);\n    if (hasJoinedColumns) {\n        PrimaryKeyJoinColumns jcsAnn = annotatedClass.getAnnotation(PrimaryKeyJoinColumns.class);\n        boolean explicitInheritanceJoinedColumns = jcsAnn != null && jcsAnn.value().length != 0;\n        if (explicitInheritanceJoinedColumns) {\n            int nbrOfInhJoinedColumns = jcsAnn.value().length;\n            PrimaryKeyJoinColumn jcAnn;\n            inheritanceJoinedColumns = new Ejb3JoinColumn[nbrOfInhJoinedColumns];\n            for (int colIndex = 0; colIndex < nbrOfInhJoinedColumns; colIndex++) {\n                jcAnn = jcsAnn.value()[colIndex];\n                inheritanceJoinedColumns[colIndex] = Ejb3JoinColumn.buildJoinColumn(jcAnn, null, superEntity.getIdentifier(), (Map<String, Join>) null, (PropertyHolder) null, mappings);\n            }\n        } else {\n            PrimaryKeyJoinColumn jcAnn = annotatedClass.getAnnotation(PrimaryKeyJoinColumn.class);\n            inheritanceJoinedColumns = new Ejb3JoinColumn[1];\n            inheritanceJoinedColumns[0] = Ejb3JoinColumn.buildJoinColumn(jcAnn, null, superEntity.getIdentifier(), (Map<String, Join>) null, (PropertyHolder) null, mappings);\n        }\n        log.debug(\"Subclass joined column(s) created\");\n    } else {\n        if (annotatedClass.isAnnotationPresent(javax.persistence.PrimaryKeyJoinColumns.class) || annotatedClass.isAnnotationPresent(javax.persistence.PrimaryKeyJoinColumn.class)) {\n            log.warn(\"Root entity should not hold an PrimaryKeyJoinColum(s), will be ignored\");\n        }\n    }\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n        javax.persistence.DiscriminatorColumn discAnn = annotatedClass.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n        DiscriminatorType discriminatorType = discAnn != null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n        org.hibernate.annotations.DiscriminatorFormula discFormulaAnn = annotatedClass.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n        if (!inheritanceState.hasParents) {\n            discriminatorColumn = Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n        }\n        if (discAnn != null && inheritanceState.hasParents) {\n            log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n        }\n        discrimValue = annotatedClass.isAnnotationPresent(DiscriminatorValue.class) ? annotatedClass.getAnnotation(DiscriminatorValue.class).value() : null;\n    }\n    PersistentClass persistentClass;\n    if (!inheritanceState.hasParents) {\n        persistentClass = new RootClass();\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n        persistentClass = new SingleTableSubclass(superEntity);\n    } else if (InheritanceType.JOINED.equals(inheritanceState.type)) {\n        persistentClass = new JoinedSubclass(superEntity);\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.type)) {\n        persistentClass = new UnionSubclass(superEntity);\n    } else {\n        throw new AssertionFailure(\"Unknown inheritance type: \" + inheritanceState.type);\n    }\n    Proxy proxyAnn = annotatedClass.getAnnotation(Proxy.class);\n    BatchSize sizeAnn = annotatedClass.getAnnotation(BatchSize.class);\n    Where whereAnn = annotatedClass.getAnnotation(Where.class);\n    Entity entityAnn = annotatedClass.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn = annotatedClass.getAnnotation(org.hibernate.annotations.Entity.class);\n    org.hibernate.annotations.Cache cacheAnn = annotatedClass.getAnnotation(org.hibernate.annotations.Cache.class);\n    EntityBinder entityBinder = new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setDiscriminatorValue(discrimValue);\n    entityBinder.setBatchSize(sizeAnn);\n    entityBinder.setProxy(proxyAnn);\n    entityBinder.setWhere(whereAnn);\n    entityBinder.setCache(cacheAnn);\n    entityBinder.setInheritanceState(inheritanceState);\n    Filter filterAnn = annotatedClass.getAnnotation(Filter.class);\n    if (filterAnn != null) {\n        entityBinder.addFilter(filterAnn.name(), filterAnn.condition());\n    }\n    Filters filtersAnn = annotatedClass.getAnnotation(Filters.class);\n    if (filtersAnn != null) {\n        for (Filter filter : filtersAnn.value()) {\n            entityBinder.addFilter(filter.name(), filter.condition());\n        }\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn = annotatedClass.getAnnotation(Check.class);\n        String constraints = checkAnn == null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else {\n        if (annotatedClass.isAnnotationPresent(Table.class)) {\n            log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n        }\n    }\n    PropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings);\n    javax.persistence.SecondaryTable secTabAnn = annotatedClass.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn = annotatedClass.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn = annotatedClass.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate = false;\n    if (InheritanceType.JOINED.equals(inheritanceState.type) && inheritanceState.hasParents) {\n        onDeleteAppropriate = true;\n        final JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n        if (persistentClass.getEntityPersisterClass() == null) {\n            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n        }\n        SimpleValue key = new DependantValue(jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk = annotatedClass.getAnnotation(ForeignKey.class);\n        if (fk != null && !BinderHelper.isDefault(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn != null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp = new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n        if (inheritanceState.hasParents) {\n            if (persistentClass.getEntityPersisterClass() == null) {\n                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n            }\n        } else {\n            if (inheritanceState.hasSons || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.type)) {\n        if (inheritanceState.hasParents) {\n            if (persistentClass.getEntityPersisterClass() == null) {\n                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n            }\n        }\n    }\n    if (onDeleteAnn != null && !onDeleteAppropriate) {\n        log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n    }\n    HashMap<String, IdGenerator> classGenerators = buildLocalGenerators(annotatedClass, mappings);\n    List<PropertyData> elements = getElementsToProcess(clazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings);\n    if (elements == null) {\n        throw new AnnotationException(\"No identifier specified for entity: \" + propertyHolder.getEntityName());\n    }\n    final boolean subclassAndSingleTableStrategy = inheritanceState.type == InheritanceType.SINGLE_TABLE && inheritanceState.hasParents;\n    Set<String> idProperties = new HashSet<String>();\n    IdClass idClass = null;\n    if (!inheritanceState.hasParents) {\n        XClass current = inheritanceState.clazz;\n        InheritanceState state = inheritanceState;\n        do {\n            current = state.clazz;\n            if (current.isAnnotationPresent(IdClass.class)) {\n                idClass = current.getAnnotation(IdClass.class);\n                break;\n            }\n            state = InheritanceState.getSuperclassInheritanceState(current, inheritanceStatePerClass, mappings.getReflectionManager());\n        } while (state != null);\n    }\n    if (idClass != null) {\n        XClass compositeClass = mappings.getReflectionManager().toXClass(idClass.value());\n        boolean isComponent = true;\n        boolean propertyAnnotated = entityBinder.isPropertyAnnotated(compositeClass);\n        String propertyAccessor = entityBinder.getPropertyAccessor(compositeClass);\n        String generatorType = \"assigned\";\n        String generator = BinderHelper.ANNOTATION_STRING_DEFAULT;\n        PropertyData inferredData = new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", compositeClass);\n        HashMap<String, IdGenerator> localGenerators = new HashMap<String, IdGenerator>();\n        boolean ignoreIdAnnotations = entityBinder.isIgnoreIdAnnotations();\n        entityBinder.setIgnoreIdAnnotations(true);\n        bindId(generatorType, generator, inferredData, null, propertyHolder, localGenerators, isComponent, propertyAnnotated, propertyAccessor, entityBinder, true, false, mappings);\n        inferredData = new PropertyPreloadedData(propertyAccessor, \"_identifierMapper\", compositeClass);\n        Component mapper = fillComponent(propertyHolder, inferredData, propertyAnnotated, propertyAccessor, false, entityBinder, true, true, false, mappings);\n        entityBinder.setIgnoreIdAnnotations(ignoreIdAnnotations);\n        persistentClass.setIdentifierMapper(mapper);\n        Property property = new Property();\n        property.setName(\"_identifierMapper\");\n        property.setNodeName(\"id\");\n        property.setUpdateable(false);\n        property.setInsertable(false);\n        property.setValue(mapper);\n        property.setPropertyAccessorName(\"embedded\");\n        persistentClass.addProperty(property);\n        entityBinder.setIgnoreIdAnnotations(true);\n        Iterator properties = mapper.getPropertyIterator();\n        while (properties.hasNext()) {\n            idProperties.add(((Property) properties.next()).getName());\n        }\n    }\n    Set<String> missingIdProperties = new HashSet<String>(idProperties);\n    for (PropertyData propertyAnnotatedElement : elements) {\n        String propertyName = propertyAnnotatedElement.getPropertyName();\n        if (!idProperties.contains(propertyName)) {\n            processElementAnnotations(propertyHolder, subclassAndSingleTableStrategy ? Nullability.FORCED_NULL : Nullability.NO_CONSTRAINT, propertyAnnotatedElement.getProperty(), propertyAnnotatedElement, classGenerators, entityBinder, false, false, false, mappings);\n        } else {\n            missingIdProperties.remove(propertyName);\n        }\n    }\n    if (missingIdProperties.size() != 0) {\n        StringBuilder missings = new StringBuilder();\n        for (String property : missingIdProperties) {\n            missings.append(property).append(\", \");\n        }\n        throw new AnnotationException(\"Unable to find properties (\" + missings.substring(0, missings.length() - 2) + \") in entity annotated with @IdClass:\" + persistentClass.getEntityName());\n    }\n    if (!inheritanceState.hasParents) {\n        final RootClass rootClass = (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, annotatedClass));\n    entityBinder.processComplementaryTableDefinitions(annotatedClass.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(annotatedClass.getAnnotation(org.hibernate.annotations.Tables.class));\n}"
    },
    {
      "commit": "9d7a03a5f7f03bc803d897baa590861154b39f5e",
      "startLine": 187,
      "endLine": 242,
      "methodCode": "public static void bindClass(XClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n    InheritanceState inheritanceState = inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType = mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType) || AnnotatedClassType.NONE.equals(classType) || AnnotatedClassType.EMBEDDABLE.equals(classType)) {\n        if (AnnotatedClassType.NONE.equals(classType) && clazzToProcess.isAnnotationPresent(org.hibernate.annotations.Entity.class)) {\n            log.warn(\"Class annotated @org.hibernate.annotations.Entity but not javax.persistence.Entity \" + \"(most likely a user error): {}\", clazzToProcess.getName());\n        }\n        return;\n    }\n    if (!classType.equals(AnnotatedClassType.ENTITY)) {\n        throw new AnnotationException(\"Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: \" + clazzToProcess.getName());\n    }\n    XAnnotatedElement annotatedClass = clazzToProcess;\n    log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n    InheritanceState superEntityState = InheritanceState.getSuperEntityInheritanceState(clazzToProcess, inheritanceStatePerClass, mappings.getReflectionManager());\n    PersistentClass superEntity = superEntityState != null ? mappings.getClass(superEntityState.clazz.getName()) : null;\n    if (superEntity == null) {\n        if (inheritanceState.hasParents) {\n            throw new AssertionFailure(\"Subclass has to be binded after it's mother class: \" + superEntityState.clazz.getName());\n        }\n    }\n    bindQueries(annotatedClass, mappings);\n    bindFilterDefs(annotatedClass, mappings);\n    bindTypeDefs(annotatedClass, mappings);\n    BinderHelper.bindAnyMetaDefs(annotatedClass, mappings);\n    String schema = \"\";\n    String table = \"\";\n    String catalog = \"\";\n    String discrimValue = null;\n    List<String[]> uniqueConstraints = new ArrayList<String[]>();\n    Ejb3DiscriminatorColumn discriminatorColumn = null;\n    Ejb3JoinColumn[] inheritanceJoinedColumns = null;\n    if (annotatedClass.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn = annotatedClass.getAnnotation(javax.persistence.Table.class);\n        table = tabAnn.name();\n        schema = tabAnn.schema();\n        catalog = tabAnn.catalog();\n        uniqueConstraints = TableBinder.buildUniqueConstraints(tabAnn.uniqueConstraints());\n    }\n    final boolean hasJoinedColumns = inheritanceState.hasParents && InheritanceType.JOINED.equals(inheritanceState.type);\n    if (hasJoinedColumns) {\n        PrimaryKeyJoinColumns jcsAnn = annotatedClass.getAnnotation(PrimaryKeyJoinColumns.class);\n        boolean explicitInheritanceJoinedColumns = jcsAnn != null && jcsAnn.value().length != 0;\n        if (explicitInheritanceJoinedColumns) {\n            int nbrOfInhJoinedColumns = jcsAnn.value().length;\n            PrimaryKeyJoinColumn jcAnn;\n            inheritanceJoinedColumns = new Ejb3JoinColumn[nbrOfInhJoinedColumns];\n            for (int colIndex = 0; colIndex < nbrOfInhJoinedColumns; colIndex++) {\n                jcAnn = jcsAnn.value()[colIndex];\n                inheritanceJoinedColumns[colIndex] = Ejb3JoinColumn.buildJoinColumn(jcAnn, null, superEntity.getIdentifier(), (Map<String, Join>) null, (PropertyHolder) null, mappings);\n            }\n        } else {\n            PrimaryKeyJoinColumn jcAnn = annotatedClass.getAnnotation(PrimaryKeyJoinColumn.class);\n            inheritanceJoinedColumns = new Ejb3JoinColumn[1];\n            inheritanceJoinedColumns[0] = Ejb3JoinColumn.buildJoinColumn(jcAnn, null, superEntity.getIdentifier(), (Map<String, Join>) null, (PropertyHolder) null, mappings);\n        }\n        log.debug(\"Subclass joined column(s) created\");\n    } else {\n        if (annotatedClass.isAnnotationPresent(javax.persistence.PrimaryKeyJoinColumns.class) || annotatedClass.isAnnotationPresent(javax.persistence.PrimaryKeyJoinColumn.class)) {\n            log.warn(\"Root entity should not hold an PrimaryKeyJoinColum(s), will be ignored\");\n        }\n    }\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n        javax.persistence.DiscriminatorColumn discAnn = annotatedClass.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n        DiscriminatorType discriminatorType = discAnn != null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n        org.hibernate.annotations.DiscriminatorFormula discFormulaAnn = annotatedClass.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n        if (!inheritanceState.hasParents) {\n            discriminatorColumn = Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n        }\n        if (discAnn != null && inheritanceState.hasParents) {\n            log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n        }\n        discrimValue = annotatedClass.isAnnotationPresent(DiscriminatorValue.class) ? annotatedClass.getAnnotation(DiscriminatorValue.class).value() : null;\n    }\n    PersistentClass persistentClass;\n    if (!inheritanceState.hasParents) {\n        persistentClass = new RootClass();\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n        persistentClass = new SingleTableSubclass(superEntity);\n    } else if (InheritanceType.JOINED.equals(inheritanceState.type)) {\n        persistentClass = new JoinedSubclass(superEntity);\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.type)) {\n        persistentClass = new UnionSubclass(superEntity);\n    } else {\n        throw new AssertionFailure(\"Unknown inheritance type: \" + inheritanceState.type);\n    }\n    Proxy proxyAnn = annotatedClass.getAnnotation(Proxy.class);\n    BatchSize sizeAnn = annotatedClass.getAnnotation(BatchSize.class);\n    Where whereAnn = annotatedClass.getAnnotation(Where.class);\n    Entity entityAnn = annotatedClass.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn = annotatedClass.getAnnotation(org.hibernate.annotations.Entity.class);\n    org.hibernate.annotations.Cache cacheAnn = annotatedClass.getAnnotation(org.hibernate.annotations.Cache.class);\n    EntityBinder entityBinder = new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setDiscriminatorValue(discrimValue);\n    entityBinder.setBatchSize(sizeAnn);\n    entityBinder.setProxy(proxyAnn);\n    entityBinder.setWhere(whereAnn);\n    entityBinder.setCache(cacheAnn);\n    entityBinder.setInheritanceState(inheritanceState);\n    Filter filterAnn = annotatedClass.getAnnotation(Filter.class);\n    if (filterAnn != null) {\n        entityBinder.addFilter(filterAnn.name(), filterAnn.condition());\n    }\n    Filters filtersAnn = annotatedClass.getAnnotation(Filters.class);\n    if (filtersAnn != null) {\n        for (Filter filter : filtersAnn.value()) {\n            entityBinder.addFilter(filter.name(), filter.condition());\n        }\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn = annotatedClass.getAnnotation(Check.class);\n        String constraints = checkAnn == null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else {\n        if (annotatedClass.isAnnotationPresent(Table.class)) {\n            log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n        }\n    }\n    PropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings);\n    javax.persistence.SecondaryTable secTabAnn = annotatedClass.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn = annotatedClass.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn = annotatedClass.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate = false;\n    if (InheritanceType.JOINED.equals(inheritanceState.type) && inheritanceState.hasParents) {\n        onDeleteAppropriate = true;\n        final JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n        if (persistentClass.getEntityPersisterClass() == null) {\n            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n        }\n        SimpleValue key = new DependantValue(jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk = annotatedClass.getAnnotation(ForeignKey.class);\n        if (fk != null && !BinderHelper.isDefault(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn != null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp = new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n        if (inheritanceState.hasParents) {\n            if (persistentClass.getEntityPersisterClass() == null) {\n                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n            }\n        } else {\n            if (inheritanceState.hasSons || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.type)) {\n        if (inheritanceState.hasParents) {\n            if (persistentClass.getEntityPersisterClass() == null) {\n                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n            }\n        }\n    }\n    if (onDeleteAnn != null && !onDeleteAppropriate) {\n        log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n    }\n    HashMap<String, IdGenerator> classGenerators = buildLocalGenerators(annotatedClass, mappings);\n    List<PropertyData> elements = getElementsToProcess(clazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings);\n    if (elements == null) {\n        throw new AnnotationException(\"No identifier specified for entity: \" + propertyHolder.getEntityName());\n    }\n    final boolean subclassAndSingleTableStrategy = inheritanceState.type == InheritanceType.SINGLE_TABLE && inheritanceState.hasParents;\n    Set<String> idProperties = new HashSet<String>();\n    IdClass idClass = null;\n    if (!inheritanceState.hasParents) {\n        XClass current = inheritanceState.clazz;\n        InheritanceState state = inheritanceState;\n        do {\n            current = state.clazz;\n            if (current.isAnnotationPresent(IdClass.class)) {\n                idClass = current.getAnnotation(IdClass.class);\n                break;\n            }\n            state = InheritanceState.getSuperclassInheritanceState(current, inheritanceStatePerClass, mappings.getReflectionManager());\n        } while (state != null);\n    }\n    if (idClass != null) {\n        XClass compositeClass = mappings.getReflectionManager().toXClass(idClass.value());\n        boolean isComponent = true;\n        boolean propertyAnnotated = entityBinder.isPropertyAnnotated(compositeClass);\n        String propertyAccessor = entityBinder.getPropertyAccessor(compositeClass);\n        String generatorType = \"assigned\";\n        String generator = BinderHelper.ANNOTATION_STRING_DEFAULT;\n        PropertyData inferredData = new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", compositeClass);\n        HashMap<String, IdGenerator> localGenerators = new HashMap<String, IdGenerator>();\n        boolean ignoreIdAnnotations = entityBinder.isIgnoreIdAnnotations();\n        entityBinder.setIgnoreIdAnnotations(true);\n        bindId(generatorType, generator, inferredData, null, propertyHolder, localGenerators, isComponent, propertyAnnotated, propertyAccessor, entityBinder, true, false, mappings);\n        inferredData = new PropertyPreloadedData(propertyAccessor, \"_identifierMapper\", compositeClass);\n        Component mapper = fillComponent(propertyHolder, inferredData, propertyAnnotated, propertyAccessor, false, entityBinder, true, true, false, mappings);\n        entityBinder.setIgnoreIdAnnotations(ignoreIdAnnotations);\n        persistentClass.setIdentifierMapper(mapper);\n        Property property = new Property();\n        property.setName(\"_identifierMapper\");\n        property.setNodeName(\"id\");\n        property.setUpdateable(false);\n        property.setInsertable(false);\n        property.setValue(mapper);\n        property.setPropertyAccessorName(\"embedded\");\n        persistentClass.addProperty(property);\n        entityBinder.setIgnoreIdAnnotations(true);\n        Iterator properties = mapper.getPropertyIterator();\n        while (properties.hasNext()) {\n            idProperties.add(((Property) properties.next()).getName());\n        }\n    }\n    Set<String> missingIdProperties = new HashSet<String>(idProperties);\n    for (PropertyData propertyAnnotatedElement : elements) {\n        String propertyName = propertyAnnotatedElement.getPropertyName();\n        if (!idProperties.contains(propertyName)) {\n            processElementAnnotations(propertyHolder, subclassAndSingleTableStrategy ? Nullability.FORCED_NULL : Nullability.NO_CONSTRAINT, propertyAnnotatedElement.getProperty(), propertyAnnotatedElement, classGenerators, entityBinder, false, false, false, mappings);\n        } else {\n            missingIdProperties.remove(propertyName);\n        }\n    }\n    if (missingIdProperties.size() != 0) {\n        StringBuilder missings = new StringBuilder();\n        for (String property : missingIdProperties) {\n            missings.append(property).append(\", \");\n        }\n        throw new AnnotationException(\"Unable to find properties (\" + missings.substring(0, missings.length() - 2) + \") in entity annotated with @IdClass:\" + persistentClass.getEntityName());\n    }\n    if (!inheritanceState.hasParents) {\n        final RootClass rootClass = (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, annotatedClass));\n    entityBinder.processComplementaryTableDefinitions(annotatedClass.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(annotatedClass.getAnnotation(org.hibernate.annotations.Tables.class));\n}"
    },
    {
      "commit": "7337743c93574823424ed6c399cfcf6bd75614f8",
      "startLine": 187,
      "endLine": 242,
      "methodCode": "public static void bindClass(XClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n    InheritanceState inheritanceState = inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType = mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType) || AnnotatedClassType.NONE.equals(classType) || AnnotatedClassType.EMBEDDABLE.equals(classType)) {\n        if (AnnotatedClassType.NONE.equals(classType) && clazzToProcess.isAnnotationPresent(org.hibernate.annotations.Entity.class)) {\n            log.warn(\"Class annotated @org.hibernate.annotations.Entity but not javax.persistence.Entity \" + \"(most likely a user error): {}\", clazzToProcess.getName());\n        }\n        return;\n    }\n    if (!classType.equals(AnnotatedClassType.ENTITY)) {\n        throw new AnnotationException(\"Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: \" + clazzToProcess.getName());\n    }\n    XAnnotatedElement annotatedClass = clazzToProcess;\n    log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n    InheritanceState superEntityState = InheritanceState.getSuperEntityInheritanceState(clazzToProcess, inheritanceStatePerClass, mappings.getReflectionManager());\n    PersistentClass superEntity = superEntityState != null ? mappings.getClass(superEntityState.clazz.getName()) : null;\n    if (superEntity == null) {\n        if (inheritanceState.hasParents) {\n            throw new AssertionFailure(\"Subclass has to be binded after it's mother class: \" + superEntityState.clazz.getName());\n        }\n    }\n    bindQueries(annotatedClass, mappings);\n    bindFilterDefs(annotatedClass, mappings);\n    bindTypeDefs(annotatedClass, mappings);\n    BinderHelper.bindAnyMetaDefs(annotatedClass, mappings);\n    String schema = \"\";\n    String table = \"\";\n    String catalog = \"\";\n    String discrimValue = null;\n    List<String[]> uniqueConstraints = new ArrayList<String[]>();\n    Ejb3DiscriminatorColumn discriminatorColumn = null;\n    Ejb3JoinColumn[] inheritanceJoinedColumns = null;\n    if (annotatedClass.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn = annotatedClass.getAnnotation(javax.persistence.Table.class);\n        table = tabAnn.name();\n        schema = tabAnn.schema();\n        catalog = tabAnn.catalog();\n        uniqueConstraints = TableBinder.buildUniqueConstraints(tabAnn.uniqueConstraints());\n    }\n    final boolean hasJoinedColumns = inheritanceState.hasParents && InheritanceType.JOINED.equals(inheritanceState.type);\n    if (hasJoinedColumns) {\n        PrimaryKeyJoinColumns jcsAnn = annotatedClass.getAnnotation(PrimaryKeyJoinColumns.class);\n        boolean explicitInheritanceJoinedColumns = jcsAnn != null && jcsAnn.value().length != 0;\n        if (explicitInheritanceJoinedColumns) {\n            int nbrOfInhJoinedColumns = jcsAnn.value().length;\n            PrimaryKeyJoinColumn jcAnn;\n            inheritanceJoinedColumns = new Ejb3JoinColumn[nbrOfInhJoinedColumns];\n            for (int colIndex = 0; colIndex < nbrOfInhJoinedColumns; colIndex++) {\n                jcAnn = jcsAnn.value()[colIndex];\n                inheritanceJoinedColumns[colIndex] = Ejb3JoinColumn.buildJoinColumn(jcAnn, null, superEntity.getIdentifier(), (Map<String, Join>) null, (PropertyHolder) null, mappings);\n            }\n        } else {\n            PrimaryKeyJoinColumn jcAnn = annotatedClass.getAnnotation(PrimaryKeyJoinColumn.class);\n            inheritanceJoinedColumns = new Ejb3JoinColumn[1];\n            inheritanceJoinedColumns[0] = Ejb3JoinColumn.buildJoinColumn(jcAnn, null, superEntity.getIdentifier(), (Map<String, Join>) null, (PropertyHolder) null, mappings);\n        }\n        log.debug(\"Subclass joined column(s) created\");\n    } else {\n        if (annotatedClass.isAnnotationPresent(javax.persistence.PrimaryKeyJoinColumns.class) || annotatedClass.isAnnotationPresent(javax.persistence.PrimaryKeyJoinColumn.class)) {\n            log.warn(\"Root entity should not hold an PrimaryKeyJoinColum(s), will be ignored\");\n        }\n    }\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n        javax.persistence.DiscriminatorColumn discAnn = annotatedClass.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n        DiscriminatorType discriminatorType = discAnn != null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n        org.hibernate.annotations.DiscriminatorFormula discFormulaAnn = annotatedClass.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n        if (!inheritanceState.hasParents) {\n            discriminatorColumn = Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n        }\n        if (discAnn != null && inheritanceState.hasParents) {\n            log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n        }\n        discrimValue = annotatedClass.isAnnotationPresent(DiscriminatorValue.class) ? annotatedClass.getAnnotation(DiscriminatorValue.class).value() : null;\n    }\n    PersistentClass persistentClass;\n    if (!inheritanceState.hasParents) {\n        persistentClass = new RootClass();\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n        persistentClass = new SingleTableSubclass(superEntity);\n    } else if (InheritanceType.JOINED.equals(inheritanceState.type)) {\n        persistentClass = new JoinedSubclass(superEntity);\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.type)) {\n        persistentClass = new UnionSubclass(superEntity);\n    } else {\n        throw new AssertionFailure(\"Unknown inheritance type: \" + inheritanceState.type);\n    }\n    Proxy proxyAnn = annotatedClass.getAnnotation(Proxy.class);\n    BatchSize sizeAnn = annotatedClass.getAnnotation(BatchSize.class);\n    Where whereAnn = annotatedClass.getAnnotation(Where.class);\n    Entity entityAnn = annotatedClass.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn = annotatedClass.getAnnotation(org.hibernate.annotations.Entity.class);\n    org.hibernate.annotations.Cache cacheAnn = annotatedClass.getAnnotation(org.hibernate.annotations.Cache.class);\n    EntityBinder entityBinder = new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setDiscriminatorValue(discrimValue);\n    entityBinder.setBatchSize(sizeAnn);\n    entityBinder.setProxy(proxyAnn);\n    entityBinder.setWhere(whereAnn);\n    entityBinder.setCache(cacheAnn);\n    entityBinder.setInheritanceState(inheritanceState);\n    Filter filterAnn = annotatedClass.getAnnotation(Filter.class);\n    if (filterAnn != null) {\n        entityBinder.addFilter(filterAnn.name(), filterAnn.condition());\n    }\n    Filters filtersAnn = annotatedClass.getAnnotation(Filters.class);\n    if (filtersAnn != null) {\n        for (Filter filter : filtersAnn.value()) {\n            entityBinder.addFilter(filter.name(), filter.condition());\n        }\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn = annotatedClass.getAnnotation(Check.class);\n        String constraints = checkAnn == null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else {\n        if (annotatedClass.isAnnotationPresent(Table.class)) {\n            log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n        }\n    }\n    PropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings);\n    javax.persistence.SecondaryTable secTabAnn = annotatedClass.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn = annotatedClass.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn = annotatedClass.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate = false;\n    if (InheritanceType.JOINED.equals(inheritanceState.type) && inheritanceState.hasParents) {\n        onDeleteAppropriate = true;\n        final JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n        if (persistentClass.getEntityPersisterClass() == null) {\n            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n        }\n        SimpleValue key = new DependantValue(jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk = annotatedClass.getAnnotation(ForeignKey.class);\n        if (fk != null && !BinderHelper.isDefault(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn != null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp = new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n        if (inheritanceState.hasParents) {\n            if (persistentClass.getEntityPersisterClass() == null) {\n                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n            }\n        } else {\n            if (inheritanceState.hasSons || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.type)) {\n        if (inheritanceState.hasParents) {\n            if (persistentClass.getEntityPersisterClass() == null) {\n                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n            }\n        }\n    }\n    if (onDeleteAnn != null && !onDeleteAppropriate) {\n        log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n    }\n    HashMap<String, IdGenerator> classGenerators = buildLocalGenerators(annotatedClass, mappings);\n    List<PropertyData> elements = getElementsToProcess(clazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings);\n    if (elements == null) {\n        throw new AnnotationException(\"No identifier specified for entity: \" + propertyHolder.getEntityName());\n    }\n    final boolean subclassAndSingleTableStrategy = inheritanceState.type == InheritanceType.SINGLE_TABLE && inheritanceState.hasParents;\n    Set<String> idProperties = new HashSet<String>();\n    IdClass idClass = null;\n    if (!inheritanceState.hasParents) {\n        XClass current = inheritanceState.clazz;\n        InheritanceState state = inheritanceState;\n        do {\n            current = state.clazz;\n            if (current.isAnnotationPresent(IdClass.class)) {\n                idClass = current.getAnnotation(IdClass.class);\n                break;\n            }\n            state = InheritanceState.getSuperclassInheritanceState(current, inheritanceStatePerClass, mappings.getReflectionManager());\n        } while (state != null);\n    }\n    if (idClass != null) {\n        XClass compositeClass = mappings.getReflectionManager().toXClass(idClass.value());\n        boolean isComponent = true;\n        boolean propertyAnnotated = entityBinder.isPropertyAnnotated(compositeClass);\n        String propertyAccessor = entityBinder.getPropertyAccessor(compositeClass);\n        String generatorType = \"assigned\";\n        String generator = BinderHelper.ANNOTATION_STRING_DEFAULT;\n        PropertyData inferredData = new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", compositeClass);\n        HashMap<String, IdGenerator> localGenerators = new HashMap<String, IdGenerator>();\n        boolean ignoreIdAnnotations = entityBinder.isIgnoreIdAnnotations();\n        entityBinder.setIgnoreIdAnnotations(true);\n        bindId(generatorType, generator, inferredData, null, propertyHolder, localGenerators, isComponent, propertyAnnotated, propertyAccessor, entityBinder, true, false, mappings);\n        inferredData = new PropertyPreloadedData(propertyAccessor, \"_identifierMapper\", compositeClass);\n        Component mapper = fillComponent(propertyHolder, inferredData, propertyAnnotated, propertyAccessor, false, entityBinder, true, true, false, mappings);\n        entityBinder.setIgnoreIdAnnotations(ignoreIdAnnotations);\n        persistentClass.setIdentifierMapper(mapper);\n        Property property = new Property();\n        property.setName(\"_identifierMapper\");\n        property.setNodeName(\"id\");\n        property.setUpdateable(false);\n        property.setInsertable(false);\n        property.setValue(mapper);\n        property.setPropertyAccessorName(\"embedded\");\n        persistentClass.addProperty(property);\n        entityBinder.setIgnoreIdAnnotations(true);\n        Iterator properties = mapper.getPropertyIterator();\n        while (properties.hasNext()) {\n            idProperties.add(((Property) properties.next()).getName());\n        }\n    }\n    Set<String> missingIdProperties = new HashSet<String>(idProperties);\n    for (PropertyData propertyAnnotatedElement : elements) {\n        String propertyName = propertyAnnotatedElement.getPropertyName();\n        if (!idProperties.contains(propertyName)) {\n            processElementAnnotations(propertyHolder, subclassAndSingleTableStrategy ? Nullability.FORCED_NULL : Nullability.NO_CONSTRAINT, propertyAnnotatedElement.getProperty(), propertyAnnotatedElement, classGenerators, entityBinder, false, false, false, mappings);\n        } else {\n            missingIdProperties.remove(propertyName);\n        }\n    }\n    if (missingIdProperties.size() != 0) {\n        StringBuilder missings = new StringBuilder();\n        for (String property : missingIdProperties) {\n            missings.append(property).append(\", \");\n        }\n        throw new AnnotationException(\"Unable to find properties (\" + missings.substring(0, missings.length() - 2) + \") in entity annotated with @IdClass:\" + persistentClass.getEntityName());\n    }\n    if (!inheritanceState.hasParents) {\n        final RootClass rootClass = (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, annotatedClass));\n    entityBinder.processComplementaryTableDefinitions(annotatedClass.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(annotatedClass.getAnnotation(org.hibernate.annotations.Tables.class));\n}"
    }
  ]
}