{
  "statementVersions": [
    {
      "commit": "b54617e765d73b3ce0d187cf12ad8da382bce439",
      "startLine": 18,
      "endLine": 28,
      "methodCode": "@Override\npublic Optional<Value> solveSymbolAsValue(String name, TypeSolver typeSolver) {\n    for (Parameter parameter : wrappedNode.getParameters()) {\n        SymbolDeclarator sb = JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n        int index = 0;\n        for (ResolvedValueDeclaration decl : sb.getSymbolDeclarations()) {\n            if (decl.getName().equals(name)) {\n                if (requireParentNode(wrappedNode) instanceof MethodCallExpr) {\n                    MethodCallExpr methodCallExpr = (MethodCallExpr) requireParentNode(wrappedNode);\n                    MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                    int i = pos(methodCallExpr, wrappedNode);\n                    ResolvedType lambdaType = methodUsage.getParamTypes().get(i);\n                    Optional<MethodUsage> functionalMethodOpt = FunctionalInterfaceLogic.getFunctionalMethod(lambdaType);\n                    if (functionalMethodOpt.isPresent()) {\n                        MethodUsage functionalMethod = functionalMethodOpt.get();\n                        InferenceContext inferenceContext = new InferenceContext(MyObjectProvider.INSTANCE);\n                        inferenceContext.addPair(lambdaType, new ReferenceTypeImpl(lambdaType.asReferenceType().getTypeDeclaration(), typeSolver));\n                        boolean found = false;\n                        int lambdaParamIndex;\n                        for (lambdaParamIndex = 0; lambdaParamIndex < wrappedNode.getParameters().size(); lambdaParamIndex++) {\n                            if (wrappedNode.getParameter(lambdaParamIndex).getName().getIdentifier().equals(name)) {\n                                found = true;\n                                break;\n                            }\n                        }\n                        if (!found) {\n                            return Optional.empty();\n                        }\n                        ResolvedType argType = inferenceContext.resolve(inferenceContext.addSingle(functionalMethod.getParamType(lambdaParamIndex)));\n                        ResolvedLambdaConstraintType conType;\n                        if (argType.isWildcard()) {\n                            conType = ResolvedLambdaConstraintType.bound(argType.asWildcard().getBoundedType());\n                        } else {\n                            conType = ResolvedLambdaConstraintType.bound(argType);\n                        }\n                        Value value = new Value(conType, name);\n                        return Optional.of(value);\n                    } else {\n                        return Optional.empty();\n                    }\n                } else if (requireParentNode(wrappedNode) instanceof VariableDeclarator) {\n                    VariableDeclarator variableDeclarator = (VariableDeclarator) requireParentNode(wrappedNode);\n                    ResolvedType t = JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                    Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(t);\n                    if (functionalMethod.isPresent()) {\n                        ResolvedType lambdaType = functionalMethod.get().getParamType(index);\n                        Map<ResolvedTypeParameterDeclaration, ResolvedType> inferredTypes = new HashMap<>();\n                        if (lambdaType.isReferenceType()) {\n                            for (com.github.javaparser.utils.Pair<ResolvedTypeParameterDeclaration, ResolvedType> entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                if (entry.b.isTypeVariable() && entry.b.asTypeParameter().declaredOnType()) {\n                                    ResolvedType ot = t.asReferenceType().typeParametersMap().getValue(entry.a);\n                                    lambdaType = lambdaType.replaceTypeVariables(entry.a, ot, inferredTypes);\n                                }\n                            }\n                        } else if (lambdaType.isTypeVariable() && lambdaType.asTypeParameter().declaredOnType()) {\n                            lambdaType = t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());\n                        }\n                        Value value = new Value(lambdaType, name);\n                        return Optional.of(value);\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                } else {\n                    throw new UnsupportedOperationException();\n                }\n            }\n            index++;\n        }\n    }\n    return getParent().solveSymbolAsValue(name, typeSolver);\n}"
    },
    {
      "commit": "09232ff6b0ea19e850482f3a87ac6ef1c063c759",
      "startLine": 18,
      "endLine": 28,
      "methodCode": "@Override\npublic Optional<Value> solveSymbolAsValue(String name, TypeSolver typeSolver) {\n    for (Parameter parameter : wrappedNode.getParameters()) {\n        SymbolDeclarator sb = JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n        int index = 0;\n        for (ResolvedValueDeclaration decl : sb.getSymbolDeclarations()) {\n            if (decl.getName().equals(name)) {\n                if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                    MethodCallExpr methodCallExpr = (MethodCallExpr) getParentNode(wrappedNode);\n                    MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                    int i = pos(methodCallExpr, wrappedNode);\n                    ResolvedType lambdaType = methodUsage.getParamTypes().get(i);\n                    Optional<MethodUsage> functionalMethodOpt = FunctionalInterfaceLogic.getFunctionalMethod(lambdaType);\n                    if (functionalMethodOpt.isPresent()) {\n                        MethodUsage functionalMethod = functionalMethodOpt.get();\n                        InferenceContext inferenceContext = new InferenceContext(MyObjectProvider.INSTANCE);\n                        inferenceContext.addPair(lambdaType, new ReferenceTypeImpl(lambdaType.asReferenceType().getTypeDeclaration(), typeSolver));\n                        boolean found = false;\n                        int lambdaParamIndex;\n                        for (lambdaParamIndex = 0; lambdaParamIndex < wrappedNode.getParameters().size(); lambdaParamIndex++) {\n                            if (wrappedNode.getParameter(lambdaParamIndex).getName().getIdentifier().equals(name)) {\n                                found = true;\n                                break;\n                            }\n                        }\n                        if (!found) {\n                            return Optional.empty();\n                        }\n                        ResolvedType argType = inferenceContext.resolve(inferenceContext.addSingle(functionalMethod.getParamType(lambdaParamIndex)));\n                        ResolvedLambdaConstraintType conType;\n                        if (argType.isWildcard()) {\n                            conType = ResolvedLambdaConstraintType.bound(argType.asWildcard().getBoundedType());\n                        } else {\n                            conType = ResolvedLambdaConstraintType.bound(argType);\n                        }\n                        Value value = new Value(conType, name);\n                        return Optional.of(value);\n                    } else {\n                        return Optional.empty();\n                    }\n                } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                    VariableDeclarator variableDeclarator = (VariableDeclarator) getParentNode(wrappedNode);\n                    ResolvedType t = JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                    Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(t);\n                    if (functionalMethod.isPresent()) {\n                        ResolvedType lambdaType = functionalMethod.get().getParamType(index);\n                        Map<ResolvedTypeParameterDeclaration, ResolvedType> inferredTypes = new HashMap<>();\n                        if (lambdaType.isReferenceType()) {\n                            for (com.github.javaparser.utils.Pair<ResolvedTypeParameterDeclaration, ResolvedType> entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                if (entry.b.isTypeVariable() && entry.b.asTypeParameter().declaredOnType()) {\n                                    ResolvedType ot = t.asReferenceType().typeParametersMap().getValue(entry.a);\n                                    lambdaType = lambdaType.replaceTypeVariables(entry.a, ot, inferredTypes);\n                                }\n                            }\n                        } else if (lambdaType.isTypeVariable() && lambdaType.asTypeParameter().declaredOnType()) {\n                            lambdaType = t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());\n                        }\n                        Value value = new Value(lambdaType, name);\n                        return Optional.of(value);\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                } else {\n                    throw new UnsupportedOperationException();\n                }\n            }\n            index++;\n        }\n    }\n    return getParent().solveSymbolAsValue(name, typeSolver);\n}"
    },
    {
      "commit": "5d8d0cb7947efcf2282f7d056302dd905f348532",
      "startLine": 18,
      "endLine": 28,
      "methodCode": "@Override\npublic Optional<Value> solveSymbolAsValue(String name, TypeSolver typeSolver) {\n    for (Parameter parameter : wrappedNode.getParameters()) {\n        SymbolDeclarator sb = JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n        int index = 0;\n        for (ResolvedValueDeclaration decl : sb.getSymbolDeclarations()) {\n            if (decl.getName().equals(name)) {\n                if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                    MethodCallExpr methodCallExpr = (MethodCallExpr) getParentNode(wrappedNode);\n                    MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                    int i = pos(methodCallExpr, wrappedNode);\n                    ResolvedType lambdaType = methodUsage.getParamTypes().get(i);\n                    Optional<MethodUsage> functionalMethodOpt = FunctionalInterfaceLogic.getFunctionalMethod(lambdaType);\n                    if (functionalMethodOpt.isPresent()) {\n                        MethodUsage functionalMethod = functionalMethodOpt.get();\n                        InferenceContext inferenceContext = new InferenceContext(MyObjectProvider.INSTANCE);\n                        inferenceContext.addPair(lambdaType, new ReferenceTypeImpl(lambdaType.asReferenceType().getTypeDeclaration(), typeSolver));\n                        boolean found = false;\n                        int lambdaParamIndex;\n                        for (lambdaParamIndex = 0; lambdaParamIndex < wrappedNode.getParameters().size(); lambdaParamIndex++) {\n                            if (wrappedNode.getParameter(lambdaParamIndex).getName().getIdentifier().equals(name)) {\n                                found = true;\n                                break;\n                            }\n                        }\n                        if (!found) {\n                            return Optional.empty();\n                        }\n                        ResolvedType argType = inferenceContext.resolve(inferenceContext.addSingle(functionalMethod.getParamType(lambdaParamIndex)));\n                        ResolvedLambdaConstraintType conType;\n                        if (argType.isWildcard()) {\n                            conType = ResolvedLambdaConstraintType.bound(argType.asWildcard().getBoundedType());\n                        } else {\n                            conType = ResolvedLambdaConstraintType.bound(argType);\n                        }\n                        Value value = new Value(conType, name);\n                        return Optional.of(value);\n                    } else {\n                        return Optional.empty();\n                    }\n                } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                    VariableDeclarator variableDeclarator = (VariableDeclarator) getParentNode(wrappedNode);\n                    ResolvedType t = JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                    Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(t);\n                    if (functionalMethod.isPresent()) {\n                        ResolvedType lambdaType = functionalMethod.get().getParamType(index);\n                        Map<ResolvedTypeParameterDeclaration, ResolvedType> inferredTypes = new HashMap<>();\n                        if (lambdaType.isReferenceType()) {\n                            for (com.github.javaparser.utils.Pair<ResolvedTypeParameterDeclaration, ResolvedType> entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                if (entry.b.isTypeVariable() && entry.b.asTypeParameter().declaredOnType()) {\n                                    ResolvedType ot = t.asReferenceType().typeParametersMap().getValue(entry.a);\n                                    lambdaType = lambdaType.replaceTypeVariables(entry.a, ot, inferredTypes);\n                                }\n                            }\n                        } else if (lambdaType.isTypeVariable() && lambdaType.asTypeParameter().declaredOnType()) {\n                            lambdaType = t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());\n                        }\n                        Value value = new Value(lambdaType, name);\n                        return Optional.of(value);\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                } else {\n                    throw new UnsupportedOperationException();\n                }\n            }\n            index++;\n        }\n    }\n    return getParent().solveSymbolAsValue(name, typeSolver);\n}"
    },
    {
      "commit": "5da7835cd514233e05ff8ceb07b4f82063b0d08e",
      "startLine": 18,
      "endLine": 28,
      "methodCode": "@Override\npublic Optional<Value> solveSymbolAsValue(String name, TypeSolver typeSolver) {\n    for (Parameter parameter : wrappedNode.getParameters()) {\n        SymbolDeclarator sb = JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n        int index = 0;\n        for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n            if (decl.getName().equals(name)) {\n                if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                    MethodCallExpr methodCallExpr = (MethodCallExpr) getParentNode(wrappedNode);\n                    MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                    int i = pos(methodCallExpr, wrappedNode);\n                    Type lambdaType = methodUsage.getParamTypes().get(i);\n                    Optional<MethodUsage> functionalMethodOpt = FunctionalInterfaceLogic.getFunctionalMethod(lambdaType);\n                    if (functionalMethodOpt.isPresent()) {\n                        MethodUsage functionalMethod = functionalMethodOpt.get();\n                        InferenceContext inferenceContext = new InferenceContext(MyObjectProvider.INSTANCE);\n                        inferenceContext.addPair(lambdaType, new ReferenceTypeImpl(lambdaType.asReferenceType().getTypeDeclaration(), typeSolver));\n                        boolean found = false;\n                        int lambdaParamIndex;\n                        for (lambdaParamIndex = 0; lambdaParamIndex < wrappedNode.getParameters().size(); lambdaParamIndex++) {\n                            if (wrappedNode.getParameter(lambdaParamIndex).getName().getIdentifier().equals(name)) {\n                                found = true;\n                                break;\n                            }\n                        }\n                        if (!found) {\n                            return Optional.empty();\n                        }\n                        Type argType = inferenceContext.resolve(inferenceContext.addSingle(functionalMethod.getParamType(lambdaParamIndex)));\n                        LambdaConstraintType conType;\n                        if (argType.isWildcard()) {\n                            conType = LambdaConstraintType.bound(argType.asWildcard().getBoundedType());\n                        } else {\n                            conType = LambdaConstraintType.bound(argType);\n                        }\n                        Value value = new Value(conType, name);\n                        return Optional.of(value);\n                    } else {\n                        return Optional.empty();\n                    }\n                } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                    VariableDeclarator variableDeclarator = (VariableDeclarator) getParentNode(wrappedNode);\n                    Type t = JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                    Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(t);\n                    if (functionalMethod.isPresent()) {\n                        Type lambdaType = functionalMethod.get().getParamType(index);\n                        Map<TypeParameterDeclaration, Type> inferredTypes = new HashMap<>();\n                        if (lambdaType.isReferenceType()) {\n                            for (Tuple2<TypeParameterDeclaration, Type> entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                if (entry._2.isTypeVariable() && entry._2.asTypeParameter().declaredOnType()) {\n                                    Type ot = t.asReferenceType().typeParametersMap().getValue(entry._1);\n                                    lambdaType = lambdaType.replaceTypeVariables(entry._1, ot, inferredTypes);\n                                }\n                            }\n                        } else if (lambdaType.isTypeVariable() && lambdaType.asTypeParameter().declaredOnType()) {\n                            lambdaType = t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());\n                        }\n                        Value value = new Value(lambdaType, name);\n                        return Optional.of(value);\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                } else {\n                    throw new UnsupportedOperationException();\n                }\n            }\n            index++;\n        }\n    }\n    return getParent().solveSymbolAsValue(name, typeSolver);\n}"
    },
    {
      "commit": "0aaa5e5b086a557801d54f8a3ac236e08513e774",
      "startLine": 18,
      "endLine": 27,
      "methodCode": "@Override\npublic Optional<Value> solveSymbolAsValue(String name, TypeSolver typeSolver) {\n    for (Parameter parameter : wrappedNode.getParameters()) {\n        SymbolDeclarator sb = JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n        int index = 0;\n        for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n            if (decl.getName().equals(name)) {\n                if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                    MethodCallExpr methodCallExpr = (MethodCallExpr) getParentNode(wrappedNode);\n                    MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                    int i = pos(methodCallExpr, wrappedNode);\n                    Type lambdaType = methodUsage.getParamTypes().get(i);\n                    Optional<MethodUsage> functionalMethodOpt = FunctionalInterfaceLogic.getFunctionalMethod(lambdaType);\n                    if (functionalMethodOpt.isPresent()) {\n                        MethodUsage functionalMethod = functionalMethodOpt.get();\n                        InferenceContext inferenceContext = new InferenceContext(MyObjectProvider.INSTANCE);\n                        inferenceContext.addPair(lambdaType, new ReferenceTypeImpl(lambdaType.asReferenceType().getTypeDeclaration(), typeSolver));\n                        boolean found = false;\n                        int lambdaParamIndex;\n                        for (lambdaParamIndex = 0; lambdaParamIndex < wrappedNode.getParameters().size(); lambdaParamIndex++) {\n                            if (wrappedNode.getParameter(lambdaParamIndex).getName().getIdentifier().equals(name)) {\n                                found = true;\n                                break;\n                            }\n                        }\n                        if (!found)\n                            return Optional.empty();\n                        Type argType = inferenceContext.resolve(inferenceContext.addSingle(functionalMethod.getParamType(lambdaParamIndex)));\n                        LambdaConstraintType conType;\n                        if (argType.isWildcard()) {\n                            conType = LambdaConstraintType.bound(argType.asWildcard().getBoundedType());\n                        } else {\n                            conType = LambdaConstraintType.bound(argType);\n                        }\n                        Value value = new Value(conType, name);\n                        return Optional.of(value);\n                    } else {\n                        return Optional.empty();\n                    }\n                } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                    VariableDeclarator variableDeclarator = (VariableDeclarator) getParentNode(wrappedNode);\n                    Type t = JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                    Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(t);\n                    if (functionalMethod.isPresent()) {\n                        Type lambdaType = functionalMethod.get().getParamType(index);\n                        Map<TypeParameterDeclaration, Type> inferredTypes = new HashMap<>();\n                        if (lambdaType.isReferenceType()) {\n                            for (Tuple2<TypeParameterDeclaration, Type> entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                if (entry._2.isTypeVariable() && entry._2.asTypeParameter().declaredOnType()) {\n                                    Type ot = t.asReferenceType().typeParametersMap().getValue(entry._1);\n                                    lambdaType = lambdaType.replaceTypeVariables(entry._1, ot, inferredTypes);\n                                }\n                            }\n                        } else if (lambdaType.isTypeVariable() && lambdaType.asTypeParameter().declaredOnType()) {\n                            lambdaType = t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());\n                        }\n                        Value value = new Value(lambdaType, name);\n                        return Optional.of(value);\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                } else {\n                    throw new UnsupportedOperationException();\n                }\n            }\n            index++;\n        }\n    }\n    return getParent().solveSymbolAsValue(name, typeSolver);\n}"
    }
  ]
}