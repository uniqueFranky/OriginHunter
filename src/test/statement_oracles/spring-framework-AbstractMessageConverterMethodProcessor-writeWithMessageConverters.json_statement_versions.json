{
  "statementVersions": [
    {
      "commit": "29ce6685cad0f6caf829c49024b1885ab31d62e0",
      "startLine": 3,
      "endLine": 14,
      "methodCode": "@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\nprotected <T> void writeWithMessageConverters(@Nullable T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n    Object body;\n    Class<?> valueType;\n    Type targetType;\n    if (value instanceof CharSequence) {\n        body = value.toString();\n        valueType = String.class;\n        targetType = String.class;\n    } else {\n        body = value;\n        valueType = getReturnValueType(body, returnType);\n        targetType = GenericTypeResolver.resolveType(getGenericType(returnType), returnType.getContainingClass());\n    }\n    if (isResourceType(value, returnType)) {\n        outputMessage.getHeaders().set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n        if (value != null && inputMessage.getHeaders().getFirst(HttpHeaders.RANGE) != null && outputMessage.getServletResponse().getStatus() == 200) {\n            Resource resource = (Resource) value;\n            try {\n                List<HttpRange> httpRanges = inputMessage.getHeaders().getRange();\n                outputMessage.getServletResponse().setStatus(HttpStatus.PARTIAL_CONTENT.value());\n                body = HttpRange.toResourceRegions(httpRanges, resource);\n                valueType = body.getClass();\n                targetType = RESOURCE_REGION_LIST_TYPE;\n            } catch (IllegalArgumentException ex) {\n                outputMessage.getHeaders().set(HttpHeaders.CONTENT_RANGE, \"bytes */\" + resource.contentLength());\n                outputMessage.getServletResponse().setStatus(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE.value());\n            }\n        }\n    }\n    MediaType selectedMediaType = null;\n    MediaType contentType = outputMessage.getHeaders().getContentType();\n    if (contentType != null && contentType.isConcrete()) {\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Found 'Content-Type:\" + contentType + \"' in response\");\n        }\n        selectedMediaType = contentType;\n    } else {\n        HttpServletRequest request = inputMessage.getServletRequest();\n        List<MediaType> acceptableTypes = getAcceptableMediaTypes(request);\n        List<MediaType> producibleTypes = getProducibleMediaTypes(request, valueType, targetType);\n        if (body != null && producibleTypes.isEmpty()) {\n            throw new HttpMessageNotWritableException(\"No converter found for return value of type: \" + valueType);\n        }\n        List<MediaType> mediaTypesToUse = new ArrayList<>();\n        for (MediaType requestedType : acceptableTypes) {\n            for (MediaType producibleType : producibleTypes) {\n                if (requestedType.isCompatibleWith(producibleType)) {\n                    mediaTypesToUse.add(getMostSpecificMediaType(requestedType, producibleType));\n                }\n            }\n        }\n        if (mediaTypesToUse.isEmpty()) {\n            if (body != null) {\n                throw new HttpMediaTypeNotAcceptableException(producibleTypes);\n            }\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"No match for \" + acceptableTypes + \", supported: \" + producibleTypes);\n            }\n            return;\n        }\n        MediaType.sortBySpecificityAndQuality(mediaTypesToUse);\n        for (MediaType mediaType : mediaTypesToUse) {\n            if (mediaType.isConcrete()) {\n                selectedMediaType = mediaType;\n                break;\n            } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n                selectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n                break;\n            }\n        }\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Using '\" + selectedMediaType + \"', given \" + acceptableTypes + \" and supported \" + producibleTypes);\n        }\n    }\n    if (selectedMediaType != null) {\n        selectedMediaType = selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter<?> converter : this.messageConverters) {\n            GenericHttpMessageConverter genericConverter = (converter instanceof GenericHttpMessageConverter ? (GenericHttpMessageConverter<?>) converter : null);\n            if (genericConverter != null ? ((GenericHttpMessageConverter) converter).canWrite(targetType, valueType, selectedMediaType) : converter.canWrite(valueType, selectedMediaType)) {\n                body = getAdvice().beforeBodyWrite(body, returnType, selectedMediaType, (Class<? extends HttpMessageConverter<?>>) converter.getClass(), inputMessage, outputMessage);\n                if (body != null) {\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Writing [\" + formatValue(body) + \"]\");\n                    }\n                    addContentDispositionHeader(inputMessage, outputMessage);\n                    if (genericConverter != null) {\n                        genericConverter.write(body, targetType, selectedMediaType, outputMessage);\n                    } else {\n                        ((HttpMessageConverter) converter).write(body, selectedMediaType, outputMessage);\n                    }\n                } else {\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Nothing to write: null body\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    if (body != null) {\n        throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n    }\n}"
    },
    {
      "commit": "0be8c20fca26357aa61c28dec2f3720f1d7488be",
      "startLine": 3,
      "endLine": 14,
      "methodCode": "@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\nprotected <T> void writeWithMessageConverters(@Nullable T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n    Object body;\n    Class<?> valueType;\n    Type targetType;\n    if (value instanceof CharSequence) {\n        body = value.toString();\n        valueType = String.class;\n        targetType = String.class;\n    } else {\n        body = value;\n        valueType = getReturnValueType(body, returnType);\n        targetType = GenericTypeResolver.resolveType(getGenericType(returnType), returnType.getContainingClass());\n    }\n    if (isResourceType(value, returnType)) {\n        outputMessage.getHeaders().set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n        if (value != null && inputMessage.getHeaders().getFirst(HttpHeaders.RANGE) != null && outputMessage.getServletResponse().getStatus() == 200) {\n            Resource resource = (Resource) value;\n            try {\n                List<HttpRange> httpRanges = inputMessage.getHeaders().getRange();\n                outputMessage.getServletResponse().setStatus(HttpStatus.PARTIAL_CONTENT.value());\n                body = HttpRange.toResourceRegions(httpRanges, resource);\n                valueType = body.getClass();\n                targetType = RESOURCE_REGION_LIST_TYPE;\n            } catch (IllegalArgumentException ex) {\n                outputMessage.getHeaders().set(HttpHeaders.CONTENT_RANGE, \"bytes */\" + resource.contentLength());\n                outputMessage.getServletResponse().setStatus(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE.value());\n            }\n        }\n    }\n    MediaType selectedMediaType = null;\n    MediaType contentType = outputMessage.getHeaders().getContentType();\n    if (contentType != null && contentType.isConcrete()) {\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Found 'Content-Type:\" + contentType + \"' in response\");\n        }\n        selectedMediaType = contentType;\n    } else {\n        HttpServletRequest request = inputMessage.getServletRequest();\n        List<MediaType> acceptableTypes = getAcceptableMediaTypes(request);\n        List<MediaType> producibleTypes = getProducibleMediaTypes(request, valueType, targetType);\n        if (body != null && producibleTypes.isEmpty()) {\n            throw new HttpMessageNotWritableException(\"No converter found for return value of type: \" + valueType);\n        }\n        List<MediaType> mediaTypesToUse = new ArrayList<>();\n        for (MediaType requestedType : acceptableTypes) {\n            for (MediaType producibleType : producibleTypes) {\n                if (requestedType.isCompatibleWith(producibleType)) {\n                    mediaTypesToUse.add(getMostSpecificMediaType(requestedType, producibleType));\n                }\n            }\n        }\n        if (mediaTypesToUse.isEmpty()) {\n            if (body != null) {\n                throw new HttpMediaTypeNotAcceptableException(producibleTypes);\n            }\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"No match for \" + acceptableTypes + \", supported: \" + producibleTypes);\n            }\n            return;\n        }\n        MediaType.sortBySpecificityAndQuality(mediaTypesToUse);\n        for (MediaType mediaType : mediaTypesToUse) {\n            if (mediaType.isConcrete()) {\n                selectedMediaType = mediaType;\n                break;\n            } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n                selectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n                break;\n            }\n        }\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Using '\" + selectedMediaType + \"', given \" + acceptableTypes + \" and supported \" + producibleTypes);\n        }\n    }\n    if (selectedMediaType != null) {\n        selectedMediaType = selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter<?> converter : this.messageConverters) {\n            GenericHttpMessageConverter genericConverter = (converter instanceof GenericHttpMessageConverter ? (GenericHttpMessageConverter<?>) converter : null);\n            if (genericConverter != null ? ((GenericHttpMessageConverter) converter).canWrite(targetType, valueType, selectedMediaType) : converter.canWrite(valueType, selectedMediaType)) {\n                body = getAdvice().beforeBodyWrite(body, returnType, selectedMediaType, (Class<? extends HttpMessageConverter<?>>) converter.getClass(), inputMessage, outputMessage);\n                if (body != null) {\n                    if (logger.isDebugEnabled()) {\n                        Object formatted = (body instanceof CharSequence ? \"\\\"\" + body + \"\\\"\" : body);\n                        logger.debug(\"Writing [\" + formatted + \"]\");\n                    }\n                    addContentDispositionHeader(inputMessage, outputMessage);\n                    if (genericConverter != null) {\n                        genericConverter.write(body, targetType, selectedMediaType, outputMessage);\n                    } else {\n                        ((HttpMessageConverter) converter).write(body, selectedMediaType, outputMessage);\n                    }\n                } else {\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Nothing to write: null body\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    if (body != null) {\n        throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n    }\n}"
    },
    {
      "commit": "b915e42c387195ed956fd908602094139148aac3",
      "startLine": 3,
      "endLine": 14,
      "methodCode": "@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\nprotected <T> void writeWithMessageConverters(@Nullable T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n    Object body;\n    Class<?> valueType;\n    Type targetType;\n    if (value instanceof CharSequence) {\n        body = value.toString();\n        valueType = String.class;\n        targetType = String.class;\n    } else {\n        body = value;\n        valueType = getReturnValueType(body, returnType);\n        targetType = GenericTypeResolver.resolveType(getGenericType(returnType), returnType.getContainingClass());\n    }\n    if (isResourceType(value, returnType)) {\n        outputMessage.getHeaders().set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n        if (value != null && inputMessage.getHeaders().getFirst(HttpHeaders.RANGE) != null && outputMessage.getServletResponse().getStatus() == 200) {\n            Resource resource = (Resource) value;\n            try {\n                List<HttpRange> httpRanges = inputMessage.getHeaders().getRange();\n                outputMessage.getServletResponse().setStatus(HttpStatus.PARTIAL_CONTENT.value());\n                body = HttpRange.toResourceRegions(httpRanges, resource);\n                valueType = body.getClass();\n                targetType = RESOURCE_REGION_LIST_TYPE;\n            } catch (IllegalArgumentException ex) {\n                outputMessage.getHeaders().set(HttpHeaders.CONTENT_RANGE, \"bytes */\" + resource.contentLength());\n                outputMessage.getServletResponse().setStatus(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE.value());\n            }\n        }\n    }\n    List<MediaType> mediaTypesToUse;\n    MediaType contentType = outputMessage.getHeaders().getContentType();\n    if (contentType != null && contentType.isConcrete()) {\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Found 'Content-Type:\" + contentType + \"' in response\");\n        }\n        mediaTypesToUse = Collections.singletonList(contentType);\n    } else {\n        HttpServletRequest request = inputMessage.getServletRequest();\n        List<MediaType> requestedMediaTypes = getAcceptableMediaTypes(request);\n        List<MediaType> producibleMediaTypes = getProducibleMediaTypes(request, valueType, targetType);\n        if (body != null && producibleMediaTypes.isEmpty()) {\n            throw new HttpMessageNotWritableException(\"No converter found for return value of type: \" + valueType);\n        }\n        mediaTypesToUse = new ArrayList<>();\n        for (MediaType requestedType : requestedMediaTypes) {\n            for (MediaType producibleType : producibleMediaTypes) {\n                if (requestedType.isCompatibleWith(producibleType)) {\n                    mediaTypesToUse.add(getMostSpecificMediaType(requestedType, producibleType));\n                }\n            }\n        }\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"No match for \" + requestedMediaTypes + \", supported: \" + producibleMediaTypes);\n        }\n        if (mediaTypesToUse.isEmpty()) {\n            if (body != null) {\n                throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n            }\n            return;\n        }\n        MediaType.sortBySpecificityAndQuality(mediaTypesToUse);\n    }\n    MediaType selectedMediaType = null;\n    for (MediaType mediaType : mediaTypesToUse) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType = mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"Using '\" + selectedMediaType + \"' given \" + mediaTypesToUse);\n    }\n    if (selectedMediaType != null) {\n        selectedMediaType = selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter<?> converter : this.messageConverters) {\n            GenericHttpMessageConverter genericConverter = (converter instanceof GenericHttpMessageConverter ? (GenericHttpMessageConverter<?>) converter : null);\n            if (genericConverter != null ? ((GenericHttpMessageConverter) converter).canWrite(targetType, valueType, selectedMediaType) : converter.canWrite(valueType, selectedMediaType)) {\n                body = getAdvice().beforeBodyWrite(body, returnType, selectedMediaType, (Class<? extends HttpMessageConverter<?>>) converter.getClass(), inputMessage, outputMessage);\n                if (body != null) {\n                    if (logger.isDebugEnabled()) {\n                        Object formatted = (body instanceof CharSequence ? \"\\\"\" + body + \"\\\"\" : body);\n                        logger.debug(\"Writing [\" + formatted + \"]\");\n                    }\n                    addContentDispositionHeader(inputMessage, outputMessage);\n                    if (genericConverter != null) {\n                        genericConverter.write(body, targetType, selectedMediaType, outputMessage);\n                    } else {\n                        ((HttpMessageConverter) converter).write(body, selectedMediaType, outputMessage);\n                    }\n                } else {\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Nothing to write: null body\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    if (body != null) {\n        throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n    }\n}"
    },
    {
      "commit": "818e4b077640056d6e65ef37be1bec76537fa991",
      "startLine": 3,
      "endLine": 14,
      "methodCode": "@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\nprotected <T> void writeWithMessageConverters(@Nullable T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n    Object body;\n    Class<?> valueType;\n    Type declaredType;\n    if (value instanceof CharSequence) {\n        body = value.toString();\n        valueType = String.class;\n        declaredType = String.class;\n    } else {\n        body = value;\n        valueType = getReturnValueType(body, returnType);\n        declaredType = getGenericType(returnType);\n    }\n    if (isResourceType(value, returnType)) {\n        outputMessage.getHeaders().set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n        if (value != null && inputMessage.getHeaders().getFirst(HttpHeaders.RANGE) != null && outputMessage.getServletResponse().getStatus() == 200) {\n            Resource resource = (Resource) value;\n            try {\n                List<HttpRange> httpRanges = inputMessage.getHeaders().getRange();\n                outputMessage.getServletResponse().setStatus(HttpStatus.PARTIAL_CONTENT.value());\n                body = HttpRange.toResourceRegions(httpRanges, resource);\n                valueType = body.getClass();\n                declaredType = RESOURCE_REGION_LIST_TYPE;\n            } catch (IllegalArgumentException ex) {\n                outputMessage.getHeaders().set(HttpHeaders.CONTENT_RANGE, \"bytes */\" + resource.contentLength());\n                outputMessage.getServletResponse().setStatus(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE.value());\n            }\n        }\n    }\n    List<MediaType> mediaTypesToUse;\n    MediaType contentType = outputMessage.getHeaders().getContentType();\n    if (contentType != null && contentType.isConcrete()) {\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Found 'Content-Type:\" + contentType + \"' in response\");\n        }\n        mediaTypesToUse = Collections.singletonList(contentType);\n    } else {\n        HttpServletRequest request = inputMessage.getServletRequest();\n        List<MediaType> requestedMediaTypes = getAcceptableMediaTypes(request);\n        List<MediaType> producibleMediaTypes = getProducibleMediaTypes(request, valueType, declaredType);\n        if (body != null && producibleMediaTypes.isEmpty()) {\n            throw new HttpMessageNotWritableException(\"No converter found for return value of type: \" + valueType);\n        }\n        mediaTypesToUse = new ArrayList<>();\n        for (MediaType requestedType : requestedMediaTypes) {\n            for (MediaType producibleType : producibleMediaTypes) {\n                if (requestedType.isCompatibleWith(producibleType)) {\n                    mediaTypesToUse.add(getMostSpecificMediaType(requestedType, producibleType));\n                }\n            }\n        }\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"No match for \" + requestedMediaTypes + \", supported: \" + producibleMediaTypes);\n        }\n        if (mediaTypesToUse.isEmpty()) {\n            if (body != null) {\n                throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n            }\n            return;\n        }\n        MediaType.sortBySpecificityAndQuality(mediaTypesToUse);\n    }\n    MediaType selectedMediaType = null;\n    for (MediaType mediaType : mediaTypesToUse) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType = mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"Using '\" + selectedMediaType + \"' given \" + mediaTypesToUse);\n    }\n    if (selectedMediaType != null) {\n        selectedMediaType = selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter<?> converter : this.messageConverters) {\n            GenericHttpMessageConverter genericConverter = (converter instanceof GenericHttpMessageConverter ? (GenericHttpMessageConverter<?>) converter : null);\n            if (genericConverter != null ? ((GenericHttpMessageConverter) converter).canWrite(declaredType, valueType, selectedMediaType) : converter.canWrite(valueType, selectedMediaType)) {\n                body = getAdvice().beforeBodyWrite(body, returnType, selectedMediaType, (Class<? extends HttpMessageConverter<?>>) converter.getClass(), inputMessage, outputMessage);\n                if (body != null) {\n                    if (logger.isDebugEnabled()) {\n                        Object formatted = body instanceof CharSequence ? \"\\\"\" + body + \"\\\"\" : body;\n                        logger.debug(\"Writing [\" + formatted + \"]\");\n                    }\n                    addContentDispositionHeader(inputMessage, outputMessage);\n                    if (genericConverter != null) {\n                        genericConverter.write(body, declaredType, selectedMediaType, outputMessage);\n                    } else {\n                        ((HttpMessageConverter) converter).write(body, selectedMediaType, outputMessage);\n                    }\n                } else {\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Nothing to write: null body\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    if (body != null) {\n        throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n    }\n}"
    },
    {
      "commit": "900bc8a2e341277296a463c7b5db4abb944e14d7",
      "startLine": 3,
      "endLine": 14,
      "methodCode": "@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\nprotected <T> void writeWithMessageConverters(@Nullable T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n    Object body;\n    Class<?> valueType;\n    Type declaredType;\n    if (value instanceof CharSequence) {\n        body = value.toString();\n        valueType = String.class;\n        declaredType = String.class;\n    } else {\n        body = value;\n        valueType = getReturnValueType(body, returnType);\n        declaredType = getGenericType(returnType);\n    }\n    if (isResourceType(value, returnType)) {\n        outputMessage.getHeaders().set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n        if (value != null && inputMessage.getHeaders().getFirst(HttpHeaders.RANGE) != null) {\n            Resource resource = (Resource) value;\n            try {\n                List<HttpRange> httpRanges = inputMessage.getHeaders().getRange();\n                outputMessage.getServletResponse().setStatus(HttpStatus.PARTIAL_CONTENT.value());\n                body = HttpRange.toResourceRegions(httpRanges, resource);\n                valueType = body.getClass();\n                declaredType = RESOURCE_REGION_LIST_TYPE;\n            } catch (IllegalArgumentException ex) {\n                outputMessage.getHeaders().set(HttpHeaders.CONTENT_RANGE, \"bytes */\" + resource.contentLength());\n                outputMessage.getServletResponse().setStatus(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE.value());\n            }\n        }\n    }\n    List<MediaType> mediaTypesToUse;\n    MediaType contentType = outputMessage.getHeaders().getContentType();\n    if (contentType != null && contentType.isConcrete()) {\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Found 'Content-Type:\" + contentType + \"' in response\");\n        }\n        mediaTypesToUse = Collections.singletonList(contentType);\n    } else {\n        HttpServletRequest request = inputMessage.getServletRequest();\n        List<MediaType> requestedMediaTypes = getAcceptableMediaTypes(request);\n        List<MediaType> producibleMediaTypes = getProducibleMediaTypes(request, valueType, declaredType);\n        if (body != null && producibleMediaTypes.isEmpty()) {\n            throw new HttpMessageNotWritableException(\"No converter found for return value of type: \" + valueType);\n        }\n        mediaTypesToUse = new ArrayList<>();\n        for (MediaType requestedType : requestedMediaTypes) {\n            for (MediaType producibleType : producibleMediaTypes) {\n                if (requestedType.isCompatibleWith(producibleType)) {\n                    mediaTypesToUse.add(getMostSpecificMediaType(requestedType, producibleType));\n                }\n            }\n        }\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"No match for \" + requestedMediaTypes + \", supported: \" + producibleMediaTypes);\n        }\n        if (mediaTypesToUse.isEmpty()) {\n            if (body != null) {\n                throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n            }\n            return;\n        }\n        MediaType.sortBySpecificityAndQuality(mediaTypesToUse);\n    }\n    MediaType selectedMediaType = null;\n    for (MediaType mediaType : mediaTypesToUse) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType = mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"Using '\" + selectedMediaType + \"' given \" + mediaTypesToUse);\n    }\n    if (selectedMediaType != null) {\n        selectedMediaType = selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter<?> converter : this.messageConverters) {\n            GenericHttpMessageConverter genericConverter = (converter instanceof GenericHttpMessageConverter ? (GenericHttpMessageConverter<?>) converter : null);\n            if (genericConverter != null ? ((GenericHttpMessageConverter) converter).canWrite(declaredType, valueType, selectedMediaType) : converter.canWrite(valueType, selectedMediaType)) {\n                body = getAdvice().beforeBodyWrite(body, returnType, selectedMediaType, (Class<? extends HttpMessageConverter<?>>) converter.getClass(), inputMessage, outputMessage);\n                if (body != null) {\n                    if (logger.isDebugEnabled()) {\n                        Object formatted = body instanceof CharSequence ? \"\\\"\" + body + \"\\\"\" : body;\n                        logger.debug(\"Writing [\" + formatted + \"]\");\n                    }\n                    addContentDispositionHeader(inputMessage, outputMessage);\n                    if (genericConverter != null) {\n                        genericConverter.write(body, declaredType, selectedMediaType, outputMessage);\n                    } else {\n                        ((HttpMessageConverter) converter).write(body, selectedMediaType, outputMessage);\n                    }\n                } else {\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Nothing to write: null body\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    if (body != null) {\n        throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n    }\n}"
    },
    {
      "commit": "28a5c3009ea0c31f879c0bb8b9e6cfd33faa81e5",
      "startLine": 3,
      "endLine": 14,
      "methodCode": "@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\nprotected <T> void writeWithMessageConverters(@Nullable T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n    Object body;\n    Class<?> valueType;\n    Type declaredType;\n    if (value instanceof CharSequence) {\n        body = value.toString();\n        valueType = String.class;\n        declaredType = String.class;\n    } else {\n        body = value;\n        valueType = getReturnValueType(body, returnType);\n        declaredType = getGenericType(returnType);\n    }\n    if (isResourceType(value, returnType)) {\n        outputMessage.getHeaders().set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n        if (value != null && inputMessage.getHeaders().getFirst(HttpHeaders.RANGE) != null) {\n            Resource resource = (Resource) value;\n            try {\n                List<HttpRange> httpRanges = inputMessage.getHeaders().getRange();\n                outputMessage.getServletResponse().setStatus(HttpStatus.PARTIAL_CONTENT.value());\n                body = HttpRange.toResourceRegions(httpRanges, resource);\n                valueType = body.getClass();\n                declaredType = RESOURCE_REGION_LIST_TYPE;\n            } catch (IllegalArgumentException ex) {\n                outputMessage.getHeaders().set(HttpHeaders.CONTENT_RANGE, \"bytes */\" + resource.contentLength());\n                outputMessage.getServletResponse().setStatus(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE.value());\n            }\n        }\n    }\n    List<MediaType> mediaTypesToUse;\n    MediaType contentType = outputMessage.getHeaders().getContentType();\n    if (contentType != null && contentType.isConcrete()) {\n        mediaTypesToUse = Collections.singletonList(contentType);\n    } else {\n        HttpServletRequest request = inputMessage.getServletRequest();\n        List<MediaType> requestedMediaTypes = getAcceptableMediaTypes(request);\n        List<MediaType> producibleMediaTypes = getProducibleMediaTypes(request, valueType, declaredType);\n        if (body != null && producibleMediaTypes.isEmpty()) {\n            throw new HttpMessageNotWritableException(\"No converter found for return value of type: \" + valueType);\n        }\n        mediaTypesToUse = new ArrayList<>();\n        for (MediaType requestedType : requestedMediaTypes) {\n            for (MediaType producibleType : producibleMediaTypes) {\n                if (requestedType.isCompatibleWith(producibleType)) {\n                    mediaTypesToUse.add(getMostSpecificMediaType(requestedType, producibleType));\n                }\n            }\n        }\n        if (mediaTypesToUse.isEmpty()) {\n            if (body != null) {\n                throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n            }\n            return;\n        }\n        MediaType.sortBySpecificityAndQuality(mediaTypesToUse);\n    }\n    MediaType selectedMediaType = null;\n    for (MediaType mediaType : mediaTypesToUse) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType = mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType != null) {\n        selectedMediaType = selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter<?> converter : this.messageConverters) {\n            GenericHttpMessageConverter genericConverter = (converter instanceof GenericHttpMessageConverter ? (GenericHttpMessageConverter<?>) converter : null);\n            if (genericConverter != null ? ((GenericHttpMessageConverter) converter).canWrite(declaredType, valueType, selectedMediaType) : converter.canWrite(valueType, selectedMediaType)) {\n                body = getAdvice().beforeBodyWrite(body, returnType, selectedMediaType, (Class<? extends HttpMessageConverter<?>>) converter.getClass(), inputMessage, outputMessage);\n                if (body != null) {\n                    addContentDispositionHeader(inputMessage, outputMessage);\n                    if (genericConverter != null) {\n                        genericConverter.write(body, declaredType, selectedMediaType, outputMessage);\n                    } else {\n                        ((HttpMessageConverter) converter).write(body, selectedMediaType, outputMessage);\n                    }\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Written \\\"\" + selectedMediaType + \"\\\" from \" + \"[\" + (body instanceof CharSequence ? \"\\\"\" + body + \"\\\"\" : body) + \"]\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    if (body != null) {\n        throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n    }\n}"
    },
    {
      "commit": "aba882af4c4f7d2ec6e0b859dbffc1bcf65e000c",
      "startLine": 3,
      "endLine": 14,
      "methodCode": "@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\nprotected <T> void writeWithMessageConverters(@Nullable T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n    Object outputValue;\n    Class<?> valueType;\n    Type declaredType;\n    if (value instanceof CharSequence) {\n        outputValue = value.toString();\n        valueType = String.class;\n        declaredType = String.class;\n    } else {\n        outputValue = value;\n        valueType = getReturnValueType(outputValue, returnType);\n        declaredType = getGenericType(returnType);\n    }\n    if (isResourceType(value, returnType)) {\n        outputMessage.getHeaders().set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n        if (value != null && inputMessage.getHeaders().getFirst(HttpHeaders.RANGE) != null) {\n            Resource resource = (Resource) value;\n            try {\n                List<HttpRange> httpRanges = inputMessage.getHeaders().getRange();\n                outputMessage.getServletResponse().setStatus(HttpStatus.PARTIAL_CONTENT.value());\n                outputValue = HttpRange.toResourceRegions(httpRanges, resource);\n                valueType = outputValue.getClass();\n                declaredType = RESOURCE_REGION_LIST_TYPE;\n            } catch (IllegalArgumentException ex) {\n                outputMessage.getHeaders().set(HttpHeaders.CONTENT_RANGE, \"bytes */\" + resource.contentLength());\n                outputMessage.getServletResponse().setStatus(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE.value());\n            }\n        }\n    }\n    List<MediaType> mediaTypesToUse;\n    MediaType contentType = outputMessage.getHeaders().getContentType();\n    if (contentType != null && contentType.isConcrete()) {\n        mediaTypesToUse = Collections.singletonList(contentType);\n    } else {\n        HttpServletRequest request = inputMessage.getServletRequest();\n        List<MediaType> requestedMediaTypes = getAcceptableMediaTypes(request);\n        List<MediaType> producibleMediaTypes = getProducibleMediaTypes(request, valueType, declaredType);\n        if (outputValue != null && producibleMediaTypes.isEmpty()) {\n            throw new HttpMessageNotWritableException(\"No converter found for return value of type: \" + valueType);\n        }\n        mediaTypesToUse = new ArrayList<>();\n        for (MediaType requestedType : requestedMediaTypes) {\n            for (MediaType producibleType : producibleMediaTypes) {\n                if (requestedType.isCompatibleWith(producibleType)) {\n                    mediaTypesToUse.add(getMostSpecificMediaType(requestedType, producibleType));\n                }\n            }\n        }\n        if (mediaTypesToUse.isEmpty()) {\n            if (outputValue != null) {\n                throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n            }\n            return;\n        }\n        MediaType.sortBySpecificityAndQuality(mediaTypesToUse);\n    }\n    MediaType selectedMediaType = null;\n    for (MediaType mediaType : mediaTypesToUse) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType = mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType != null) {\n        selectedMediaType = selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter<?> converter : this.messageConverters) {\n            GenericHttpMessageConverter genericConverter = (converter instanceof GenericHttpMessageConverter ? (GenericHttpMessageConverter<?>) converter : null);\n            if (genericConverter != null ? ((GenericHttpMessageConverter) converter).canWrite(declaredType, valueType, selectedMediaType) : converter.canWrite(valueType, selectedMediaType)) {\n                outputValue = getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class<? extends HttpMessageConverter<?>>) converter.getClass(), inputMessage, outputMessage);\n                if (outputValue != null) {\n                    addContentDispositionHeader(inputMessage, outputMessage);\n                    if (genericConverter != null) {\n                        genericConverter.write(outputValue, declaredType, selectedMediaType, outputMessage);\n                    } else {\n                        ((HttpMessageConverter) converter).write(outputValue, selectedMediaType, outputMessage);\n                    }\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + converter + \"]\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    if (outputValue != null) {\n        throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n    }\n}"
    },
    {
      "commit": "fda08852ba9f5d52c149209382c0d03380de413c",
      "startLine": 3,
      "endLine": 14,
      "methodCode": "@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\nprotected <T> void writeWithMessageConverters(@Nullable T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n    Object outputValue;\n    Class<?> valueType;\n    Type declaredType;\n    if (value instanceof CharSequence) {\n        outputValue = value.toString();\n        valueType = String.class;\n        declaredType = String.class;\n    } else {\n        outputValue = value;\n        valueType = getReturnValueType(outputValue, returnType);\n        declaredType = getGenericType(returnType);\n    }\n    if (isResourceType(value, returnType)) {\n        outputMessage.getHeaders().set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n        if (value != null && inputMessage.getHeaders().getFirst(HttpHeaders.RANGE) != null) {\n            Resource resource = (Resource) value;\n            try {\n                List<HttpRange> httpRanges = inputMessage.getHeaders().getRange();\n                outputMessage.getServletResponse().setStatus(HttpStatus.PARTIAL_CONTENT.value());\n                outputValue = HttpRange.toResourceRegions(httpRanges, resource);\n                valueType = outputValue.getClass();\n                declaredType = RESOURCE_REGION_LIST_TYPE;\n            } catch (IllegalArgumentException ex) {\n                outputMessage.getHeaders().set(HttpHeaders.CONTENT_RANGE, \"bytes */\" + resource.contentLength());\n                outputMessage.getServletResponse().setStatus(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE.value());\n            }\n        }\n    }\n    List<MediaType> mediaTypesToUse;\n    MediaType contentType = outputMessage.getHeaders().getContentType();\n    if (contentType != null && contentType.isConcrete()) {\n        mediaTypesToUse = Collections.singletonList(contentType);\n    } else {\n        HttpServletRequest request = inputMessage.getServletRequest();\n        List<MediaType> requestedMediaTypes = getAcceptableMediaTypes(request);\n        List<MediaType> producibleMediaTypes = getProducibleMediaTypes(request, valueType, declaredType);\n        if (outputValue != null && producibleMediaTypes.isEmpty()) {\n            throw new HttpMessageNotWritableException(\"No converter found for return value of type: \" + valueType);\n        }\n        mediaTypesToUse = new ArrayList<>();\n        for (MediaType requestedType : requestedMediaTypes) {\n            for (MediaType producibleType : producibleMediaTypes) {\n                if (requestedType.isCompatibleWith(producibleType)) {\n                    mediaTypesToUse.add(getMostSpecificMediaType(requestedType, producibleType));\n                }\n            }\n        }\n        if (mediaTypesToUse.isEmpty()) {\n            if (outputValue != null) {\n                throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n            }\n            return;\n        }\n        MediaType.sortBySpecificityAndQuality(mediaTypesToUse);\n    }\n    MediaType selectedMediaType = null;\n    for (MediaType mediaType : mediaTypesToUse) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType = mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType != null) {\n        selectedMediaType = selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter<?> converter : this.messageConverters) {\n            GenericHttpMessageConverter genericConverter = (converter instanceof GenericHttpMessageConverter ? (GenericHttpMessageConverter<?>) converter : null);\n            if (genericConverter != null ? ((GenericHttpMessageConverter) converter).canWrite(declaredType, valueType, selectedMediaType) : converter.canWrite(valueType, selectedMediaType)) {\n                outputValue = (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class<? extends HttpMessageConverter<?>>) converter.getClass(), inputMessage, outputMessage);\n                if (outputValue != null) {\n                    addContentDispositionHeader(inputMessage, outputMessage);\n                    if (genericConverter != null) {\n                        genericConverter.write(outputValue, declaredType, selectedMediaType, outputMessage);\n                    } else {\n                        ((HttpMessageConverter) converter).write(outputValue, selectedMediaType, outputMessage);\n                    }\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + converter + \"]\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    if (outputValue != null) {\n        throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n    }\n}"
    },
    {
      "commit": "9a894ab61e4613af176029761b75d7ad2a733440",
      "startLine": 3,
      "endLine": 14,
      "methodCode": "@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\nprotected <T> void writeWithMessageConverters(@Nullable T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n    Object outputValue;\n    Class<?> valueType;\n    Type declaredType;\n    if (value instanceof CharSequence) {\n        outputValue = value.toString();\n        valueType = String.class;\n        declaredType = String.class;\n    } else {\n        outputValue = value;\n        valueType = getReturnValueType(outputValue, returnType);\n        declaredType = getGenericType(returnType);\n    }\n    if (isResourceType(value, returnType)) {\n        outputMessage.getHeaders().set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n        if (value != null && inputMessage.getHeaders().getFirst(HttpHeaders.RANGE) != null) {\n            Resource resource = (Resource) value;\n            try {\n                List<HttpRange> httpRanges = inputMessage.getHeaders().getRange();\n                outputMessage.getServletResponse().setStatus(HttpStatus.PARTIAL_CONTENT.value());\n                outputValue = HttpRange.toResourceRegions(httpRanges, resource);\n                valueType = outputValue.getClass();\n                declaredType = RESOURCE_REGION_LIST_TYPE;\n            } catch (IllegalArgumentException ex) {\n                outputMessage.getHeaders().set(HttpHeaders.CONTENT_RANGE, \"bytes */\" + resource.contentLength());\n                outputMessage.getServletResponse().setStatus(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE.value());\n            }\n        }\n    }\n    HttpServletRequest request = inputMessage.getServletRequest();\n    List<MediaType> requestedMediaTypes = getAcceptableMediaTypes(request);\n    MediaType contentType = outputMessage.getHeaders().getContentType();\n    List<MediaType> producibleMediaTypes = (contentType != null && contentType.isConcrete() ? Collections.singletonList(contentType) : getProducibleMediaTypes(request, valueType, declaredType));\n    if (outputValue != null && producibleMediaTypes.isEmpty()) {\n        throw new HttpMessageNotWritableException(\"No converter found for return value of type: \" + valueType);\n    }\n    Set<MediaType> compatibleMediaTypes = new LinkedHashSet<>();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        if (outputValue != null) {\n            throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n        }\n        return;\n    }\n    List<MediaType> mediaTypes = new ArrayList<>(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType = null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType = mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType != null) {\n        selectedMediaType = selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter<?> converter : this.messageConverters) {\n            GenericHttpMessageConverter genericConverter = (converter instanceof GenericHttpMessageConverter ? (GenericHttpMessageConverter<?>) converter : null);\n            if (genericConverter != null ? ((GenericHttpMessageConverter) converter).canWrite(declaredType, valueType, selectedMediaType) : converter.canWrite(valueType, selectedMediaType)) {\n                outputValue = (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class<? extends HttpMessageConverter<?>>) converter.getClass(), inputMessage, outputMessage);\n                if (outputValue != null) {\n                    addContentDispositionHeader(inputMessage, outputMessage);\n                    if (genericConverter != null) {\n                        genericConverter.write(outputValue, declaredType, selectedMediaType, outputMessage);\n                    } else {\n                        ((HttpMessageConverter) converter).write(outputValue, selectedMediaType, outputMessage);\n                    }\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + converter + \"]\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    if (outputValue != null) {\n        throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n    }\n}"
    },
    {
      "commit": "582014e944002609b562f6e4998935c06bbe6922",
      "startLine": 3,
      "endLine": 14,
      "methodCode": "@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\nprotected <T> void writeWithMessageConverters(@Nullable T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n    Object outputValue;\n    Class<?> valueType;\n    Type declaredType;\n    if (value instanceof CharSequence) {\n        outputValue = value.toString();\n        valueType = String.class;\n        declaredType = String.class;\n    } else {\n        outputValue = value;\n        valueType = getReturnValueType(outputValue, returnType);\n        declaredType = getGenericType(returnType);\n    }\n    if (isResourceType(value, returnType)) {\n        outputMessage.getHeaders().set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n        if (value != null && inputMessage.getHeaders().getFirst(HttpHeaders.RANGE) != null) {\n            Resource resource = (Resource) value;\n            try {\n                List<HttpRange> httpRanges = inputMessage.getHeaders().getRange();\n                outputMessage.getServletResponse().setStatus(HttpStatus.PARTIAL_CONTENT.value());\n                outputValue = HttpRange.toResourceRegions(httpRanges, resource);\n                valueType = outputValue.getClass();\n                declaredType = RESOURCE_REGION_LIST_TYPE;\n            } catch (IllegalArgumentException ex) {\n                outputMessage.getHeaders().set(HttpHeaders.CONTENT_RANGE, \"bytes */\" + resource.contentLength());\n                outputMessage.getServletResponse().setStatus(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE.value());\n            }\n        }\n    }\n    HttpServletRequest request = inputMessage.getServletRequest();\n    List<MediaType> requestedMediaTypes = getAcceptableMediaTypes(request);\n    List<MediaType> producibleMediaTypes = getProducibleMediaTypes(request, valueType, declaredType);\n    if (outputValue != null && producibleMediaTypes.isEmpty()) {\n        throw new HttpMessageNotWritableException(\"No converter found for return value of type: \" + valueType);\n    }\n    Set<MediaType> compatibleMediaTypes = new LinkedHashSet<>();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        if (outputValue != null) {\n            throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n        }\n        return;\n    }\n    List<MediaType> mediaTypes = new ArrayList<>(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType = null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType = mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType != null) {\n        selectedMediaType = selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter<?> converter : this.messageConverters) {\n            GenericHttpMessageConverter genericConverter = (converter instanceof GenericHttpMessageConverter ? (GenericHttpMessageConverter<?>) converter : null);\n            if (genericConverter != null ? ((GenericHttpMessageConverter) converter).canWrite(declaredType, valueType, selectedMediaType) : converter.canWrite(valueType, selectedMediaType)) {\n                outputValue = (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class<? extends HttpMessageConverter<?>>) converter.getClass(), inputMessage, outputMessage);\n                if (outputValue != null) {\n                    addContentDispositionHeader(inputMessage, outputMessage);\n                    if (genericConverter != null) {\n                        genericConverter.write(outputValue, declaredType, selectedMediaType, outputMessage);\n                    } else {\n                        ((HttpMessageConverter) converter).write(outputValue, selectedMediaType, outputMessage);\n                    }\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + converter + \"]\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    if (outputValue != null) {\n        throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n    }\n}"
    },
    {
      "commit": "7dd8dc62a5fa08e3cc99d2388ff62f5825151fb9",
      "startLine": 3,
      "endLine": 14,
      "methodCode": "@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\nprotected <T> void writeWithMessageConverters(@Nullable T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n    Object outputValue;\n    Class<?> valueType;\n    Type declaredType;\n    if (value instanceof CharSequence) {\n        outputValue = value.toString();\n        valueType = String.class;\n        declaredType = String.class;\n    } else {\n        outputValue = value;\n        valueType = getReturnValueType(outputValue, returnType);\n        declaredType = getGenericType(returnType);\n    }\n    HttpServletRequest request = inputMessage.getServletRequest();\n    List<MediaType> requestedMediaTypes = getAcceptableMediaTypes(request);\n    List<MediaType> producibleMediaTypes = getProducibleMediaTypes(request, valueType, declaredType);\n    if (outputValue != null && producibleMediaTypes.isEmpty()) {\n        throw new HttpMessageNotWritableException(\"No converter found for return value of type: \" + valueType);\n    }\n    Set<MediaType> compatibleMediaTypes = new LinkedHashSet<>();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        if (outputValue != null) {\n            throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n        }\n        return;\n    }\n    List<MediaType> mediaTypes = new ArrayList<>(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType = null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType = mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType != null) {\n        selectedMediaType = selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter<?> converter : this.messageConverters) {\n            GenericHttpMessageConverter genericConverter = (converter instanceof GenericHttpMessageConverter ? (GenericHttpMessageConverter<?>) converter : null);\n            if (genericConverter != null ? ((GenericHttpMessageConverter) converter).canWrite(declaredType, valueType, selectedMediaType) : converter.canWrite(valueType, selectedMediaType)) {\n                outputValue = (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class<? extends HttpMessageConverter<?>>) converter.getClass(), inputMessage, outputMessage);\n                if (outputValue != null) {\n                    addContentDispositionHeader(inputMessage, outputMessage);\n                    if (genericConverter != null) {\n                        genericConverter.write(outputValue, declaredType, selectedMediaType, outputMessage);\n                    } else {\n                        ((HttpMessageConverter) converter).write(outputValue, selectedMediaType, outputMessage);\n                    }\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + converter + \"]\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    if (outputValue != null) {\n        throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n    }\n}"
    },
    {
      "commit": "f813712f5b413b354560cd7cc006352e9defa9a3",
      "startLine": 3,
      "endLine": 14,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprotected <T> void writeWithMessageConverters(@Nullable T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n    Object outputValue;\n    Class<?> valueType;\n    Type declaredType;\n    if (value instanceof CharSequence) {\n        outputValue = value.toString();\n        valueType = String.class;\n        declaredType = String.class;\n    } else {\n        outputValue = value;\n        valueType = getReturnValueType(outputValue, returnType);\n        declaredType = getGenericType(returnType);\n    }\n    HttpServletRequest request = inputMessage.getServletRequest();\n    List<MediaType> requestedMediaTypes = getAcceptableMediaTypes(request);\n    List<MediaType> producibleMediaTypes = getProducibleMediaTypes(request, valueType, declaredType);\n    if (outputValue != null && producibleMediaTypes.isEmpty()) {\n        throw new HttpMessageNotWritableException(\"No converter found for return value of type: \" + valueType);\n    }\n    Set<MediaType> compatibleMediaTypes = new LinkedHashSet<>();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        if (outputValue != null) {\n            throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n        }\n        return;\n    }\n    List<MediaType> mediaTypes = new ArrayList<>(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType = null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType = mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType != null) {\n        selectedMediaType = selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n            if (messageConverter instanceof GenericHttpMessageConverter) {\n                if (((GenericHttpMessageConverter) messageConverter).canWrite(declaredType, valueType, selectedMediaType)) {\n                    outputValue = (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class<? extends HttpMessageConverter<?>>) messageConverter.getClass(), inputMessage, outputMessage);\n                    if (outputValue != null) {\n                        addContentDispositionHeader(inputMessage, outputMessage);\n                        ((GenericHttpMessageConverter) messageConverter).write(outputValue, declaredType, selectedMediaType, outputMessage);\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                        }\n                    }\n                    return;\n                }\n            } else if (messageConverter.canWrite(valueType, selectedMediaType)) {\n                outputValue = (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class<? extends HttpMessageConverter<?>>) messageConverter.getClass(), inputMessage, outputMessage);\n                if (outputValue != null) {\n                    addContentDispositionHeader(inputMessage, outputMessage);\n                    ((HttpMessageConverter) messageConverter).write(outputValue, selectedMediaType, outputMessage);\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    if (outputValue != null) {\n        throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n    }\n}"
    },
    {
      "commit": "39f8bd663ee944d92ecd8b1e33b5315807419c94",
      "startLine": 3,
      "endLine": 14,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprotected <T> void writeWithMessageConverters(T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n    Object outputValue;\n    Class<?> valueType;\n    Type declaredType;\n    if (value instanceof CharSequence) {\n        outputValue = value.toString();\n        valueType = String.class;\n        declaredType = String.class;\n    } else {\n        outputValue = value;\n        valueType = getReturnValueType(outputValue, returnType);\n        declaredType = getGenericType(returnType);\n    }\n    HttpServletRequest request = inputMessage.getServletRequest();\n    List<MediaType> requestedMediaTypes = getAcceptableMediaTypes(request);\n    List<MediaType> producibleMediaTypes = getProducibleMediaTypes(request, valueType, declaredType);\n    if (outputValue != null && producibleMediaTypes.isEmpty()) {\n        throw new IllegalArgumentException(\"No converter found for return value of type: \" + valueType);\n    }\n    Set<MediaType> compatibleMediaTypes = new LinkedHashSet<>();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        if (outputValue != null) {\n            throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n        }\n        return;\n    }\n    List<MediaType> mediaTypes = new ArrayList<>(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType = null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType = mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType != null) {\n        selectedMediaType = selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n            if (messageConverter instanceof GenericHttpMessageConverter) {\n                if (((GenericHttpMessageConverter) messageConverter).canWrite(declaredType, valueType, selectedMediaType)) {\n                    outputValue = (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class<? extends HttpMessageConverter<?>>) messageConverter.getClass(), inputMessage, outputMessage);\n                    if (outputValue != null) {\n                        addContentDispositionHeader(inputMessage, outputMessage);\n                        ((GenericHttpMessageConverter) messageConverter).write(outputValue, declaredType, selectedMediaType, outputMessage);\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                        }\n                    }\n                    return;\n                }\n            } else if (messageConverter.canWrite(valueType, selectedMediaType)) {\n                outputValue = (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class<? extends HttpMessageConverter<?>>) messageConverter.getClass(), inputMessage, outputMessage);\n                if (outputValue != null) {\n                    addContentDispositionHeader(inputMessage, outputMessage);\n                    ((HttpMessageConverter) messageConverter).write(outputValue, selectedMediaType, outputMessage);\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    if (outputValue != null) {\n        throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n    }\n}"
    },
    {
      "commit": "00d2606b000f9bdafbd7f4a16b6599fb51b53fa4",
      "startLine": 3,
      "endLine": 14,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprotected <T> void writeWithMessageConverters(T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n    Object outputValue;\n    Class<?> valueType;\n    Type declaredType;\n    if (value instanceof CharSequence) {\n        outputValue = value.toString();\n        valueType = String.class;\n        declaredType = String.class;\n    } else {\n        outputValue = value;\n        valueType = getReturnValueType(outputValue, returnType);\n        declaredType = getGenericType(returnType);\n    }\n    HttpServletRequest request = inputMessage.getServletRequest();\n    List<MediaType> requestedMediaTypes = getAcceptableMediaTypes(request);\n    List<MediaType> producibleMediaTypes = getProducibleMediaTypes(request, valueType, declaredType);\n    if (outputValue != null && producibleMediaTypes.isEmpty()) {\n        throw new IllegalArgumentException(\"No converter found for return value of type: \" + valueType);\n    }\n    Set<MediaType> compatibleMediaTypes = new LinkedHashSet<>();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        if (outputValue != null) {\n            throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n        }\n        return;\n    }\n    List<MediaType> mediaTypes = new ArrayList<>(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType = null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType = mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType != null) {\n        selectedMediaType = selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n            if (messageConverter instanceof GenericHttpMessageConverter) {\n                if (((GenericHttpMessageConverter) messageConverter).canWrite(declaredType, valueType, selectedMediaType)) {\n                    outputValue = (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class<? extends HttpMessageConverter<?>>) messageConverter.getClass(), inputMessage, outputMessage);\n                    if (outputValue != null) {\n                        addContentDispositionHeader(inputMessage, outputMessage);\n                        ((GenericHttpMessageConverter) messageConverter).write(outputValue, declaredType, selectedMediaType, outputMessage);\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                        }\n                    }\n                    return;\n                }\n            } else if (messageConverter.canWrite(valueType, selectedMediaType)) {\n                outputValue = (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class<? extends HttpMessageConverter<?>>) messageConverter.getClass(), inputMessage, outputMessage);\n                if (outputValue != null) {\n                    addContentDispositionHeader(inputMessage, outputMessage);\n                    ((HttpMessageConverter) messageConverter).write(outputValue, selectedMediaType, outputMessage);\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    if (outputValue != null) {\n        throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n    }\n}"
    },
    {
      "commit": "b204437cef0976f5af0e1c5290e77e266b306a51",
      "startLine": 3,
      "endLine": 14,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprotected <T> void writeWithMessageConverters(T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n    Object outputValue;\n    Class<?> valueType;\n    Type declaredType;\n    if (value instanceof CharSequence) {\n        outputValue = value.toString();\n        valueType = String.class;\n        declaredType = String.class;\n    } else {\n        outputValue = value;\n        valueType = getReturnValueType(outputValue, returnType);\n        declaredType = getGenericType(returnType);\n    }\n    HttpServletRequest request = inputMessage.getServletRequest();\n    List<MediaType> requestedMediaTypes = getAcceptableMediaTypes(request);\n    List<MediaType> producibleMediaTypes = getProducibleMediaTypes(request, valueType, declaredType);\n    if (outputValue != null && producibleMediaTypes.isEmpty()) {\n        throw new IllegalArgumentException(\"No converter found for return value of type: \" + valueType);\n    }\n    Set<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        if (outputValue != null) {\n            throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n        }\n        return;\n    }\n    List<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType = null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType = mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType != null) {\n        selectedMediaType = selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n            if (messageConverter instanceof GenericHttpMessageConverter) {\n                if (((GenericHttpMessageConverter) messageConverter).canWrite(declaredType, valueType, selectedMediaType)) {\n                    outputValue = (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class<? extends HttpMessageConverter<?>>) messageConverter.getClass(), inputMessage, outputMessage);\n                    if (outputValue != null) {\n                        addContentDispositionHeader(inputMessage, outputMessage);\n                        ((GenericHttpMessageConverter) messageConverter).write(outputValue, declaredType, selectedMediaType, outputMessage);\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                        }\n                    }\n                    return;\n                }\n            } else if (messageConverter.canWrite(valueType, selectedMediaType)) {\n                outputValue = (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class<? extends HttpMessageConverter<?>>) messageConverter.getClass(), inputMessage, outputMessage);\n                if (outputValue != null) {\n                    addContentDispositionHeader(inputMessage, outputMessage);\n                    ((HttpMessageConverter) messageConverter).write(outputValue, selectedMediaType, outputMessage);\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    if (outputValue != null) {\n        throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n    }\n}"
    },
    {
      "commit": "7756feacd877093ad925d222c8bb911b6bb7c381",
      "startLine": 3,
      "endLine": 9,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprotected <T> void writeWithMessageConverters(T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n    Class<?> clazz = getReturnValueType(value, returnType);\n    Type type = getGenericType(returnType);\n    if (value != null && value instanceof CharSequence) {\n        clazz = String.class;\n        type = String.class;\n        value = (T) value.toString();\n    }\n    HttpServletRequest servletRequest = inputMessage.getServletRequest();\n    List<MediaType> requestedMediaTypes = getAcceptableMediaTypes(servletRequest);\n    List<MediaType> producibleMediaTypes = getProducibleMediaTypes(servletRequest, clazz, type);\n    if (value != null && producibleMediaTypes.isEmpty()) {\n        throw new IllegalArgumentException(\"No converter found for return value of type: \" + clazz);\n    }\n    Set<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        if (value != null) {\n            throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n        }\n        return;\n    }\n    List<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType = null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType = mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType != null) {\n        selectedMediaType = selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n            if (messageConverter instanceof GenericHttpMessageConverter) {\n                if (((GenericHttpMessageConverter<T>) messageConverter).canWrite(type, clazz, selectedMediaType)) {\n                    value = (T) getAdvice().beforeBodyWrite(value, returnType, selectedMediaType, (Class<? extends HttpMessageConverter<?>>) messageConverter.getClass(), inputMessage, outputMessage);\n                    if (value != null) {\n                        addContentDispositionHeader(inputMessage, outputMessage);\n                        ((GenericHttpMessageConverter<T>) messageConverter).write(value, type, selectedMediaType, outputMessage);\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Written [\" + value + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                        }\n                    }\n                    return;\n                }\n            } else if (messageConverter.canWrite(clazz, selectedMediaType)) {\n                value = (T) getAdvice().beforeBodyWrite(value, returnType, selectedMediaType, (Class<? extends HttpMessageConverter<?>>) messageConverter.getClass(), inputMessage, outputMessage);\n                if (value != null) {\n                    addContentDispositionHeader(inputMessage, outputMessage);\n                    ((HttpMessageConverter<T>) messageConverter).write(value, selectedMediaType, outputMessage);\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Written [\" + value + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    if (value != null) {\n        throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n    }\n}"
    },
    {
      "commit": "1291d6e1bd5ba6524c3fb68813aad807d123c2e1",
      "startLine": 3,
      "endLine": 9,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprotected <T> void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n    Class<?> returnValueClass = getReturnValueType(returnValue, returnType);\n    Type returnValueType = getGenericType(returnType);\n    if (returnValue != null && returnValue instanceof CharSequence) {\n        returnValueClass = String.class;\n        returnValueType = String.class;\n        returnValue = (T) returnValue.toString();\n    }\n    HttpServletRequest servletRequest = inputMessage.getServletRequest();\n    List<MediaType> requestedMediaTypes = getAcceptableMediaTypes(servletRequest);\n    List<MediaType> producibleMediaTypes = getProducibleMediaTypes(servletRequest, returnValueClass, returnValueType);\n    if (returnValue != null && producibleMediaTypes.isEmpty()) {\n        throw new IllegalArgumentException(\"No converter found for return value of type: \" + returnValueClass);\n    }\n    Set<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        if (returnValue != null) {\n            throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n        }\n        return;\n    }\n    List<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType = null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType = mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType != null) {\n        selectedMediaType = selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n            if (messageConverter instanceof GenericHttpMessageConverter) {\n                if (((GenericHttpMessageConverter<T>) messageConverter).canWrite(returnValueType, returnValueClass, selectedMediaType)) {\n                    returnValue = (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType, (Class<? extends HttpMessageConverter<?>>) messageConverter.getClass(), inputMessage, outputMessage);\n                    if (returnValue != null) {\n                        addContentDispositionHeader(inputMessage, outputMessage);\n                        ((GenericHttpMessageConverter<T>) messageConverter).write(returnValue, returnValueType, selectedMediaType, outputMessage);\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                        }\n                    }\n                    return;\n                }\n            } else if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                returnValue = (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType, (Class<? extends HttpMessageConverter<?>>) messageConverter.getClass(), inputMessage, outputMessage);\n                if (returnValue != null) {\n                    addContentDispositionHeader(inputMessage, outputMessage);\n                    ((HttpMessageConverter<T>) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    if (returnValue != null) {\n        throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n    }\n}"
    },
    {
      "commit": "2bd1daa75ee0b8ec33608ca6ab065ef3e1815543",
      "startLine": 3,
      "endLine": 4,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprotected <T> void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n    Class<?> returnValueClass = getReturnValueType(returnValue, returnType);\n    Type returnValueType = getGenericType(returnType);\n    HttpServletRequest servletRequest = inputMessage.getServletRequest();\n    List<MediaType> requestedMediaTypes = getAcceptableMediaTypes(servletRequest);\n    List<MediaType> producibleMediaTypes = getProducibleMediaTypes(servletRequest, returnValueClass, returnValueType);\n    if (returnValue != null && producibleMediaTypes.isEmpty()) {\n        throw new IllegalArgumentException(\"No converter found for return value of type: \" + returnValueClass);\n    }\n    Set<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        if (returnValue != null) {\n            throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n        }\n        return;\n    }\n    List<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType = null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType = mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType != null) {\n        selectedMediaType = selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n            if (messageConverter instanceof GenericHttpMessageConverter) {\n                if (((GenericHttpMessageConverter<T>) messageConverter).canWrite(returnValueType, returnValueClass, selectedMediaType)) {\n                    returnValue = (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType, (Class<? extends HttpMessageConverter<?>>) messageConverter.getClass(), inputMessage, outputMessage);\n                    if (returnValue != null) {\n                        addContentDispositionHeader(inputMessage, outputMessage);\n                        ((GenericHttpMessageConverter<T>) messageConverter).write(returnValue, returnValueType, selectedMediaType, outputMessage);\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                        }\n                    }\n                    return;\n                }\n            } else if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                returnValue = (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType, (Class<? extends HttpMessageConverter<?>>) messageConverter.getClass(), inputMessage, outputMessage);\n                if (returnValue != null) {\n                    addContentDispositionHeader(inputMessage, outputMessage);\n                    ((HttpMessageConverter<T>) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    if (returnValue != null) {\n        throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n    }\n}"
    },
    {
      "commit": "667fc7e4a9d9daf15110339af3659404ace6adba",
      "startLine": 3,
      "endLine": 4,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprotected <T> void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n    Class<?> returnValueClass = getReturnValueType(returnValue, returnType);\n    Type returnValueType = getGenericType(returnType);\n    HttpServletRequest servletRequest = inputMessage.getServletRequest();\n    List<MediaType> requestedMediaTypes = getAcceptableMediaTypes(servletRequest);\n    List<MediaType> producibleMediaTypes = getProducibleMediaTypes(servletRequest, returnValueClass, returnValueType);\n    if (returnValue != null && producibleMediaTypes.isEmpty()) {\n        throw new IllegalArgumentException(\"No converter found for return value of type: \" + returnValueClass);\n    }\n    Set<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        if (returnValue != null) {\n            throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n        }\n        return;\n    }\n    List<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType = null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType = mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType != null) {\n        selectedMediaType = selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n            if (messageConverter instanceof GenericHttpMessageConverter) {\n                if (((GenericHttpMessageConverter<T>) messageConverter).canWrite(returnValueType, returnValueClass, selectedMediaType)) {\n                    returnValue = (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType, (Class<? extends HttpMessageConverter<?>>) messageConverter.getClass(), inputMessage, outputMessage);\n                    if (returnValue != null) {\n                        ((GenericHttpMessageConverter<T>) messageConverter).write(returnValue, returnValueType, selectedMediaType, outputMessage);\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                        }\n                    }\n                    return;\n                }\n            } else if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                returnValue = (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType, (Class<? extends HttpMessageConverter<?>>) messageConverter.getClass(), inputMessage, outputMessage);\n                if (returnValue != null) {\n                    ((HttpMessageConverter<T>) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    if (returnValue != null) {\n        throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n    }\n}"
    },
    {
      "commit": "d83735694eff6919434e8a4557cfb6dc66e5175d",
      "startLine": 3,
      "endLine": 4,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprotected <T> void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n    Class<?> returnValueClass = getReturnValueType(returnValue, returnType);\n    Type returnValueType = getGenericType(returnType);\n    HttpServletRequest servletRequest = inputMessage.getServletRequest();\n    List<MediaType> requestedMediaTypes = getAcceptableMediaTypes(servletRequest);\n    List<MediaType> producibleMediaTypes = getProducibleMediaTypes(servletRequest, returnValueClass, returnValueType);\n    Assert.isTrue(returnValue == null || !producibleMediaTypes.isEmpty(), \"No converter found for return value of type: \" + returnValueClass);\n    Set<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        if (returnValue != null) {\n            throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n        }\n        return;\n    }\n    List<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType = null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType = mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType != null) {\n        selectedMediaType = selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n            if (messageConverter instanceof GenericHttpMessageConverter) {\n                if (((GenericHttpMessageConverter<T>) messageConverter).canWrite(returnValueType, returnValueClass, selectedMediaType)) {\n                    returnValue = (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType, (Class<? extends HttpMessageConverter<?>>) messageConverter.getClass(), inputMessage, outputMessage);\n                    if (returnValue != null) {\n                        ((GenericHttpMessageConverter<T>) messageConverter).write(returnValue, returnValueType, selectedMediaType, outputMessage);\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                        }\n                    }\n                    return;\n                }\n            } else if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                returnValue = (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType, (Class<? extends HttpMessageConverter<?>>) messageConverter.getClass(), inputMessage, outputMessage);\n                if (returnValue != null) {\n                    ((HttpMessageConverter<T>) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    if (returnValue != null) {\n        throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n    }\n}"
    },
    {
      "commit": "289f35da3a57bb5e491b30c7351072b4e801c519",
      "startLine": 3,
      "endLine": 4,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprotected <T> void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n    Class<?> returnValueClass = getReturnValueType(returnValue, returnType);\n    Type returnValueType = getGenericType(returnType);\n    HttpServletRequest servletRequest = inputMessage.getServletRequest();\n    List<MediaType> requestedMediaTypes = getAcceptableMediaTypes(servletRequest);\n    List<MediaType> producibleMediaTypes = getProducibleMediaTypes(servletRequest, returnValueClass, returnValueType);\n    Assert.isTrue(returnValue == null || !producibleMediaTypes.isEmpty(), \"No converter found for return value of type: \" + returnValueClass);\n    Set<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        if (returnValue != null) {\n            throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n        }\n        return;\n    }\n    List<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType = null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType = mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType != null) {\n        selectedMediaType = selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n            if (messageConverter instanceof GenericHttpMessageConverter) {\n                if (((GenericHttpMessageConverter<T>) messageConverter).canWrite(returnValueType, returnValueClass, selectedMediaType)) {\n                    returnValue = (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType, (Class<? extends HttpMessageConverter<?>>) messageConverter.getClass(), inputMessage, outputMessage);\n                    if (returnValue != null) {\n                        ((GenericHttpMessageConverter<T>) messageConverter).write(returnValue, returnValueType, selectedMediaType, outputMessage);\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                        }\n                    }\n                    return;\n                }\n            } else if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                returnValue = (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType, (Class<? extends HttpMessageConverter<?>>) messageConverter.getClass(), inputMessage, outputMessage);\n                if (returnValue != null) {\n                    ((HttpMessageConverter<T>) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    if (returnValue != null) {\n        throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n    }\n}"
    },
    {
      "commit": "31a5434ea433bdec2283797bf9415c02bb2f41c1",
      "startLine": 3,
      "endLine": 3,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprotected <T> void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n    Class<?> returnValueClass = getReturnValueType(returnValue, returnType);\n    HttpServletRequest servletRequest = inputMessage.getServletRequest();\n    List<MediaType> requestedMediaTypes = getAcceptableMediaTypes(servletRequest);\n    List<MediaType> producibleMediaTypes = getProducibleMediaTypes(servletRequest, returnValueClass);\n    Assert.isTrue(returnValue == null || !producibleMediaTypes.isEmpty(), \"No converter found for return value of type: \" + returnValueClass);\n    Set<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        if (returnValue != null) {\n            throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n        }\n        return;\n    }\n    List<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType = null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType = mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType != null) {\n        selectedMediaType = selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n            if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                returnValue = (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType, (Class<? extends HttpMessageConverter<?>>) messageConverter.getClass(), inputMessage, outputMessage);\n                if (returnValue != null) {\n                    if (messageConverter instanceof GenericHttpMessageConverter) {\n                        Type type;\n                        if (HttpEntity.class.isAssignableFrom(returnType.getParameterType())) {\n                            returnType.increaseNestingLevel();\n                            type = returnType.getNestedGenericParameterType();\n                        } else {\n                            type = returnType.getGenericParameterType();\n                        }\n                        ((GenericHttpMessageConverter<T>) messageConverter).write(returnValue, type, selectedMediaType, outputMessage);\n                    } else {\n                        ((HttpMessageConverter<T>) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                    }\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    if (returnValue != null) {\n        throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n    }\n}"
    },
    {
      "commit": "8d7812b1b6c47c3edef1332639cb57b92327ec46",
      "startLine": 3,
      "endLine": 3,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprotected <T> void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n    Class<?> returnValueClass = getReturnValueType(returnValue, returnType);\n    HttpServletRequest servletRequest = inputMessage.getServletRequest();\n    List<MediaType> requestedMediaTypes = getAcceptableMediaTypes(servletRequest);\n    List<MediaType> producibleMediaTypes = getProducibleMediaTypes(servletRequest, returnValueClass);\n    Assert.isTrue(returnValue == null || !producibleMediaTypes.isEmpty(), \"No converter found for return value of type: \" + returnValueClass);\n    Set<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        if (returnValue != null) {\n            throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n        }\n        return;\n    }\n    List<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType = null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType = mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType != null) {\n        selectedMediaType = selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n            if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                returnValue = (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType, (Class<? extends HttpMessageConverter<?>>) messageConverter.getClass(), inputMessage, outputMessage);\n                if (returnValue != null) {\n                    ((HttpMessageConverter<T>) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    if (returnValue != null) {\n        throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n    }\n}"
    },
    {
      "commit": "0556ed4f161cddf992cc49960ba0181a564a8667",
      "startLine": 3,
      "endLine": 3,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprotected <T> void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n    Class<?> returnValueClass = getReturnValueType(returnValue, returnType);\n    HttpServletRequest servletRequest = inputMessage.getServletRequest();\n    List<MediaType> requestedMediaTypes = getAcceptableMediaTypes(servletRequest);\n    List<MediaType> producibleMediaTypes = getProducibleMediaTypes(servletRequest, returnValueClass);\n    Set<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        if (returnValue != null) {\n            throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n        }\n        return;\n    }\n    List<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType = null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType = mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType != null) {\n        selectedMediaType = selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n            if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                returnValue = (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType, (Class<? extends HttpMessageConverter<?>>) messageConverter.getClass(), inputMessage, outputMessage);\n                if (returnValue != null) {\n                    ((HttpMessageConverter<T>) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    if (returnValue != null) {\n        throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n    }\n}"
    },
    {
      "commit": "c5e360d886931f761c2be5ff4b31d5df2042d415",
      "startLine": 3,
      "endLine": 3,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprotected <T> void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n    Class<?> returnValueClass = getReturnValueType(returnValue, returnType);\n    HttpServletRequest servletRequest = inputMessage.getServletRequest();\n    List<MediaType> requestedMediaTypes = getAcceptableMediaTypes(servletRequest);\n    List<MediaType> producibleMediaTypes = getProducibleMediaTypes(servletRequest, returnValueClass);\n    Set<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        if (returnValue != null) {\n            throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n        }\n        return;\n    }\n    List<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType = null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType = mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType != null) {\n        selectedMediaType = selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n            if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                returnValue = this.adviceChain.invoke(returnValue, returnType, selectedMediaType, (Class<HttpMessageConverter<?>>) messageConverter.getClass(), inputMessage, outputMessage);\n                if (returnValue != null) {\n                    ((HttpMessageConverter<T>) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    if (returnValue != null) {\n        throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n    }\n}"
    },
    {
      "commit": "8cce40469631327e0afdd5d41393248313819270",
      "startLine": 3,
      "endLine": 3,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprotected <T> void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n    Class<?> returnValueClass = getReturnValueType(returnValue, returnType);\n    if (returnValue == null && Void.class.equals(returnValueClass)) {\n        return;\n    }\n    HttpServletRequest servletRequest = inputMessage.getServletRequest();\n    List<MediaType> requestedMediaTypes = getAcceptableMediaTypes(servletRequest);\n    List<MediaType> producibleMediaTypes = getProducibleMediaTypes(servletRequest, returnValueClass);\n    Set<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n    }\n    List<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType = null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType = mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType != null) {\n        selectedMediaType = selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n            if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                returnValue = this.adviceChain.invoke(returnValue, returnType, selectedMediaType, (Class<HttpMessageConverter<?>>) messageConverter.getClass(), inputMessage, outputMessage);\n                if (returnValue != null) {\n                    ((HttpMessageConverter<T>) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n}"
    },
    {
      "commit": "a9b2a12491aa2259851b93824b7e560b3dbd1902",
      "startLine": 3,
      "endLine": 3,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprotected <T> void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n    Class<?> returnValueClass = getReturnValueType(returnValue, returnType);\n    HttpServletRequest servletRequest = inputMessage.getServletRequest();\n    List<MediaType> requestedMediaTypes = getAcceptableMediaTypes(servletRequest);\n    List<MediaType> producibleMediaTypes = getProducibleMediaTypes(servletRequest, returnValueClass);\n    Set<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n    }\n    List<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType = null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType = mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType != null) {\n        selectedMediaType = selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n            if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                returnValue = this.adviceChain.invoke(returnValue, returnType, selectedMediaType, (Class<HttpMessageConverter<?>>) messageConverter.getClass(), inputMessage, outputMessage);\n                if (returnValue != null) {\n                    ((HttpMessageConverter<T>) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n}"
    },
    {
      "commit": "c9d0ebd730953ef693edf275b57cfeeb9bf15af9",
      "startLine": 3,
      "endLine": 3,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprotected <T> void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n    Class<?> returnValueClass = returnValue.getClass();\n    HttpServletRequest servletRequest = inputMessage.getServletRequest();\n    List<MediaType> requestedMediaTypes = getAcceptableMediaTypes(servletRequest);\n    List<MediaType> producibleMediaTypes = getProducibleMediaTypes(servletRequest, returnValueClass);\n    Set<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n    }\n    List<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType = null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType = mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType != null) {\n        selectedMediaType = selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n            if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                returnValue = this.adviceChain.invoke(returnValue, returnType, selectedMediaType, (Class<HttpMessageConverter<?>>) messageConverter.getClass(), inputMessage, outputMessage);\n                ((HttpMessageConverter<T>) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                }\n                return;\n            }\n        }\n    }\n    throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n}"
    },
    {
      "commit": "2655c507e041fb3c245d550b33ba7f1b21fc341e",
      "startLine": 3,
      "endLine": 3,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprotected <T> void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n    Class<?> returnValueClass = returnValue.getClass();\n    HttpServletRequest servletRequest = inputMessage.getServletRequest();\n    List<MediaType> requestedMediaTypes = getAcceptableMediaTypes(servletRequest);\n    List<MediaType> producibleMediaTypes = getProducibleMediaTypes(servletRequest, returnValueClass);\n    Set<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n    }\n    List<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType = null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType = mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType != null) {\n        selectedMediaType = selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n            if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                returnValue = this.interceptorChain.invoke(returnValue, returnType, selectedMediaType, (Class<HttpMessageConverter<?>>) messageConverter.getClass(), inputMessage, outputMessage);\n                ((HttpMessageConverter<T>) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                }\n                return;\n            }\n        }\n    }\n    throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n}"
    },
    {
      "commit": "51fc3b4aaf01a3d8f8f0f9ec98f5e5c1215cc096",
      "startLine": 3,
      "endLine": 3,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprotected <T> void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n    Class<?> returnValueClass = returnValue.getClass();\n    HttpServletRequest servletRequest = inputMessage.getServletRequest();\n    List<MediaType> requestedMediaTypes = getAcceptableMediaTypes(servletRequest);\n    List<MediaType> producibleMediaTypes = getProducibleMediaTypes(servletRequest, returnValueClass);\n    Set<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n    }\n    List<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType = null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType = mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType != null) {\n        selectedMediaType = selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n            if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                returnValue = this.interceptorChain.invoke(returnValue, selectedMediaType, (Class<HttpMessageConverter<T>>) messageConverter.getClass(), returnType, inputMessage, outputMessage);\n                ((HttpMessageConverter<T>) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                }\n                return;\n            }\n        }\n    }\n    throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n}"
    },
    {
      "commit": "96b18c8dc22c0c57605a594b21ceec84ec16ee37",
      "startLine": 3,
      "endLine": 3,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprotected <T> void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n    Class<?> returnValueClass = returnValue.getClass();\n    HttpServletRequest servletRequest = inputMessage.getServletRequest();\n    List<MediaType> requestedMediaTypes = getAcceptableMediaTypes(servletRequest);\n    List<MediaType> producibleMediaTypes = getProducibleMediaTypes(servletRequest, returnValueClass);\n    Set<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n    }\n    List<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType = null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType = mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType != null) {\n        selectedMediaType = selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n            if (messageConverter instanceof MethodParameterHttpMessageConverter) {\n                MethodParameterHttpMessageConverter<T> c = (MethodParameterHttpMessageConverter<T>) messageConverter;\n                if (c.canWrite(returnValueClass, selectedMediaType, returnType)) {\n                    c.write(returnValue, selectedMediaType, outputMessage, returnType);\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                    }\n                    return;\n                }\n            }\n            if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                returnValue = this.interceptorChain.invoke(returnValue, selectedMediaType, (Class<HttpMessageConverter<T>>) messageConverter.getClass(), returnType, inputMessage, outputMessage);\n                ((HttpMessageConverter<T>) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                }\n                return;\n            }\n        }\n    }\n    throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n}"
    },
    {
      "commit": "be0b69cbf1377e3fa8d8abc94f24274f4d0945b2",
      "startLine": 3,
      "endLine": 3,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprotected <T> void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n    Class<?> returnValueClass = returnValue.getClass();\n    HttpServletRequest servletRequest = inputMessage.getServletRequest();\n    List<MediaType> requestedMediaTypes = getAcceptableMediaTypes(servletRequest);\n    List<MediaType> producibleMediaTypes = getProducibleMediaTypes(servletRequest, returnValueClass);\n    Set<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n    }\n    List<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType = null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType = mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType != null) {\n        selectedMediaType = selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n            if (messageConverter instanceof MethodParameterHttpMessageConverter) {\n                MethodParameterHttpMessageConverter<T> c = (MethodParameterHttpMessageConverter<T>) messageConverter;\n                if (c.canWrite(returnValueClass, selectedMediaType, returnType)) {\n                    c.write(returnValue, selectedMediaType, outputMessage, returnType);\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                    }\n                    return;\n                }\n            }\n            if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                ((HttpMessageConverter<T>) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                }\n                return;\n            }\n        }\n    }\n    throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n}"
    },
    {
      "commit": "ec7d80b8519332ffb5f0595dddc9ef52de532730",
      "startLine": 3,
      "endLine": 3,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprotected <T> void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n    Class<?> returnValueClass = returnValue.getClass();\n    HttpServletRequest servletRequest = inputMessage.getServletRequest();\n    List<MediaType> requestedMediaTypes = getAcceptableMediaTypes(servletRequest);\n    List<MediaType> producibleMediaTypes = getProducibleMediaTypes(servletRequest, returnValueClass);\n    Set<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n    }\n    List<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType = null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType = mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType != null) {\n        selectedMediaType = selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n            if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                ((HttpMessageConverter<T>) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                }\n                return;\n            }\n        }\n    }\n    throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n}"
    },
    {
      "commit": "e4fcad9f936ba492f28ec5f0421eea4b3f76f8aa",
      "startLine": 3,
      "endLine": 3,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprotected <T> void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n    Class<?> returnValueClass = returnValue.getClass();\n    HttpServletRequest servletRequest = inputMessage.getServletRequest();\n    List<MediaType> requestedMediaTypes = getAcceptableMediaTypes(servletRequest);\n    List<MediaType> producibleMediaTypes = getProducibleMediaTypes(servletRequest, returnValueClass);\n    Set<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();\n    for (MediaType r : requestedMediaTypes) {\n        for (MediaType p : producibleMediaTypes) {\n            if (r.isCompatibleWith(p)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(r, p));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n    }\n    List<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType = null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType = mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType != null) {\n        selectedMediaType = selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter<?> messageConverter : messageConverters) {\n            if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                ((HttpMessageConverter<T>) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                }\n                return;\n            }\n        }\n    }\n    throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n}"
    },
    {
      "commit": "d4fa5c0331e5a8008dae2f6f0ba157bdddaf122d",
      "startLine": 3,
      "endLine": 3,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprotected <T> void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n    Class<?> returnValueClass = returnValue.getClass();\n    HttpServletRequest servletRequest = inputMessage.getServletRequest();\n    List<MediaType> requestedMediaTypes = getAcceptableMediaTypes(servletRequest);\n    List<MediaType> producibleMediaTypes = getProducibleMediaTypes(servletRequest, returnValueClass);\n    Set<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();\n    for (MediaType r : requestedMediaTypes) {\n        for (MediaType p : producibleMediaTypes) {\n            if (r.isCompatibleWith(p)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(r, p));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n    }\n    List<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType = null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType = mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType != null) {\n        selectedMediaType = selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter<?> messageConverter : messageConverters) {\n            if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                ((HttpMessageConverter<T>) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                }\n                return;\n            }\n        }\n    }\n    throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n}"
    },
    {
      "commit": "f05e2bc56f8e03466977d73a5e99c37651248803",
      "startLine": 3,
      "endLine": 3,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprotected <T> void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n    Class<?> returnValueClass = returnValue.getClass();\n    HttpServletRequest servletRequest = inputMessage.getServletRequest();\n    List<MediaType> requestedMediaTypes = getAcceptableMediaTypes(servletRequest);\n    List<MediaType> producibleMediaTypes = getProducibleMediaTypes(servletRequest, returnValueClass);\n    Set<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();\n    for (MediaType r : requestedMediaTypes) {\n        for (MediaType p : producibleMediaTypes) {\n            if (r.isCompatibleWith(p)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(r, p));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n    }\n    List<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType = null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType = mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    selectedMediaType = selectedMediaType.removeQualityValue();\n    if (selectedMediaType != null) {\n        for (HttpMessageConverter<?> messageConverter : messageConverters) {\n            if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                ((HttpMessageConverter<T>) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                }\n                return;\n            }\n        }\n    }\n    throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n}"
    },
    {
      "commit": "982cb2f258a5be1173115044d379f54702dc8c5b",
      "startLine": 3,
      "endLine": 3,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprotected <T> void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n    Class<?> returnValueClass = returnValue.getClass();\n    List<MediaType> acceptableMediaTypes = getAcceptableMediaTypes(inputMessage);\n    List<MediaType> producibleMediaTypes = getProducibleMediaTypes(inputMessage.getServletRequest(), returnValueClass);\n    Set<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();\n    for (MediaType a : acceptableMediaTypes) {\n        for (MediaType p : producibleMediaTypes) {\n            if (a.isCompatibleWith(p)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(a, p));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n    }\n    List<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType = null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType = mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    selectedMediaType = selectedMediaType.removeQualityValue();\n    if (selectedMediaType != null) {\n        for (HttpMessageConverter<?> messageConverter : messageConverters) {\n            if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                ((HttpMessageConverter<T>) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                }\n                return;\n            }\n        }\n    }\n    throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n}"
    },
    {
      "commit": "02a4473c62d8240837bec297f0a1f3cb67ef8a7b",
      "startLine": 3,
      "endLine": 3,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprotected <T> void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n    Class<?> returnValueClass = returnValue.getClass();\n    List<MediaType> acceptableMediaTypes = getAcceptableMediaTypes(inputMessage);\n    List<MediaType> producibleMediaTypes = getProducibleMediaTypes(inputMessage.getServletRequest(), returnValueClass);\n    Set<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();\n    for (MediaType a : acceptableMediaTypes) {\n        for (MediaType p : producibleMediaTypes) {\n            if (a.isCompatibleWith(p)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(a, p));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n    }\n    List<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);\n    MediaType.sortBySpecificity(mediaTypes);\n    MediaType selectedMediaType = null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType = mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType != null) {\n        for (HttpMessageConverter<?> messageConverter : messageConverters) {\n            if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                ((HttpMessageConverter<T>) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                }\n                return;\n            }\n        }\n    }\n    throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n}"
    },
    {
      "commit": "1c45c51fe10bd3739d4b4c938a288ee3ebbf0f54",
      "startLine": 3,
      "endLine": 3,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprotected <T> void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n    Class<?> returnValueClass = returnValue.getClass();\n    List<MediaType> acceptableMediaTypes = getAcceptableMediaTypes(inputMessage);\n    List<MediaType> producibleMediaTypes = getProducibleMediaTypes(inputMessage.getServletRequest(), returnValueClass);\n    Set<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();\n    for (MediaType a : acceptableMediaTypes) {\n        for (MediaType p : producibleMediaTypes) {\n            if (a.isCompatibleWith(p)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(a, p));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n    }\n    List<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);\n    MediaType.sortBySpecificity(mediaTypes);\n    MediaType selectedMediaType = null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType = mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType != null) {\n        for (HttpMessageConverter<?> messageConverter : messageConverters) {\n            if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                ((HttpMessageConverter<T>) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                }\n                return;\n            }\n        }\n    }\n    throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n}"
    },
    {
      "commit": "c5833b192e3f3a280f8c63a9c45ca96776415a6b",
      "startLine": 3,
      "endLine": 3,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprotected <T> void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n    Class<?> returnValueClass = returnValue.getClass();\n    List<MediaType> acceptableMediaTypes = getAcceptableMediaTypes(inputMessage);\n    List<MediaType> producibleMediaTypes = getProducibleMediaTypes(inputMessage.getServletRequest(), returnValueClass);\n    Set<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();\n    for (MediaType a : acceptableMediaTypes) {\n        for (MediaType p : producibleMediaTypes) {\n            if (a.isCompatibleWith(p)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(a, p));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n    }\n    List<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);\n    MediaType.sortBySpecificity(mediaTypes);\n    MediaType selectedMediaType = null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType = mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType != null) {\n        for (HttpMessageConverter<?> messageConverter : messageConverters) {\n            if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                ((HttpMessageConverter<T>) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                }\n                return;\n            }\n        }\n    }\n    throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n}"
    }
  ]
}