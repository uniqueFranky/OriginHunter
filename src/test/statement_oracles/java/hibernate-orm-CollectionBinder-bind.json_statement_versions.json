{
  "statementVersions": [
    {
      "commit": "f49efc7864ad2809e2cc42ec0185c2b07b8c4b83",
      "startLine": 36,
      "endLine": 55,
      "methodCode": "public void bind() {\n    this.collection = createCollection(propertyHolder.getPersistentClass());\n    String role = StringHelper.qualify(propertyHolder.getPath(), propertyName);\n    LOG.debugf(\"Collection role: %s\", role);\n    collection.setRole(role);\n    collection.setMappedByProperty(mappedBy);\n    if (property.isAnnotationPresent(MapKeyColumn.class) && mapKeyPropertyName != null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    if (explicitType != null) {\n        final TypeDefinition typeDef = buildingContext.getMetadataCollector().getTypeDefinition(explicitType);\n        if (typeDef == null) {\n            collection.setTypeName(explicitType);\n            collection.setTypeParameters(explicitTypeParameters);\n        } else {\n            collection.setTypeName(typeDef.getTypeImplementorClass().getName());\n            collection.setTypeParameters(typeDef.getParameters());\n        }\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    boolean isMappedBy = !BinderHelper.isEmptyAnnotationValue(mappedBy);\n    final OptimisticLock lockAnn = property.getAnnotation(OptimisticLock.class);\n    final boolean includeInOptimisticLockChecks = (lockAnn != null) ? !lockAnn.excluded() : !isMappedBy;\n    collection.setOptimisticLocked(includeInOptimisticLockChecks);\n    Persister persisterAnn = property.getAnnotation(Persister.class);\n    if (persisterAnn != null) {\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    }\n    applySortingAndOrdering(collection);\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert = property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate = property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete = property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll = property.getAnnotation(SQLDeleteAll.class);\n    Loader loader = property.getAnnotation(Loader.class);\n    if (sqlInsert != null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlInsert.check().toString().toLowerCase(Locale.ROOT)));\n    }\n    if (sqlUpdate != null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlUpdate.check().toString().toLowerCase(Locale.ROOT)));\n    }\n    if (sqlDelete != null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDelete.check().toString().toLowerCase(Locale.ROOT)));\n    }\n    if (sqlDeleteAll != null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDeleteAll.check().toString().toLowerCase(Locale.ROOT)));\n    }\n    if (loader != null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    if (isMappedBy && (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) != null)) {\n        String message = \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n        message += StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        throw new AnnotationException(message);\n    }\n    if (!isMappedBy && oneToMany && property.isAnnotationPresent(OnDelete.class) && !property.isAnnotationPresent(JoinColumn.class)) {\n        String message = \"Unidirectional one-to-many associations annotated with @OnDelete must define @JoinColumn: \";\n        message += StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        throw new AnnotationException(message);\n    }\n    collection.setInverse(isMappedBy);\n    if (!oneToMany && isMappedBy) {\n        buildingContext.getMetadataCollector().addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType = getCollectionType();\n    if (inheritanceStatePerClass == null)\n        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n    SecondPass sp = getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, buildingContext);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        buildingContext.getMetadataCollector().addSecondPass(sp, !isMappedBy);\n    } else {\n        buildingContext.getMetadataCollector().addSecondPass(sp, !isMappedBy);\n    }\n    buildingContext.getMetadataCollector().addCollectionBinding(collection);\n    PropertyBinder binder = new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy != null && cascadeStrategy.contains(\"delete-orphan\")) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setLazy(collection.isLazy());\n    final LazyGroup lazyGroupAnnotation = property.getAnnotation(LazyGroup.class);\n    if (lazyGroupAnnotation != null) {\n        binder.setLazyGroup(lazyGroupAnnotation.value());\n    }\n    binder.setAccessType(accessType);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop = binder.makeProperty();\n    if (!declaringClassSet)\n        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n    propertyHolder.addProperty(prop, declaringClass);\n}"
    },
    {
      "commit": "7c2a58861341f1404b4974f1ed9809f40c1da8f6",
      "startLine": 36,
      "endLine": 55,
      "methodCode": "public void bind() {\n    this.collection = createCollection(propertyHolder.getPersistentClass());\n    String role = StringHelper.qualify(propertyHolder.getPath(), propertyName);\n    LOG.debugf(\"Collection role: %s\", role);\n    collection.setRole(role);\n    collection.setMappedByProperty(mappedBy);\n    if (property.isAnnotationPresent(MapKeyColumn.class) && mapKeyPropertyName != null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    if (explicitType != null) {\n        final TypeDefinition typeDef = buildingContext.getMetadataCollector().getTypeDefinition(explicitType);\n        if (typeDef == null) {\n            collection.setTypeName(explicitType);\n            collection.setTypeParameters(explicitTypeParameters);\n        } else {\n            collection.setTypeName(typeDef.getTypeImplementorClass().getName());\n            collection.setTypeParameters(typeDef.getParameters());\n        }\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    boolean isMappedBy = !BinderHelper.isEmptyAnnotationValue(mappedBy);\n    final OptimisticLock lockAnn = property.getAnnotation(OptimisticLock.class);\n    final boolean includeInOptimisticLockChecks = (lockAnn != null) ? !lockAnn.excluded() : !isMappedBy;\n    collection.setOptimisticLocked(includeInOptimisticLockChecks);\n    Persister persisterAnn = property.getAnnotation(Persister.class);\n    if (persisterAnn != null) {\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    }\n    applySortingAndOrdering(collection);\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert = property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate = property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete = property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll = property.getAnnotation(SQLDeleteAll.class);\n    Loader loader = property.getAnnotation(Loader.class);\n    if (sqlInsert != null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlInsert.check().toString().toLowerCase(Locale.ROOT)));\n    }\n    if (sqlUpdate != null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlUpdate.check().toString().toLowerCase(Locale.ROOT)));\n    }\n    if (sqlDelete != null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDelete.check().toString().toLowerCase(Locale.ROOT)));\n    }\n    if (sqlDeleteAll != null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDeleteAll.check().toString().toLowerCase(Locale.ROOT)));\n    }\n    if (loader != null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    if (isMappedBy && (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) != null)) {\n        String message = \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n        message += StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        throw new AnnotationException(message);\n    }\n    if (!isMappedBy && oneToMany && property.isAnnotationPresent(OnDelete.class) && !property.isAnnotationPresent(JoinColumn.class)) {\n        String message = \"Unidirectional one-to-many associations annotated with @OnDelete must define @JoinColumn: \";\n        message += StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        throw new AnnotationException(message);\n    }\n    collection.setInverse(isMappedBy);\n    if (!oneToMany && isMappedBy) {\n        buildingContext.getMetadataCollector().addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType = getCollectionType();\n    if (inheritanceStatePerClass == null)\n        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n    SecondPass sp = getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, buildingContext);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        buildingContext.getMetadataCollector().addSecondPass(sp, !isMappedBy);\n    } else {\n        buildingContext.getMetadataCollector().addSecondPass(sp, !isMappedBy);\n    }\n    buildingContext.getMetadataCollector().addCollectionBinding(collection);\n    PropertyBinder binder = new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy != null && cascadeStrategy.indexOf(\"delete-orphan\") >= 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setLazy(collection.isLazy());\n    final LazyGroup lazyGroupAnnotation = property.getAnnotation(LazyGroup.class);\n    if (lazyGroupAnnotation != null) {\n        binder.setLazyGroup(lazyGroupAnnotation.value());\n    }\n    binder.setAccessType(accessType);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop = binder.makeProperty();\n    if (!declaringClassSet)\n        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n    propertyHolder.addProperty(prop, declaringClass);\n}"
    },
    {
      "commit": "1e44e7420b7af10adc9547a461f02a6d979624f1",
      "startLine": 36,
      "endLine": 55,
      "methodCode": "public void bind() {\n    this.collection = createCollection(propertyHolder.getPersistentClass());\n    String role = StringHelper.qualify(propertyHolder.getPath(), propertyName);\n    LOG.debugf(\"Collection role: %s\", role);\n    collection.setRole(role);\n    collection.setMappedByProperty(mappedBy);\n    if (property.isAnnotationPresent(MapKeyColumn.class) && mapKeyPropertyName != null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    if (explicitType != null) {\n        final TypeDefinition typeDef = buildingContext.getMetadataCollector().getTypeDefinition(explicitType);\n        if (typeDef == null) {\n            collection.setTypeName(explicitType);\n            collection.setTypeParameters(explicitTypeParameters);\n        } else {\n            collection.setTypeName(typeDef.getTypeImplementorClass().getName());\n            collection.setTypeParameters(typeDef.getParameters());\n        }\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    boolean isMappedBy = !BinderHelper.isEmptyAnnotationValue(mappedBy);\n    final OptimisticLock lockAnn = property.getAnnotation(OptimisticLock.class);\n    final boolean includeInOptimisticLockChecks = (lockAnn != null) ? !lockAnn.excluded() : !isMappedBy;\n    collection.setOptimisticLocked(includeInOptimisticLockChecks);\n    Persister persisterAnn = property.getAnnotation(Persister.class);\n    if (persisterAnn != null) {\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    }\n    applySortingAndOrdering(collection);\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert = property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate = property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete = property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll = property.getAnnotation(SQLDeleteAll.class);\n    Loader loader = property.getAnnotation(Loader.class);\n    if (sqlInsert != null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlInsert.check().toString().toLowerCase(Locale.ROOT)));\n    }\n    if (sqlUpdate != null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlUpdate.check().toString().toLowerCase(Locale.ROOT)));\n    }\n    if (sqlDelete != null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDelete.check().toString().toLowerCase(Locale.ROOT)));\n    }\n    if (sqlDeleteAll != null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDeleteAll.check().toString().toLowerCase(Locale.ROOT)));\n    }\n    if (loader != null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    if (isMappedBy && (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) != null)) {\n        String message = \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n        message += StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        throw new AnnotationException(message);\n    }\n    collection.setInverse(isMappedBy);\n    if (!oneToMany && isMappedBy) {\n        buildingContext.getMetadataCollector().addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType = getCollectionType();\n    if (inheritanceStatePerClass == null)\n        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n    SecondPass sp = getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, buildingContext);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        buildingContext.getMetadataCollector().addSecondPass(sp, !isMappedBy);\n    } else {\n        buildingContext.getMetadataCollector().addSecondPass(sp, !isMappedBy);\n    }\n    buildingContext.getMetadataCollector().addCollectionBinding(collection);\n    PropertyBinder binder = new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy != null && cascadeStrategy.indexOf(\"delete-orphan\") >= 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setLazy(collection.isLazy());\n    final LazyGroup lazyGroupAnnotation = property.getAnnotation(LazyGroup.class);\n    if (lazyGroupAnnotation != null) {\n        binder.setLazyGroup(lazyGroupAnnotation.value());\n    }\n    binder.setAccessType(accessType);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop = binder.makeProperty();\n    if (!declaringClassSet)\n        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n    propertyHolder.addProperty(prop, declaringClass);\n}"
    },
    {
      "commit": "1376b12ca9e383ef51c2ec50c88f4ef8a01f01f8",
      "startLine": 36,
      "endLine": 55,
      "methodCode": "public void bind() {\n    this.collection = createCollection(propertyHolder.getPersistentClass());\n    String role = StringHelper.qualify(propertyHolder.getPath(), propertyName);\n    LOG.debugf(\"Collection role: %s\", role);\n    collection.setRole(role);\n    collection.setMappedByProperty(mappedBy);\n    if (property.isAnnotationPresent(MapKeyColumn.class) && mapKeyPropertyName != null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    if (explicitType != null) {\n        final TypeDefinition typeDef = buildingContext.getMetadataCollector().getTypeDefinition(explicitType);\n        if (typeDef == null) {\n            collection.setTypeName(explicitType);\n            collection.setTypeParameters(explicitTypeParameters);\n        } else {\n            collection.setTypeName(typeDef.getTypeImplementorClass().getName());\n            collection.setTypeParameters(typeDef.getParameters());\n        }\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    boolean isMappedBy = !BinderHelper.isEmptyAnnotationValue(mappedBy);\n    final OptimisticLock lockAnn = property.getAnnotation(OptimisticLock.class);\n    final boolean includeInOptimisticLockChecks = (lockAnn != null) ? !lockAnn.excluded() : !isMappedBy;\n    collection.setOptimisticLocked(includeInOptimisticLockChecks);\n    Persister persisterAnn = property.getAnnotation(Persister.class);\n    if (persisterAnn != null) {\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    }\n    applySortingAndOrdering(collection);\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert = property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate = property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete = property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll = property.getAnnotation(SQLDeleteAll.class);\n    Loader loader = property.getAnnotation(Loader.class);\n    if (sqlInsert != null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlInsert.check().toString().toLowerCase(Locale.ROOT)));\n    }\n    if (sqlUpdate != null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlUpdate.check().toString().toLowerCase(Locale.ROOT)));\n    }\n    if (sqlDelete != null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDelete.check().toString().toLowerCase(Locale.ROOT)));\n    }\n    if (sqlDeleteAll != null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDeleteAll.check().toString().toLowerCase(Locale.ROOT)));\n    }\n    if (loader != null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    if (isMappedBy && (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) != null)) {\n        String message = \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n        message += StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        throw new AnnotationException(message);\n    }\n    collection.setInverse(isMappedBy);\n    if (!oneToMany && isMappedBy) {\n        buildingContext.getMetadataCollector().addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType = getCollectionType();\n    if (inheritanceStatePerClass == null)\n        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n    SecondPass sp = getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, buildingContext);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        buildingContext.getMetadataCollector().addSecondPass(sp, !isMappedBy);\n    } else {\n        buildingContext.getMetadataCollector().addSecondPass(sp, !isMappedBy);\n    }\n    buildingContext.getMetadataCollector().addCollectionBinding(collection);\n    PropertyBinder binder = new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy != null && cascadeStrategy.indexOf(\"delete-orphan\") >= 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setLazy(collection.isLazy());\n    binder.setAccessType(accessType);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop = binder.makeProperty();\n    if (!declaringClassSet)\n        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n    propertyHolder.addProperty(prop, declaringClass);\n}"
    },
    {
      "commit": "c6fa2b1df18ce0a6ad8e99f4c7b964ce84cda050",
      "startLine": 37,
      "endLine": 56,
      "methodCode": "public void bind() {\n    this.collection = createCollection(propertyHolder.getPersistentClass());\n    String role = StringHelper.qualify(propertyHolder.getPath(), propertyName);\n    LOG.debugf(\"Collection role: %s\", role);\n    collection.setRole(role);\n    collection.setNodeName(propertyName);\n    collection.setMappedByProperty(mappedBy);\n    if (property.isAnnotationPresent(MapKeyColumn.class) && mapKeyPropertyName != null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    if (explicitType != null) {\n        final TypeDefinition typeDef = buildingContext.getMetadataCollector().getTypeDefinition(explicitType);\n        if (typeDef == null) {\n            collection.setTypeName(explicitType);\n            collection.setTypeParameters(explicitTypeParameters);\n        } else {\n            collection.setTypeName(typeDef.getTypeImplementorClass().getName());\n            collection.setTypeParameters(typeDef.getParameters());\n        }\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    boolean isMappedBy = !BinderHelper.isEmptyAnnotationValue(mappedBy);\n    final OptimisticLock lockAnn = property.getAnnotation(OptimisticLock.class);\n    final boolean includeInOptimisticLockChecks = (lockAnn != null) ? !lockAnn.excluded() : !isMappedBy;\n    collection.setOptimisticLocked(includeInOptimisticLockChecks);\n    Persister persisterAnn = property.getAnnotation(Persister.class);\n    if (persisterAnn != null) {\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    }\n    applySortingAndOrdering(collection);\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert = property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate = property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete = property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll = property.getAnnotation(SQLDeleteAll.class);\n    Loader loader = property.getAnnotation(Loader.class);\n    if (sqlInsert != null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlInsert.check().toString().toLowerCase(Locale.ROOT)));\n    }\n    if (sqlUpdate != null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlUpdate.check().toString().toLowerCase(Locale.ROOT)));\n    }\n    if (sqlDelete != null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDelete.check().toString().toLowerCase(Locale.ROOT)));\n    }\n    if (sqlDeleteAll != null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDeleteAll.check().toString().toLowerCase(Locale.ROOT)));\n    }\n    if (loader != null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    if (isMappedBy && (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) != null)) {\n        String message = \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n        message += StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        throw new AnnotationException(message);\n    }\n    collection.setInverse(isMappedBy);\n    if (!oneToMany && isMappedBy) {\n        buildingContext.getMetadataCollector().addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType = getCollectionType();\n    if (inheritanceStatePerClass == null)\n        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n    SecondPass sp = getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, buildingContext);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        buildingContext.getMetadataCollector().addSecondPass(sp, !isMappedBy);\n    } else {\n        buildingContext.getMetadataCollector().addSecondPass(sp, !isMappedBy);\n    }\n    buildingContext.getMetadataCollector().addCollectionBinding(collection);\n    PropertyBinder binder = new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy != null && cascadeStrategy.indexOf(\"delete-orphan\") >= 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setLazy(collection.isLazy());\n    binder.setAccessType(accessType);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop = binder.makeProperty();\n    if (!declaringClassSet)\n        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n    propertyHolder.addProperty(prop, declaringClass);\n}"
    },
    {
      "commit": "1361925bc73a539bd6bd5d4a93de162e4a5b332b",
      "startLine": 37,
      "endLine": 56,
      "methodCode": "public void bind() {\n    this.collection = createCollection(propertyHolder.getPersistentClass());\n    String role = StringHelper.qualify(propertyHolder.getPath(), propertyName);\n    LOG.debugf(\"Collection role: %s\", role);\n    collection.setRole(role);\n    collection.setNodeName(propertyName);\n    collection.setMappedByProperty(mappedBy);\n    if (property.isAnnotationPresent(MapKeyColumn.class) && mapKeyPropertyName != null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    if (explicitType != null) {\n        final TypeDefinition typeDef = buildingContext.getMetadataCollector().getTypeDefinition(explicitType);\n        if (typeDef == null) {\n            collection.setTypeName(explicitType);\n            collection.setTypeParameters(explicitTypeParameters);\n        } else {\n            collection.setTypeName(typeDef.getTypeImplementorClass().getName());\n            collection.setTypeParameters(typeDef.getParameters());\n        }\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    boolean isMappedBy = !BinderHelper.isEmptyAnnotationValue(mappedBy);\n    final OptimisticLock lockAnn = property.getAnnotation(OptimisticLock.class);\n    final boolean includeInOptimisticLockChecks = (lockAnn != null) ? !lockAnn.excluded() : !isMappedBy;\n    collection.setOptimisticLocked(includeInOptimisticLockChecks);\n    Persister persisterAnn = property.getAnnotation(Persister.class);\n    if (persisterAnn != null) {\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    }\n    applySortingAndOrdering(collection);\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert = property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate = property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete = property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll = property.getAnnotation(SQLDeleteAll.class);\n    Loader loader = property.getAnnotation(Loader.class);\n    if (sqlInsert != null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlInsert.check().toString().toLowerCase(Locale.ROOT)));\n    }\n    if (sqlUpdate != null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlUpdate.check().toString().toLowerCase(Locale.ROOT)));\n    }\n    if (sqlDelete != null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDelete.check().toString().toLowerCase(Locale.ROOT)));\n    }\n    if (sqlDeleteAll != null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDeleteAll.check().toString().toLowerCase(Locale.ROOT)));\n    }\n    if (loader != null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    if (isMappedBy && (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) != null)) {\n        String message = \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n        message += StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        throw new AnnotationException(message);\n    }\n    collection.setInverse(isMappedBy);\n    if (!oneToMany && isMappedBy) {\n        buildingContext.getMetadataCollector().addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType = getCollectionType();\n    if (inheritanceStatePerClass == null)\n        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n    SecondPass sp = getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, buildingContext);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        buildingContext.getMetadataCollector().addSecondPass(sp, !isMappedBy);\n    } else {\n        buildingContext.getMetadataCollector().addSecondPass(sp, !isMappedBy);\n    }\n    buildingContext.getMetadataCollector().addCollectionBinding(collection);\n    PropertyBinder binder = new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy != null && cascadeStrategy.indexOf(\"delete-orphan\") >= 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setAccessType(accessType);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop = binder.makeProperty();\n    if (!declaringClassSet)\n        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n    propertyHolder.addProperty(prop, declaringClass);\n}"
    },
    {
      "commit": "9caca0ce37d5a2763d476c6fa2471addcca710ca",
      "startLine": 37,
      "endLine": 56,
      "methodCode": "public void bind() {\n    this.collection = createCollection(propertyHolder.getPersistentClass());\n    String role = StringHelper.qualify(propertyHolder.getPath(), propertyName);\n    LOG.debugf(\"Collection role: %s\", role);\n    collection.setRole(role);\n    collection.setNodeName(propertyName);\n    collection.setMappedByProperty(mappedBy);\n    if (property.isAnnotationPresent(MapKeyColumn.class) && mapKeyPropertyName != null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    if (explicitType != null) {\n        final TypeDefinition typeDef = buildingContext.getMetadataCollector().getTypeDefinition(explicitType);\n        if (typeDef == null) {\n            collection.setTypeName(explicitType);\n            collection.setTypeParameters(explicitTypeParameters);\n        } else {\n            collection.setTypeName(typeDef.getTypeImplementorClass().getName());\n            collection.setTypeParameters(typeDef.getParameters());\n        }\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    boolean isMappedBy = !BinderHelper.isEmptyAnnotationValue(mappedBy);\n    final OptimisticLock lockAnn = property.getAnnotation(OptimisticLock.class);\n    final boolean includeInOptimisticLockChecks = (lockAnn != null) ? !lockAnn.excluded() : !isMappedBy;\n    collection.setOptimisticLocked(includeInOptimisticLockChecks);\n    Persister persisterAnn = property.getAnnotation(Persister.class);\n    if (persisterAnn != null) {\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    }\n    applySortingAndOrdering(collection);\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert = property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate = property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete = property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll = property.getAnnotation(SQLDeleteAll.class);\n    Loader loader = property.getAnnotation(Loader.class);\n    if (sqlInsert != null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlInsert.check().toString().toLowerCase()));\n    }\n    if (sqlUpdate != null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlUpdate.check().toString().toLowerCase()));\n    }\n    if (sqlDelete != null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDelete.check().toString().toLowerCase()));\n    }\n    if (sqlDeleteAll != null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDeleteAll.check().toString().toLowerCase()));\n    }\n    if (loader != null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    if (isMappedBy && (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) != null)) {\n        String message = \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n        message += StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        throw new AnnotationException(message);\n    }\n    collection.setInverse(isMappedBy);\n    if (!oneToMany && isMappedBy) {\n        buildingContext.getMetadataCollector().addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType = getCollectionType();\n    if (inheritanceStatePerClass == null)\n        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n    SecondPass sp = getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, buildingContext);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        buildingContext.getMetadataCollector().addSecondPass(sp, !isMappedBy);\n    } else {\n        buildingContext.getMetadataCollector().addSecondPass(sp, !isMappedBy);\n    }\n    buildingContext.getMetadataCollector().addCollectionBinding(collection);\n    PropertyBinder binder = new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy != null && cascadeStrategy.indexOf(\"delete-orphan\") >= 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setAccessType(accessType);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop = binder.makeProperty();\n    if (!declaringClassSet)\n        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n    propertyHolder.addProperty(prop, declaringClass);\n}"
    },
    {
      "commit": "bcd6185809ecf9202267134d646037e8acdd0939",
      "startLine": 37,
      "endLine": 56,
      "methodCode": "public void bind() {\n    this.collection = createCollection(propertyHolder.getPersistentClass());\n    String role = StringHelper.qualify(propertyHolder.getPath(), propertyName);\n    LOG.debugf(\"Collection role: %s\", role);\n    collection.setRole(role);\n    collection.setNodeName(propertyName);\n    collection.setMappedByProperty(mappedBy);\n    if (property.isAnnotationPresent(MapKeyColumn.class) && mapKeyPropertyName != null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    if (explicitType != null) {\n        final TypeDef typeDef = mappings.getTypeDef(explicitType);\n        if (typeDef == null) {\n            collection.setTypeName(explicitType);\n            collection.setTypeParameters(explicitTypeParameters);\n        } else {\n            collection.setTypeName(typeDef.getTypeClass());\n            collection.setTypeParameters(typeDef.getParameters());\n        }\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    boolean isMappedBy = !BinderHelper.isEmptyAnnotationValue(mappedBy);\n    final OptimisticLock lockAnn = property.getAnnotation(OptimisticLock.class);\n    final boolean includeInOptimisticLockChecks = (lockAnn != null) ? !lockAnn.excluded() : !isMappedBy;\n    collection.setOptimisticLocked(includeInOptimisticLockChecks);\n    Persister persisterAnn = property.getAnnotation(Persister.class);\n    if (persisterAnn != null) {\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    }\n    applySortingAndOrdering(collection);\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert = property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate = property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete = property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll = property.getAnnotation(SQLDeleteAll.class);\n    Loader loader = property.getAnnotation(Loader.class);\n    if (sqlInsert != null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlInsert.check().toString().toLowerCase()));\n    }\n    if (sqlUpdate != null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlUpdate.check().toString().toLowerCase()));\n    }\n    if (sqlDelete != null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDelete.check().toString().toLowerCase()));\n    }\n    if (sqlDeleteAll != null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDeleteAll.check().toString().toLowerCase()));\n    }\n    if (loader != null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    if (isMappedBy && (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) != null)) {\n        String message = \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n        message += StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        throw new AnnotationException(message);\n    }\n    collection.setInverse(isMappedBy);\n    if (!oneToMany && isMappedBy) {\n        mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType = getCollectionType();\n    if (inheritanceStatePerClass == null)\n        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n    SecondPass sp = getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        mappings.addSecondPass(sp, !isMappedBy);\n    } else {\n        mappings.addSecondPass(sp, !isMappedBy);\n    }\n    mappings.addCollection(collection);\n    PropertyBinder binder = new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy != null && cascadeStrategy.indexOf(\"delete-orphan\") >= 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setAccessType(accessType);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop = binder.makeProperty();\n    if (!declaringClassSet)\n        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n    propertyHolder.addProperty(prop, declaringClass);\n}"
    },
    {
      "commit": "33640ae2bdd37a0102e21f5a3ff8a47f0d6361b5",
      "startLine": 36,
      "endLine": 55,
      "methodCode": "public void bind() {\n    this.collection = createCollection(propertyHolder.getPersistentClass());\n    String role = StringHelper.qualify(propertyHolder.getPath(), propertyName);\n    LOG.debugf(\"Collection role: %s\", role);\n    collection.setRole(role);\n    collection.setNodeName(propertyName);\n    if (property.isAnnotationPresent(MapKeyColumn.class) && mapKeyPropertyName != null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    if (explicitType != null) {\n        final TypeDef typeDef = mappings.getTypeDef(explicitType);\n        if (typeDef == null) {\n            collection.setTypeName(explicitType);\n            collection.setTypeParameters(explicitTypeParameters);\n        } else {\n            collection.setTypeName(typeDef.getTypeClass());\n            collection.setTypeParameters(typeDef.getParameters());\n        }\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    boolean isMappedBy = !BinderHelper.isEmptyAnnotationValue(mappedBy);\n    final OptimisticLock lockAnn = property.getAnnotation(OptimisticLock.class);\n    final boolean includeInOptimisticLockChecks = (lockAnn != null) ? !lockAnn.excluded() : !isMappedBy;\n    collection.setOptimisticLocked(includeInOptimisticLockChecks);\n    Persister persisterAnn = property.getAnnotation(Persister.class);\n    if (persisterAnn != null) {\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    }\n    applySortingAndOrdering(collection);\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert = property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate = property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete = property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll = property.getAnnotation(SQLDeleteAll.class);\n    Loader loader = property.getAnnotation(Loader.class);\n    if (sqlInsert != null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlInsert.check().toString().toLowerCase()));\n    }\n    if (sqlUpdate != null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlUpdate.check().toString().toLowerCase()));\n    }\n    if (sqlDelete != null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDelete.check().toString().toLowerCase()));\n    }\n    if (sqlDeleteAll != null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDeleteAll.check().toString().toLowerCase()));\n    }\n    if (loader != null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    if (isMappedBy && (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) != null)) {\n        String message = \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n        message += StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        throw new AnnotationException(message);\n    }\n    collection.setInverse(isMappedBy);\n    if (!oneToMany && isMappedBy) {\n        mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType = getCollectionType();\n    if (inheritanceStatePerClass == null)\n        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n    SecondPass sp = getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        mappings.addSecondPass(sp, !isMappedBy);\n    } else {\n        mappings.addSecondPass(sp, !isMappedBy);\n    }\n    mappings.addCollection(collection);\n    PropertyBinder binder = new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy != null && cascadeStrategy.indexOf(\"delete-orphan\") >= 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setAccessType(accessType);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop = binder.makeProperty();\n    if (!declaringClassSet)\n        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n    propertyHolder.addProperty(prop, declaringClass);\n}"
    },
    {
      "commit": "05c36793730fb1b4e3d08c731998c7649c9b34ef",
      "startLine": 56,
      "endLine": 75,
      "methodCode": "public void bind() {\n    this.collection = createCollection(propertyHolder.getPersistentClass());\n    String role = StringHelper.qualify(propertyHolder.getPath(), propertyName);\n    LOG.debugf(\"Collection role: %s\", role);\n    collection.setRole(role);\n    collection.setNodeName(propertyName);\n    if (property.isAnnotationPresent(MapKeyColumn.class) && mapKeyPropertyName != null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    if (explicitType != null) {\n        final TypeDef typeDef = mappings.getTypeDef(explicitType);\n        if (typeDef == null) {\n            collection.setTypeName(explicitType);\n            collection.setTypeParameters(explicitTypeParameters);\n        } else {\n            collection.setTypeName(typeDef.getTypeClass());\n            collection.setTypeParameters(typeDef.getParameters());\n        }\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    if (orderBy != null && hqlOrderBy != null) {\n        throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n    }\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    boolean isMappedBy = !BinderHelper.isEmptyAnnotationValue(mappedBy);\n    final OptimisticLock lockAnn = property.getAnnotation(OptimisticLock.class);\n    final boolean includeInOptimisticLockChecks = (lockAnn != null) ? !lockAnn.excluded() : !isMappedBy;\n    collection.setOptimisticLocked(includeInOptimisticLockChecks);\n    Persister persisterAnn = property.getAnnotation(Persister.class);\n    if (persisterAnn != null) {\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    }\n    if (orderBy != null)\n        collection.setOrderBy(orderBy);\n    if (isSorted) {\n        collection.setSorted(true);\n        if (comparator != null) {\n            try {\n                collection.setComparator((Comparator) comparator.newInstance());\n            } catch (ClassCastException e) {\n                throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            } catch (Exception e) {\n                throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            }\n        }\n    } else {\n        if (hasToBeSorted) {\n            throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n        }\n    }\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert = property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate = property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete = property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll = property.getAnnotation(SQLDeleteAll.class);\n    Loader loader = property.getAnnotation(Loader.class);\n    if (sqlInsert != null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlInsert.check().toString().toLowerCase()));\n    }\n    if (sqlUpdate != null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlUpdate.check().toString().toLowerCase()));\n    }\n    if (sqlDelete != null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDelete.check().toString().toLowerCase()));\n    }\n    if (sqlDeleteAll != null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDeleteAll.check().toString().toLowerCase()));\n    }\n    if (loader != null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    if (isMappedBy && (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) != null)) {\n        String message = \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n        message += StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        throw new AnnotationException(message);\n    }\n    collection.setInverse(isMappedBy);\n    if (!oneToMany && isMappedBy) {\n        mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType = getCollectionType();\n    if (inheritanceStatePerClass == null)\n        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n    SecondPass sp = getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        mappings.addSecondPass(sp, !isMappedBy);\n    } else {\n        mappings.addSecondPass(sp, !isMappedBy);\n    }\n    mappings.addCollection(collection);\n    PropertyBinder binder = new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy != null && cascadeStrategy.indexOf(\"delete-orphan\") >= 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setAccessType(accessType);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop = binder.makeProperty();\n    if (!declaringClassSet)\n        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n    propertyHolder.addProperty(prop, declaringClass);\n}"
    },
    {
      "commit": "d7d9f0dfb207cb8238ea2962fee81708942fa368",
      "startLine": 55,
      "endLine": 74,
      "methodCode": "public void bind() {\n    this.collection = createCollection(propertyHolder.getPersistentClass());\n    String role = StringHelper.qualify(propertyHolder.getPath(), propertyName);\n    LOG.debugf(\"Collection role: %s\", role);\n    collection.setRole(role);\n    collection.setNodeName(propertyName);\n    if (property.isAnnotationPresent(MapKeyColumn.class) && mapKeyPropertyName != null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    if (explicitType != null) {\n        final TypeDef typeDef = mappings.getTypeDef(explicitType);\n        if (typeDef == null) {\n            collection.setTypeName(explicitType);\n            collection.setTypeParameters(explicitTypeParameters);\n        } else {\n            collection.setTypeName(typeDef.getTypeClass());\n            collection.setTypeParameters(typeDef.getParameters());\n        }\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    if (orderBy != null && hqlOrderBy != null) {\n        throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n    }\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    OptimisticLock lockAnn = property.getAnnotation(OptimisticLock.class);\n    if (lockAnn != null)\n        collection.setOptimisticLocked(!lockAnn.excluded());\n    Persister persisterAnn = property.getAnnotation(Persister.class);\n    if (persisterAnn != null) {\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    }\n    if (orderBy != null)\n        collection.setOrderBy(orderBy);\n    if (isSorted) {\n        collection.setSorted(true);\n        if (comparator != null) {\n            try {\n                collection.setComparator((Comparator) comparator.newInstance());\n            } catch (ClassCastException e) {\n                throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            } catch (Exception e) {\n                throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            }\n        }\n    } else {\n        if (hasToBeSorted) {\n            throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n        }\n    }\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert = property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate = property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete = property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll = property.getAnnotation(SQLDeleteAll.class);\n    Loader loader = property.getAnnotation(Loader.class);\n    if (sqlInsert != null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlInsert.check().toString().toLowerCase()));\n    }\n    if (sqlUpdate != null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlUpdate.check().toString().toLowerCase()));\n    }\n    if (sqlDelete != null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDelete.check().toString().toLowerCase()));\n    }\n    if (sqlDeleteAll != null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDeleteAll.check().toString().toLowerCase()));\n    }\n    if (loader != null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    boolean isMappedBy = !BinderHelper.isEmptyAnnotationValue(mappedBy);\n    if (isMappedBy && (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) != null)) {\n        String message = \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n        message += StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        throw new AnnotationException(message);\n    }\n    collection.setInverse(isMappedBy);\n    if (!oneToMany && isMappedBy) {\n        mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType = getCollectionType();\n    if (inheritanceStatePerClass == null)\n        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n    SecondPass sp = getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        mappings.addSecondPass(sp, !isMappedBy);\n    } else {\n        mappings.addSecondPass(sp, !isMappedBy);\n    }\n    mappings.addCollection(collection);\n    PropertyBinder binder = new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy != null && cascadeStrategy.indexOf(\"delete-orphan\") >= 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setAccessType(accessType);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop = binder.makeProperty();\n    if (!declaringClassSet)\n        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n    propertyHolder.addProperty(prop, declaringClass);\n}"
    },
    {
      "commit": "ffb14b28b72c67dc2d658bfeb89545ca16eb3399",
      "startLine": 45,
      "endLine": 64,
      "methodCode": "public void bind() {\n    this.collection = createCollection(propertyHolder.getPersistentClass());\n    String role = StringHelper.qualify(propertyHolder.getPath(), propertyName);\n    LOG.debugf(\"Collection role: %s\", role);\n    collection.setRole(role);\n    collection.setNodeName(propertyName);\n    if (property.isAnnotationPresent(MapKeyColumn.class) && mapKeyPropertyName != null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    if (orderBy != null && hqlOrderBy != null) {\n        throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n    }\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    OptimisticLock lockAnn = property.getAnnotation(OptimisticLock.class);\n    if (lockAnn != null)\n        collection.setOptimisticLocked(!lockAnn.excluded());\n    Persister persisterAnn = property.getAnnotation(Persister.class);\n    if (persisterAnn != null) {\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    }\n    if (orderBy != null)\n        collection.setOrderBy(orderBy);\n    if (isSorted) {\n        collection.setSorted(true);\n        if (comparator != null) {\n            try {\n                collection.setComparator((Comparator) comparator.newInstance());\n            } catch (ClassCastException e) {\n                throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            } catch (Exception e) {\n                throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            }\n        }\n    } else {\n        if (hasToBeSorted) {\n            throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n        }\n    }\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert = property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate = property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete = property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll = property.getAnnotation(SQLDeleteAll.class);\n    Loader loader = property.getAnnotation(Loader.class);\n    if (sqlInsert != null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlInsert.check().toString().toLowerCase()));\n    }\n    if (sqlUpdate != null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlUpdate.check().toString().toLowerCase()));\n    }\n    if (sqlDelete != null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDelete.check().toString().toLowerCase()));\n    }\n    if (sqlDeleteAll != null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDeleteAll.check().toString().toLowerCase()));\n    }\n    if (loader != null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    boolean isMappedBy = !BinderHelper.isEmptyAnnotationValue(mappedBy);\n    if (isMappedBy && (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) != null)) {\n        String message = \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n        message += StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        throw new AnnotationException(message);\n    }\n    collection.setInverse(isMappedBy);\n    if (!oneToMany && isMappedBy) {\n        mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType = getCollectionType();\n    if (inheritanceStatePerClass == null)\n        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n    SecondPass sp = getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        mappings.addSecondPass(sp, !isMappedBy);\n    } else {\n        mappings.addSecondPass(sp, !isMappedBy);\n    }\n    mappings.addCollection(collection);\n    PropertyBinder binder = new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy != null && cascadeStrategy.indexOf(\"delete-orphan\") >= 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setAccessType(accessType);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop = binder.makeProperty();\n    if (!declaringClassSet)\n        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n    propertyHolder.addProperty(prop, declaringClass);\n}"
    },
    {
      "commit": "fb44ad936d8d54d311ecbaea1633683a8d809d04",
      "startLine": 45,
      "endLine": 64,
      "methodCode": "public void bind() {\n    this.collection = createCollection(propertyHolder.getPersistentClass());\n    String role = StringHelper.qualify(propertyHolder.getPath(), propertyName);\n    LOG.debugf(\"Collection role: %s\", role);\n    collection.setRole(role);\n    collection.setNodeName(propertyName);\n    if ((property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) || property.isAnnotationPresent(MapKeyColumn.class)) && mapKeyPropertyName != null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    if (orderBy != null && hqlOrderBy != null) {\n        throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n    }\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    OptimisticLock lockAnn = property.getAnnotation(OptimisticLock.class);\n    if (lockAnn != null)\n        collection.setOptimisticLocked(!lockAnn.excluded());\n    Persister persisterAnn = property.getAnnotation(Persister.class);\n    if (persisterAnn != null) {\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    }\n    if (orderBy != null)\n        collection.setOrderBy(orderBy);\n    if (isSorted) {\n        collection.setSorted(true);\n        if (comparator != null) {\n            try {\n                collection.setComparator((Comparator) comparator.newInstance());\n            } catch (ClassCastException e) {\n                throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            } catch (Exception e) {\n                throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            }\n        }\n    } else {\n        if (hasToBeSorted) {\n            throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n        }\n    }\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert = property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate = property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete = property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll = property.getAnnotation(SQLDeleteAll.class);\n    Loader loader = property.getAnnotation(Loader.class);\n    if (sqlInsert != null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlInsert.check().toString().toLowerCase()));\n    }\n    if (sqlUpdate != null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlUpdate.check().toString().toLowerCase()));\n    }\n    if (sqlDelete != null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDelete.check().toString().toLowerCase()));\n    }\n    if (sqlDeleteAll != null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.fromExternalName(sqlDeleteAll.check().toString().toLowerCase()));\n    }\n    if (loader != null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    boolean isMappedBy = !BinderHelper.isEmptyAnnotationValue(mappedBy);\n    if (isMappedBy && (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) != null)) {\n        String message = \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n        message += StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        throw new AnnotationException(message);\n    }\n    collection.setInverse(isMappedBy);\n    if (!oneToMany && isMappedBy) {\n        mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType = getCollectionType();\n    if (inheritanceStatePerClass == null)\n        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n    SecondPass sp = getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        mappings.addSecondPass(sp, !isMappedBy);\n    } else {\n        mappings.addSecondPass(sp, !isMappedBy);\n    }\n    mappings.addCollection(collection);\n    PropertyBinder binder = new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy != null && cascadeStrategy.indexOf(\"delete-orphan\") >= 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setAccessType(accessType);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop = binder.makeProperty();\n    if (!declaringClassSet)\n        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n    propertyHolder.addProperty(prop, declaringClass);\n}"
    },
    {
      "commit": "ddfcc44d760938578771cb6ce24c809c980c8b8b",
      "startLine": 44,
      "endLine": 63,
      "methodCode": "public void bind() {\n    this.collection = createCollection(propertyHolder.getPersistentClass());\n    log.debug(\"Collection role: {}\", StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setRole(StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setNodeName(propertyName);\n    if ((property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) || property.isAnnotationPresent(MapKeyColumn.class)) && mapKeyPropertyName != null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    if (orderBy != null && hqlOrderBy != null) {\n        throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n    }\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    OptimisticLock lockAnn = property.getAnnotation(OptimisticLock.class);\n    if (lockAnn != null)\n        collection.setOptimisticLocked(!lockAnn.excluded());\n    Persister persisterAnn = property.getAnnotation(Persister.class);\n    if (persisterAnn != null) {\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    }\n    if (orderBy != null)\n        collection.setOrderBy(orderBy);\n    if (isSorted) {\n        collection.setSorted(true);\n        if (comparator != null) {\n            try {\n                collection.setComparator((Comparator) comparator.newInstance());\n            } catch (ClassCastException e) {\n                throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            } catch (Exception e) {\n                throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            }\n        }\n    } else {\n        if (hasToBeSorted) {\n            throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n        }\n    }\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert = property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate = property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete = property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll = property.getAnnotation(SQLDeleteAll.class);\n    Loader loader = property.getAnnotation(Loader.class);\n    if (sqlInsert != null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.parse(sqlInsert.check().toString().toLowerCase()));\n    }\n    if (sqlUpdate != null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.parse(sqlUpdate.check().toString().toLowerCase()));\n    }\n    if (sqlDelete != null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDelete.check().toString().toLowerCase()));\n    }\n    if (sqlDeleteAll != null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDeleteAll.check().toString().toLowerCase()));\n    }\n    if (loader != null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    boolean isMappedBy = !BinderHelper.isEmptyAnnotationValue(mappedBy);\n    if (isMappedBy && (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) != null)) {\n        String message = \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n        message += StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        throw new AnnotationException(message);\n    }\n    collection.setInverse(isMappedBy);\n    if (!oneToMany && isMappedBy) {\n        mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType = getCollectionType();\n    if (inheritanceStatePerClass == null)\n        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n    SecondPass sp = getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        mappings.addSecondPass(sp, !isMappedBy);\n    } else {\n        mappings.addSecondPass(sp, !isMappedBy);\n    }\n    mappings.addCollection(collection);\n    PropertyBinder binder = new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy != null && cascadeStrategy.indexOf(\"delete-orphan\") >= 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setAccessType(accessType);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop = binder.makeProperty();\n    if (!declaringClassSet)\n        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n    propertyHolder.addProperty(prop, declaringClass);\n}"
    },
    {
      "commit": "4ffba763cf6645e722a2deeea552f998ec7dc22a",
      "startLine": 53,
      "endLine": 72,
      "methodCode": "public void bind() {\n    this.collection = createCollection(propertyHolder.getPersistentClass());\n    String role = StringHelper.qualify(propertyHolder.getPath(), propertyName);\n    LOG.debugf(\"Collection role: %s\", role);\n    collection.setRole(role);\n    collection.setNodeName(propertyName);\n    if ((property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) || property.isAnnotationPresent(MapKeyColumn.class)) && mapKeyPropertyName != null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    if (orderBy != null && hqlOrderBy != null) {\n        throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n    }\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    OptimisticLock lockAnn = property.getAnnotation(OptimisticLock.class);\n    if (lockAnn != null)\n        collection.setOptimisticLocked(!lockAnn.excluded());\n    Persister persisterAnn = property.getAnnotation(Persister.class);\n    if (persisterAnn != null) {\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    } else {\n        final PersisterClassProvider persisterClassProvider = mappings.getPersisterClassProvider();\n        if (persisterClassProvider != null) {\n            final Class<? extends CollectionPersister> persister = persisterClassProvider.getCollectionPersisterClass(collection.getRole());\n            if (persister != null) {\n                collection.setCollectionPersisterClass(persister);\n            }\n        }\n    }\n    if (orderBy != null)\n        collection.setOrderBy(orderBy);\n    if (isSorted) {\n        collection.setSorted(true);\n        if (comparator != null) {\n            try {\n                collection.setComparator((Comparator) comparator.newInstance());\n            } catch (ClassCastException e) {\n                throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            } catch (Exception e) {\n                throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            }\n        }\n    } else {\n        if (hasToBeSorted) {\n            throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n        }\n    }\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert = property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate = property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete = property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll = property.getAnnotation(SQLDeleteAll.class);\n    Loader loader = property.getAnnotation(Loader.class);\n    if (sqlInsert != null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.parse(sqlInsert.check().toString().toLowerCase()));\n    }\n    if (sqlUpdate != null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.parse(sqlUpdate.check().toString().toLowerCase()));\n    }\n    if (sqlDelete != null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDelete.check().toString().toLowerCase()));\n    }\n    if (sqlDeleteAll != null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDeleteAll.check().toString().toLowerCase()));\n    }\n    if (loader != null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    boolean isMappedBy = !BinderHelper.isEmptyAnnotationValue(mappedBy);\n    if (isMappedBy && (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) != null)) {\n        String message = \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n        message += StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        throw new AnnotationException(message);\n    }\n    collection.setInverse(isMappedBy);\n    if (!oneToMany && isMappedBy) {\n        mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType = getCollectionType();\n    if (inheritanceStatePerClass == null)\n        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n    SecondPass sp = getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        mappings.addSecondPass(sp, !isMappedBy);\n    } else {\n        mappings.addSecondPass(sp, !isMappedBy);\n    }\n    mappings.addCollection(collection);\n    PropertyBinder binder = new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy != null && cascadeStrategy.indexOf(\"delete-orphan\") >= 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setAccessType(accessType);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop = binder.makeProperty();\n    if (!declaringClassSet)\n        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n    propertyHolder.addProperty(prop, declaringClass);\n}"
    },
    {
      "commit": "e18799b03611ef8dc37690585de984f63b35bc34",
      "startLine": 52,
      "endLine": 71,
      "methodCode": "public void bind() {\n    this.collection = createCollection(propertyHolder.getPersistentClass());\n    log.debug(\"Collection role: {}\", StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setRole(StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setNodeName(propertyName);\n    if ((property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) || property.isAnnotationPresent(MapKeyColumn.class)) && mapKeyPropertyName != null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    if (orderBy != null && hqlOrderBy != null) {\n        throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n    }\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    OptimisticLock lockAnn = property.getAnnotation(OptimisticLock.class);\n    if (lockAnn != null)\n        collection.setOptimisticLocked(!lockAnn.excluded());\n    Persister persisterAnn = property.getAnnotation(Persister.class);\n    if (persisterAnn != null) {\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    } else {\n        final PersisterClassProvider persisterClassProvider = mappings.getPersisterClassProvider();\n        if (persisterClassProvider != null) {\n            final Class<? extends CollectionPersister> persister = persisterClassProvider.getCollectionPersisterClass(collection.getRole());\n            if (persister != null) {\n                collection.setCollectionPersisterClass(persister);\n            }\n        }\n    }\n    if (orderBy != null)\n        collection.setOrderBy(orderBy);\n    if (isSorted) {\n        collection.setSorted(true);\n        if (comparator != null) {\n            try {\n                collection.setComparator((Comparator) comparator.newInstance());\n            } catch (ClassCastException e) {\n                throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            } catch (Exception e) {\n                throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            }\n        }\n    } else {\n        if (hasToBeSorted) {\n            throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n        }\n    }\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert = property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate = property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete = property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll = property.getAnnotation(SQLDeleteAll.class);\n    Loader loader = property.getAnnotation(Loader.class);\n    if (sqlInsert != null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.parse(sqlInsert.check().toString().toLowerCase()));\n    }\n    if (sqlUpdate != null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.parse(sqlUpdate.check().toString().toLowerCase()));\n    }\n    if (sqlDelete != null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDelete.check().toString().toLowerCase()));\n    }\n    if (sqlDeleteAll != null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDeleteAll.check().toString().toLowerCase()));\n    }\n    if (loader != null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    boolean isMappedBy = !BinderHelper.isEmptyAnnotationValue(mappedBy);\n    if (isMappedBy && (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) != null)) {\n        String message = \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n        message += StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        throw new AnnotationException(message);\n    }\n    collection.setInverse(isMappedBy);\n    if (!oneToMany && isMappedBy) {\n        mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType = getCollectionType();\n    if (inheritanceStatePerClass == null)\n        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n    SecondPass sp = getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        mappings.addSecondPass(sp, !isMappedBy);\n    } else {\n        mappings.addSecondPass(sp, !isMappedBy);\n    }\n    mappings.addCollection(collection);\n    PropertyBinder binder = new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy != null && cascadeStrategy.indexOf(\"delete-orphan\") >= 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setAccessType(accessType);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop = binder.makeProperty();\n    if (!declaringClassSet)\n        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n    propertyHolder.addProperty(prop, declaringClass);\n}"
    },
    {
      "commit": "8c806d361d63764e8523006944dde52aff70532c",
      "startLine": 44,
      "endLine": 63,
      "methodCode": "public void bind() {\n    this.collection = createCollection(propertyHolder.getPersistentClass());\n    String role = StringHelper.qualify(propertyHolder.getPath(), propertyName);\n    LOG.debugf(\"Collection role: %s\", role);\n    collection.setRole(role);\n    collection.setNodeName(propertyName);\n    if ((property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) || property.isAnnotationPresent(MapKeyColumn.class)) && mapKeyPropertyName != null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    if (orderBy != null && hqlOrderBy != null) {\n        throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n    }\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    OptimisticLock lockAnn = property.getAnnotation(OptimisticLock.class);\n    if (lockAnn != null)\n        collection.setOptimisticLocked(!lockAnn.excluded());\n    Persister persisterAnn = property.getAnnotation(Persister.class);\n    if (persisterAnn != null)\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    if (orderBy != null)\n        collection.setOrderBy(orderBy);\n    if (isSorted) {\n        collection.setSorted(true);\n        if (comparator != null) {\n            try {\n                collection.setComparator((Comparator) comparator.newInstance());\n            } catch (ClassCastException e) {\n                throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            } catch (Exception e) {\n                throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            }\n        }\n    } else {\n        if (hasToBeSorted) {\n            throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n        }\n    }\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert = property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate = property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete = property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll = property.getAnnotation(SQLDeleteAll.class);\n    Loader loader = property.getAnnotation(Loader.class);\n    if (sqlInsert != null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.parse(sqlInsert.check().toString().toLowerCase()));\n    }\n    if (sqlUpdate != null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.parse(sqlUpdate.check().toString().toLowerCase()));\n    }\n    if (sqlDelete != null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDelete.check().toString().toLowerCase()));\n    }\n    if (sqlDeleteAll != null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDeleteAll.check().toString().toLowerCase()));\n    }\n    if (loader != null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    boolean isMappedBy = !BinderHelper.isEmptyAnnotationValue(mappedBy);\n    if (isMappedBy && (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) != null)) {\n        String message = \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n        message += StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        throw new AnnotationException(message);\n    }\n    collection.setInverse(isMappedBy);\n    if (!oneToMany && isMappedBy) {\n        mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType = getCollectionType();\n    if (inheritanceStatePerClass == null)\n        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n    SecondPass sp = getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        mappings.addSecondPass(sp, !isMappedBy);\n    } else {\n        mappings.addSecondPass(sp, !isMappedBy);\n    }\n    mappings.addCollection(collection);\n    PropertyBinder binder = new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy != null && cascadeStrategy.indexOf(\"delete-orphan\") >= 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setAccessType(accessType);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop = binder.makeProperty();\n    if (!declaringClassSet)\n        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n    propertyHolder.addProperty(prop, declaringClass);\n}"
    },
    {
      "commit": "3712e1ad7efccd2ba0c24b3d7d3b23f84d948b9d",
      "startLine": 44,
      "endLine": 63,
      "methodCode": "public void bind() {\n    this.collection = createCollection(propertyHolder.getPersistentClass());\n    String role = StringHelper.qualify(propertyHolder.getPath(), propertyName);\n    LOG.debug(\"Collection role: \" + role);\n    collection.setRole(role);\n    collection.setNodeName(propertyName);\n    if ((property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) || property.isAnnotationPresent(MapKeyColumn.class)) && mapKeyPropertyName != null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    if (orderBy != null && hqlOrderBy != null) {\n        throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n    }\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    OptimisticLock lockAnn = property.getAnnotation(OptimisticLock.class);\n    if (lockAnn != null)\n        collection.setOptimisticLocked(!lockAnn.excluded());\n    Persister persisterAnn = property.getAnnotation(Persister.class);\n    if (persisterAnn != null)\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    if (orderBy != null)\n        collection.setOrderBy(orderBy);\n    if (isSorted) {\n        collection.setSorted(true);\n        if (comparator != null) {\n            try {\n                collection.setComparator((Comparator) comparator.newInstance());\n            } catch (ClassCastException e) {\n                throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            } catch (Exception e) {\n                throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            }\n        }\n    } else {\n        if (hasToBeSorted) {\n            throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n        }\n    }\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert = property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate = property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete = property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll = property.getAnnotation(SQLDeleteAll.class);\n    Loader loader = property.getAnnotation(Loader.class);\n    if (sqlInsert != null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.parse(sqlInsert.check().toString().toLowerCase()));\n    }\n    if (sqlUpdate != null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.parse(sqlUpdate.check().toString().toLowerCase()));\n    }\n    if (sqlDelete != null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDelete.check().toString().toLowerCase()));\n    }\n    if (sqlDeleteAll != null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDeleteAll.check().toString().toLowerCase()));\n    }\n    if (loader != null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    boolean isMappedBy = !BinderHelper.isEmptyAnnotationValue(mappedBy);\n    if (isMappedBy && (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) != null)) {\n        String message = \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n        message += StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        throw new AnnotationException(message);\n    }\n    collection.setInverse(isMappedBy);\n    if (!oneToMany && isMappedBy) {\n        mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType = getCollectionType();\n    if (inheritanceStatePerClass == null)\n        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n    SecondPass sp = getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        mappings.addSecondPass(sp, !isMappedBy);\n    } else {\n        mappings.addSecondPass(sp, !isMappedBy);\n    }\n    mappings.addCollection(collection);\n    PropertyBinder binder = new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy != null && cascadeStrategy.indexOf(\"delete-orphan\") >= 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setAccessType(accessType);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop = binder.makeProperty();\n    if (!declaringClassSet)\n        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n    propertyHolder.addProperty(prop, declaringClass);\n}"
    },
    {
      "commit": "a9b1425f3f07021dae556e710b2bdfdc3812661b",
      "startLine": 44,
      "endLine": 63,
      "methodCode": "public void bind() {\n    this.collection = createCollection(propertyHolder.getPersistentClass());\n    String role = StringHelper.qualify(propertyHolder.getPath(), propertyName);\n    LOG.collectionRole(role);\n    collection.setRole(role);\n    collection.setNodeName(propertyName);\n    if ((property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) || property.isAnnotationPresent(MapKeyColumn.class)) && mapKeyPropertyName != null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    if (orderBy != null && hqlOrderBy != null) {\n        throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n    }\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    OptimisticLock lockAnn = property.getAnnotation(OptimisticLock.class);\n    if (lockAnn != null)\n        collection.setOptimisticLocked(!lockAnn.excluded());\n    Persister persisterAnn = property.getAnnotation(Persister.class);\n    if (persisterAnn != null)\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    if (orderBy != null)\n        collection.setOrderBy(orderBy);\n    if (isSorted) {\n        collection.setSorted(true);\n        if (comparator != null) {\n            try {\n                collection.setComparator((Comparator) comparator.newInstance());\n            } catch (ClassCastException e) {\n                throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            } catch (Exception e) {\n                throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            }\n        }\n    } else {\n        if (hasToBeSorted) {\n            throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n        }\n    }\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert = property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate = property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete = property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll = property.getAnnotation(SQLDeleteAll.class);\n    Loader loader = property.getAnnotation(Loader.class);\n    if (sqlInsert != null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.parse(sqlInsert.check().toString().toLowerCase()));\n    }\n    if (sqlUpdate != null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.parse(sqlUpdate.check().toString().toLowerCase()));\n    }\n    if (sqlDelete != null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDelete.check().toString().toLowerCase()));\n    }\n    if (sqlDeleteAll != null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDeleteAll.check().toString().toLowerCase()));\n    }\n    if (loader != null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    boolean isMappedBy = !BinderHelper.isEmptyAnnotationValue(mappedBy);\n    if (isMappedBy && (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) != null)) {\n        String message = \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n        message += StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        throw new AnnotationException(message);\n    }\n    collection.setInverse(isMappedBy);\n    if (!oneToMany && isMappedBy) {\n        mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType = getCollectionType();\n    if (inheritanceStatePerClass == null)\n        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n    SecondPass sp = getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        mappings.addSecondPass(sp, !isMappedBy);\n    } else {\n        mappings.addSecondPass(sp, !isMappedBy);\n    }\n    mappings.addCollection(collection);\n    PropertyBinder binder = new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy != null && cascadeStrategy.indexOf(\"delete-orphan\") >= 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setAccessType(accessType);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop = binder.makeProperty();\n    if (!declaringClassSet)\n        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n    propertyHolder.addProperty(prop, declaringClass);\n}"
    },
    {
      "commit": "34c2839dccef33a8f3abb4eaf3192c1e1d9e1814",
      "startLine": 43,
      "endLine": 62,
      "methodCode": "public void bind() {\n    this.collection = createCollection(propertyHolder.getPersistentClass());\n    log.debug(\"Collection role: {}\", StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setRole(StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setNodeName(propertyName);\n    if ((property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) || property.isAnnotationPresent(MapKeyColumn.class)) && mapKeyPropertyName != null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    if (orderBy != null && hqlOrderBy != null) {\n        throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n    }\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    OptimisticLock lockAnn = property.getAnnotation(OptimisticLock.class);\n    if (lockAnn != null)\n        collection.setOptimisticLocked(!lockAnn.excluded());\n    Persister persisterAnn = property.getAnnotation(Persister.class);\n    if (persisterAnn != null)\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    if (orderBy != null)\n        collection.setOrderBy(orderBy);\n    if (isSorted) {\n        collection.setSorted(true);\n        if (comparator != null) {\n            try {\n                collection.setComparator((Comparator) comparator.newInstance());\n            } catch (ClassCastException e) {\n                throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            } catch (Exception e) {\n                throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            }\n        }\n    } else {\n        if (hasToBeSorted) {\n            throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n        }\n    }\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert = property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate = property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete = property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll = property.getAnnotation(SQLDeleteAll.class);\n    Loader loader = property.getAnnotation(Loader.class);\n    if (sqlInsert != null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.parse(sqlInsert.check().toString().toLowerCase()));\n    }\n    if (sqlUpdate != null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.parse(sqlUpdate.check().toString().toLowerCase()));\n    }\n    if (sqlDelete != null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDelete.check().toString().toLowerCase()));\n    }\n    if (sqlDeleteAll != null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDeleteAll.check().toString().toLowerCase()));\n    }\n    if (loader != null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    boolean isMappedBy = !BinderHelper.isEmptyAnnotationValue(mappedBy);\n    if (isMappedBy && (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) != null)) {\n        String message = \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n        message += StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        throw new AnnotationException(message);\n    }\n    collection.setInverse(isMappedBy);\n    if (!oneToMany && isMappedBy) {\n        mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType = getCollectionType();\n    if (inheritanceStatePerClass == null)\n        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n    SecondPass sp = getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        mappings.addSecondPass(sp, !isMappedBy);\n    } else {\n        mappings.addSecondPass(sp, !isMappedBy);\n    }\n    mappings.addCollection(collection);\n    PropertyBinder binder = new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy != null && cascadeStrategy.indexOf(\"delete-orphan\") >= 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setAccessType(accessType);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop = binder.makeProperty();\n    if (!declaringClassSet)\n        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n    propertyHolder.addProperty(prop, declaringClass);\n}"
    },
    {
      "commit": "7419fc298dab9afe82fbdbb8b64854fa37f60817",
      "startLine": 43,
      "endLine": 62,
      "methodCode": "public void bind() {\n    this.collection = createCollection(propertyHolder.getPersistentClass());\n    log.debug(\"Collection role: {}\", StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setRole(StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setNodeName(propertyName);\n    if ((property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) || property.isAnnotationPresent(MapKeyColumn.class)) && mapKeyPropertyName != null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    if (orderBy != null && hqlOrderBy != null) {\n        throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n    }\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    OptimisticLock lockAnn = property.getAnnotation(OptimisticLock.class);\n    if (lockAnn != null)\n        collection.setOptimisticLocked(!lockAnn.excluded());\n    Persister persisterAnn = property.getAnnotation(Persister.class);\n    if (persisterAnn != null)\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    if (orderBy != null)\n        collection.setOrderBy(orderBy);\n    if (isSorted) {\n        collection.setSorted(true);\n        if (comparator != null) {\n            try {\n                collection.setComparator((Comparator) comparator.newInstance());\n            } catch (ClassCastException e) {\n                throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            } catch (Exception e) {\n                throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            }\n        }\n    } else {\n        if (hasToBeSorted) {\n            throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n        }\n    }\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert = property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate = property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete = property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll = property.getAnnotation(SQLDeleteAll.class);\n    Loader loader = property.getAnnotation(Loader.class);\n    if (sqlInsert != null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.parse(sqlInsert.check().toString().toLowerCase()));\n    }\n    if (sqlUpdate != null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.parse(sqlUpdate.check().toString().toLowerCase()));\n    }\n    if (sqlDelete != null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDelete.check().toString().toLowerCase()));\n    }\n    if (sqlDeleteAll != null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDeleteAll.check().toString().toLowerCase()));\n    }\n    if (loader != null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    boolean isMappedBy = !BinderHelper.isEmptyAnnotationValue(mappedBy);\n    if (isMappedBy && (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) != null)) {\n        String message = \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n        message += StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        throw new AnnotationException(message);\n    }\n    collection.setInverse(isMappedBy);\n    if (!oneToMany && isMappedBy) {\n        mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType = getCollectionType();\n    if (inheritanceStatePerClass == null)\n        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n    SecondPass sp = getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        mappings.addSecondPass(sp, !isMappedBy);\n    } else {\n        mappings.addSecondPass(sp, !isMappedBy);\n    }\n    mappings.addCollection(collection);\n    PropertyBinder binder = new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy != null && cascadeStrategy.indexOf(\"delete-orphan\") >= 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setAccessType(accessType);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop = binder.makeProperty();\n    if (!declaringClassSet)\n        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n    propertyHolder.addProperty(prop, declaringClass);\n}"
    },
    {
      "commit": "1ca2bc19a5f667e10f9a2c2b10320b9c40921563",
      "startLine": 43,
      "endLine": 62,
      "methodCode": "public void bind() {\n    this.collection = createCollection(propertyHolder.getPersistentClass());\n    log.debug(\"Collection role: {}\", StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setRole(StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setNodeName(propertyName);\n    if ((property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) || property.isAnnotationPresent(MapKeyColumn.class)) && mapKeyPropertyName != null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    if (orderBy != null && hqlOrderBy != null) {\n        throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n    }\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    OptimisticLock lockAnn = property.getAnnotation(OptimisticLock.class);\n    if (lockAnn != null)\n        collection.setOptimisticLocked(!lockAnn.excluded());\n    Persister persisterAnn = property.getAnnotation(Persister.class);\n    if (persisterAnn != null)\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    if (orderBy != null)\n        collection.setOrderBy(orderBy);\n    if (isSorted) {\n        collection.setSorted(true);\n        if (comparator != null) {\n            try {\n                collection.setComparator((Comparator) comparator.newInstance());\n            } catch (ClassCastException e) {\n                throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            } catch (Exception e) {\n                throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            }\n        }\n    } else {\n        if (hasToBeSorted) {\n            throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n        }\n    }\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert = property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate = property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete = property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll = property.getAnnotation(SQLDeleteAll.class);\n    Loader loader = property.getAnnotation(Loader.class);\n    if (sqlInsert != null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.parse(sqlInsert.check().toString().toLowerCase()));\n    }\n    if (sqlUpdate != null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.parse(sqlUpdate.check().toString().toLowerCase()));\n    }\n    if (sqlDelete != null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDelete.check().toString().toLowerCase()));\n    }\n    if (sqlDeleteAll != null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDeleteAll.check().toString().toLowerCase()));\n    }\n    if (loader != null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    boolean isMappedBy = !BinderHelper.isDefault(mappedBy);\n    if (isMappedBy && (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) != null)) {\n        String message = \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n        message += StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        throw new AnnotationException(message);\n    }\n    collection.setInverse(isMappedBy);\n    if (!oneToMany && isMappedBy) {\n        mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType = getCollectionType();\n    if (inheritanceStatePerClass == null)\n        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n    SecondPass sp = getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        mappings.addSecondPass(sp, !isMappedBy);\n    } else {\n        mappings.addSecondPass(sp, !isMappedBy);\n    }\n    mappings.addCollection(collection);\n    PropertyBinder binder = new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy != null && cascadeStrategy.indexOf(\"delete-orphan\") >= 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setAccessType(accessType);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop = binder.makeProperty();\n    if (!declaringClassSet)\n        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n    propertyHolder.addProperty(prop, declaringClass);\n}"
    },
    {
      "commit": "8577a68e69d30d9e671024bf3330616000a3ec54",
      "startLine": 43,
      "endLine": 62,
      "methodCode": "public void bind() {\n    this.collection = createCollection(propertyHolder.getPersistentClass());\n    log.debug(\"Collection role: {}\", StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setRole(StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setNodeName(propertyName);\n    if ((property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) || property.isAnnotationPresent(MapKeyColumn.class)) && mapKeyPropertyName != null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    if (orderBy != null && hqlOrderBy != null) {\n        throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n    }\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    OptimisticLock lockAnn = property.getAnnotation(OptimisticLock.class);\n    if (lockAnn != null)\n        collection.setOptimisticLocked(!lockAnn.excluded());\n    Persister persisterAnn = property.getAnnotation(Persister.class);\n    if (persisterAnn != null)\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    if (orderBy != null)\n        collection.setOrderBy(orderBy);\n    if (isSorted) {\n        collection.setSorted(true);\n        if (comparator != null) {\n            try {\n                collection.setComparator((Comparator) comparator.newInstance());\n            } catch (ClassCastException e) {\n                throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            } catch (Exception e) {\n                throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            }\n        }\n    } else {\n        if (hasToBeSorted) {\n            throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n        }\n    }\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert = property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate = property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete = property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll = property.getAnnotation(SQLDeleteAll.class);\n    Loader loader = property.getAnnotation(Loader.class);\n    if (sqlInsert != null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.parse(sqlInsert.check().toString().toLowerCase()));\n    }\n    if (sqlUpdate != null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.parse(sqlUpdate.check().toString().toLowerCase()));\n    }\n    if (sqlDelete != null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDelete.check().toString().toLowerCase()));\n    }\n    if (sqlDeleteAll != null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDeleteAll.check().toString().toLowerCase()));\n    }\n    if (loader != null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    boolean isMappedBy = !BinderHelper.isDefault(mappedBy);\n    if (isMappedBy && (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) != null)) {\n        String message = \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n        message += StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        throw new AnnotationException(message);\n    }\n    collection.setInverse(isMappedBy);\n    if (!oneToMany && isMappedBy) {\n        mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType = getCollectionType();\n    if (inheritanceStatePerClass == null)\n        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n    SecondPass sp = getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        mappings.addSecondPass(sp, !isMappedBy);\n    } else {\n        mappings.addSecondPass(sp, !isMappedBy);\n    }\n    mappings.addCollection(collection);\n    PropertyBinder binder = new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy != null && cascadeStrategy.indexOf(\"delete-orphan\") >= 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setAccessType(accessType);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop = binder.makeProperty();\n    if (!declaringClassSet)\n        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n    propertyHolder.addProperty(prop, declaringClass);\n}"
    },
    {
      "commit": "b1f925458eeb636897bf8a053712ed25fff39054",
      "startLine": 43,
      "endLine": 62,
      "methodCode": "public void bind() {\n    this.collection = createCollection(propertyHolder.getPersistentClass());\n    log.debug(\"Collection role: {}\", StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setRole(StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setNodeName(propertyName);\n    if ((property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) || property.isAnnotationPresent(MapKeyColumn.class)) && mapKeyPropertyName != null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    if (orderBy != null && hqlOrderBy != null) {\n        throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n    }\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    OptimisticLock lockAnn = property.getAnnotation(OptimisticLock.class);\n    if (lockAnn != null)\n        collection.setOptimisticLocked(!lockAnn.excluded());\n    Persister persisterAnn = property.getAnnotation(Persister.class);\n    if (persisterAnn != null)\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    if (orderBy != null)\n        collection.setOrderBy(orderBy);\n    if (isSorted) {\n        collection.setSorted(true);\n        if (comparator != null) {\n            try {\n                collection.setComparator((Comparator) comparator.newInstance());\n            } catch (ClassCastException e) {\n                throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            } catch (Exception e) {\n                throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            }\n        }\n    } else {\n        if (hasToBeSorted) {\n            throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n        }\n    }\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert = property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate = property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete = property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll = property.getAnnotation(SQLDeleteAll.class);\n    Loader loader = property.getAnnotation(Loader.class);\n    if (sqlInsert != null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.parse(sqlInsert.check().toString().toLowerCase()));\n    }\n    if (sqlUpdate != null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.parse(sqlUpdate.check().toString().toLowerCase()));\n    }\n    if (sqlDelete != null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDelete.check().toString().toLowerCase()));\n    }\n    if (sqlDeleteAll != null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDeleteAll.check().toString().toLowerCase()));\n    }\n    if (loader != null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    boolean isMappedBy = !BinderHelper.isDefault(mappedBy);\n    if (isMappedBy && (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) != null)) {\n        String message = \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n        message += StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        throw new AnnotationException(message);\n    }\n    collection.setInverse(isMappedBy);\n    if (!oneToMany && isMappedBy) {\n        mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType = getCollectionType();\n    if (inheritanceStatePerClass == null)\n        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n    SecondPass sp = getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        mappings.addSecondPass(sp, !isMappedBy);\n    } else {\n        mappings.addSecondPass(sp, !isMappedBy);\n    }\n    mappings.addCollection(collection);\n    PropertyBinder binder = new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy != null && cascadeStrategy.indexOf(\"delete-orphan\") >= 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setAccessType(accessType);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop = binder.make();\n    if (!declaringClassSet)\n        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n    propertyHolder.addProperty(prop, declaringClass);\n}"
    },
    {
      "commit": "e44b5f197d77e1d1a847cd04eaa0d25254362483",
      "startLine": 43,
      "endLine": 62,
      "methodCode": "public void bind() {\n    this.collection = createCollection(propertyHolder.getPersistentClass());\n    log.debug(\"Collection role: {}\", StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setRole(StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setNodeName(propertyName);\n    if ((property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) || property.isAnnotationPresent(MapKeyColumn.class)) && mapKeyPropertyName != null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    if (orderBy != null && hqlOrderBy != null) {\n        throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n    }\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    OptimisticLock lockAnn = property.getAnnotation(OptimisticLock.class);\n    if (lockAnn != null)\n        collection.setOptimisticLocked(!lockAnn.excluded());\n    Persister persisterAnn = property.getAnnotation(Persister.class);\n    if (persisterAnn != null)\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    if (orderBy != null)\n        collection.setOrderBy(orderBy);\n    if (isSorted) {\n        collection.setSorted(true);\n        if (comparator != null) {\n            try {\n                collection.setComparator((Comparator) comparator.newInstance());\n            } catch (ClassCastException e) {\n                throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            } catch (Exception e) {\n                throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            }\n        }\n    } else {\n        if (hasToBeSorted) {\n            throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n        }\n    }\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert = property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate = property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete = property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll = property.getAnnotation(SQLDeleteAll.class);\n    Loader loader = property.getAnnotation(Loader.class);\n    if (sqlInsert != null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.parse(sqlInsert.check().toString().toLowerCase()));\n    }\n    if (sqlUpdate != null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.parse(sqlUpdate.check().toString().toLowerCase()));\n    }\n    if (sqlDelete != null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDelete.check().toString().toLowerCase()));\n    }\n    if (sqlDeleteAll != null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDeleteAll.check().toString().toLowerCase()));\n    }\n    if (loader != null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    boolean isMappedBy = !BinderHelper.isDefault(mappedBy);\n    if (isMappedBy && (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || property.isAnnotationPresent(JoinTable.class))) {\n        String message = \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n        message += StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        throw new AnnotationException(message);\n    }\n    collection.setInverse(isMappedBy);\n    if (!oneToMany && isMappedBy) {\n        mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType = getCollectionType();\n    if (inheritanceStatePerClass == null)\n        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n    SecondPass sp = getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        mappings.addSecondPass(sp, !isMappedBy);\n    } else {\n        mappings.addSecondPass(sp, !isMappedBy);\n    }\n    mappings.addCollection(collection);\n    PropertyBinder binder = new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy != null && cascadeStrategy.indexOf(\"delete-orphan\") >= 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setAccessType(accessType);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop = binder.make();\n    if (!declaringClassSet)\n        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n    propertyHolder.addProperty(prop, declaringClass);\n}"
    },
    {
      "commit": "658df91a5e308fd1d97cec62acf6110143012592",
      "startLine": 43,
      "endLine": 62,
      "methodCode": "public void bind() {\n    this.collection = createCollection(propertyHolder.getPersistentClass());\n    log.debug(\"Collection role: {}\", StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setRole(StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setNodeName(propertyName);\n    if ((property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) || property.isAnnotationPresent(MapKeyColumn.class)) && mapKeyPropertyName != null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    if (orderBy != null && hqlOrderBy != null) {\n        throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n    }\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    OptimisticLock lockAnn = property.getAnnotation(OptimisticLock.class);\n    if (lockAnn != null)\n        collection.setOptimisticLocked(!lockAnn.excluded());\n    Persister persisterAnn = property.getAnnotation(Persister.class);\n    if (persisterAnn != null)\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    if (orderBy != null)\n        collection.setOrderBy(orderBy);\n    if (isSorted) {\n        collection.setSorted(true);\n        if (comparator != null) {\n            try {\n                collection.setComparator((Comparator) comparator.newInstance());\n            } catch (ClassCastException e) {\n                throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            } catch (Exception e) {\n                throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            }\n        }\n    } else {\n        if (hasToBeSorted) {\n            throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n        }\n    }\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert = property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate = property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete = property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll = property.getAnnotation(SQLDeleteAll.class);\n    Loader loader = property.getAnnotation(Loader.class);\n    if (sqlInsert != null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.parse(sqlInsert.check().toString().toLowerCase()));\n    }\n    if (sqlUpdate != null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.parse(sqlUpdate.check().toString().toLowerCase()));\n    }\n    if (sqlDelete != null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDelete.check().toString().toLowerCase()));\n    }\n    if (sqlDeleteAll != null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDeleteAll.check().toString().toLowerCase()));\n    }\n    if (loader != null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    boolean isMappedBy = !BinderHelper.isDefault(mappedBy);\n    if (isMappedBy && (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinTable.class))) {\n        String message = \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n        message += StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        throw new AnnotationException(message);\n    }\n    collection.setInverse(isMappedBy);\n    if (!oneToMany && isMappedBy) {\n        mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType = getCollectionType();\n    if (inheritanceStatePerClass == null)\n        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n    SecondPass sp = getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        mappings.addSecondPass(sp, !isMappedBy);\n    } else {\n        mappings.addSecondPass(sp, !isMappedBy);\n    }\n    mappings.addCollection(collection);\n    PropertyBinder binder = new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy != null && cascadeStrategy.indexOf(\"delete-orphan\") >= 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setAccessType(accessType);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop = binder.make();\n    if (!declaringClassSet)\n        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n    propertyHolder.addProperty(prop, declaringClass);\n}"
    },
    {
      "commit": "4a9d8dcf0b054d4dc769b463145c1fdecede6e09",
      "startLine": 43,
      "endLine": 62,
      "methodCode": "public void bind() {\n    this.collection = createCollection(propertyHolder.getPersistentClass());\n    log.debug(\"Collection role: {}\", StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setRole(StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setNodeName(propertyName);\n    if ((property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) || property.isAnnotationPresent(MapKeyColumn.class)) && mapKeyPropertyName != null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    if (orderBy != null && hqlOrderBy != null) {\n        throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n    }\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    OptimisticLock lockAnn = property.getAnnotation(OptimisticLock.class);\n    if (lockAnn != null)\n        collection.setOptimisticLocked(!lockAnn.excluded());\n    Persister persisterAnn = property.getAnnotation(Persister.class);\n    if (persisterAnn != null)\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    if (orderBy != null)\n        collection.setOrderBy(orderBy);\n    if (isSorted) {\n        collection.setSorted(true);\n        if (comparator != null) {\n            try {\n                collection.setComparator((Comparator) comparator.newInstance());\n            } catch (ClassCastException e) {\n                throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            } catch (Exception e) {\n                throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            }\n        }\n    } else {\n        if (hasToBeSorted) {\n            throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n        }\n    }\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert = property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate = property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete = property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll = property.getAnnotation(SQLDeleteAll.class);\n    Loader loader = property.getAnnotation(Loader.class);\n    if (sqlInsert != null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.parse(sqlInsert.check().toString().toLowerCase()));\n    }\n    if (sqlUpdate != null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.parse(sqlUpdate.check().toString().toLowerCase()));\n    }\n    if (sqlDelete != null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDelete.check().toString().toLowerCase()));\n    }\n    if (sqlDeleteAll != null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDeleteAll.check().toString().toLowerCase()));\n    }\n    if (loader != null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    boolean isMappedBy = !BinderHelper.isDefault(mappedBy);\n    collection.setInverse(isMappedBy);\n    if (!oneToMany && isMappedBy) {\n        mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType = getCollectionType();\n    if (inheritanceStatePerClass == null)\n        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n    SecondPass sp = getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        mappings.addSecondPass(sp, !isMappedBy);\n    } else {\n        mappings.addSecondPass(sp, !isMappedBy);\n    }\n    mappings.addCollection(collection);\n    PropertyBinder binder = new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy != null && cascadeStrategy.indexOf(\"delete-orphan\") >= 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setAccessType(accessType);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop = binder.make();\n    if (!declaringClassSet)\n        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n    propertyHolder.addProperty(prop, declaringClass);\n}"
    },
    {
      "commit": "c7c6981a558e35f01ff8d27938e98aa83896765c",
      "startLine": 43,
      "endLine": 62,
      "methodCode": "public void bind() {\n    this.collection = createCollection(propertyHolder.getPersistentClass());\n    log.debug(\"Collection role: {}\", StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setRole(StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setNodeName(propertyName);\n    if ((property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) || property.isAnnotationPresent(MapKeyColumn.class)) && mapKeyPropertyName != null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    if (orderBy != null && hqlOrderBy != null) {\n        throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n    }\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    OptimisticLock lockAnn = property.getAnnotation(OptimisticLock.class);\n    if (lockAnn != null)\n        collection.setOptimisticLocked(!lockAnn.excluded());\n    Persister persisterAnn = property.getAnnotation(Persister.class);\n    if (persisterAnn != null)\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    if (orderBy != null)\n        collection.setOrderBy(orderBy);\n    if (isSorted) {\n        collection.setSorted(true);\n        if (comparator != null) {\n            try {\n                collection.setComparator((Comparator) comparator.newInstance());\n            } catch (ClassCastException e) {\n                throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            } catch (Exception e) {\n                throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            }\n        }\n    } else {\n        if (hasToBeSorted) {\n            throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n        }\n    }\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert = property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate = property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete = property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll = property.getAnnotation(SQLDeleteAll.class);\n    Loader loader = property.getAnnotation(Loader.class);\n    if (sqlInsert != null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.parse(sqlInsert.check().toString().toLowerCase()));\n    }\n    if (sqlUpdate != null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.parse(sqlUpdate.check().toString().toLowerCase()));\n    }\n    if (sqlDelete != null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDelete.check().toString().toLowerCase()));\n    }\n    if (sqlDeleteAll != null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDeleteAll.check().toString().toLowerCase()));\n    }\n    if (loader != null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    boolean isMappedBy = !BinderHelper.isDefault(mappedBy);\n    collection.setInverse(isMappedBy);\n    if (!oneToMany && isMappedBy) {\n        mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType = getCollectionType();\n    if (inheritanceStatePerClass == null)\n        throw new AssertionFailure(\"inheritanceStatePerClass not set\");\n    SecondPass sp = getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        mappings.addSecondPass(sp, !isMappedBy);\n    } else {\n        mappings.addSecondPass(sp, !isMappedBy);\n    }\n    mappings.addCollection(collection);\n    PropertyBinder binder = new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy != null && cascadeStrategy.indexOf(\"delete-orphan\") >= 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setPropertyAccessorName(propertyAccessorName);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop = binder.make();\n    if (!declaringClassSet)\n        throw new AssertionFailure(\"DeclaringClass is not set in CollectionBinder while binding\");\n    propertyHolder.addProperty(prop, declaringClass);\n}"
    },
    {
      "commit": "20d22941c0e07b37295704d5300a7071e48e640d",
      "startLine": 43,
      "endLine": 62,
      "methodCode": "public void bind() {\n    this.collection = createCollection(propertyHolder.getPersistentClass());\n    log.debug(\"Collection role: {}\", StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setRole(StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setNodeName(propertyName);\n    if ((property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) || property.isAnnotationPresent(MapKeyColumn.class)) && mapKeyPropertyName != null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    if (orderBy != null && hqlOrderBy != null) {\n        throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n    }\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    OptimisticLock lockAnn = property.getAnnotation(OptimisticLock.class);\n    if (lockAnn != null)\n        collection.setOptimisticLocked(!lockAnn.excluded());\n    Persister persisterAnn = property.getAnnotation(Persister.class);\n    if (persisterAnn != null)\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    if (orderBy != null)\n        collection.setOrderBy(orderBy);\n    if (isSorted) {\n        collection.setSorted(true);\n        if (comparator != null) {\n            try {\n                collection.setComparator((Comparator) comparator.newInstance());\n            } catch (ClassCastException e) {\n                throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            } catch (Exception e) {\n                throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            }\n        }\n    } else {\n        if (hasToBeSorted) {\n            throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n        }\n    }\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert = property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate = property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete = property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll = property.getAnnotation(SQLDeleteAll.class);\n    Loader loader = property.getAnnotation(Loader.class);\n    if (sqlInsert != null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.parse(sqlInsert.check().toString().toLowerCase()));\n    }\n    if (sqlUpdate != null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.parse(sqlUpdate.check().toString().toLowerCase()));\n    }\n    if (sqlDelete != null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDelete.check().toString().toLowerCase()));\n    }\n    if (sqlDeleteAll != null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDeleteAll.check().toString().toLowerCase()));\n    }\n    if (loader != null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    boolean isMappedBy = !BinderHelper.isDefault(mappedBy);\n    collection.setInverse(isMappedBy);\n    if (!oneToMany && isMappedBy) {\n        mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType = getCollectionType();\n    SecondPass sp = getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        mappings.addSecondPass(sp, !isMappedBy);\n    } else {\n        mappings.addSecondPass(sp, !isMappedBy);\n    }\n    mappings.addCollection(collection);\n    PropertyBinder binder = new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy != null && cascadeStrategy.indexOf(\"delete-orphan\") >= 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setPropertyAccessorName(propertyAccessorName);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop = binder.make();\n    propertyHolder.addProperty(prop);\n}"
    },
    {
      "commit": "11668ca67c916595d2789787e37b3ed1affc1aa8",
      "startLine": 43,
      "endLine": 62,
      "methodCode": "public void bind() {\n    this.collection = createCollection(propertyHolder.getPersistentClass());\n    log.debug(\"Collection role: {}\", StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setRole(StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setNodeName(propertyName);\n    if (property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) && mapKeyPropertyName != null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    if (orderBy != null && hqlOrderBy != null) {\n        throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n    }\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    OptimisticLock lockAnn = property.getAnnotation(OptimisticLock.class);\n    if (lockAnn != null)\n        collection.setOptimisticLocked(!lockAnn.excluded());\n    Persister persisterAnn = property.getAnnotation(Persister.class);\n    if (persisterAnn != null)\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    if (orderBy != null)\n        collection.setOrderBy(orderBy);\n    if (isSorted) {\n        collection.setSorted(true);\n        if (comparator != null) {\n            try {\n                collection.setComparator((Comparator) comparator.newInstance());\n            } catch (ClassCastException e) {\n                throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            } catch (Exception e) {\n                throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            }\n        }\n    } else {\n        if (hasToBeSorted) {\n            throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n        }\n    }\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert = property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate = property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete = property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll = property.getAnnotation(SQLDeleteAll.class);\n    Loader loader = property.getAnnotation(Loader.class);\n    if (sqlInsert != null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.parse(sqlInsert.check().toString().toLowerCase()));\n    }\n    if (sqlUpdate != null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.parse(sqlUpdate.check().toString().toLowerCase()));\n    }\n    if (sqlDelete != null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDelete.check().toString().toLowerCase()));\n    }\n    if (sqlDeleteAll != null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDeleteAll.check().toString().toLowerCase()));\n    }\n    if (loader != null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    boolean isMappedBy = !BinderHelper.isDefault(mappedBy);\n    collection.setInverse(isMappedBy);\n    if (!oneToMany && isMappedBy) {\n        mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType = getCollectionType();\n    SecondPass sp = getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class) || property.isAnnotationPresent(ElementCollection.class)) {\n        mappings.addSecondPass(sp, !isMappedBy);\n    } else {\n        mappings.addSecondPass(sp, !isMappedBy);\n    }\n    mappings.addCollection(collection);\n    PropertyBinder binder = new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy != null && cascadeStrategy.indexOf(\"delete-orphan\") >= 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setPropertyAccessorName(propertyAccessorName);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop = binder.make();\n    propertyHolder.addProperty(prop);\n}"
    },
    {
      "commit": "9d7a03a5f7f03bc803d897baa590861154b39f5e",
      "startLine": 43,
      "endLine": 62,
      "methodCode": "public void bind() {\n    this.collection = createCollection(propertyHolder.getPersistentClass());\n    log.debug(\"Collection role: {}\", StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setRole(StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setNodeName(propertyName);\n    if (property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) && mapKeyPropertyName != null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    if (orderBy != null && hqlOrderBy != null) {\n        throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n    }\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    OptimisticLock lockAnn = property.getAnnotation(OptimisticLock.class);\n    if (lockAnn != null)\n        collection.setOptimisticLocked(!lockAnn.excluded());\n    Persister persisterAnn = property.getAnnotation(Persister.class);\n    if (persisterAnn != null)\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    if (orderBy != null)\n        collection.setOrderBy(orderBy);\n    if (isSorted) {\n        collection.setSorted(true);\n        if (comparator != null) {\n            try {\n                collection.setComparator((Comparator) comparator.newInstance());\n            } catch (ClassCastException e) {\n                throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            } catch (Exception e) {\n                throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            }\n        }\n    } else {\n        if (hasToBeSorted) {\n            throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n        }\n    }\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert = property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate = property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete = property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll = property.getAnnotation(SQLDeleteAll.class);\n    Loader loader = property.getAnnotation(Loader.class);\n    if (sqlInsert != null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.parse(sqlInsert.check().toString().toLowerCase()));\n    }\n    if (sqlUpdate != null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.parse(sqlUpdate.check().toString().toLowerCase()));\n    }\n    if (sqlDelete != null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDelete.check().toString().toLowerCase()));\n    }\n    if (sqlDeleteAll != null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDeleteAll.check().toString().toLowerCase()));\n    }\n    if (loader != null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    boolean isMappedBy = !BinderHelper.isDefault(mappedBy);\n    collection.setInverse(isMappedBy);\n    if (!oneToMany && isMappedBy) {\n        mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType = getCollectionType();\n    SecondPass sp = getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class)) {\n        mappings.addSecondPass(sp, !isMappedBy);\n    } else {\n        mappings.addSecondPass(sp, !isMappedBy);\n    }\n    mappings.addCollection(collection);\n    PropertyBinder binder = new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy != null && cascadeStrategy.indexOf(\"delete-orphan\") >= 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setPropertyAccessorName(propertyAccessorName);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop = binder.make();\n    propertyHolder.addProperty(prop);\n}"
    },
    {
      "commit": "7337743c93574823424ed6c399cfcf6bd75614f8",
      "startLine": 43,
      "endLine": 62,
      "methodCode": "public void bind() {\n    this.collection = createCollection(propertyHolder.getPersistentClass());\n    log.debug(\"Collection role: {}\", StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setRole(StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    collection.setNodeName(propertyName);\n    if (property.isAnnotationPresent(org.hibernate.annotations.MapKey.class) && mapKeyPropertyName != null) {\n        throw new AnnotationException(\"Cannot mix @javax.persistence.MapKey and @org.hibernate.annotations.MapKey \" + \"on the same collection: \" + StringHelper.qualify(propertyHolder.getPath(), propertyName));\n    }\n    defineFetchingStrategy();\n    collection.setBatchSize(batchSize);\n    if (orderBy != null && hqlOrderBy != null) {\n        throw new AnnotationException(\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole());\n    }\n    collection.setMutable(!property.isAnnotationPresent(Immutable.class));\n    OptimisticLock lockAnn = property.getAnnotation(OptimisticLock.class);\n    if (lockAnn != null)\n        collection.setOptimisticLocked(!lockAnn.excluded());\n    Persister persisterAnn = property.getAnnotation(Persister.class);\n    if (persisterAnn != null)\n        collection.setCollectionPersisterClass(persisterAnn.impl());\n    if (orderBy != null)\n        collection.setOrderBy(orderBy);\n    if (isSorted) {\n        collection.setSorted(true);\n        if (comparator != null) {\n            try {\n                collection.setComparator((Comparator) comparator.newInstance());\n            } catch (ClassCastException e) {\n                throw new AnnotationException(\"Comparator not implementing java.util.Comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            } catch (Exception e) {\n                throw new AnnotationException(\"Could not instantiate comparator class: \" + comparator.getName() + \"(\" + safeCollectionRole() + \")\");\n            }\n        }\n    } else {\n        if (hasToBeSorted) {\n            throw new AnnotationException(\"A sorted collection has to define @Sort: \" + safeCollectionRole());\n        }\n    }\n    if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {\n        collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);\n        collection.setCacheRegionName(cacheRegionName);\n    }\n    SQLInsert sqlInsert = property.getAnnotation(SQLInsert.class);\n    SQLUpdate sqlUpdate = property.getAnnotation(SQLUpdate.class);\n    SQLDelete sqlDelete = property.getAnnotation(SQLDelete.class);\n    SQLDeleteAll sqlDeleteAll = property.getAnnotation(SQLDeleteAll.class);\n    Loader loader = property.getAnnotation(Loader.class);\n    if (sqlInsert != null) {\n        collection.setCustomSQLInsert(sqlInsert.sql().trim(), sqlInsert.callable(), ExecuteUpdateResultCheckStyle.parse(sqlInsert.check().toString().toLowerCase()));\n    }\n    if (sqlUpdate != null) {\n        collection.setCustomSQLUpdate(sqlUpdate.sql(), sqlUpdate.callable(), ExecuteUpdateResultCheckStyle.parse(sqlUpdate.check().toString().toLowerCase()));\n    }\n    if (sqlDelete != null) {\n        collection.setCustomSQLDelete(sqlDelete.sql(), sqlDelete.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDelete.check().toString().toLowerCase()));\n    }\n    if (sqlDeleteAll != null) {\n        collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(), sqlDeleteAll.callable(), ExecuteUpdateResultCheckStyle.parse(sqlDeleteAll.check().toString().toLowerCase()));\n    }\n    if (loader != null) {\n        collection.setLoaderName(loader.namedQuery());\n    }\n    boolean isMappedBy = !BinderHelper.isDefault(mappedBy);\n    collection.setInverse(isMappedBy);\n    if (!oneToMany && isMappedBy) {\n        mappings.addMappedBy(getCollectionType().getName(), mappedBy, propertyName);\n    }\n    XClass collectionType = getCollectionType();\n    SecondPass sp = getSecondPass(fkJoinColumns, joinColumns, inverseJoinColumns, elementColumns, mapKeyColumns, mapKeyManyToManyColumns, isEmbedded, property, collectionType, ignoreNotFound, oneToMany, tableBinder, mappings);\n    if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(CollectionOfElements.class)) {\n        mappings.addSecondPass(sp, !isMappedBy);\n    } else {\n        mappings.addSecondPass(sp, !isMappedBy);\n    }\n    mappings.addCollection(collection);\n    PropertyBinder binder = new PropertyBinder();\n    binder.setName(propertyName);\n    binder.setValue(collection);\n    binder.setCascade(cascadeStrategy);\n    if (cascadeStrategy != null && cascadeStrategy.indexOf(\"delete-orphan\") >= 0) {\n        collection.setOrphanDelete(true);\n    }\n    binder.setPropertyAccessorName(propertyAccessorName);\n    binder.setProperty(property);\n    binder.setInsertable(insertable);\n    binder.setUpdatable(updatable);\n    Property prop = binder.make();\n    propertyHolder.addProperty(prop);\n}"
    }
  ]
}