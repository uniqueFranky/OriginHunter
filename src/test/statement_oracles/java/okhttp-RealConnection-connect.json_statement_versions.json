{
  "statementVersions": [
    {
      "commit": "db18f0e404ab35c7b23e8ecc27913d717e96eb84",
      "startLine": 4,
      "endLine": 19,
      "methodCode": "public void connect(int connectTimeout, int readTimeout, int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled, Call call, EventListener eventListener) {\n    if (protocol != null)\n        throw new IllegalStateException(\"already connected\");\n    RouteException routeException = null;\n    List<ConnectionSpec> connectionSpecs = route.address().connectionSpecs();\n    ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);\n    if (route.address().sslSocketFactory() == null) {\n        if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n            throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not enabled for client\"));\n        }\n        String host = route.address().url().host();\n        if (!Platform.get().isCleartextTrafficPermitted(host)) {\n            throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n        }\n    } else {\n        if (route.address().protocols().contains(Protocol.H2_PRIOR_KNOWLEDGE)) {\n            throw new RouteException(new UnknownServiceException(\"H2_PRIOR_KNOWLEDGE cannot be used with HTTPS\"));\n        }\n    }\n    while (true) {\n        try {\n            if (route.requiresTunnel()) {\n                connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);\n                if (rawSocket == null) {\n                    break;\n                }\n            } else {\n                connectSocket(connectTimeout, readTimeout, call, eventListener);\n            }\n            establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener);\n            eventListener.connectEnd(call, route.socketAddress(), route.proxy(), protocol);\n            break;\n        } catch (IOException e) {\n            closeQuietly(socket);\n            closeQuietly(rawSocket);\n            socket = null;\n            rawSocket = null;\n            source = null;\n            sink = null;\n            handshake = null;\n            protocol = null;\n            http2Connection = null;\n            eventListener.connectFailed(call, route.socketAddress(), route.proxy(), null, e);\n            if (routeException == null) {\n                routeException = new RouteException(e);\n            } else {\n                routeException.addConnectException(e);\n            }\n            if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                throw routeException;\n            }\n        }\n    }\n    if (route.requiresTunnel() && rawSocket == null) {\n        ProtocolException exception = new ProtocolException(\"Too many tunnel connections attempted: \" + MAX_TUNNEL_ATTEMPTS);\n        throw new RouteException(exception);\n    }\n    if (http2Connection != null) {\n        synchronized (connectionPool) {\n            allocationLimit = http2Connection.maxConcurrentStreams();\n        }\n    }\n}"
    },
    {
      "commit": "abb0a790802996d1039c35424b70b0f3f06b94b7",
      "startLine": 4,
      "endLine": 15,
      "methodCode": "public void connect(int connectTimeout, int readTimeout, int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled, Call call, EventListener eventListener) {\n    if (protocol != null)\n        throw new IllegalStateException(\"already connected\");\n    RouteException routeException = null;\n    List<ConnectionSpec> connectionSpecs = route.address().connectionSpecs();\n    ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);\n    if (route.address().sslSocketFactory() == null) {\n        if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n            throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not enabled for client\"));\n        }\n        String host = route.address().url().host();\n        if (!Platform.get().isCleartextTrafficPermitted(host)) {\n            throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n        }\n    }\n    while (true) {\n        try {\n            if (route.requiresTunnel()) {\n                connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);\n                if (rawSocket == null) {\n                    break;\n                }\n            } else {\n                connectSocket(connectTimeout, readTimeout, call, eventListener);\n            }\n            establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener);\n            eventListener.connectEnd(call, route.socketAddress(), route.proxy(), protocol);\n            break;\n        } catch (IOException e) {\n            closeQuietly(socket);\n            closeQuietly(rawSocket);\n            socket = null;\n            rawSocket = null;\n            source = null;\n            sink = null;\n            handshake = null;\n            protocol = null;\n            http2Connection = null;\n            eventListener.connectFailed(call, route.socketAddress(), route.proxy(), null, e);\n            if (routeException == null) {\n                routeException = new RouteException(e);\n            } else {\n                routeException.addConnectException(e);\n            }\n            if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                throw routeException;\n            }\n        }\n    }\n    if (route.requiresTunnel() && rawSocket == null) {\n        ProtocolException exception = new ProtocolException(\"Too many tunnel connections attempted: \" + MAX_TUNNEL_ATTEMPTS);\n        throw new RouteException(exception);\n    }\n    if (http2Connection != null) {\n        synchronized (connectionPool) {\n            allocationLimit = http2Connection.maxConcurrentStreams();\n        }\n    }\n}"
    },
    {
      "commit": "1c98464839434a0fe7c7581cdae44bd3f2e6edd3",
      "startLine": 4,
      "endLine": 15,
      "methodCode": "public void connect(int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled, Call call, EventListener eventListener) {\n    if (protocol != null)\n        throw new IllegalStateException(\"already connected\");\n    RouteException routeException = null;\n    List<ConnectionSpec> connectionSpecs = route.address().connectionSpecs();\n    ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);\n    if (route.address().sslSocketFactory() == null) {\n        if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n            throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not enabled for client\"));\n        }\n        String host = route.address().url().host();\n        if (!Platform.get().isCleartextTrafficPermitted(host)) {\n            throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n        }\n    }\n    while (true) {\n        try {\n            if (route.requiresTunnel()) {\n                connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);\n                if (rawSocket == null) {\n                    break;\n                }\n            } else {\n                connectSocket(connectTimeout, readTimeout, call, eventListener);\n            }\n            establishProtocol(connectionSpecSelector, call, eventListener);\n            eventListener.connectEnd(call, route.socketAddress(), route.proxy(), protocol);\n            break;\n        } catch (IOException e) {\n            closeQuietly(socket);\n            closeQuietly(rawSocket);\n            socket = null;\n            rawSocket = null;\n            source = null;\n            sink = null;\n            handshake = null;\n            protocol = null;\n            http2Connection = null;\n            eventListener.connectFailed(call, route.socketAddress(), route.proxy(), null, e);\n            if (routeException == null) {\n                routeException = new RouteException(e);\n            } else {\n                routeException.addConnectException(e);\n            }\n            if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                throw routeException;\n            }\n        }\n    }\n    if (route.requiresTunnel() && rawSocket == null) {\n        ProtocolException exception = new ProtocolException(\"Too many tunnel connections attempted: \" + MAX_TUNNEL_ATTEMPTS);\n        throw new RouteException(exception);\n    }\n    if (http2Connection != null) {\n        synchronized (connectionPool) {\n            allocationLimit = http2Connection.maxConcurrentStreams();\n        }\n    }\n}"
    },
    {
      "commit": "29267ac4e8eae099064483dc4c4b246690a92009",
      "startLine": 4,
      "endLine": 15,
      "methodCode": "public void connect(int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled, Call call, EventListener eventListener) {\n    if (protocol != null)\n        throw new IllegalStateException(\"already connected\");\n    RouteException routeException = null;\n    List<ConnectionSpec> connectionSpecs = route.address().connectionSpecs();\n    ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);\n    if (route.address().sslSocketFactory() == null) {\n        if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n            throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not enabled for client\"));\n        }\n        String host = route.address().url().host();\n        if (!Platform.get().isCleartextTrafficPermitted(host)) {\n            throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n        }\n    }\n    while (true) {\n        try {\n            if (route.requiresTunnel()) {\n                connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);\n                if (rawSocket == null) {\n                    break;\n                }\n            } else {\n                connectSocket(connectTimeout, readTimeout, call, eventListener);\n            }\n            establishProtocol(connectionSpecSelector, call, eventListener);\n            eventListener.connectEnd(call, route.socketAddress(), route.proxy(), protocol, null);\n            break;\n        } catch (IOException e) {\n            closeQuietly(socket);\n            closeQuietly(rawSocket);\n            socket = null;\n            rawSocket = null;\n            source = null;\n            sink = null;\n            handshake = null;\n            protocol = null;\n            http2Connection = null;\n            eventListener.connectEnd(call, route.socketAddress(), route.proxy(), null, e);\n            if (routeException == null) {\n                routeException = new RouteException(e);\n            } else {\n                routeException.addConnectException(e);\n            }\n            if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                throw routeException;\n            }\n        }\n    }\n    if (route.requiresTunnel() && rawSocket == null) {\n        ProtocolException exception = new ProtocolException(\"Too many tunnel connections attempted: \" + MAX_TUNNEL_ATTEMPTS);\n        throw new RouteException(exception);\n    }\n    if (http2Connection != null) {\n        synchronized (connectionPool) {\n            allocationLimit = http2Connection.maxConcurrentStreams();\n        }\n    }\n}"
    },
    {
      "commit": "c7d508b79c9e201c91ec23f5eec47c18be206567",
      "startLine": 4,
      "endLine": 15,
      "methodCode": "public void connect(int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled, Call call, EventListener eventListener) {\n    if (protocol != null)\n        throw new IllegalStateException(\"already connected\");\n    RouteException routeException = null;\n    List<ConnectionSpec> connectionSpecs = route.address().connectionSpecs();\n    ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);\n    if (route.address().sslSocketFactory() == null) {\n        if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n            throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not enabled for client\"));\n        }\n        String host = route.address().url().host();\n        if (!Platform.get().isCleartextTrafficPermitted(host)) {\n            throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n        }\n    }\n    while (true) {\n        try {\n            if (route.requiresTunnel()) {\n                connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);\n                if (rawSocket == null) {\n                    break;\n                }\n            } else {\n                connectSocket(connectTimeout, readTimeout, call, eventListener);\n            }\n            establishProtocol(connectionSpecSelector, call, eventListener);\n            eventListener.connectEnd(call, route.socketAddress(), protocol, null);\n            break;\n        } catch (IOException e) {\n            closeQuietly(socket);\n            closeQuietly(rawSocket);\n            socket = null;\n            rawSocket = null;\n            source = null;\n            sink = null;\n            handshake = null;\n            protocol = null;\n            http2Connection = null;\n            eventListener.connectEnd(call, route.socketAddress(), null, e);\n            if (routeException == null) {\n                routeException = new RouteException(e);\n            } else {\n                routeException.addConnectException(e);\n            }\n            if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                throw routeException;\n            }\n        }\n    }\n    if (route.requiresTunnel() && rawSocket == null) {\n        ProtocolException exception = new ProtocolException(\"Too many tunnel connections attempted: \" + MAX_TUNNEL_ATTEMPTS);\n        throw new RouteException(exception);\n    }\n    if (http2Connection != null) {\n        synchronized (connectionPool) {\n            allocationLimit = http2Connection.maxConcurrentStreams();\n        }\n    }\n}"
    },
    {
      "commit": "5fb5ab50a77efc761489493d4a0b8b9de85feec7",
      "startLine": 4,
      "endLine": 15,
      "methodCode": "public void connect(int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled, Call call, EventListener eventListener) {\n    if (protocol != null)\n        throw new IllegalStateException(\"already connected\");\n    RouteException routeException = null;\n    List<ConnectionSpec> connectionSpecs = route.address().connectionSpecs();\n    ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);\n    if (route.address().sslSocketFactory() == null) {\n        if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n            throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not enabled for client\"));\n        }\n        String host = route.address().url().host();\n        if (!Platform.get().isCleartextTrafficPermitted(host)) {\n            throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n        }\n    }\n    while (true) {\n        try {\n            if (route.requiresTunnel()) {\n                connectTunnel(connectTimeout, readTimeout, writeTimeout);\n            } else {\n                connectSocket(connectTimeout, readTimeout);\n            }\n            establishProtocol(connectionSpecSelector, call, eventListener);\n            break;\n        } catch (IOException e) {\n            closeQuietly(socket);\n            closeQuietly(rawSocket);\n            socket = null;\n            rawSocket = null;\n            source = null;\n            sink = null;\n            handshake = null;\n            protocol = null;\n            http2Connection = null;\n            if (routeException == null) {\n                routeException = new RouteException(e);\n            } else {\n                routeException.addConnectException(e);\n            }\n            if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                throw routeException;\n            }\n        }\n    }\n    if (http2Connection != null) {\n        synchronized (connectionPool) {\n            allocationLimit = http2Connection.maxConcurrentStreams();\n        }\n    }\n}"
    },
    {
      "commit": "98443a9ca8ca9ad82d5fb9b05b32f180bb510601",
      "startLine": 4,
      "endLine": 15,
      "methodCode": "public void connect(int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled) {\n    if (protocol != null)\n        throw new IllegalStateException(\"already connected\");\n    RouteException routeException = null;\n    List<ConnectionSpec> connectionSpecs = route.address().connectionSpecs();\n    ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);\n    if (route.address().sslSocketFactory() == null) {\n        if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n            throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not enabled for client\"));\n        }\n        String host = route.address().url().host();\n        if (!Platform.get().isCleartextTrafficPermitted(host)) {\n            throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n        }\n    }\n    while (true) {\n        try {\n            if (route.requiresTunnel()) {\n                connectTunnel(connectTimeout, readTimeout, writeTimeout);\n            } else {\n                connectSocket(connectTimeout, readTimeout);\n            }\n            establishProtocol(connectionSpecSelector);\n            break;\n        } catch (IOException e) {\n            closeQuietly(socket);\n            closeQuietly(rawSocket);\n            socket = null;\n            rawSocket = null;\n            source = null;\n            sink = null;\n            handshake = null;\n            protocol = null;\n            http2Connection = null;\n            if (routeException == null) {\n                routeException = new RouteException(e);\n            } else {\n                routeException.addConnectException(e);\n            }\n            if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                throw routeException;\n            }\n        }\n    }\n    if (http2Connection != null) {\n        synchronized (connectionPool) {\n            allocationLimit = http2Connection.maxConcurrentStreams();\n        }\n    }\n}"
    },
    {
      "commit": "8331b2d75a51631bee622daf2175854fe49ce29a",
      "startLine": 4,
      "endLine": 14,
      "methodCode": "public void connect(int connectTimeout, int readTimeout, int writeTimeout, List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) {\n    if (protocol != null)\n        throw new IllegalStateException(\"already connected\");\n    RouteException routeException = null;\n    ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);\n    if (route.address().sslSocketFactory() == null) {\n        if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n            throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not enabled for client\"));\n        }\n        String host = route.address().url().host();\n        if (!Platform.get().isCleartextTrafficPermitted(host)) {\n            throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n        }\n    }\n    while (true) {\n        try {\n            if (route.requiresTunnel()) {\n                connectTunnel(connectTimeout, readTimeout, writeTimeout);\n            } else {\n                connectSocket(connectTimeout, readTimeout);\n            }\n            establishProtocol(connectionSpecSelector);\n            break;\n        } catch (IOException e) {\n            closeQuietly(socket);\n            closeQuietly(rawSocket);\n            socket = null;\n            rawSocket = null;\n            source = null;\n            sink = null;\n            handshake = null;\n            protocol = null;\n            http2Connection = null;\n            if (routeException == null) {\n                routeException = new RouteException(e);\n            } else {\n                routeException.addConnectException(e);\n            }\n            if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                throw routeException;\n            }\n        }\n    }\n    if (http2Connection != null) {\n        synchronized (connectionPool) {\n            allocationLimit = http2Connection.maxConcurrentStreams();\n        }\n    }\n}"
    },
    {
      "commit": "1f58b14bd18565b3dc4aaf15c072033e68b69660",
      "startLine": 4,
      "endLine": 14,
      "methodCode": "public void connect(int connectTimeout, int readTimeout, int writeTimeout, List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) {\n    if (protocol != null)\n        throw new IllegalStateException(\"already connected\");\n    RouteException routeException = null;\n    ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);\n    if (route.address().sslSocketFactory() == null) {\n        if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n            throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not enabled for client\"));\n        }\n        String host = route.address().url().host();\n        if (!Platform.get().isCleartextTrafficPermitted(host)) {\n            throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n        }\n    }\n    while (protocol == null) {\n        try {\n            if (route.requiresTunnel()) {\n                buildTunneledConnection(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n            } else {\n                buildConnection(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n            }\n        } catch (IOException e) {\n            closeQuietly(socket);\n            closeQuietly(rawSocket);\n            socket = null;\n            rawSocket = null;\n            source = null;\n            sink = null;\n            handshake = null;\n            protocol = null;\n            if (routeException == null) {\n                routeException = new RouteException(e);\n            } else {\n                routeException.addConnectException(e);\n            }\n            if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                throw routeException;\n            }\n        }\n    }\n}"
    },
    {
      "commit": "c5187583bbfe93fe58db80f95b5b478c84180c29",
      "startLine": 4,
      "endLine": 8,
      "methodCode": "public void connect(int connectTimeout, int readTimeout, int writeTimeout, List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) {\n    if (protocol != null)\n        throw new IllegalStateException(\"already connected\");\n    RouteException routeException = null;\n    ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);\n    if (route.address().sslSocketFactory() == null && !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n        throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not supported: \" + connectionSpecs));\n    }\n    while (protocol == null) {\n        try {\n            if (route.requiresTunnel()) {\n                buildTunneledConnection(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n            } else {\n                buildConnection(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n            }\n        } catch (IOException e) {\n            closeQuietly(socket);\n            closeQuietly(rawSocket);\n            socket = null;\n            rawSocket = null;\n            source = null;\n            sink = null;\n            handshake = null;\n            protocol = null;\n            if (routeException == null) {\n                routeException = new RouteException(e);\n            } else {\n                routeException.addConnectException(e);\n            }\n            if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                throw routeException;\n            }\n        }\n    }\n}"
    },
    {
      "commit": "576408374d58a3e9a63714b6f7761cb42a315102",
      "startLine": 4,
      "endLine": 8,
      "methodCode": "public void connect(int connectTimeout, int readTimeout, int writeTimeout, List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) {\n    if (protocol != null)\n        throw new IllegalStateException(\"already connected\");\n    RouteException routeException = null;\n    ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);\n    if (route.address().sslSocketFactory() == null && !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n        throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not supported: \" + connectionSpecs));\n    }\n    while (protocol == null) {\n        try {\n            if (route.requiresTunnel()) {\n                buildTunneledConnection(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n            } else {\n                buildConnection(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n            }\n        } catch (IOException e) {\n            closeQuietly(socket);\n            closeQuietly(rawSocket);\n            socket = null;\n            rawSocket = null;\n            source = null;\n            sink = null;\n            handshake = null;\n            protocol = null;\n            if (routeException == null) {\n                routeException = new RouteException(e);\n            } else {\n                routeException.addConnectException(e);\n            }\n            if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                throw routeException;\n            }\n        }\n    }\n}"
    },
    {
      "commit": "03a840de533b1f1c201aa4e99f95f42f9a8269a4",
      "startLine": 4,
      "endLine": 8,
      "methodCode": "public void connect(int connectTimeout, int readTimeout, int writeTimeout, List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n    if (protocol != null)\n        throw new IllegalStateException(\"already connected\");\n    RouteException routeException = null;\n    ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);\n    if (route.address().sslSocketFactory() == null && !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n        throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not supported: \" + connectionSpecs));\n    }\n    while (protocol == null) {\n        try {\n            if (route.requiresTunnel()) {\n                buildTunneledConnection(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n            } else {\n                buildConnection(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n            }\n        } catch (IOException e) {\n            closeQuietly(socket);\n            closeQuietly(rawSocket);\n            socket = null;\n            rawSocket = null;\n            source = null;\n            sink = null;\n            handshake = null;\n            protocol = null;\n            if (routeException == null) {\n                routeException = new RouteException(e);\n            } else {\n                routeException.addConnectException(e);\n            }\n            if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                throw routeException;\n            }\n        }\n    }\n}"
    },
    {
      "commit": "c9a89876de476983f273edbf108c365127c18c5e",
      "startLine": 4,
      "endLine": 10,
      "methodCode": "public void connect(int connectTimeout, int readTimeout, int writeTimeout, List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n    if (protocol != null)\n        throw new IllegalStateException(\"already connected\");\n    RouteException routeException = null;\n    ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);\n    Proxy proxy = route.proxy();\n    Address address = route.address();\n    if (route.address().sslSocketFactory() == null && !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n        throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not supported: \" + connectionSpecs));\n    }\n    while (protocol == null) {\n        try {\n            rawSocket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP ? address.socketFactory().createSocket() : new Socket(proxy);\n            connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n        } catch (IOException e) {\n            closeQuietly(socket);\n            closeQuietly(rawSocket);\n            socket = null;\n            rawSocket = null;\n            source = null;\n            sink = null;\n            handshake = null;\n            protocol = null;\n            if (routeException == null) {\n                routeException = new RouteException(e);\n            } else {\n                routeException.addConnectException(e);\n            }\n            if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                throw routeException;\n            }\n        }\n    }\n}"
    },
    {
      "commit": "b63841d3a3922440c258098190371f1e17d977c1",
      "startLine": 4,
      "endLine": 10,
      "methodCode": "public void connect(int connectTimeout, int readTimeout, int writeTimeout, List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n    if (protocol != null)\n        throw new IllegalStateException(\"already connected\");\n    RouteException routeException = null;\n    ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);\n    Proxy proxy = route.proxy();\n    Address address = route.address();\n    if (route.address().sslSocketFactory() == null && !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n        throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not supported: \" + connectionSpecs));\n    }\n    while (protocol == null) {\n        try {\n            rawSocket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP ? address.socketFactory().createSocket() : new Socket(proxy);\n            connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n        } catch (IOException e) {\n            Util.closeQuietly(socket);\n            Util.closeQuietly(rawSocket);\n            socket = null;\n            rawSocket = null;\n            source = null;\n            sink = null;\n            handshake = null;\n            protocol = null;\n            if (routeException == null) {\n                routeException = new RouteException(e);\n            } else {\n                routeException.addConnectException(e);\n            }\n            if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                throw routeException;\n            }\n        }\n    }\n}"
    },
    {
      "commit": "71ae4df298f42039579fd6e3c6d9d9060ac91214",
      "startLine": 4,
      "endLine": 10,
      "methodCode": "public void connect(int connectTimeout, int readTimeout, int writeTimeout, List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n    if (protocol != null)\n        throw new IllegalStateException(\"already connected\");\n    RouteException routeException = null;\n    ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);\n    Proxy proxy = route.proxy();\n    Address address = route.address();\n    if (route.address().getSslSocketFactory() == null && !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n        throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not supported: \" + connectionSpecs));\n    }\n    while (protocol == null) {\n        try {\n            rawSocket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP ? address.getSocketFactory().createSocket() : new Socket(proxy);\n            connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n        } catch (IOException e) {\n            Util.closeQuietly(socket);\n            Util.closeQuietly(rawSocket);\n            socket = null;\n            rawSocket = null;\n            source = null;\n            sink = null;\n            handshake = null;\n            protocol = null;\n            if (routeException == null) {\n                routeException = new RouteException(e);\n            } else {\n                routeException.addConnectException(e);\n            }\n            if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                throw routeException;\n            }\n        }\n    }\n}"
    },
    {
      "commit": "c5f58e45454d1ffc621c65e377cb91345018e087",
      "startLine": 4,
      "endLine": 10,
      "methodCode": "public void connect(int connectTimeout, int readTimeout, int writeTimeout, List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n    if (protocol != null)\n        throw new IllegalStateException(\"already connected\");\n    RouteException routeException = null;\n    ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);\n    Proxy proxy = route.getProxy();\n    Address address = route.getAddress();\n    if (route.getAddress().getSslSocketFactory() == null && !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n        throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not supported: \" + connectionSpecs));\n    }\n    while (protocol == null) {\n        try {\n            rawSocket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP ? address.getSocketFactory().createSocket() : new Socket(proxy);\n            connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n        } catch (IOException e) {\n            Util.closeQuietly(socket);\n            Util.closeQuietly(rawSocket);\n            socket = null;\n            rawSocket = null;\n            source = null;\n            sink = null;\n            handshake = null;\n            protocol = null;\n            if (routeException == null) {\n                routeException = new RouteException(e);\n            } else {\n                routeException.addConnectException(e);\n            }\n            if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                throw routeException;\n            }\n        }\n    }\n}"
    },
    {
      "commit": "ee87f8036f99fdfd63f8ef145f4478907682db29",
      "startLine": 4,
      "endLine": 10,
      "methodCode": "public void connect(int connectTimeout, int readTimeout, int writeTimeout, List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n    if (protocol != null)\n        throw new IllegalStateException(\"already connected\");\n    RouteException routeException = null;\n    ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);\n    Proxy proxy = route.getProxy();\n    Address address = route.getAddress();\n    if (route.getAddress().getSslSocketFactory() == null && !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n        throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not supported: \" + connectionSpecs));\n    }\n    while (protocol == null) {\n        try {\n            rawSocket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP ? address.getSocketFactory().createSocket() : new Socket(proxy);\n            connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n        } catch (IOException e) {\n            Util.closeQuietly(socket);\n            Util.closeQuietly(rawSocket);\n            socket = null;\n            rawSocket = null;\n            source = null;\n            sink = null;\n            handshake = null;\n            protocol = null;\n            framedConnection = null;\n            if (routeException == null) {\n                routeException = new RouteException(e);\n            } else {\n                routeException.addConnectException(e);\n            }\n            if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                throw routeException;\n            }\n        }\n    }\n}"
    },
    {
      "commit": "c358656c8799d30fd422448153e99a5dd37e298a",
      "startLine": 4,
      "endLine": 10,
      "methodCode": "public void connect(int connectTimeout, int readTimeout, int writeTimeout, List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n    if (protocol != null)\n        throw new IllegalStateException(\"already connected\");\n    RouteException routeException = null;\n    ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);\n    Proxy proxy = route.getProxy();\n    Address address = route.getAddress();\n    if (route.getAddress().getSslSocketFactory() == null && !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n        throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not supported: \" + connectionSpecs));\n    }\n    while (protocol == null) {\n        try {\n            socket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP ? address.getSocketFactory().createSocket() : new Socket(proxy);\n            connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n        } catch (IOException e) {\n            Util.closeQuietly(socket);\n            socket = null;\n            source = null;\n            sink = null;\n            handshake = null;\n            protocol = null;\n            framedConnection = null;\n            if (routeException == null) {\n                routeException = new RouteException(e);\n            } else {\n                routeException.addConnectException(e);\n            }\n            if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                throw routeException;\n            }\n        }\n    }\n}"
    },
    {
      "commit": "529c4a36bb21b3fb7717c27f8a31c39c1b603e9d",
      "startLine": 4,
      "endLine": 10,
      "methodCode": "void connect(int connectTimeout, int readTimeout, int writeTimeout, List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n    if (protocol != null)\n        throw new IllegalStateException(\"already connected\");\n    RouteException routeException = null;\n    ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);\n    Proxy proxy = route.getProxy();\n    Address address = route.getAddress();\n    if (route.address.getSslSocketFactory() == null && !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n        throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not supported: \" + connectionSpecs));\n    }\n    while (protocol == null) {\n        try {\n            socket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP ? address.getSocketFactory().createSocket() : new Socket(proxy);\n            connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n        } catch (IOException e) {\n            Util.closeQuietly(socket);\n            socket = null;\n            handshake = null;\n            protocol = null;\n            httpConnection = null;\n            framedConnection = null;\n            if (routeException == null) {\n                routeException = new RouteException(e);\n            } else {\n                routeException.addConnectException(e);\n            }\n            if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                throw routeException;\n            }\n        }\n    }\n}"
    },
    {
      "commit": "457fb428a729c50c562822571ea9b13e689648f3",
      "startLine": 4,
      "endLine": 10,
      "methodCode": "void connect(int connectTimeout, int readTimeout, int writeTimeout, List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n    if (connected)\n        throw new IllegalStateException(\"already connected\");\n    RouteException routeException = null;\n    ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);\n    Proxy proxy = route.getProxy();\n    Address address = route.getAddress();\n    if (route.address.getSslSocketFactory() == null && !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n        throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not supported: \" + connectionSpecs));\n    }\n    while (!connected) {\n        try {\n            socket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP ? address.getSocketFactory().createSocket() : new Socket(proxy);\n            connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n            connected = true;\n        } catch (IOException e) {\n            Util.closeQuietly(socket);\n            socket = null;\n            if (routeException == null) {\n                routeException = new RouteException(e);\n            } else {\n                routeException.addConnectException(e);\n            }\n            if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                throw routeException;\n            }\n        }\n    }\n}"
    },
    {
      "commit": "b42e73f497eafe147667117202267ec756adff26",
      "startLine": 4,
      "endLine": 10,
      "methodCode": "void connect(int connectTimeout, int readTimeout, int writeTimeout, Request request, List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n    if (connected)\n        throw new IllegalStateException(\"already connected\");\n    RouteException routeException = null;\n    ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);\n    Proxy proxy = route.getProxy();\n    Address address = route.getAddress();\n    if (route.address.getSslSocketFactory() == null && !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n        throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not supported: \" + connectionSpecs));\n    }\n    while (!connected) {\n        try {\n            socket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP ? address.getSocketFactory().createSocket() : new Socket(proxy);\n            connectSocket(connectTimeout, readTimeout, writeTimeout, request, connectionSpecSelector);\n            connected = true;\n        } catch (IOException e) {\n            Util.closeQuietly(socket);\n            socket = null;\n            if (routeException == null) {\n                routeException = new RouteException(e);\n            } else {\n                routeException.addConnectException(e);\n            }\n            if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                throw routeException;\n            }\n        }\n    }\n}"
    },
    {
      "commit": "c753d2e41ba667f9b5a31451a16ecbaecdc65d80",
      "startLine": 9,
      "endLine": 11,
      "methodCode": "void connect(int connectTimeout, int readTimeout, int writeTimeout, Request request, List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n    if (connected)\n        throw new IllegalStateException(\"already connected\");\n    SocketConnector socketConnector = new SocketConnector(this, pool);\n    SocketConnector.ConnectedSocket connectedSocket;\n    if (route.address.getSslSocketFactory() != null) {\n        connectedSocket = socketConnector.connectTls(connectTimeout, readTimeout, writeTimeout, request, route, connectionSpecs, connectionRetryEnabled);\n    } else {\n        if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n            throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not supported: \" + connectionSpecs));\n        }\n        connectedSocket = socketConnector.connectCleartext(connectTimeout, readTimeout, route);\n    }\n    socket = connectedSocket.socket;\n    handshake = connectedSocket.handshake;\n    protocol = connectedSocket.alpnProtocol == null ? Protocol.HTTP_1_1 : connectedSocket.alpnProtocol;\n    try {\n        if (protocol == Protocol.SPDY_3 || protocol == Protocol.HTTP_2) {\n            socket.setSoTimeout(0);\n            framedConnection = new FramedConnection.Builder(route.address.uriHost, true, socket).protocol(protocol).build();\n            framedConnection.sendConnectionPreface();\n        } else {\n            httpConnection = new HttpConnection(pool, this, socket);\n        }\n    } catch (IOException e) {\n        throw new RouteException(e);\n    }\n    connected = true;\n}"
    },
    {
      "commit": "60f5406dcc094d0431420139bd002e8bdd4ea5d5",
      "startLine": 9,
      "endLine": 11,
      "methodCode": "void connect(int connectTimeout, int readTimeout, int writeTimeout, Request request, List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n    if (connected)\n        throw new IllegalStateException(\"already connected\");\n    SocketConnector socketConnector = new SocketConnector(this, pool);\n    SocketConnector.ConnectedSocket connectedSocket;\n    if (route.address.getSslSocketFactory() != null) {\n        connectedSocket = socketConnector.connectTls(connectTimeout, readTimeout, writeTimeout, request, route, connectionSpecs, connectionRetryEnabled);\n    } else {\n        if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n            throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not supported: \" + connectionSpecs));\n        }\n        connectedSocket = socketConnector.connectCleartext(connectTimeout, readTimeout, route);\n    }\n    socket = connectedSocket.socket;\n    handshake = connectedSocket.handshake;\n    protocol = connectedSocket.alpnProtocol == null ? Protocol.HTTP_1_1 : connectedSocket.alpnProtocol;\n    try {\n        if (protocol == Protocol.SPDY_3 || protocol == Protocol.HTTP_2) {\n            socket.setSoTimeout(0);\n            spdyConnection = new SpdyConnection.Builder(route.address.uriHost, true, socket).protocol(protocol).build();\n            spdyConnection.sendConnectionPreface();\n        } else {\n            httpConnection = new HttpConnection(pool, this, socket);\n        }\n    } catch (IOException e) {\n        throw new RouteException(e);\n    }\n    connected = true;\n}"
    }
  ]
}