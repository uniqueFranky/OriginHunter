{
  "statementVersions": [
    {
      "commit": "427dd53b9ebedcb0bdb687007eb0faf2de734df4",
      "startLine": 12,
      "endLine": 26,
      "methodCode": "protected ResolvedType convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n    if (context == null) {\n        throw new NullPointerException(\"Context should not be null\");\n    }\n    if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n        String name = qName(classOrInterfaceType);\n        SymbolReference<ResolvedTypeDeclaration> ref = context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        ResolvedTypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<ResolvedType> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return ResolvedPrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType = (WildcardType) type;\n        if (wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context));\n        } else if (!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context));\n        } else if (!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return ResolvedVoidType.INSTANCE;\n    } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n        com.github.javaparser.ast.type.ArrayType jpArrayType = (com.github.javaparser.ast.type.ArrayType) type;\n        return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n    } else if (type instanceof UnionType) {\n        UnionType unionType = (UnionType) type;\n        return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n    } else if (type instanceof VarType) {\n        Node parent = type.getParentNode().get();\n        if (!(parent instanceof VariableDeclarator)) {\n            throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n        }\n        final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n        return variableDeclarator.getInitializer().map(Expression::calculateResolvedType).orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}"
    },
    {
      "commit": "6d59e3083ed82de3490c2f5ca35a07bb73806fea",
      "startLine": 12,
      "endLine": 26,
      "methodCode": "protected ResolvedType convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n    if (context == null) {\n        throw new NullPointerException(\"Context should not be null\");\n    }\n    if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n        String name = qName(classOrInterfaceType);\n        SymbolReference<ResolvedTypeDeclaration> ref = context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        ResolvedTypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<ResolvedType> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return ResolvedPrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType = (WildcardType) type;\n        if (wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context));\n        } else if (!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context));\n        } else if (!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return ResolvedVoidType.INSTANCE;\n    } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n        com.github.javaparser.ast.type.ArrayType jpArrayType = (com.github.javaparser.ast.type.ArrayType) type;\n        return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n    } else if (type instanceof UnionType) {\n        UnionType unionType = (UnionType) type;\n        return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n    } else if (type instanceof VarType) {\n        final VariableDeclarator variableDeclarator = (VariableDeclarator) type.getParentNode().get();\n        return variableDeclarator.getInitializer().get().calculateResolvedType();\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}"
    },
    {
      "commit": "b54617e765d73b3ce0d187cf12ad8da382bce439",
      "startLine": 12,
      "endLine": 26,
      "methodCode": "protected ResolvedType convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n    if (context == null) {\n        throw new NullPointerException(\"Context should not be null\");\n    }\n    if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n        String name = qName(classOrInterfaceType);\n        SymbolReference<ResolvedTypeDeclaration> ref = context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        ResolvedTypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<ResolvedType> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return ResolvedPrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType = (WildcardType) type;\n        if (wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context));\n        } else if (!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context));\n        } else if (!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return ResolvedVoidType.INSTANCE;\n    } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n        com.github.javaparser.ast.type.ArrayType jpArrayType = (com.github.javaparser.ast.type.ArrayType) type;\n        return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n    } else if (type instanceof UnionType) {\n        UnionType unionType = (UnionType) type;\n        return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}"
    },
    {
      "commit": "09232ff6b0ea19e850482f3a87ac6ef1c063c759",
      "startLine": 12,
      "endLine": 26,
      "methodCode": "protected ResolvedType convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n    if (context == null) {\n        throw new NullPointerException(\"Context should not be null\");\n    }\n    if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n        String name = qName(classOrInterfaceType);\n        SymbolReference<ResolvedTypeDeclaration> ref = context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        ResolvedTypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<ResolvedType> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return ResolvedPrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType = (WildcardType) type;\n        if (wildcardType.getExtendedTypes().isPresent() && !wildcardType.getSuperTypes().isPresent()) {\n            return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context));\n        } else if (!wildcardType.getExtendedTypes().isPresent() && wildcardType.getSuperTypes().isPresent()) {\n            return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context));\n        } else if (!wildcardType.getExtendedTypes().isPresent() && !wildcardType.getSuperTypes().isPresent()) {\n            return ResolvedWildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return ResolvedVoidType.INSTANCE;\n    } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n        com.github.javaparser.ast.type.ArrayType jpArrayType = (com.github.javaparser.ast.type.ArrayType) type;\n        return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n    } else if (type instanceof UnionType) {\n        UnionType unionType = (UnionType) type;\n        return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}"
    },
    {
      "commit": "f63811a47591d89b25a1de78686bdc6dfcaf42b9",
      "startLine": 12,
      "endLine": 26,
      "methodCode": "protected ResolvedType convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n    if (context == null) {\n        throw new NullPointerException(\"Context should not be null\");\n    }\n    if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n        String name = qName(classOrInterfaceType);\n        SymbolReference<ResolvedTypeDeclaration> ref = context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        ResolvedTypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<ResolvedType> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return ResolvedPrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType = (WildcardType) type;\n        if (wildcardType.getExtendedTypes().isPresent() && !wildcardType.getSuperTypes().isPresent()) {\n            return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context));\n        } else if (!wildcardType.getExtendedTypes().isPresent() && wildcardType.getSuperTypes().isPresent()) {\n            return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context));\n        } else if (!wildcardType.getExtendedTypes().isPresent() && !wildcardType.getSuperTypes().isPresent()) {\n            return ResolvedWildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return ResolvedVoidType.INSTANCE;\n    } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n        com.github.javaparser.ast.type.ArrayType jpArrayType = (com.github.javaparser.ast.type.ArrayType) type;\n        return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n    } else if (type instanceof UnionType) {\n        UnionType unionType = (UnionType) type;\n        return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}"
    },
    {
      "commit": "478a9ba268137913d67438b1e3c8f61e5e0976a5",
      "startLine": 12,
      "endLine": 26,
      "methodCode": "protected ResolvedType convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n    if (context == null) {\n        throw new NullPointerException(\"Context should not be null\");\n    }\n    if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n        String name = qName(classOrInterfaceType);\n        SymbolReference<ResolvedTypeDeclaration> ref = context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        ResolvedTypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<ResolvedType> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return ResolvedPrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType = (WildcardType) type;\n        if (wildcardType.getExtendedTypes().isPresent() && !wildcardType.getSuperTypes().isPresent()) {\n            return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context));\n        } else if (!wildcardType.getExtendedTypes().isPresent() && wildcardType.getSuperTypes().isPresent()) {\n            return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context));\n        } else if (!wildcardType.getExtendedTypes().isPresent() && !wildcardType.getSuperTypes().isPresent()) {\n            return ResolvedWildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return ResolvedVoidType.INSTANCE;\n    } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n        com.github.javaparser.ast.type.ArrayType jpArrayType = (com.github.javaparser.ast.type.ArrayType) type;\n        return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}"
    },
    {
      "commit": "198ba6cbe49832ac09ca84c6920e9be661a3b56a",
      "startLine": 9,
      "endLine": 23,
      "methodCode": "protected ResolvedType convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n    if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n        String name = qName(classOrInterfaceType);\n        SymbolReference<ResolvedTypeDeclaration> ref = context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        ResolvedTypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<ResolvedType> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return ResolvedPrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType = (WildcardType) type;\n        if (wildcardType.getExtendedTypes().isPresent() && !wildcardType.getSuperTypes().isPresent()) {\n            return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context));\n        } else if (!wildcardType.getExtendedTypes().isPresent() && wildcardType.getSuperTypes().isPresent()) {\n            return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context));\n        } else if (!wildcardType.getExtendedTypes().isPresent() && !wildcardType.getSuperTypes().isPresent()) {\n            return ResolvedWildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return ResolvedVoidType.INSTANCE;\n    } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n        com.github.javaparser.ast.type.ArrayType jpArrayType = (com.github.javaparser.ast.type.ArrayType) type;\n        return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}"
    },
    {
      "commit": "5d8d0cb7947efcf2282f7d056302dd905f348532",
      "startLine": 9,
      "endLine": 23,
      "methodCode": "protected ResolvedType convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n    if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n        String name = qName(classOrInterfaceType);\n        SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<ResolvedType> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof TypeParameterDeclaration) {\n                return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType = (WildcardType) type;\n        if (wildcardType.getExtendedTypes().isPresent() && !wildcardType.getSuperTypes().isPresent()) {\n            return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context));\n        } else if (!wildcardType.getExtendedTypes().isPresent() && wildcardType.getSuperTypes().isPresent()) {\n            return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context));\n        } else if (!wildcardType.getExtendedTypes().isPresent() && !wildcardType.getSuperTypes().isPresent()) {\n            return ResolvedWildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return ResolvedVoidType.INSTANCE;\n    } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n        com.github.javaparser.ast.type.ArrayType jpArrayType = (com.github.javaparser.ast.type.ArrayType) type;\n        return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}"
    },
    {
      "commit": "56377a22d552f0880ceccacf1aca1eafbc7094e4",
      "startLine": 9,
      "endLine": 23,
      "methodCode": "protected Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n    if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n        String name = qName(classOrInterfaceType);\n        SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<Type> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof TypeParameterDeclaration) {\n                return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType = (WildcardType) type;\n        if (wildcardType.getExtendedTypes().isPresent() && !wildcardType.getSuperTypes().isPresent()) {\n            return Wildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context));\n        } else if (!wildcardType.getExtendedTypes().isPresent() && wildcardType.getSuperTypes().isPresent()) {\n            return Wildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context));\n        } else if (!wildcardType.getExtendedTypes().isPresent() && !wildcardType.getSuperTypes().isPresent()) {\n            return Wildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return VoidType.INSTANCE;\n    } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n        com.github.javaparser.ast.type.ArrayType jpArrayType = (com.github.javaparser.ast.type.ArrayType) type;\n        return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}"
    },
    {
      "commit": "0f40221492b47df25615a1b5909fefa6f2d6fa0e",
      "startLine": 9,
      "endLine": 23,
      "methodCode": "public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n    if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n        String name = qName(classOrInterfaceType);\n        SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<Type> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof TypeParameterDeclaration) {\n                return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType = (WildcardType) type;\n        if (wildcardType.getExtendedTypes().isPresent() && !wildcardType.getSuperTypes().isPresent()) {\n            return Wildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context));\n        } else if (!wildcardType.getExtendedTypes().isPresent() && wildcardType.getSuperTypes().isPresent()) {\n            return Wildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context));\n        } else if (!wildcardType.getExtendedTypes().isPresent() && !wildcardType.getSuperTypes().isPresent()) {\n            return Wildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return VoidType.INSTANCE;\n    } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n        com.github.javaparser.ast.type.ArrayType jpArrayType = (com.github.javaparser.ast.type.ArrayType) type;\n        return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}"
    },
    {
      "commit": "33d37d1089463ba9af543996a05cac5955c46251",
      "startLine": 9,
      "endLine": 23,
      "methodCode": "private Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n    if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n        String name = qName(classOrInterfaceType);\n        SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<Type> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof TypeParameterDeclaration) {\n                return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType = (WildcardType) type;\n        if (wildcardType.getExtendedTypes().isPresent() && !wildcardType.getSuperTypes().isPresent()) {\n            return Wildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context));\n        } else if (!wildcardType.getExtendedTypes().isPresent() && wildcardType.getSuperTypes().isPresent()) {\n            return Wildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context));\n        } else if (!wildcardType.getExtendedTypes().isPresent() && !wildcardType.getSuperTypes().isPresent()) {\n            return Wildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return VoidType.INSTANCE;\n    } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n        com.github.javaparser.ast.type.ArrayType jpArrayType = (com.github.javaparser.ast.type.ArrayType) type;\n        return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}"
    },
    {
      "commit": "90c22f84a61e12130a8750d235acf7ed06305796",
      "startLine": 9,
      "endLine": 23,
      "methodCode": "private Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n    if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n        String name = qName(classOrInterfaceType);\n        SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<Type> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof TypeParameterDeclaration) {\n                return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType = (WildcardType) type;\n        if (wildcardType.getExtendedTypes().isPresent() && !wildcardType.getSuperTypes().isPresent()) {\n            return Wildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context));\n        } else if (!wildcardType.getExtendedTypes().isPresent() && wildcardType.getSuperTypes().isPresent()) {\n            return Wildcard.extendsBound(convertToUsage(wildcardType.getSuperTypes().get(), context));\n        } else if (!wildcardType.getExtendedTypes().isPresent() && !wildcardType.getSuperTypes().isPresent()) {\n            return Wildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return VoidType.INSTANCE;\n    } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n        com.github.javaparser.ast.type.ArrayType jpArrayType = (com.github.javaparser.ast.type.ArrayType) type;\n        return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}"
    },
    {
      "commit": "52b60cf471dc9d7b53d8f22018d9c4e4fcc15923",
      "startLine": 9,
      "endLine": 23,
      "methodCode": "private Type convertToUsage(com.github.javaparser.ast.type.Type<?> type, Context context) {\n    if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n        String name = qName(classOrInterfaceType);\n        SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<Type> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof TypeParameterDeclaration) {\n                return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType = (WildcardType) type;\n        if (wildcardType.getExtendedTypes().isPresent() && !wildcardType.getSuperTypes().isPresent()) {\n            return Wildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context));\n        } else if (!wildcardType.getExtendedTypes().isPresent() && wildcardType.getSuperTypes().isPresent()) {\n            return Wildcard.extendsBound(convertToUsage(wildcardType.getSuperTypes().get(), context));\n        } else if (!wildcardType.getExtendedTypes().isPresent() && !wildcardType.getSuperTypes().isPresent()) {\n            return Wildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return VoidType.INSTANCE;\n    } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n        com.github.javaparser.ast.type.ArrayType jpArrayType = (com.github.javaparser.ast.type.ArrayType) type;\n        return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}"
    },
    {
      "commit": "07782fbbe149055d495e0c358da844734c08641f",
      "startLine": 9,
      "endLine": 23,
      "methodCode": "private Type convertToUsage(com.github.javaparser.ast.type.Type<?> type, Context context) {\n    if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n        String name = qName(classOrInterfaceType);\n        SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<Type> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof TypeParameterDeclaration) {\n                return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType = (WildcardType) type;\n        if (wildcardType.getExtends().isPresent() && !wildcardType.getSuper().isPresent()) {\n            return Wildcard.extendsBound(convertToUsage(wildcardType.getExtends().get(), context));\n        } else if (!wildcardType.getExtends().isPresent() && wildcardType.getSuper().isPresent()) {\n            return Wildcard.extendsBound(convertToUsage(wildcardType.getSuper().get(), context));\n        } else if (!wildcardType.getExtends().isPresent() && !wildcardType.getSuper().isPresent()) {\n            return Wildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return VoidType.INSTANCE;\n    } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n        com.github.javaparser.ast.type.ArrayType jpArrayType = (com.github.javaparser.ast.type.ArrayType) type;\n        return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}"
    },
    {
      "commit": "c990d23490f5c4ac4322119b03d5951b63eef055",
      "startLine": 9,
      "endLine": 23,
      "methodCode": "public Type convertToUsage(com.github.javaparser.ast.type.Type<?> type, Context context) {\n    if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n        String name = qName(classOrInterfaceType);\n        SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<Type> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof TypeParameterDeclaration) {\n                return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType = (WildcardType) type;\n        if (wildcardType.getExtends().isPresent() && !wildcardType.getSuper().isPresent()) {\n            return Wildcard.extendsBound(convertToUsage(wildcardType.getExtends().get(), context));\n        } else if (!wildcardType.getExtends().isPresent() && wildcardType.getSuper().isPresent()) {\n            return Wildcard.extendsBound(convertToUsage(wildcardType.getSuper().get(), context));\n        } else if (!wildcardType.getExtends().isPresent() && !wildcardType.getSuper().isPresent()) {\n            return Wildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return VoidType.INSTANCE;\n    } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n        com.github.javaparser.ast.type.ArrayType jpArrayType = (com.github.javaparser.ast.type.ArrayType) type;\n        return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}"
    },
    {
      "commit": "6e1380f412d334f1c887d15edf0b4610c3cf0da2",
      "startLine": 9,
      "endLine": 23,
      "methodCode": "public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n    if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n        String name = qName(classOrInterfaceType);\n        SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<Type> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof TypeParameterDeclaration) {\n                return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType = (WildcardType) type;\n        if (wildcardType.getExtends().isPresent() && !wildcardType.getSuper().isPresent()) {\n            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n        } else if (!wildcardType.getExtends().isPresent() && wildcardType.getSuper().isPresent()) {\n            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n        } else if (!wildcardType.getExtends().isPresent() && !wildcardType.getSuper().isPresent()) {\n            return Wildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return VoidType.INSTANCE;\n    } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n        com.github.javaparser.ast.type.ArrayType jpArrayType = (com.github.javaparser.ast.type.ArrayType) type;\n        return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}"
    },
    {
      "commit": "ca3e3a946698cf3a4f93e6fb7b4d2b16ee2e3ed5",
      "startLine": 9,
      "endLine": 23,
      "methodCode": "public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n    if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n        String name = qName(classOrInterfaceType);\n        SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<Type> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments() != null) {\n            typeParameters = classOrInterfaceType.getTypeArguments().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof TypeParameterDeclaration) {\n                return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType = (WildcardType) type;\n        if (wildcardType.getExtends() != null && wildcardType.getSuper() == null) {\n            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends(), context));\n        } else if (wildcardType.getExtends() == null && wildcardType.getSuper() != null) {\n            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper(), context));\n        } else if (wildcardType.getExtends() == null && wildcardType.getSuper() == null) {\n            return Wildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return VoidType.INSTANCE;\n    } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n        com.github.javaparser.ast.type.ArrayType jpArrayType = (com.github.javaparser.ast.type.ArrayType) type;\n        return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}"
    },
    {
      "commit": "a1c7c58143a592965f8378767adc69709e4c0043",
      "startLine": 9,
      "endLine": 23,
      "methodCode": "public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n    if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n        String name = qName(classOrInterfaceType);\n        SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<Type> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof TypeParameterDeclaration) {\n                return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType = (WildcardType) type;\n        if (wildcardType.getExtends().isPresent() && !wildcardType.getSuper().isPresent()) {\n            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n        } else if (!wildcardType.getExtends().isPresent() && wildcardType.getSuper().isPresent()) {\n            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n        } else if (!wildcardType.getExtends().isPresent() && !wildcardType.getSuper().isPresent()) {\n            return Wildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return VoidType.INSTANCE;\n    } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n        com.github.javaparser.ast.type.ArrayType jpArrayType = (com.github.javaparser.ast.type.ArrayType) type;\n        return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}"
    },
    {
      "commit": "6df1aa26f75ff0d716a1290007e2b63cc05001ae",
      "startLine": 9,
      "endLine": 23,
      "methodCode": "public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n    if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n        String name = qName(classOrInterfaceType);\n        SymbolReference<ReferenceTypeDeclaration> ref = context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        ReferenceTypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<Type> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof TypeParameterDeclaration) {\n                return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType = (WildcardType) type;\n        if (wildcardType.getExtends().isPresent() && !wildcardType.getSuper().isPresent()) {\n            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n        } else if (!wildcardType.getExtends().isPresent() && wildcardType.getSuper().isPresent()) {\n            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n        } else if (!wildcardType.getExtends().isPresent() && !wildcardType.getSuper().isPresent()) {\n            return Wildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return VoidType.INSTANCE;\n    } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n        com.github.javaparser.ast.type.ArrayType jpArrayType = (com.github.javaparser.ast.type.ArrayType) type;\n        return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}"
    },
    {
      "commit": "b32947e8c85bc21fe533173f50d4a0a91036fdaf",
      "startLine": 9,
      "endLine": 23,
      "methodCode": "public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n    if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n        String name = qName(classOrInterfaceType);\n        SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<Type> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof TypeParameterDeclaration) {\n                return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType = (WildcardType) type;\n        if (wildcardType.getExtends().isPresent() && !wildcardType.getSuper().isPresent()) {\n            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n        } else if (!wildcardType.getExtends().isPresent() && wildcardType.getSuper().isPresent()) {\n            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n        } else if (!wildcardType.getExtends().isPresent() && !wildcardType.getSuper().isPresent()) {\n            return Wildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return VoidType.INSTANCE;\n    } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n        com.github.javaparser.ast.type.ArrayType jpArrayType = (com.github.javaparser.ast.type.ArrayType) type;\n        return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}"
    },
    {
      "commit": "9c53c2cbc607ea694438ade8630be0c155a33162",
      "startLine": 9,
      "endLine": 23,
      "methodCode": "public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n    if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n        String name = qName(classOrInterfaceType);\n        SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<Type> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeVariable()) {\n            if (typeDeclaration instanceof TypeParameterDeclaration) {\n                return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType = (WildcardType) type;\n        if (wildcardType.getExtends().isPresent() && !wildcardType.getSuper().isPresent()) {\n            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n        } else if (!wildcardType.getExtends().isPresent() && wildcardType.getSuper().isPresent()) {\n            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n        } else if (!wildcardType.getExtends().isPresent() && !wildcardType.getSuper().isPresent()) {\n            return Wildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return VoidType.INSTANCE;\n    } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n        com.github.javaparser.ast.type.ArrayType jpArrayType = (com.github.javaparser.ast.type.ArrayType) type;\n        return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}"
    },
    {
      "commit": "4601dfb9d1acf7f564948b7ddbb9201d62849ad7",
      "startLine": 9,
      "endLine": 23,
      "methodCode": "public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n    if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n        String name = qName(classOrInterfaceType);\n        SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<Type> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeVariable()) {\n            if (typeDeclaration instanceof TypeParameterDeclaration) {\n                return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType = (WildcardType) type;\n        if (wildcardType.getExtends().isPresent() && !wildcardType.getSuper().isPresent()) {\n            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n        } else if (!wildcardType.getExtends().isPresent() && wildcardType.getSuper().isPresent()) {\n            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n        } else if (!wildcardType.getExtends().isPresent() && !wildcardType.getSuper().isPresent()) {\n            return Wildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return VoidType.INSTANCE;\n    } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n        com.github.javaparser.ast.type.ArrayType jpArrayType = (com.github.javaparser.ast.type.ArrayType) type;\n        return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}"
    },
    {
      "commit": "3fcd7b41f404d112b13d3bfe732b26eceec0dbfe",
      "startLine": 9,
      "endLine": 23,
      "methodCode": "public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n    if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n        String name = qName(classOrInterfaceType);\n        SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<Type> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeVariable()) {\n            if (typeDeclaration instanceof TypeParameterDeclaration) {\n                return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType = (WildcardType) type;\n        if (wildcardType.getExtends().isPresent() && !wildcardType.getSuper().isPresent()) {\n            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n        } else if (!wildcardType.getExtends().isPresent() && wildcardType.getSuper().isPresent()) {\n            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n        } else if (!wildcardType.getExtends().isPresent() && !wildcardType.getSuper().isPresent()) {\n            return Wildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return VoidType.INSTANCE;\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}"
    },
    {
      "commit": "33753cab1604a44d43215ba4055b435606a7a71b",
      "startLine": 9,
      "endLine": 23,
      "methodCode": "public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n    if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n        String name = qName(classOrInterfaceType);\n        SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<Type> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeVariable()) {\n            if (typeDeclaration instanceof TypeParameterDeclaration) {\n                return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType = (WildcardType) type;\n        if (wildcardType.getExtends().isPresent() && wildcardType.getSuper().isPresent()) {\n            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n        } else if (!wildcardType.getExtends().isPresent() && wildcardType.getSuper().isPresent()) {\n            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n        } else if (wildcardType.getExtends().isPresent() && !wildcardType.getSuper().isPresent()) {\n            return Wildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException();\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return VoidType.INSTANCE;\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}"
    },
    {
      "commit": "341e081a5f8909a3a467671befcca2941b786d3d",
      "startLine": 13,
      "endLine": 27,
      "methodCode": "public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n    if (type instanceof com.github.javaparser.ast.type.ReferenceType) {\n        com.github.javaparser.ast.type.ReferenceType referenceType = (com.github.javaparser.ast.type.ReferenceType) type;\n        Type typeUsage = convertToUsage(referenceType, context);\n        return typeUsage;\n    } else if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n        String name = qName(classOrInterfaceType);\n        SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<Type> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments() != null) {\n            typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeVariable()) {\n            if (typeDeclaration instanceof TypeParameterDeclaration) {\n                return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType = (WildcardType) type;\n        if (wildcardType.getExtends().isPresent() && wildcardType.getSuper().isPresent()) {\n            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n        } else if (!wildcardType.getExtends().isPresent() && wildcardType.getSuper().isPresent()) {\n            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n        } else if (wildcardType.getExtends().isPresent() && !wildcardType.getSuper().isPresent()) {\n            return Wildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException();\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return VoidType.INSTANCE;\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}"
    },
    {
      "commit": "d6a1f32f00bd513d6bc56fbbfefcb9ae9c706492",
      "startLine": 16,
      "endLine": 30,
      "methodCode": "public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n    if (type instanceof com.github.javaparser.ast.type.ReferenceType) {\n        com.github.javaparser.ast.type.ReferenceType referenceType = (com.github.javaparser.ast.type.ReferenceType) type;\n        Type typeUsage = convertToUsage(referenceType.getType(), context);\n        for (int i = 0; i < referenceType.getArrayCount(); i++) {\n            typeUsage = new ArrayType(typeUsage);\n        }\n        return typeUsage;\n    } else if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n        String name = qName(classOrInterfaceType);\n        SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<Type> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArgs() != null) {\n            typeParameters = classOrInterfaceType.getTypeArgs().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeVariable()) {\n            if (typeDeclaration instanceof TypeParameterDeclaration) {\n                return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType = (WildcardType) type;\n        if (wildcardType.getExtends() != null && wildcardType.getSuper() == null) {\n            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends(), context));\n        } else if (wildcardType.getExtends() == null && wildcardType.getSuper() != null) {\n            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper(), context));\n        } else if (wildcardType.getExtends() == null && wildcardType.getSuper() == null) {\n            return Wildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException();\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return VoidType.INSTANCE;\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}"
    },
    {
      "commit": "ecc78c8b480ceb41019f764c983aaa69c2dabfe3",
      "startLine": 16,
      "endLine": 30,
      "methodCode": "public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n    if (type instanceof com.github.javaparser.ast.type.ReferenceType) {\n        com.github.javaparser.ast.type.ReferenceType referenceType = (com.github.javaparser.ast.type.ReferenceType) type;\n        Type typeUsage = convertToUsage(referenceType.getType(), context);\n        for (int i = 0; i < referenceType.getArrayCount(); i++) {\n            typeUsage = new ArrayType(typeUsage);\n        }\n        return typeUsage;\n    } else if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n        String name = qName(classOrInterfaceType);\n        SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<Type> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArgs() != null) {\n            typeParameters = classOrInterfaceType.getTypeArgs().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeVariable()) {\n            if (typeDeclaration instanceof TypeParameterDeclaration) {\n                return new TypeParameter((TypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType = (WildcardType) type;\n        if (wildcardType.getExtends() != null && wildcardType.getSuper() == null) {\n            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends(), context));\n        } else if (wildcardType.getExtends() == null && wildcardType.getSuper() != null) {\n            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper(), context));\n        } else if (wildcardType.getExtends() == null && wildcardType.getSuper() == null) {\n            return Wildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException();\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return VoidType.INSTANCE;\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}"
    },
    {
      "commit": "82eb44707b620803d424188a1eb8708fcaf093cb",
      "startLine": 16,
      "endLine": 30,
      "methodCode": "public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n    if (type instanceof com.github.javaparser.ast.type.ReferenceType) {\n        com.github.javaparser.ast.type.ReferenceType referenceType = (com.github.javaparser.ast.type.ReferenceType) type;\n        Type typeUsage = convertToUsage(referenceType.getType(), context);\n        for (int i = 0; i < referenceType.getArrayCount(); i++) {\n            typeUsage = new ArrayType(typeUsage);\n        }\n        return typeUsage;\n    } else if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n        String name = qName(classOrInterfaceType);\n        SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<Type> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArgs() != null) {\n            typeParameters = classOrInterfaceType.getTypeArgs().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeVariable()) {\n            if (typeDeclaration instanceof me.tomassetti.symbolsolver.model.resolution.TypeParameter) {\n                return new TypeParameter((me.tomassetti.symbolsolver.model.resolution.TypeParameter) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType = (WildcardType) type;\n        if (wildcardType.getExtends() != null && wildcardType.getSuper() == null) {\n            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends(), context));\n        } else if (wildcardType.getExtends() == null && wildcardType.getSuper() != null) {\n            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper(), context));\n        } else if (wildcardType.getExtends() == null && wildcardType.getSuper() == null) {\n            return Wildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException();\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return VoidType.INSTANCE;\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}"
    },
    {
      "commit": "14c9305d49885a12acdb7c09d2e35ad29b5403cf",
      "startLine": 16,
      "endLine": 30,
      "methodCode": "public TypeUsage convertToUsage(Type type, Context context) {\n    if (type instanceof ReferenceType) {\n        ReferenceType referenceType = (ReferenceType) type;\n        TypeUsage typeUsage = convertToUsage(referenceType.getType(), context);\n        for (int i = 0; i < referenceType.getArrayCount(); i++) {\n            typeUsage = new ArrayTypeUsage(typeUsage);\n        }\n        return typeUsage;\n    } else if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n        String name = qName(classOrInterfaceType);\n        SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<TypeUsage> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArgs() != null) {\n            typeParameters = classOrInterfaceType.getTypeArgs().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeVariable()) {\n            if (typeDeclaration instanceof TypeParameter) {\n                return new TypeParameterUsage((TypeParameter) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeParameterUsage(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeUsageImpl(typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof PrimitiveType) {\n        return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType = (WildcardType) type;\n        if (wildcardType.getExtends() != null && wildcardType.getSuper() == null) {\n            return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getExtends(), context));\n        } else if (wildcardType.getExtends() == null && wildcardType.getSuper() != null) {\n            return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getSuper(), context));\n        } else if (wildcardType.getExtends() == null && wildcardType.getSuper() == null) {\n            return WildcardUsage.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException();\n        }\n    } else if (type instanceof VoidType) {\n        return VoidTypeUsage.INSTANCE;\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}"
    },
    {
      "commit": "e581ddb297f5a1da9790adaeadbb6d0f43c8432f",
      "startLine": 16,
      "endLine": 30,
      "methodCode": "public TypeUsage convertToUsage(Type type, Context context) {\n    if (type instanceof ReferenceType) {\n        ReferenceType referenceType = (ReferenceType) type;\n        TypeUsage typeUsage = convertToUsage(referenceType.getType(), context);\n        for (int i = 0; i < referenceType.getArrayCount(); i++) {\n            typeUsage = new ArrayTypeUsage(typeUsage);\n        }\n        return typeUsage;\n    } else if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n        String name = qName(classOrInterfaceType);\n        SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<TypeUsage> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArgs() != null) {\n            typeParameters = classOrInterfaceType.getTypeArgs().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeVariable()) {\n            if (typeDeclaration instanceof TypeParameter) {\n                return new TypeParameterUsage((TypeParameter) typeDeclaration, typeSolver);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeParameterUsage(javaParserTypeVariableDeclaration.asTypeParameter(), typeSolver);\n            }\n        } else {\n            return new ReferenceTypeUsageImpl(typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof PrimitiveType) {\n        return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType = (WildcardType) type;\n        if (wildcardType.getExtends() != null && wildcardType.getSuper() == null) {\n            return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getExtends(), context));\n        } else if (wildcardType.getExtends() == null && wildcardType.getSuper() != null) {\n            return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getSuper(), context));\n        } else if (wildcardType.getExtends() == null && wildcardType.getSuper() == null) {\n            return WildcardUsage.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException();\n        }\n    } else if (type instanceof VoidType) {\n        return VoidTypeUsage.INSTANCE;\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}"
    },
    {
      "commit": "8e655d386a595ea1927ebeded58939d7b8a7ce0c",
      "startLine": 16,
      "endLine": 30,
      "methodCode": "public TypeUsage convertToUsage(Type type, Context context) {\n    if (type instanceof ReferenceType) {\n        ReferenceType referenceType = (ReferenceType) type;\n        TypeUsage typeUsage = convertToUsage(referenceType.getType(), context);\n        for (int i = 0; i < referenceType.getArrayCount(); i++) {\n            typeUsage = new ArrayTypeUsage(typeUsage);\n        }\n        return typeUsage;\n    } else if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n        String name = qName(classOrInterfaceType);\n        SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<TypeUsage> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArgs() != null) {\n            typeParameters = classOrInterfaceType.getTypeArgs().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeVariable()) {\n            if (typeDeclaration instanceof TypeParameter) {\n                return new TypeParameterUsage((TypeParameter) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeParameterUsage(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeUsageImpl(typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof PrimitiveType) {\n        return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType = (WildcardType) type;\n        if (wildcardType.getExtends() != null && wildcardType.getSuper() == null) {\n            return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getExtends(), context));\n        } else if (wildcardType.getExtends() == null && wildcardType.getSuper() != null) {\n            return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getSuper(), context));\n        } else if (wildcardType.getExtends() == null && wildcardType.getSuper() == null) {\n            return WildcardUsage.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException();\n        }\n    } else if (type instanceof VoidType) {\n        return VoidTypeUsage.INSTANCE;\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}"
    },
    {
      "commit": "4a18b1ee8ed716d6e32e190f728f1eee57148872",
      "startLine": 16,
      "endLine": 30,
      "methodCode": "public TypeUsage convertToUsage(Type type, Context context) {\n    if (type instanceof ReferenceType) {\n        ReferenceType referenceType = (ReferenceType) type;\n        TypeUsage typeUsage = convertToUsage(referenceType.getType(), context);\n        for (int i = 0; i < referenceType.getArrayCount(); i++) {\n            typeUsage = new ArrayTypeUsage(typeUsage);\n        }\n        return typeUsage;\n    } else if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n        String name = qName(classOrInterfaceType);\n        SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<TypeUsage> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArgs() != null) {\n            typeParameters = classOrInterfaceType.getTypeArgs().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeVariable()) {\n            if (typeDeclaration instanceof TypeParameter) {\n                return new TypeParameterUsage((TypeParameter) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeParameterUsage(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeUsageImpl(typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof PrimitiveType) {\n        return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType = (WildcardType) type;\n        if (wildcardType.getExtends() != null && wildcardType.getSuper() == null) {\n            return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getExtends(), context));\n        } else if (wildcardType.getExtends() == null && wildcardType.getSuper() != null) {\n            return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getSuper(), context));\n        } else if (wildcardType.getExtends() == null && wildcardType.getSuper() == null) {\n            return WildcardUsage.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException();\n        }\n    } else if (type instanceof VoidType) {\n        return VoidTypeUsage.INSTANCE;\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}"
    },
    {
      "commit": "f4b07b1a2deac6d1b562424ac2380b92cec77a90",
      "startLine": 16,
      "endLine": 30,
      "methodCode": "public TypeUsage convertToUsage(Type type, Context context) {\n    if (type instanceof ReferenceType) {\n        ReferenceType referenceType = (ReferenceType) type;\n        TypeUsage typeUsage = convertToUsage(referenceType.getType(), context);\n        for (int i = 0; i < referenceType.getArrayCount(); i++) {\n            typeUsage = new ArrayTypeUsage(typeUsage);\n        }\n        return typeUsage;\n    } else if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n        String name = qName(classOrInterfaceType);\n        SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<TypeUsage> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArgs() != null) {\n            typeParameters = classOrInterfaceType.getTypeArgs().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeVariable()) {\n            if (typeDeclaration instanceof TypeParameter) {\n                return new TypeParameterUsage((TypeParameter) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeParameterUsage(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeUsage(typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof PrimitiveType) {\n        return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType = (WildcardType) type;\n        if (wildcardType.getExtends() != null && wildcardType.getSuper() == null) {\n            return WildcardUsage.extendsBound((ReferenceTypeUsage) convertToUsage(wildcardType.getExtends(), context));\n        } else if (wildcardType.getExtends() == null && wildcardType.getSuper() != null) {\n            return WildcardUsage.extendsBound((ReferenceTypeUsage) convertToUsage(wildcardType.getSuper(), context));\n        } else if (wildcardType.getExtends() == null && wildcardType.getSuper() == null) {\n            return WildcardUsage.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException();\n        }\n    } else if (type instanceof VoidType) {\n        return VoidTypeUsage.INSTANCE;\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}"
    },
    {
      "commit": "03ec309bba14eaf50a32b05353fa9711b831de7f",
      "startLine": 16,
      "endLine": 30,
      "methodCode": "public TypeUsage convertToUsage(Type type, Context context) {\n    if (type instanceof ReferenceType) {\n        ReferenceType referenceType = (ReferenceType) type;\n        TypeUsage typeUsage = convertToUsage(referenceType.getType(), context);\n        for (int i = 0; i < referenceType.getArrayCount(); i++) {\n            typeUsage = new ArrayTypeUsage(typeUsage);\n        }\n        return typeUsage;\n    } else if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n        String name = qName(classOrInterfaceType);\n        SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<TypeUsage> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArgs() != null) {\n            typeParameters = classOrInterfaceType.getTypeArgs().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeVariable()) {\n            if (typeDeclaration instanceof TypeParameter) {\n                return new TypeParameterUsage((TypeParameter) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeParameterUsage(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeUsage(typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof PrimitiveType) {\n        return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType = (WildcardType) type;\n        if (wildcardType.getExtends() != null && wildcardType.getSuper() == null) {\n            return WildcardUsage.extendsBound((ReferenceTypeUsage) convertToUsage(wildcardType.getExtends(), context));\n        } else if (wildcardType.getExtends() == null && wildcardType.getSuper() != null) {\n            return WildcardUsage.extendsBound((ReferenceTypeUsage) convertToUsage(wildcardType.getSuper(), context));\n        } else if (wildcardType.getExtends() == null && wildcardType.getSuper() == null) {\n            return WildcardUsage.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException();\n        }\n    } else if (type instanceof VoidType) {\n        return VoidTypeUsage.INSTANCE;\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}"
    },
    {
      "commit": "fb388c36c0045c50744cf215521e5c280036aa70",
      "startLine": 16,
      "endLine": 30,
      "methodCode": "public TypeUsage convertToUsage(Type type, Context context) {\n    if (type instanceof ReferenceType) {\n        ReferenceType referenceType = (ReferenceType) type;\n        TypeUsage typeUsage = convertToUsage(referenceType.getType(), context);\n        for (int i = 0; i < referenceType.getArrayCount(); i++) {\n            typeUsage = new ArrayTypeUsage(typeUsage);\n        }\n        return typeUsage;\n    } else if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n        String name = qName(classOrInterfaceType);\n        SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<TypeUsage> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArgs() != null) {\n            typeParameters = classOrInterfaceType.getTypeArgs().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeVariable()) {\n            if (typeDeclaration instanceof TypeParameter) {\n                return new TypeParameterUsage((TypeParameter) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeParameterUsage(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeUsage(typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof PrimitiveType) {\n        return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        return new WildcardUsage((WildcardType) type);\n    } else if (type instanceof VoidType) {\n        return VoidTypeUsage.INSTANCE;\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}"
    },
    {
      "commit": "1613b8d9cc00da012539ea3db05cdb0cc8153358",
      "startLine": 16,
      "endLine": 30,
      "methodCode": "public TypeUsage convertToUsage(Type type, Context context) {\n    if (type instanceof ReferenceType) {\n        ReferenceType referenceType = (ReferenceType) type;\n        TypeUsage typeUsage = convertToUsage(referenceType.getType(), context);\n        for (int i = 0; i < referenceType.getArrayCount(); i++) {\n            typeUsage = new ArrayTypeUsage(typeUsage);\n        }\n        return typeUsage;\n    } else if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n        String name = qName(classOrInterfaceType);\n        SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<TypeUsage> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArgs() != null) {\n            typeParameters = classOrInterfaceType.getTypeArgs().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeVariable()) {\n            if (typeDeclaration instanceof TypeParameter) {\n                return new TypeParameterUsage((TypeParameter) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeParameterUsage(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeUsage(typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof PrimitiveType) {\n        return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        return new WildcardUsage((WildcardType) type);\n    } else if (type instanceof VoidType) {\n        return VoidTypeUsage.INSTANCE;\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}"
    },
    {
      "commit": "0e81f51c40996b42cb262dc2397126cee8f60965",
      "startLine": 16,
      "endLine": 30,
      "methodCode": "public TypeUsage convertToUsage(Type type, Context context) {\n    if (type instanceof ReferenceType) {\n        ReferenceType referenceType = (ReferenceType) type;\n        TypeUsage typeUsage = convertToUsage(referenceType.getType(), context);\n        for (int i = 0; i < referenceType.getArrayCount(); i++) {\n            typeUsage = new ArrayTypeUsage(typeUsage);\n        }\n        return typeUsage;\n    } else if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n        String name = qName(classOrInterfaceType);\n        SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<TypeUsage> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArgs() != null) {\n            typeParameters = classOrInterfaceType.getTypeArgs().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeVariable()) {\n            if (typeDeclaration instanceof TypeParameter) {\n                return new TypeUsageOfTypeParameter((TypeParameter) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeUsageOfTypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeUsage(typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof PrimitiveType) {\n        return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        return new WildcardUsage((WildcardType) type);\n    } else if (type instanceof VoidType) {\n        return VoidTypeUsage.INSTANCE;\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}"
    },
    {
      "commit": "68aeb576ccb2b44e436d13d0be2660f85dc9ee4b",
      "startLine": 16,
      "endLine": 30,
      "methodCode": "public TypeUsage convertToUsage(Type type, Context context) {\n    if (type instanceof ReferenceType) {\n        ReferenceType referenceType = (ReferenceType) type;\n        TypeUsage typeUsage = convertToUsage(referenceType.getType(), context);\n        for (int i = 0; i < referenceType.getArrayCount(); i++) {\n            typeUsage = new ArrayTypeUsage(typeUsage);\n        }\n        return typeUsage;\n    } else if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n        String name = qName(classOrInterfaceType);\n        SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<TypeUsage> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArgs() != null) {\n            typeParameters = classOrInterfaceType.getTypeArgs().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeVariable()) {\n            if (typeDeclaration instanceof TypeParameter) {\n                return new TypeUsageOfTypeParameter((TypeParameter) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeUsageOfTypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeUsage(typeDeclaration, typeParameters);\n        }\n    } else if (type instanceof PrimitiveType) {\n        return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        return new WildcardUsage((WildcardType) type);\n    } else if (type instanceof VoidType) {\n        return VoidTypeUsage.INSTANCE;\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}"
    },
    {
      "commit": "eec165d9e3ef0ab1d93f69a231964984a3379762",
      "startLine": 16,
      "endLine": 30,
      "methodCode": "public TypeUsage convertToUsage(Type type, Context context) {\n    if (type instanceof ReferenceType) {\n        ReferenceType referenceType = (ReferenceType) type;\n        TypeUsage typeUsage = convertToUsage(referenceType.getType(), context);\n        for (int i = 0; i < referenceType.getArrayCount(); i++) {\n            typeUsage = new ArrayTypeUsage(typeUsage);\n        }\n        return typeUsage;\n    } else if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n        String name = qName(classOrInterfaceType);\n        SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<TypeUsage> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArgs() != null) {\n            typeParameters = classOrInterfaceType.getTypeArgs().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeVariable()) {\n            if (typeDeclaration instanceof TypeParameter) {\n                return new TypeUsageOfTypeParameter((TypeParameter) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeUsageOfTypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n        }\n    } else if (type instanceof PrimitiveType) {\n        return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        return new WildcardUsage((WildcardType) type);\n    } else if (type instanceof VoidType) {\n        return VoidTypeUsage.INSTANCE;\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}"
    },
    {
      "commit": "ee58eb8363ecd8fad15a63eb2fdc94a387b58807",
      "startLine": 12,
      "endLine": 26,
      "methodCode": "public TypeUsage convertToUsage(Type type, Context context) {\n    if (type instanceof ReferenceType) {\n        ReferenceType referenceType = (ReferenceType) type;\n        return convertToUsage(referenceType.getType(), context);\n    } else if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n        String name = qName(classOrInterfaceType);\n        SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<TypeUsage> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArgs() != null) {\n            typeParameters = classOrInterfaceType.getTypeArgs().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeVariable()) {\n            if (typeDeclaration instanceof TypeParameter) {\n                return new TypeUsageOfTypeParameter((TypeParameter) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeUsageOfTypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n        }\n    } else if (type instanceof PrimitiveType) {\n        return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        return new WildcardUsage((WildcardType) type);\n    } else if (type instanceof VoidType) {\n        return VoidTypeUsage.INSTANCE;\n    } else {\n        throw new UnsupportedOperationException(\"FOO \" + type.getClass().getCanonicalName());\n    }\n}"
    },
    {
      "commit": "283204dd5840cb11dd6c73dbbb196e80db79c9a4",
      "startLine": 11,
      "endLine": 25,
      "methodCode": "public TypeUsage convertToUsage(Type type, Context context) {\n    if (type instanceof ReferenceType) {\n        ReferenceType referenceType = (ReferenceType) type;\n        return convertToUsage(referenceType.getType(), context);\n    } else if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n        SymbolReference<TypeDeclaration> ref = context.solveType(classOrInterfaceType.getName(), typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(classOrInterfaceType.getName());\n        }\n        TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<TypeUsage> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArgs() != null) {\n            typeParameters = classOrInterfaceType.getTypeArgs().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeVariable()) {\n            if (typeDeclaration instanceof TypeParameter) {\n                return new TypeUsageOfTypeParameter((TypeParameter) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeUsageOfTypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n        }\n    } else if (type instanceof PrimitiveType) {\n        return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        return new WildcardUsage((WildcardType) type);\n    } else if (type instanceof VoidType) {\n        return VoidTypeUsage.INSTANCE;\n    } else {\n        throw new UnsupportedOperationException(\"FOO \" + type.getClass().getCanonicalName());\n    }\n}"
    },
    {
      "commit": "f77a169eec5a2e0fdeea1b9d67641426af0e1176",
      "startLine": 11,
      "endLine": 25,
      "methodCode": "public TypeUsage convertToUsage(Type type, Context context) {\n    if (type instanceof ReferenceType) {\n        ReferenceType referenceType = (ReferenceType) type;\n        return convertToUsage(referenceType.getType(), context);\n    } else if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n        SymbolReference<TypeDeclaration> ref = context.solveType(classOrInterfaceType.getName(), typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(classOrInterfaceType.getName());\n        }\n        TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<TypeUsage> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArgs() != null) {\n            typeParameters = classOrInterfaceType.getTypeArgs().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeVariable()) {\n            if (typeDeclaration instanceof TypeParameter) {\n                return new TypeUsageOfTypeParameter((TypeParameter) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeUsageOfTypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n        }\n    } else if (type instanceof PrimitiveType) {\n        return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        return new WildcardUsage((WildcardType) type);\n    } else if (type instanceof VoidType) {\n        return new VoidTypeUsage();\n    } else {\n        throw new UnsupportedOperationException(\"FOO \" + type.getClass().getCanonicalName());\n    }\n}"
    },
    {
      "commit": "416e7b16f820700af08a94e4b38a2b4c24ef6a2c",
      "startLine": 11,
      "endLine": 21,
      "methodCode": "public TypeUsage convertToUsage(Type type, Context context) {\n    if (type instanceof ReferenceType) {\n        ReferenceType referenceType = (ReferenceType) type;\n        return convertToUsage(referenceType.getType(), context);\n    } else if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n        SymbolReference<TypeDeclaration> ref = context.solveType(classOrInterfaceType.getName(), typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(classOrInterfaceType.getName());\n        }\n        TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<TypeUsage> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArgs() != null) {\n            typeParameters = classOrInterfaceType.getTypeArgs().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeVariable()) {\n            JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n            return new TypeUsageOfTypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n        } else {\n            return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n        }\n    } else if (type instanceof PrimitiveType) {\n        return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n    } else {\n        throw new UnsupportedOperationException(\"FOO \" + type.getClass().getCanonicalName());\n    }\n}"
    },
    {
      "commit": "1829d9560d37efd59722aaa2f1f22e392918429b",
      "startLine": 11,
      "endLine": 21,
      "methodCode": "public TypeUsage convertToUsage(Type type, Context context) {\n    if (type instanceof ReferenceType) {\n        ReferenceType referenceType = (ReferenceType) type;\n        return convertToUsage(referenceType.getType(), context);\n    } else if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n        SymbolReference<TypeDeclaration> ref = context.solveType(classOrInterfaceType.getName(), typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(classOrInterfaceType.getName());\n        }\n        TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<TypeUsage> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArgs() != null) {\n            typeParameters = classOrInterfaceType.getTypeArgs().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeVariable()) {\n            JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n            return new TypeUsageOfTypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n        } else {\n            return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n        }\n    } else if (type instanceof PrimitiveType) {\n        return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}"
    },
    {
      "commit": "0c4c859f472f7243919f1af7a0871cf8155af1ba",
      "startLine": 11,
      "endLine": 16,
      "methodCode": "public TypeUsage convertToUsage(Type type, Context context) {\n    if (type instanceof ReferenceType) {\n        ReferenceType referenceType = (ReferenceType) type;\n        return convertToUsage(referenceType.getType(), context);\n    } else if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n        SymbolReference<TypeDeclaration> ref = context.solveType(classOrInterfaceType.getName(), typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(classOrInterfaceType.getName());\n        }\n        TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<TypeUsage> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArgs() != null) {\n            typeParameters = classOrInterfaceType.getTypeArgs().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n    } else if (type instanceof PrimitiveType) {\n        return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}"
    },
    {
      "commit": "7b6c27e95fef9e725fbf9e15afb852bb952dfa34",
      "startLine": 11,
      "endLine": 16,
      "methodCode": "public TypeUsage convertToUsage(Type type, Context context) {\n    if (type instanceof ReferenceType) {\n        ReferenceType referenceType = (ReferenceType) type;\n        return convertToUsage(referenceType.getType(), context);\n    } else if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n        SymbolReference<TypeDeclaration> ref = context.solveType(classOrInterfaceType.getName(), typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(null, classOrInterfaceType.getName());\n        }\n        TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<TypeUsage> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArgs() != null) {\n            typeParameters = classOrInterfaceType.getTypeArgs().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n    } else if (type instanceof PrimitiveType) {\n        return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}"
    },
    {
      "commit": "1d5332815b543d569be3d7ec672a65b7efc39a04",
      "startLine": 11,
      "endLine": 16,
      "methodCode": "public TypeUsage convertToUsage(Type type, Context context) {\n    if (type instanceof ReferenceType) {\n        ReferenceType referenceType = (ReferenceType) type;\n        return convertToUsage(referenceType.getType(), context);\n    } else if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n        SymbolReference<TypeDeclaration> ref = context.solveType(classOrInterfaceType.getName(), typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(null, classOrInterfaceType.getName());\n        }\n        TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<TypeUsage> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArgs() != null) {\n            typeParameters = classOrInterfaceType.getTypeArgs().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n    } else if (type instanceof PrimitiveType) {\n        return new TypeUsageOfTypeDeclaration(new PrimitiveTypeDeclaration((PrimitiveType) type), Collections.emptyList());\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}"
    },
    {
      "commit": "6650e5a3818c15de2883b71cd41524b0337e26f6",
      "startLine": 11,
      "endLine": 16,
      "methodCode": "public TypeUsage convertToUsage(Type type, Context context) {\n    if (type instanceof ReferenceType) {\n        ReferenceType referenceType = (ReferenceType) type;\n        return convertToUsage(referenceType.getType(), context);\n    } else if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n        SymbolReference<TypeDeclaration> ref = context.solveType(classOrInterfaceType.getName(), typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(null, classOrInterfaceType.getName());\n        }\n        TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<TypeUsage> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArgs() != null) {\n            typeParameters = classOrInterfaceType.getTypeArgs().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}"
    },
    {
      "commit": "2568d9ebe91ceb0a13c98b16f99593cd22084efa",
      "startLine": 11,
      "endLine": 16,
      "methodCode": "private TypeUsage convertToUsage(Type type, Context context) {\n    if (type instanceof ReferenceType) {\n        ReferenceType referenceType = (ReferenceType) type;\n        return convertToUsage(referenceType.getType(), context);\n    } else if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n        SymbolReference<TypeDeclaration> ref = context.solveType(classOrInterfaceType.getName(), typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(null, classOrInterfaceType.getName());\n        }\n        TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<TypeUsage> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArgs() != null) {\n            typeParameters = classOrInterfaceType.getTypeArgs().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}"
    }
  ]
}