{
  "statementVersions": [
    {
      "commit": "783dbf1b03cdabc5a8db63c9ac10fae164e6cf41",
      "startLine": 8,
      "endLine": 18,
      "methodCode": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor == null)\n        compressMonitor = NullProgressMonitor.INSTANCE;\n    if (writeMonitor == null)\n        writeMonitor = NullProgressMonitor.INSTANCE;\n    excludeInPacks = null;\n    excludeInPackLast = null;\n    boolean needSearchForReuse = reuseSupport != null && (reuseDeltas || config.isReuseObjects() || !cachedPacks.isEmpty());\n    if (compressMonitor instanceof BatchingProgressMonitor) {\n        long delay = 1000;\n        if (needSearchForReuse && config.isDeltaCompress())\n            delay = 500;\n        ((BatchingProgressMonitor) compressMonitor).setDelayStart(delay, TimeUnit.MILLISECONDS);\n    }\n    if (needSearchForReuse)\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    crc32 = new CRC32();\n    final PackOutputStream out = new PackOutputStream(writeMonitor, isIndexDisabled() ? packStream : new CheckedOutputStream(packStream, crc32), this);\n    long objCnt = getObjectCount();\n    stats.totalObjects = objCnt;\n    if (callback != null)\n        callback.setObjectCount(objCnt);\n    beginPhase(PackingPhase.WRITING, writeMonitor, objCnt);\n    long writeStart = System.currentTimeMillis();\n    try {\n        out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n        out.flush();\n        writeObjects(out);\n        if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n            for (PackStatistics.ObjectType.Accumulator typeStat : stats.objectTypes) {\n                if (typeStat == null)\n                    continue;\n                stats.thinPackBytes += typeStat.bytes;\n            }\n        }\n        stats.reusedPacks = Collections.unmodifiableList(cachedPacks);\n        for (CachedPack pack : cachedPacks) {\n            long deltaCnt = pack.getDeltaCount();\n            stats.reusedObjects += pack.getObjectCount();\n            stats.reusedDeltas += deltaCnt;\n            stats.totalDeltas += deltaCnt;\n            reuseSupport.copyPackAsIs(out, pack);\n        }\n        writeChecksum(out);\n        out.flush();\n    } finally {\n        stats.timeWriting = System.currentTimeMillis() - writeStart;\n        stats.depth = depth;\n        for (PackStatistics.ObjectType.Accumulator typeStat : stats.objectTypes) {\n            if (typeStat == null)\n                continue;\n            typeStat.cntDeltas += typeStat.reusedDeltas;\n            stats.reusedObjects += typeStat.reusedObjects;\n            stats.reusedDeltas += typeStat.reusedDeltas;\n            stats.totalDeltas += typeStat.cntDeltas;\n        }\n    }\n    stats.totalBytes = out.length();\n    reader.close();\n    endPhase(writeMonitor);\n}"
    },
    {
      "commit": "c46c720e99baa081bff0dd7bcc1ae8ca48b5e3d1",
      "startLine": 8,
      "endLine": 18,
      "methodCode": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor == null)\n        compressMonitor = NullProgressMonitor.INSTANCE;\n    if (writeMonitor == null)\n        writeMonitor = NullProgressMonitor.INSTANCE;\n    excludeInPacks = null;\n    excludeInPackLast = null;\n    boolean needSearchForReuse = reuseSupport != null && (reuseDeltas || config.isReuseObjects() || !cachedPacks.isEmpty());\n    if (compressMonitor instanceof BatchingProgressMonitor) {\n        long delay = 1000;\n        if (needSearchForReuse && config.isDeltaCompress())\n            delay = 500;\n        ((BatchingProgressMonitor) compressMonitor).setDelayStart(delay, TimeUnit.MILLISECONDS);\n    }\n    if (needSearchForReuse)\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    crc32 = new CRC32();\n    final PackOutputStream out = new PackOutputStream(writeMonitor, isIndexDisabled() ? packStream : new CheckedOutputStream(packStream, crc32), this);\n    long objCnt = getObjectCount();\n    stats.totalObjects = objCnt;\n    if (callback != null)\n        callback.setObjectCount(objCnt);\n    beginPhase(PackingPhase.WRITING, writeMonitor, objCnt);\n    long writeStart = System.currentTimeMillis();\n    try {\n        out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n        out.flush();\n        writeObjects(out);\n        if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n            for (PackStatistics.ObjectType.Accumulator typeStat : stats.objectTypes) {\n                if (typeStat == null)\n                    continue;\n                stats.thinPackBytes += typeStat.bytes;\n            }\n        }\n        stats.reusedPacks = Collections.unmodifiableList(cachedPacks);\n        for (CachedPack pack : cachedPacks) {\n            long deltaCnt = pack.getDeltaCount();\n            stats.reusedObjects += pack.getObjectCount();\n            stats.reusedDeltas += deltaCnt;\n            stats.totalDeltas += deltaCnt;\n            reuseSupport.copyPackAsIs(out, pack);\n        }\n        writeChecksum(out);\n        out.flush();\n    } finally {\n        stats.timeWriting = System.currentTimeMillis() - writeStart;\n        stats.depth = depth;\n        for (PackStatistics.ObjectType.Accumulator typeStat : stats.objectTypes) {\n            if (typeStat == null)\n                continue;\n            typeStat.cntDeltas += typeStat.reusedDeltas;\n            stats.reusedObjects += typeStat.reusedObjects;\n            stats.reusedDeltas += typeStat.reusedDeltas;\n            stats.totalDeltas += typeStat.cntDeltas;\n        }\n    }\n    stats.totalBytes = out.length();\n    reader.close();\n    endPhase(writeMonitor);\n}"
    },
    {
      "commit": "4bb523475d44ec1c4d9b4f92944a359aef99894c",
      "startLine": 8,
      "endLine": 18,
      "methodCode": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor == null)\n        compressMonitor = NullProgressMonitor.INSTANCE;\n    if (writeMonitor == null)\n        writeMonitor = NullProgressMonitor.INSTANCE;\n    excludeInPacks = null;\n    excludeInPackLast = null;\n    boolean needSearchForReuse = reuseSupport != null && (reuseDeltas || config.isReuseObjects() || !cachedPacks.isEmpty());\n    if (compressMonitor instanceof BatchingProgressMonitor) {\n        long delay = 1000;\n        if (needSearchForReuse && config.isDeltaCompress())\n            delay = 500;\n        ((BatchingProgressMonitor) compressMonitor).setDelayStart(delay, TimeUnit.MILLISECONDS);\n    }\n    if (needSearchForReuse)\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    crc32 = new CRC32();\n    final PackOutputStream out = new PackOutputStream(writeMonitor, isIndexDisabled() ? packStream : new CheckedOutputStream(packStream, crc32), this);\n    long objCnt = getObjectCount();\n    stats.totalObjects = objCnt;\n    if (callback != null)\n        callback.setObjectCount(objCnt);\n    beginPhase(PackingPhase.WRITING, writeMonitor, objCnt);\n    long writeStart = System.currentTimeMillis();\n    try {\n        out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n        out.flush();\n        writeObjects(out);\n        if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n            for (PackStatistics.ObjectType.Accumulator typeStat : stats.objectTypes) {\n                if (typeStat == null)\n                    continue;\n                stats.thinPackBytes += typeStat.bytes;\n            }\n        }\n        stats.reusedPacks = Collections.unmodifiableList(cachedPacks);\n        for (CachedPack pack : cachedPacks) {\n            long deltaCnt = pack.getDeltaCount();\n            stats.reusedObjects += pack.getObjectCount();\n            stats.reusedDeltas += deltaCnt;\n            stats.totalDeltas += deltaCnt;\n            reuseSupport.copyPackAsIs(out, pack);\n        }\n        writeChecksum(out);\n        out.flush();\n    } finally {\n        stats.timeWriting = System.currentTimeMillis() - writeStart;\n        stats.depth = depth;\n        for (PackStatistics.ObjectType.Accumulator typeStat : stats.objectTypes) {\n            if (typeStat == null)\n                continue;\n            typeStat.cntDeltas += typeStat.reusedDeltas;\n            stats.reusedObjects += typeStat.reusedObjects;\n            stats.reusedDeltas += typeStat.reusedDeltas;\n            stats.totalDeltas += typeStat.cntDeltas;\n        }\n    }\n    stats.totalBytes = out.length();\n    reader.close();\n    endPhase(writeMonitor);\n}"
    },
    {
      "commit": "d9bbb04c3ef28db1d2e492506a819b7ac5c5f9df",
      "startLine": 8,
      "endLine": 18,
      "methodCode": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor == null)\n        compressMonitor = NullProgressMonitor.INSTANCE;\n    if (writeMonitor == null)\n        writeMonitor = NullProgressMonitor.INSTANCE;\n    excludeInPacks = null;\n    excludeInPackLast = null;\n    boolean needSearchForReuse = reuseSupport != null && (reuseDeltas || config.isReuseObjects() || !cachedPacks.isEmpty());\n    if (compressMonitor instanceof BatchingProgressMonitor) {\n        long delay = 1000;\n        if (needSearchForReuse && config.isDeltaCompress())\n            delay = 500;\n        ((BatchingProgressMonitor) compressMonitor).setDelayStart(delay, TimeUnit.MILLISECONDS);\n    }\n    if (needSearchForReuse)\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    crc32 = new CRC32();\n    final PackOutputStream out = new PackOutputStream(writeMonitor, isIndexDisabled() ? packStream : new CheckedOutputStream(packStream, crc32), this);\n    long objCnt = getObjectCount();\n    stats.totalObjects = objCnt;\n    if (callback != null)\n        callback.setObjectCount(objCnt);\n    beginPhase(PackingPhase.WRITING, writeMonitor, objCnt);\n    long writeStart = System.currentTimeMillis();\n    try {\n        out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n        out.flush();\n        writeObjects(out);\n        if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n            for (PackStatistics.ObjectType.Accumulator typeStat : stats.objectTypes) {\n                if (typeStat == null)\n                    continue;\n                stats.thinPackBytes += typeStat.bytes;\n            }\n        }\n        stats.reusedPacks = Collections.unmodifiableList(cachedPacks);\n        for (CachedPack pack : cachedPacks) {\n            long deltaCnt = pack.getDeltaCount();\n            stats.reusedObjects += pack.getObjectCount();\n            stats.reusedDeltas += deltaCnt;\n            stats.totalDeltas += deltaCnt;\n            reuseSupport.copyPackAsIs(out, pack);\n        }\n        writeChecksum(out);\n        out.flush();\n    } finally {\n        stats.timeWriting = System.currentTimeMillis() - writeStart;\n        stats.depth = depth;\n        for (PackStatistics.ObjectType.Accumulator typeStat : stats.objectTypes) {\n            if (typeStat == null)\n                continue;\n            typeStat.cntDeltas += typeStat.reusedDeltas;\n            stats.reusedObjects += typeStat.reusedObjects;\n            stats.reusedDeltas += typeStat.reusedDeltas;\n            stats.totalDeltas += typeStat.cntDeltas;\n        }\n    }\n    stats.totalBytes = out.length();\n    reader.close();\n    endPhase(writeMonitor);\n}"
    },
    {
      "commit": "9cbe2228376808239b7e9efb5d7424d6762b3982",
      "startLine": 8,
      "endLine": 18,
      "methodCode": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor == null)\n        compressMonitor = NullProgressMonitor.INSTANCE;\n    if (writeMonitor == null)\n        writeMonitor = NullProgressMonitor.INSTANCE;\n    excludeInPacks = null;\n    excludeInPackLast = null;\n    boolean needSearchForReuse = reuseSupport != null && (reuseDeltas || config.isReuseObjects() || !cachedPacks.isEmpty());\n    if (compressMonitor instanceof BatchingProgressMonitor) {\n        long delay = 1000;\n        if (needSearchForReuse && config.isDeltaCompress())\n            delay = 500;\n        ((BatchingProgressMonitor) compressMonitor).setDelayStart(delay, TimeUnit.MILLISECONDS);\n    }\n    if (needSearchForReuse)\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    crc32 = new CRC32();\n    final PackOutputStream out = new PackOutputStream(writeMonitor, isIndexDisabled() ? packStream : new CheckedOutputStream(packStream, crc32), this);\n    long objCnt = getObjectCount();\n    stats.totalObjects = objCnt;\n    if (callback != null)\n        callback.setObjectCount(objCnt);\n    beginPhase(PackingPhase.WRITING, writeMonitor, objCnt);\n    long writeStart = System.currentTimeMillis();\n    try {\n        out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n        out.flush();\n        writeObjects(out);\n        if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n            for (Statistics.ObjectType typeStat : stats.objectTypes) {\n                if (typeStat == null)\n                    continue;\n                stats.thinPackBytes += typeStat.bytes;\n            }\n        }\n        stats.reusedPacks = Collections.unmodifiableList(cachedPacks);\n        for (CachedPack pack : cachedPacks) {\n            long deltaCnt = pack.getDeltaCount();\n            stats.reusedObjects += pack.getObjectCount();\n            stats.reusedDeltas += deltaCnt;\n            stats.totalDeltas += deltaCnt;\n            reuseSupport.copyPackAsIs(out, pack);\n        }\n        writeChecksum(out);\n        out.flush();\n    } finally {\n        stats.timeWriting = System.currentTimeMillis() - writeStart;\n        stats.depth = depth;\n        for (Statistics.ObjectType typeStat : stats.objectTypes) {\n            if (typeStat == null)\n                continue;\n            typeStat.cntDeltas += typeStat.reusedDeltas;\n            stats.reusedObjects += typeStat.reusedObjects;\n            stats.reusedDeltas += typeStat.reusedDeltas;\n            stats.totalDeltas += typeStat.cntDeltas;\n        }\n    }\n    stats.totalBytes = out.length();\n    reader.close();\n    endPhase(writeMonitor);\n}"
    },
    {
      "commit": "53be446f6a0a9776c5fd0d507fe11b14d79104c2",
      "startLine": 8,
      "endLine": 18,
      "methodCode": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor == null)\n        compressMonitor = NullProgressMonitor.INSTANCE;\n    if (writeMonitor == null)\n        writeMonitor = NullProgressMonitor.INSTANCE;\n    excludeInPacks = null;\n    excludeInPackLast = null;\n    boolean needSearchForReuse = reuseSupport != null && (reuseDeltas || config.isReuseObjects() || !cachedPacks.isEmpty());\n    if (compressMonitor instanceof BatchingProgressMonitor) {\n        long delay = 1000;\n        if (needSearchForReuse && config.isDeltaCompress())\n            delay = 500;\n        ((BatchingProgressMonitor) compressMonitor).setDelayStart(delay, TimeUnit.MILLISECONDS);\n    }\n    if (needSearchForReuse)\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    crc32 = new CRC32();\n    final PackOutputStream out = new PackOutputStream(writeMonitor, isIndexDisabled() ? packStream : new CheckedOutputStream(packStream, crc32), this);\n    long objCnt = getObjectCount();\n    stats.totalObjects = objCnt;\n    if (callback != null)\n        callback.setObjectCount(objCnt);\n    beginPhase(PackingPhase.WRITING, writeMonitor, objCnt);\n    long writeStart = System.currentTimeMillis();\n    try {\n        out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n        out.flush();\n        writeObjects(out);\n        if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n            for (Statistics.ObjectType typeStat : stats.objectTypes) {\n                if (typeStat == null)\n                    continue;\n                stats.thinPackBytes += typeStat.bytes;\n            }\n        }\n        stats.reusedPacks = Collections.unmodifiableList(cachedPacks);\n        for (CachedPack pack : cachedPacks) {\n            long deltaCnt = pack.getDeltaCount();\n            stats.reusedObjects += pack.getObjectCount();\n            stats.reusedDeltas += deltaCnt;\n            stats.totalDeltas += deltaCnt;\n            reuseSupport.copyPackAsIs(out, pack);\n        }\n        writeChecksum(out);\n        out.flush();\n    } finally {\n        stats.timeWriting = System.currentTimeMillis() - writeStart;\n        stats.depth = depth;\n        for (Statistics.ObjectType typeStat : stats.objectTypes) {\n            if (typeStat == null)\n                continue;\n            typeStat.cntDeltas += typeStat.reusedDeltas;\n            stats.reusedObjects += typeStat.reusedObjects;\n            stats.reusedDeltas += typeStat.reusedDeltas;\n            stats.totalDeltas += typeStat.cntDeltas;\n        }\n    }\n    stats.totalBytes = out.length();\n    reader.close();\n    endPhase(writeMonitor);\n}"
    },
    {
      "commit": "0e73d395061d1bfee365acaa2f79c392175d13bf",
      "startLine": 8,
      "endLine": 18,
      "methodCode": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor == null)\n        compressMonitor = NullProgressMonitor.INSTANCE;\n    if (writeMonitor == null)\n        writeMonitor = NullProgressMonitor.INSTANCE;\n    excludeInPacks = null;\n    excludeInPackLast = null;\n    boolean needSearchForReuse = reuseSupport != null && (reuseDeltas || config.isReuseObjects() || !cachedPacks.isEmpty());\n    if (compressMonitor instanceof BatchingProgressMonitor) {\n        long delay = 1000;\n        if (needSearchForReuse && config.isDeltaCompress())\n            delay = 500;\n        ((BatchingProgressMonitor) compressMonitor).setDelayStart(delay, TimeUnit.MILLISECONDS);\n    }\n    if (needSearchForReuse)\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    crc32 = new CRC32();\n    final PackOutputStream out = new PackOutputStream(writeMonitor, isIndexDisabled() ? packStream : new CheckedOutputStream(packStream, crc32), this);\n    long objCnt = getObjectCount();\n    stats.totalObjects = objCnt;\n    beginPhase(PackingPhase.WRITING, writeMonitor, objCnt);\n    long writeStart = System.currentTimeMillis();\n    try {\n        out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n        out.flush();\n        writeObjects(out);\n        if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n            for (Statistics.ObjectType typeStat : stats.objectTypes) {\n                if (typeStat == null)\n                    continue;\n                stats.thinPackBytes += typeStat.bytes;\n            }\n        }\n        stats.reusedPacks = Collections.unmodifiableList(cachedPacks);\n        for (CachedPack pack : cachedPacks) {\n            long deltaCnt = pack.getDeltaCount();\n            stats.reusedObjects += pack.getObjectCount();\n            stats.reusedDeltas += deltaCnt;\n            stats.totalDeltas += deltaCnt;\n            reuseSupport.copyPackAsIs(out, pack);\n        }\n        writeChecksum(out);\n        out.flush();\n    } finally {\n        stats.timeWriting = System.currentTimeMillis() - writeStart;\n        stats.depth = depth;\n        for (Statistics.ObjectType typeStat : stats.objectTypes) {\n            if (typeStat == null)\n                continue;\n            typeStat.cntDeltas += typeStat.reusedDeltas;\n            stats.reusedObjects += typeStat.reusedObjects;\n            stats.reusedDeltas += typeStat.reusedDeltas;\n            stats.totalDeltas += typeStat.cntDeltas;\n        }\n    }\n    stats.totalBytes = out.length();\n    reader.close();\n    endPhase(writeMonitor);\n}"
    },
    {
      "commit": "6e5c71b358e9b9b883f24f073e869ff6affe5bf4",
      "startLine": 8,
      "endLine": 18,
      "methodCode": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor == null)\n        compressMonitor = NullProgressMonitor.INSTANCE;\n    if (writeMonitor == null)\n        writeMonitor = NullProgressMonitor.INSTANCE;\n    excludeInPacks = null;\n    excludeInPackLast = null;\n    boolean needSearchForReuse = reuseSupport != null && (reuseDeltas || config.isReuseObjects() || !cachedPacks.isEmpty());\n    if (compressMonitor instanceof BatchingProgressMonitor) {\n        long delay = 1000;\n        if (needSearchForReuse && config.isDeltaCompress())\n            delay = 500;\n        ((BatchingProgressMonitor) compressMonitor).setDelayStart(delay, TimeUnit.MILLISECONDS);\n    }\n    if (needSearchForReuse)\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    crc32 = new CRC32();\n    final PackOutputStream out = new PackOutputStream(writeMonitor, isIndexDisabled() ? packStream : new CheckedOutputStream(packStream, crc32), this);\n    long objCnt = getObjectCount();\n    stats.totalObjects = objCnt;\n    beginPhase(PackingPhase.WRITING, writeMonitor, objCnt);\n    long writeStart = System.currentTimeMillis();\n    try {\n        out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n        out.flush();\n        writeObjects(out);\n        if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n            for (Statistics.ObjectType typeStat : stats.objectTypes) {\n                if (typeStat == null)\n                    continue;\n                stats.thinPackBytes += typeStat.bytes;\n            }\n        }\n        stats.reusedPacks = Collections.unmodifiableList(cachedPacks);\n        for (CachedPack pack : cachedPacks) {\n            long deltaCnt = pack.getDeltaCount();\n            stats.reusedObjects += pack.getObjectCount();\n            stats.reusedDeltas += deltaCnt;\n            stats.totalDeltas += deltaCnt;\n            reuseSupport.copyPackAsIs(out, pack);\n        }\n        writeChecksum(out);\n        out.flush();\n    } finally {\n        stats.timeWriting = System.currentTimeMillis() - writeStart;\n        stats.depth = depth;\n        for (Statistics.ObjectType typeStat : stats.objectTypes) {\n            if (typeStat == null)\n                continue;\n            typeStat.cntDeltas += typeStat.reusedDeltas;\n            stats.reusedObjects += typeStat.reusedObjects;\n            stats.reusedDeltas += typeStat.reusedDeltas;\n            stats.totalDeltas += typeStat.cntDeltas;\n        }\n    }\n    stats.totalBytes = out.length();\n    reader.release();\n    endPhase(writeMonitor);\n}"
    },
    {
      "commit": "bc90ce7788e77af11552799cecf65edeb97e3b7c",
      "startLine": 8,
      "endLine": 18,
      "methodCode": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor == null)\n        compressMonitor = NullProgressMonitor.INSTANCE;\n    if (writeMonitor == null)\n        writeMonitor = NullProgressMonitor.INSTANCE;\n    excludeInPacks = null;\n    excludeInPackLast = null;\n    boolean needSearchForReuse = reuseSupport != null && (reuseDeltas || config.isReuseObjects() || !cachedPacks.isEmpty());\n    if (compressMonitor instanceof BatchingProgressMonitor) {\n        long delay = 1000;\n        if (needSearchForReuse && config.isDeltaCompress())\n            delay = 500;\n        ((BatchingProgressMonitor) compressMonitor).setDelayStart(delay, TimeUnit.MILLISECONDS);\n    }\n    if (needSearchForReuse)\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    crc32 = new CRC32();\n    final PackOutputStream out = new PackOutputStream(writeMonitor, isIndexDisabled() ? packStream : new CheckedOutputStream(packStream, crc32), this);\n    long objCnt = getObjectCount();\n    stats.totalObjects = objCnt;\n    beginPhase(PackingPhase.WRITING, writeMonitor, objCnt);\n    long writeStart = System.currentTimeMillis();\n    try {\n        out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n        out.flush();\n        writeObjects(out);\n        if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n            for (Statistics.ObjectType typeStat : stats.objectTypes) {\n                if (typeStat == null)\n                    continue;\n                stats.thinPackBytes += typeStat.bytes;\n            }\n        }\n        stats.reusedPacks = Collections.unmodifiableList(cachedPacks);\n        for (CachedPack pack : cachedPacks) {\n            long deltaCnt = pack.getDeltaCount();\n            stats.reusedObjects += pack.getObjectCount();\n            stats.reusedDeltas += deltaCnt;\n            stats.totalDeltas += deltaCnt;\n            reuseSupport.copyPackAsIs(out, pack, reuseValidate);\n        }\n        writeChecksum(out);\n        out.flush();\n    } finally {\n        stats.timeWriting = System.currentTimeMillis() - writeStart;\n        stats.depth = depth;\n        for (Statistics.ObjectType typeStat : stats.objectTypes) {\n            if (typeStat == null)\n                continue;\n            typeStat.cntDeltas += typeStat.reusedDeltas;\n            stats.reusedObjects += typeStat.reusedObjects;\n            stats.reusedDeltas += typeStat.reusedDeltas;\n            stats.totalDeltas += typeStat.cntDeltas;\n        }\n    }\n    stats.totalBytes = out.length();\n    reader.release();\n    endPhase(writeMonitor);\n}"
    },
    {
      "commit": "eb17495ca4ce95c63bacf81af16ab19ff042b65c",
      "startLine": 8,
      "endLine": 18,
      "methodCode": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor == null)\n        compressMonitor = NullProgressMonitor.INSTANCE;\n    if (writeMonitor == null)\n        writeMonitor = NullProgressMonitor.INSTANCE;\n    excludeInPacks = null;\n    excludeInPackLast = null;\n    boolean needSearchForReuse = reuseSupport != null && (reuseDeltas || config.isReuseObjects() || !cachedPacks.isEmpty());\n    if (compressMonitor instanceof BatchingProgressMonitor) {\n        long delay = 1000;\n        if (needSearchForReuse && config.isDeltaCompress())\n            delay = 500;\n        ((BatchingProgressMonitor) compressMonitor).setDelayStart(delay, TimeUnit.MILLISECONDS);\n    }\n    if (needSearchForReuse)\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    crc32 = new CRC32();\n    final PackOutputStream out = new PackOutputStream(writeMonitor, isIndexDisabled() ? packStream : new CheckedOutputStream(packStream, crc32), this);\n    long objCnt = getObjectCount();\n    stats.totalObjects = objCnt;\n    beginPhase(PackingPhase.WRITING, writeMonitor, objCnt);\n    long writeStart = System.currentTimeMillis();\n    out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n    out.flush();\n    writeObjects(out);\n    if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n        for (Statistics.ObjectType typeStat : stats.objectTypes) {\n            if (typeStat == null)\n                continue;\n            stats.thinPackBytes += typeStat.bytes;\n        }\n    }\n    for (CachedPack pack : cachedPacks) {\n        long deltaCnt = pack.getDeltaCount();\n        stats.reusedObjects += pack.getObjectCount();\n        stats.reusedDeltas += deltaCnt;\n        stats.totalDeltas += deltaCnt;\n        reuseSupport.copyPackAsIs(out, pack, reuseValidate);\n    }\n    writeChecksum(out);\n    out.flush();\n    stats.timeWriting = System.currentTimeMillis() - writeStart;\n    stats.totalBytes = out.length();\n    stats.reusedPacks = Collections.unmodifiableList(cachedPacks);\n    stats.depth = depth;\n    for (Statistics.ObjectType typeStat : stats.objectTypes) {\n        if (typeStat == null)\n            continue;\n        typeStat.cntDeltas += typeStat.reusedDeltas;\n        stats.reusedObjects += typeStat.reusedObjects;\n        stats.reusedDeltas += typeStat.reusedDeltas;\n        stats.totalDeltas += typeStat.cntDeltas;\n    }\n    reader.release();\n    endPhase(writeMonitor);\n}"
    },
    {
      "commit": "f32b8612433e499090c76ded014dd5e94322b786",
      "startLine": 8,
      "endLine": 18,
      "methodCode": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor == null)\n        compressMonitor = NullProgressMonitor.INSTANCE;\n    if (writeMonitor == null)\n        writeMonitor = NullProgressMonitor.INSTANCE;\n    excludeInPacks = null;\n    excludeInPackLast = null;\n    boolean needSearchForReuse = reuseSupport != null && (reuseDeltas || config.isReuseObjects() || !cachedPacks.isEmpty());\n    if (compressMonitor instanceof BatchingProgressMonitor) {\n        long delay = 1000;\n        if (needSearchForReuse && config.isDeltaCompress())\n            delay = 500;\n        ((BatchingProgressMonitor) compressMonitor).setDelayStart(delay, TimeUnit.MILLISECONDS);\n    }\n    if (needSearchForReuse)\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    final PackOutputStream out = new PackOutputStream(writeMonitor, packStream, this);\n    long objCnt = getObjectCount();\n    stats.totalObjects = objCnt;\n    beginPhase(PackingPhase.WRITING, writeMonitor, objCnt);\n    long writeStart = System.currentTimeMillis();\n    out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n    out.flush();\n    writeObjects(out);\n    if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n        for (Statistics.ObjectType typeStat : stats.objectTypes) {\n            if (typeStat == null)\n                continue;\n            stats.thinPackBytes += typeStat.bytes;\n        }\n    }\n    for (CachedPack pack : cachedPacks) {\n        long deltaCnt = pack.getDeltaCount();\n        stats.reusedObjects += pack.getObjectCount();\n        stats.reusedDeltas += deltaCnt;\n        stats.totalDeltas += deltaCnt;\n        reuseSupport.copyPackAsIs(out, pack, reuseValidate);\n    }\n    writeChecksum(out);\n    out.flush();\n    stats.timeWriting = System.currentTimeMillis() - writeStart;\n    stats.totalBytes = out.length();\n    stats.reusedPacks = Collections.unmodifiableList(cachedPacks);\n    stats.depth = depth;\n    for (Statistics.ObjectType typeStat : stats.objectTypes) {\n        if (typeStat == null)\n            continue;\n        typeStat.cntDeltas += typeStat.reusedDeltas;\n        stats.reusedObjects += typeStat.reusedObjects;\n        stats.reusedDeltas += typeStat.reusedDeltas;\n        stats.totalDeltas += typeStat.cntDeltas;\n    }\n    reader.release();\n    endPhase(writeMonitor);\n}"
    },
    {
      "commit": "1421106d7627eb2c55b97b70d105b5ba1e26a2c0",
      "startLine": 8,
      "endLine": 18,
      "methodCode": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor == null)\n        compressMonitor = NullProgressMonitor.INSTANCE;\n    if (writeMonitor == null)\n        writeMonitor = NullProgressMonitor.INSTANCE;\n    excludeInPacks = null;\n    excludeInPackLast = null;\n    boolean needSearchForReuse = reuseSupport != null && (reuseDeltas || config.isReuseObjects() || !cachedPacks.isEmpty());\n    if (compressMonitor instanceof BatchingProgressMonitor) {\n        long delay = 1000;\n        if (needSearchForReuse && config.isDeltaCompress())\n            delay = 500;\n        ((BatchingProgressMonitor) compressMonitor).setDelayStart(delay, TimeUnit.MILLISECONDS);\n    }\n    if (needSearchForReuse)\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    final PackOutputStream out = new PackOutputStream(writeMonitor, packStream, this);\n    long objCnt = getObjectCount();\n    stats.totalObjects = objCnt;\n    beginPhase(PackingPhase.WRITING, writeMonitor, objCnt);\n    long writeStart = System.currentTimeMillis();\n    out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n    out.flush();\n    writeObjects(out);\n    if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n        for (Statistics.ObjectType typeStat : stats.objectTypes) {\n            if (typeStat == null)\n                continue;\n            stats.thinPackBytes += typeStat.bytes;\n        }\n    }\n    for (CachedPack pack : cachedPacks) {\n        long deltaCnt = pack.getDeltaCount();\n        stats.reusedObjects += pack.getObjectCount();\n        stats.reusedDeltas += deltaCnt;\n        stats.totalDeltas += deltaCnt;\n        reuseSupport.copyPackAsIs(out, pack, reuseValidate);\n    }\n    writeChecksum(out);\n    out.flush();\n    stats.timeWriting = System.currentTimeMillis() - writeStart;\n    stats.totalBytes = out.length();\n    stats.reusedPacks = Collections.unmodifiableList(cachedPacks);\n    stats.depth = depth;\n    for (Statistics.ObjectType typeStat : stats.objectTypes) {\n        if (typeStat == null)\n            continue;\n        typeStat.cntDeltas += typeStat.reusedDeltas;\n        stats.reusedObjects += typeStat.reusedObjects;\n        stats.reusedDeltas += typeStat.reusedDeltas;\n        stats.totalDeltas += typeStat.cntDeltas;\n    }\n    reader.release();\n    endPhase(writeMonitor);\n}"
    },
    {
      "commit": "16b8ebf2d1d099ac355767b1b1853ae7bf8854f1",
      "startLine": 8,
      "endLine": 18,
      "methodCode": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor == null)\n        compressMonitor = NullProgressMonitor.INSTANCE;\n    if (writeMonitor == null)\n        writeMonitor = NullProgressMonitor.INSTANCE;\n    excludeInPacks = null;\n    excludeInPackLast = null;\n    boolean needSearchForReuse = reuseSupport != null && (reuseDeltas || config.isReuseObjects() || !cachedPacks.isEmpty());\n    if (compressMonitor instanceof BatchingProgressMonitor) {\n        long delay = 1000;\n        if (needSearchForReuse && config.isDeltaCompress())\n            delay = 500;\n        ((BatchingProgressMonitor) compressMonitor).setDelayStart(delay, TimeUnit.MILLISECONDS);\n    }\n    if (needSearchForReuse)\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    final PackOutputStream out = new PackOutputStream(writeMonitor, packStream, this);\n    long objCnt = getObjectCount();\n    stats.totalObjects = objCnt;\n    beginPhase(PackingPhase.WRITING, writeMonitor, (int) objCnt);\n    long writeStart = System.currentTimeMillis();\n    out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n    out.flush();\n    writeObjects(out);\n    if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n        for (Statistics.ObjectType typeStat : stats.objectTypes) {\n            if (typeStat == null)\n                continue;\n            stats.thinPackBytes += typeStat.bytes;\n        }\n    }\n    for (CachedPack pack : cachedPacks) {\n        long deltaCnt = pack.getDeltaCount();\n        stats.reusedObjects += pack.getObjectCount();\n        stats.reusedDeltas += deltaCnt;\n        stats.totalDeltas += deltaCnt;\n        reuseSupport.copyPackAsIs(out, pack, reuseValidate);\n    }\n    writeChecksum(out);\n    out.flush();\n    stats.timeWriting = System.currentTimeMillis() - writeStart;\n    stats.totalBytes = out.length();\n    stats.reusedPacks = Collections.unmodifiableList(cachedPacks);\n    stats.depth = depth;\n    for (Statistics.ObjectType typeStat : stats.objectTypes) {\n        if (typeStat == null)\n            continue;\n        typeStat.cntDeltas += typeStat.reusedDeltas;\n        stats.reusedObjects += typeStat.reusedObjects;\n        stats.reusedDeltas += typeStat.reusedDeltas;\n        stats.totalDeltas += typeStat.cntDeltas;\n    }\n    reader.release();\n    endPhase(writeMonitor);\n}"
    },
    {
      "commit": "1b6a549ff350673402f797fe7f878175e2b5ba30",
      "startLine": 8,
      "endLine": 18,
      "methodCode": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor == null)\n        compressMonitor = NullProgressMonitor.INSTANCE;\n    if (writeMonitor == null)\n        writeMonitor = NullProgressMonitor.INSTANCE;\n    excludeInPacks = null;\n    excludeInPackLast = null;\n    boolean needSearchForReuse = reuseSupport != null && (reuseDeltas || config.isReuseObjects() || !cachedPacks.isEmpty());\n    if (compressMonitor instanceof BatchingProgressMonitor) {\n        long delay = 1000;\n        if (needSearchForReuse && config.isDeltaCompress())\n            delay = 500;\n        ((BatchingProgressMonitor) compressMonitor).setDelayStart(delay, TimeUnit.MILLISECONDS);\n    }\n    if (needSearchForReuse)\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    final PackOutputStream out = new PackOutputStream(writeMonitor, packStream, this);\n    long objCnt = getObjectCount();\n    stats.totalObjects = objCnt;\n    writeMonitor.beginTask(JGitText.get().writingObjects, (int) objCnt);\n    long writeStart = System.currentTimeMillis();\n    out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n    out.flush();\n    writeObjects(out);\n    if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n        for (Statistics.ObjectType typeStat : stats.objectTypes) {\n            if (typeStat == null)\n                continue;\n            stats.thinPackBytes += typeStat.bytes;\n        }\n    }\n    for (CachedPack pack : cachedPacks) {\n        long deltaCnt = pack.getDeltaCount();\n        stats.reusedObjects += pack.getObjectCount();\n        stats.reusedDeltas += deltaCnt;\n        stats.totalDeltas += deltaCnt;\n        reuseSupport.copyPackAsIs(out, pack, reuseValidate);\n    }\n    writeChecksum(out);\n    out.flush();\n    stats.timeWriting = System.currentTimeMillis() - writeStart;\n    stats.totalBytes = out.length();\n    stats.reusedPacks = Collections.unmodifiableList(cachedPacks);\n    stats.depth = depth;\n    for (Statistics.ObjectType typeStat : stats.objectTypes) {\n        if (typeStat == null)\n            continue;\n        typeStat.cntDeltas += typeStat.reusedDeltas;\n        stats.reusedObjects += typeStat.reusedObjects;\n        stats.reusedDeltas += typeStat.reusedDeltas;\n        stats.totalDeltas += typeStat.cntDeltas;\n    }\n    reader.release();\n    writeMonitor.endTask();\n}"
    },
    {
      "commit": "a1a8c6d77ec5bea13c4f5ca428e425d95e14e003",
      "startLine": 8,
      "endLine": 18,
      "methodCode": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor == null)\n        compressMonitor = NullProgressMonitor.INSTANCE;\n    if (writeMonitor == null)\n        writeMonitor = NullProgressMonitor.INSTANCE;\n    excludeInPacks = null;\n    excludeInPackLast = null;\n    boolean needSearchForReuse = reuseSupport != null && (reuseDeltas || config.isReuseObjects() || !cachedPacks.isEmpty());\n    if (compressMonitor instanceof BatchingProgressMonitor) {\n        long delay = 1000;\n        if (needSearchForReuse && config.isDeltaCompress())\n            delay = 500;\n        ((BatchingProgressMonitor) compressMonitor).setDelayStart(delay, TimeUnit.MILLISECONDS);\n    }\n    if (needSearchForReuse)\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    final PackOutputStream out = new PackOutputStream(writeMonitor, packStream, this);\n    long objCnt = getObjectCount();\n    stats.totalObjects = objCnt;\n    writeMonitor.beginTask(JGitText.get().writingObjects, (int) objCnt);\n    long writeStart = System.currentTimeMillis();\n    out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n    out.flush();\n    writeObjects(out);\n    if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n        for (Statistics.ObjectType typeStat : stats.objectTypes) {\n            if (typeStat == null)\n                continue;\n            stats.thinPackBytes += typeStat.bytes;\n        }\n    }\n    for (CachedPack pack : cachedPacks) {\n        long deltaCnt = pack.getDeltaCount();\n        stats.reusedObjects += pack.getObjectCount();\n        stats.reusedDeltas += deltaCnt;\n        stats.totalDeltas += deltaCnt;\n        reuseSupport.copyPackAsIs(out, pack, reuseValidate);\n    }\n    writeChecksum(out);\n    out.flush();\n    stats.timeWriting = System.currentTimeMillis() - writeStart;\n    stats.totalBytes = out.length();\n    stats.reusedPacks = Collections.unmodifiableList(cachedPacks);\n    for (Statistics.ObjectType typeStat : stats.objectTypes) {\n        if (typeStat == null)\n            continue;\n        typeStat.cntDeltas += typeStat.reusedDeltas;\n        stats.reusedObjects += typeStat.reusedObjects;\n        stats.reusedDeltas += typeStat.reusedDeltas;\n        stats.totalDeltas += typeStat.cntDeltas;\n    }\n    reader.release();\n    writeMonitor.endTask();\n}"
    },
    {
      "commit": "68cc21b60d83b5c4fb1de6c34a79836c51dd9b3b",
      "startLine": 6,
      "endLine": 16,
      "methodCode": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor == null)\n        compressMonitor = NullProgressMonitor.INSTANCE;\n    if (writeMonitor == null)\n        writeMonitor = NullProgressMonitor.INSTANCE;\n    boolean needSearchForReuse = reuseSupport != null && (reuseDeltas || config.isReuseObjects() || !cachedPacks.isEmpty());\n    if (compressMonitor instanceof BatchingProgressMonitor) {\n        long delay = 1000;\n        if (needSearchForReuse && config.isDeltaCompress())\n            delay = 500;\n        ((BatchingProgressMonitor) compressMonitor).setDelayStart(delay, TimeUnit.MILLISECONDS);\n    }\n    if (needSearchForReuse)\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    final PackOutputStream out = new PackOutputStream(writeMonitor, packStream, this);\n    long objCnt = getObjectCount();\n    stats.totalObjects = objCnt;\n    writeMonitor.beginTask(JGitText.get().writingObjects, (int) objCnt);\n    long writeStart = System.currentTimeMillis();\n    out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n    out.flush();\n    writeObjects(out);\n    if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n        for (Statistics.ObjectType typeStat : stats.objectTypes) {\n            if (typeStat == null)\n                continue;\n            stats.thinPackBytes += typeStat.bytes;\n        }\n    }\n    for (CachedPack pack : cachedPacks) {\n        long deltaCnt = pack.getDeltaCount();\n        stats.reusedObjects += pack.getObjectCount();\n        stats.reusedDeltas += deltaCnt;\n        stats.totalDeltas += deltaCnt;\n        reuseSupport.copyPackAsIs(out, pack, reuseValidate);\n    }\n    writeChecksum(out);\n    out.flush();\n    stats.timeWriting = System.currentTimeMillis() - writeStart;\n    stats.totalBytes = out.length();\n    stats.reusedPacks = Collections.unmodifiableList(cachedPacks);\n    for (Statistics.ObjectType typeStat : stats.objectTypes) {\n        if (typeStat == null)\n            continue;\n        typeStat.cntDeltas += typeStat.reusedDeltas;\n        stats.reusedObjects += typeStat.reusedObjects;\n        stats.reusedDeltas += typeStat.reusedDeltas;\n        stats.totalDeltas += typeStat.cntDeltas;\n    }\n    reader.release();\n    writeMonitor.endTask();\n}"
    },
    {
      "commit": "9f5bbb5dd41f87d6428eb49c021e00d8099d0c17",
      "startLine": 6,
      "endLine": 9,
      "methodCode": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor == null)\n        compressMonitor = NullProgressMonitor.INSTANCE;\n    if (writeMonitor == null)\n        writeMonitor = NullProgressMonitor.INSTANCE;\n    if (reuseSupport != null && (reuseDeltas || config.isReuseObjects() || !cachedPacks.isEmpty()))\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    final PackOutputStream out = new PackOutputStream(writeMonitor, packStream, this);\n    long objCnt = getObjectCount();\n    stats.totalObjects = objCnt;\n    writeMonitor.beginTask(JGitText.get().writingObjects, (int) objCnt);\n    long writeStart = System.currentTimeMillis();\n    out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n    out.flush();\n    writeObjects(out);\n    if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n        for (Statistics.ObjectType typeStat : stats.objectTypes) {\n            if (typeStat == null)\n                continue;\n            stats.thinPackBytes += typeStat.bytes;\n        }\n    }\n    for (CachedPack pack : cachedPacks) {\n        long deltaCnt = pack.getDeltaCount();\n        stats.reusedObjects += pack.getObjectCount();\n        stats.reusedDeltas += deltaCnt;\n        stats.totalDeltas += deltaCnt;\n        reuseSupport.copyPackAsIs(out, pack, reuseValidate);\n    }\n    writeChecksum(out);\n    out.flush();\n    stats.timeWriting = System.currentTimeMillis() - writeStart;\n    stats.totalBytes = out.length();\n    stats.reusedPacks = Collections.unmodifiableList(cachedPacks);\n    for (Statistics.ObjectType typeStat : stats.objectTypes) {\n        if (typeStat == null)\n            continue;\n        typeStat.cntDeltas += typeStat.reusedDeltas;\n        stats.reusedObjects += typeStat.reusedObjects;\n        stats.reusedDeltas += typeStat.reusedDeltas;\n        stats.totalDeltas += typeStat.cntDeltas;\n    }\n    reader.release();\n    writeMonitor.endTask();\n}"
    },
    {
      "commit": "bb1956e647d2f48ef36ef98a7f22120fdad0b37c",
      "startLine": 6,
      "endLine": 9,
      "methodCode": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor == null)\n        compressMonitor = NullProgressMonitor.INSTANCE;\n    if (writeMonitor == null)\n        writeMonitor = NullProgressMonitor.INSTANCE;\n    if ((reuseDeltas || config.isReuseObjects()) && reuseSupport != null)\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    final PackOutputStream out = new PackOutputStream(writeMonitor, packStream, this);\n    long objCnt = getObjectCount();\n    stats.totalObjects = objCnt;\n    writeMonitor.beginTask(JGitText.get().writingObjects, (int) objCnt);\n    long writeStart = System.currentTimeMillis();\n    out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n    out.flush();\n    writeObjects(out);\n    if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n        for (Statistics.ObjectType typeStat : stats.objectTypes) {\n            if (typeStat == null)\n                continue;\n            stats.thinPackBytes += typeStat.bytes;\n        }\n    }\n    for (CachedPack pack : cachedPacks) {\n        long deltaCnt = pack.getDeltaCount();\n        stats.reusedObjects += pack.getObjectCount();\n        stats.reusedDeltas += deltaCnt;\n        stats.totalDeltas += deltaCnt;\n        reuseSupport.copyPackAsIs(out, pack, reuseValidate);\n    }\n    writeChecksum(out);\n    out.flush();\n    stats.timeWriting = System.currentTimeMillis() - writeStart;\n    stats.totalBytes = out.length();\n    stats.reusedPacks = Collections.unmodifiableList(cachedPacks);\n    for (Statistics.ObjectType typeStat : stats.objectTypes) {\n        if (typeStat == null)\n            continue;\n        typeStat.cntDeltas += typeStat.reusedDeltas;\n        stats.reusedObjects += typeStat.reusedObjects;\n        stats.reusedDeltas += typeStat.reusedDeltas;\n        stats.totalDeltas += typeStat.cntDeltas;\n    }\n    reader.release();\n    writeMonitor.endTask();\n}"
    },
    {
      "commit": "7a9bf1e2e034ad922a6fe4c7fc5b0f43baa69267",
      "startLine": 6,
      "endLine": 9,
      "methodCode": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor == null)\n        compressMonitor = NullProgressMonitor.INSTANCE;\n    if (writeMonitor == null)\n        writeMonitor = NullProgressMonitor.INSTANCE;\n    if ((reuseDeltas || config.isReuseObjects()) && reuseSupport != null)\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    final PackOutputStream out = new PackOutputStream(writeMonitor, packStream, this);\n    long objCnt = getObjectCount();\n    stats.totalObjects = objCnt;\n    writeMonitor.beginTask(JGitText.get().writingObjects, (int) objCnt);\n    long writeStart = System.currentTimeMillis();\n    long headerStart = out.length();\n    out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n    out.flush();\n    long headerEnd = out.length();\n    writeObjects(out);\n    if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty())\n        stats.thinPackBytes = out.length() - (headerEnd - headerStart);\n    for (CachedPack pack : cachedPacks) {\n        long deltaCnt = pack.getDeltaCount();\n        stats.reusedObjects += pack.getObjectCount();\n        stats.reusedDeltas += deltaCnt;\n        stats.totalDeltas += deltaCnt;\n        reuseSupport.copyPackAsIs(out, pack, reuseValidate);\n    }\n    writeChecksum(out);\n    out.flush();\n    stats.timeWriting = System.currentTimeMillis() - writeStart;\n    stats.totalBytes = out.length();\n    stats.reusedPacks = Collections.unmodifiableList(cachedPacks);\n    reader.release();\n    writeMonitor.endTask();\n}"
    },
    {
      "commit": "65f9a6e58bd9296cbbe1cffc7cf079fd65991686",
      "startLine": 6,
      "endLine": 9,
      "methodCode": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor == null)\n        compressMonitor = NullProgressMonitor.INSTANCE;\n    if (writeMonitor == null)\n        writeMonitor = NullProgressMonitor.INSTANCE;\n    if ((reuseDeltas || config.isReuseObjects()) && reuseSupport != null)\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    final PackOutputStream out = new PackOutputStream(writeMonitor, packStream, this);\n    long objCnt = getObjectsNumber();\n    stats.totalObjects = objCnt;\n    writeMonitor.beginTask(JGitText.get().writingObjects, (int) objCnt);\n    long writeStart = System.currentTimeMillis();\n    long headerStart = out.length();\n    out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n    out.flush();\n    long headerEnd = out.length();\n    writeObjects(out);\n    if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty())\n        stats.thinPackBytes = out.length() - (headerEnd - headerStart);\n    for (CachedPack pack : cachedPacks) {\n        long deltaCnt = pack.getDeltaCount();\n        stats.reusedObjects += pack.getObjectCount();\n        stats.reusedDeltas += deltaCnt;\n        stats.totalDeltas += deltaCnt;\n        reuseSupport.copyPackAsIs(out, pack, reuseValidate);\n    }\n    writeChecksum(out);\n    out.flush();\n    stats.timeWriting = System.currentTimeMillis() - writeStart;\n    stats.totalBytes = out.length();\n    stats.reusedPacks = Collections.unmodifiableList(cachedPacks);\n    reader.release();\n    writeMonitor.endTask();\n}"
    },
    {
      "commit": "a468cb57c2f2fbd8da163f002b505255ea768244",
      "startLine": 6,
      "endLine": 9,
      "methodCode": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor == null)\n        compressMonitor = NullProgressMonitor.INSTANCE;\n    if (writeMonitor == null)\n        writeMonitor = NullProgressMonitor.INSTANCE;\n    if ((reuseDeltas || config.isReuseObjects()) && reuseSupport != null)\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    final PackOutputStream out = new PackOutputStream(writeMonitor, packStream, this);\n    long objCnt = 0;\n    for (List<ObjectToPack> list : objectsLists) objCnt += list.size();\n    for (CachedPack pack : cachedPacks) objCnt += pack.getObjectCount();\n    stats.totalObjects = objCnt;\n    writeMonitor.beginTask(JGitText.get().writingObjects, (int) objCnt);\n    long writeStart = System.currentTimeMillis();\n    long headerStart = out.length();\n    out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n    out.flush();\n    long headerEnd = out.length();\n    writeObjects(out);\n    if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty())\n        stats.thinPackBytes = out.length() - (headerEnd - headerStart);\n    for (CachedPack pack : cachedPacks) {\n        long deltaCnt = pack.getDeltaCount();\n        stats.reusedObjects += pack.getObjectCount();\n        stats.reusedDeltas += deltaCnt;\n        stats.totalDeltas += deltaCnt;\n        reuseSupport.copyPackAsIs(out, pack, reuseValidate);\n    }\n    writeChecksum(out);\n    out.flush();\n    stats.timeWriting = System.currentTimeMillis() - writeStart;\n    stats.totalBytes = out.length();\n    stats.reusedPacks = Collections.unmodifiableList(cachedPacks);\n    reader.release();\n    writeMonitor.endTask();\n}"
    },
    {
      "commit": "388ba7e005fdc5b61a7a494fa44ba24489d0c6d0",
      "startLine": 6,
      "endLine": 9,
      "methodCode": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor == null)\n        compressMonitor = NullProgressMonitor.INSTANCE;\n    if (writeMonitor == null)\n        writeMonitor = NullProgressMonitor.INSTANCE;\n    if ((reuseDeltas || config.isReuseObjects()) && reuseSupport != null)\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    final PackOutputStream out = new PackOutputStream(writeMonitor, packStream, this);\n    long objCnt = 0;\n    for (List<ObjectToPack> list : objectsLists) objCnt += list.size();\n    for (CachedPack pack : cachedPacks) objCnt += pack.getObjectCount();\n    stats.totalObjects = objCnt;\n    writeMonitor.beginTask(JGitText.get().writingObjects, (int) objCnt);\n    long writeStart = System.currentTimeMillis();\n    long headerStart = out.length();\n    out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n    out.flush();\n    long headerEnd = out.length();\n    writeObjects(out);\n    if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty())\n        stats.thinPackBytes = out.length() - (headerEnd - headerStart);\n    for (CachedPack pack : cachedPacks) {\n        long deltaCnt = pack.getDeltaCount();\n        stats.reusedObjects += pack.getObjectCount();\n        stats.reusedDeltas += deltaCnt;\n        stats.totalDeltas += deltaCnt;\n        reuseSupport.copyPackAsIs(out, pack);\n    }\n    writeChecksum(out);\n    out.flush();\n    stats.timeWriting = System.currentTimeMillis() - writeStart;\n    stats.totalBytes = out.length();\n    stats.reusedPacks = Collections.unmodifiableList(cachedPacks);\n    reader.release();\n    writeMonitor.endTask();\n}"
    },
    {
      "commit": "14f99dc29d67fa4d2cb227ab906c5c8379499f6b",
      "startLine": 6,
      "endLine": 9,
      "methodCode": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor == null)\n        compressMonitor = NullProgressMonitor.INSTANCE;\n    if (writeMonitor == null)\n        writeMonitor = NullProgressMonitor.INSTANCE;\n    if ((reuseDeltas || config.isReuseObjects()) && reuseSupport != null)\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    final PackOutputStream out = new PackOutputStream(writeMonitor, packStream, this);\n    long objCnt = 0;\n    for (List<ObjectToPack> list : objectsLists) objCnt += list.size();\n    for (CachedPack pack : cachedPacks) objCnt += pack.getObjectCount();\n    stats.totalObjects = objCnt;\n    writeMonitor.beginTask(JGitText.get().writingObjects, (int) objCnt);\n    long writeStart = System.currentTimeMillis();\n    long headerStart = out.length();\n    out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n    out.flush();\n    long headerEnd = out.length();\n    writeObjects(out);\n    if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty())\n        stats.thinPackBytes = out.length() - (headerEnd - headerStart);\n    for (CachedPack pack : cachedPacks) {\n        stats.reusedObjects += pack.getObjectCount();\n        stats.reusedDeltas += pack.getDeltaCount();\n        reuseSupport.copyPackAsIs(out, pack);\n    }\n    writeChecksum(out);\n    out.flush();\n    stats.timeWriting = System.currentTimeMillis() - writeStart;\n    stats.totalBytes = out.length();\n    stats.reusedPacks = Collections.unmodifiableList(cachedPacks);\n    reader.release();\n    writeMonitor.endTask();\n}"
    },
    {
      "commit": "c8c4524b6b36c1d97e715de9e1ff1aa18763a390",
      "startLine": 6,
      "endLine": 9,
      "methodCode": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor == null)\n        compressMonitor = NullProgressMonitor.INSTANCE;\n    if (writeMonitor == null)\n        writeMonitor = NullProgressMonitor.INSTANCE;\n    if ((reuseDeltas || config.isReuseObjects()) && reuseSupport != null)\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    final PackOutputStream out = new PackOutputStream(writeMonitor, packStream, this);\n    long objCnt = 0;\n    for (List<ObjectToPack> list : objectsLists) objCnt += list.size();\n    for (CachedPack pack : cachedPacks) objCnt += pack.getObjectCount();\n    stats.totalObjects = objCnt;\n    writeMonitor.beginTask(JGitText.get().writingObjects, (int) objCnt);\n    long writeStart = System.currentTimeMillis();\n    long headerStart = out.length();\n    out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n    out.flush();\n    long headerEnd = out.length();\n    writeObjects(out);\n    if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty())\n        stats.thinPackBytes = out.length() - (headerEnd - headerStart);\n    for (CachedPack pack : cachedPacks) {\n        stats.reusedObjects += pack.getObjectCount();\n        reuseSupport.copyPackAsIs(out, pack);\n    }\n    writeChecksum(out);\n    out.flush();\n    stats.timeWriting = System.currentTimeMillis() - writeStart;\n    stats.totalBytes = out.length();\n    stats.reusedPacks = Collections.unmodifiableList(cachedPacks);\n    reader.release();\n    writeMonitor.endTask();\n}"
    },
    {
      "commit": "461b012e9565af8174e5b9d2b2c3a582011ce77e",
      "startLine": 6,
      "endLine": 9,
      "methodCode": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor == null)\n        compressMonitor = NullProgressMonitor.INSTANCE;\n    if (writeMonitor == null)\n        writeMonitor = NullProgressMonitor.INSTANCE;\n    if ((reuseDeltas || config.isReuseObjects()) && reuseSupport != null)\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    final PackOutputStream out = new PackOutputStream(writeMonitor, packStream, this);\n    long objCnt = 0;\n    for (List<ObjectToPack> list : objectsLists) objCnt += list.size();\n    for (CachedPack pack : cachedPacks) objCnt += pack.getObjectCount();\n    stats.totalObjects = objCnt;\n    writeMonitor.beginTask(JGitText.get().writingObjects, (int) objCnt);\n    out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n    out.flush();\n    writeObjects(out);\n    for (CachedPack pack : cachedPacks) {\n        stats.reusedObjects += pack.getObjectCount();\n        reuseSupport.copyPackAsIs(out, pack);\n    }\n    writeChecksum(out);\n    reader.release();\n    writeMonitor.endTask();\n}"
    },
    {
      "commit": "71f168fcd77ec100d68233d3d467f770304f6eb8",
      "startLine": 6,
      "endLine": 9,
      "methodCode": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor == null)\n        compressMonitor = NullProgressMonitor.INSTANCE;\n    if (writeMonitor == null)\n        writeMonitor = NullProgressMonitor.INSTANCE;\n    if ((reuseDeltas || config.isReuseObjects()) && reuseSupport != null)\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    final PackOutputStream out = new PackOutputStream(writeMonitor, packStream, this);\n    int objCnt = getObjectsNumber();\n    stats.totalObjects = objCnt;\n    writeMonitor.beginTask(JGitText.get().writingObjects, objCnt);\n    out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n    out.flush();\n    writeObjects(out);\n    writeChecksum(out);\n    reader.release();\n    writeMonitor.endTask();\n}"
    },
    {
      "commit": "28ba4747bc166243ecff86cdc7460cbc969a8eb4",
      "startLine": 6,
      "endLine": 9,
      "methodCode": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor == null)\n        compressMonitor = NullProgressMonitor.INSTANCE;\n    if (writeMonitor == null)\n        writeMonitor = NullProgressMonitor.INSTANCE;\n    if ((reuseDeltas || config.isReuseObjects()) && reuseSupport != null)\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    final PackOutputStream out = new PackOutputStream(writeMonitor, packStream, this);\n    int objCnt = getObjectsNumber();\n    writeMonitor.beginTask(JGitText.get().writingObjects, objCnt);\n    out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n    out.flush();\n    writeObjects(out);\n    writeChecksum(out);\n    reader.release();\n    writeMonitor.endTask();\n}"
    },
    {
      "commit": "b85af06324644e699bd2cc7e2047ae1f65f35db5",
      "startLine": 6,
      "endLine": 9,
      "methodCode": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor == null)\n        compressMonitor = NullProgressMonitor.INSTANCE;\n    if (writeMonitor == null)\n        writeMonitor = NullProgressMonitor.INSTANCE;\n    if ((reuseDeltas || config.isReuseObjects()) && reuseSupport != null)\n        searchForReuse(compressMonitor);\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    final PackOutputStream out = new PackOutputStream(writeMonitor, packStream, this);\n    int objCnt = getObjectsNumber();\n    writeMonitor.beginTask(JGitText.get().writingObjects, objCnt);\n    out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n    out.flush();\n    writeObjects(writeMonitor, out);\n    writeChecksum(out);\n    reader.release();\n    writeMonitor.endTask();\n}"
    },
    {
      "commit": "cc6210619b82dc0c7bdb014b5ccf29d6f93e5ef3",
      "startLine": 6,
      "endLine": 9,
      "methodCode": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor == null)\n        compressMonitor = NullProgressMonitor.INSTANCE;\n    if (writeMonitor == null)\n        writeMonitor = NullProgressMonitor.INSTANCE;\n    if ((reuseDeltas || config.isReuseObjects()) && reuseSupport != null)\n        searchForReuse();\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    final PackOutputStream out = new PackOutputStream(writeMonitor, packStream, this);\n    int objCnt = getObjectsNumber();\n    writeMonitor.beginTask(JGitText.get().writingObjects, objCnt);\n    out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n    out.flush();\n    writeObjects(writeMonitor, out);\n    writeChecksum(out);\n    reader.release();\n    writeMonitor.endTask();\n}"
    },
    {
      "commit": "1a06179ea707ab088b6543df77be5cf0ea44c497",
      "startLine": 6,
      "endLine": 9,
      "methodCode": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor == null)\n        compressMonitor = NullProgressMonitor.INSTANCE;\n    if (writeMonitor == null)\n        writeMonitor = NullProgressMonitor.INSTANCE;\n    if ((reuseDeltas || config.isReuseObjects()) && reuseSupport != null)\n        searchForReuse();\n    if (config.isDeltaCompress())\n        searchForDeltas(compressMonitor);\n    final PackOutputStream out = new PackOutputStream(writeMonitor, packStream, this);\n    int objCnt = getObjectsNumber();\n    writeMonitor.beginTask(JGitText.get().writingObjects, objCnt);\n    out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n    writeObjects(writeMonitor, out);\n    writeChecksum(out);\n    reader.release();\n    writeMonitor.endTask();\n}"
    },
    {
      "commit": "21f76c2a69836ec618c82eb9305656dcec70befb",
      "startLine": 6,
      "endLine": 9,
      "methodCode": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor == null)\n        compressMonitor = NullProgressMonitor.INSTANCE;\n    if (writeMonitor == null)\n        writeMonitor = NullProgressMonitor.INSTANCE;\n    if ((reuseDeltas || reuseObjects) && reuseSupport != null)\n        searchForReuse();\n    if (deltaCompress)\n        searchForDeltas(compressMonitor);\n    final PackOutputStream out = new PackOutputStream(writeMonitor, packStream, this);\n    int objCnt = getObjectsNumber();\n    writeMonitor.beginTask(JGitText.get().writingObjects, objCnt);\n    out.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n    writeObjects(writeMonitor, out);\n    writeChecksum(out);\n    reader.release();\n    writeMonitor.endTask();\n}"
    },
    {
      "commit": "a00377a7e23dbde315598ee20f61c45d031e159a",
      "startLine": 6,
      "endLine": 9,
      "methodCode": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor == null)\n        compressMonitor = NullProgressMonitor.INSTANCE;\n    if (writeMonitor == null)\n        writeMonitor = NullProgressMonitor.INSTANCE;\n    if ((reuseDeltas || reuseObjects) && reuseSupport != null)\n        searchForReuse();\n    if (deltaCompress)\n        searchForDeltas(compressMonitor);\n    final PackOutputStream out = new PackOutputStream(writeMonitor, packStream, this);\n    writeMonitor.beginTask(WRITING_OBJECTS_PROGRESS, getObjectsNumber());\n    out.writeFileHeader(PACK_VERSION_GENERATED, getObjectsNumber());\n    writeObjects(writeMonitor, out);\n    writeChecksum(out);\n    reader.release();\n    writeMonitor.endTask();\n}"
    },
    {
      "commit": "dfad23bf3d9b17cc3e9d736fa3daf6ace52dbc33",
      "startLine": 6,
      "endLine": 9,
      "methodCode": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor == null)\n        compressMonitor = NullProgressMonitor.INSTANCE;\n    if (writeMonitor == null)\n        writeMonitor = NullProgressMonitor.INSTANCE;\n    if ((reuseDeltas || reuseObjects) && reuseSupport != null)\n        searchForReuse();\n    if (deltaCompress)\n        searchForDeltas(compressMonitor);\n    final PackOutputStream out = new PackOutputStream(writeMonitor, packStream, this);\n    writeMonitor.beginTask(WRITING_OBJECTS_PROGRESS, getObjectsNumber());\n    out.writeFileHeader(PACK_VERSION_GENERATED, getObjectsNumber());\n    writeObjects(writeMonitor, out);\n    writeChecksum(out);\n    reader.release();\n    writeMonitor.endTask();\n}"
    },
    {
      "commit": "074055d747026c47040d0306585863ad5d428860",
      "startLine": 6,
      "endLine": 7,
      "methodCode": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor == null)\n        compressMonitor = NullProgressMonitor.INSTANCE;\n    if (writeMonitor == null)\n        writeMonitor = NullProgressMonitor.INSTANCE;\n    if ((reuseDeltas || reuseObjects) && reuseSupport != null)\n        searchForReuse();\n    final PackOutputStream out = new PackOutputStream(writeMonitor, packStream, this);\n    writeMonitor.beginTask(WRITING_OBJECTS_PROGRESS, getObjectsNumber());\n    out.writeFileHeader(PACK_VERSION_GENERATED, getObjectsNumber());\n    writeObjects(writeMonitor, out);\n    writeChecksum(out);\n    reader.release();\n    writeMonitor.endTask();\n}"
    },
    {
      "commit": "4569d77e13c7bbf0c7466cbc57d0eefd117cb206",
      "startLine": 6,
      "endLine": 7,
      "methodCode": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor == null)\n        compressMonitor = NullProgressMonitor.INSTANCE;\n    if (writeMonitor == null)\n        writeMonitor = NullProgressMonitor.INSTANCE;\n    if ((reuseDeltas || reuseObjects) && reuseSupport != null)\n        searchForReuse();\n    final PackOutputStream out = new PackOutputStream(writeMonitor, packStream, isDeltaBaseAsOffset());\n    writeMonitor.beginTask(WRITING_OBJECTS_PROGRESS, getObjectsNumber());\n    out.writeFileHeader(PACK_VERSION_GENERATED, getObjectsNumber());\n    writeObjects(writeMonitor, out);\n    writeChecksum(out);\n    reader.release();\n    writeMonitor.endTask();\n}"
    },
    {
      "commit": "6b62e53b607630b6c00411741972838ced552f4d",
      "startLine": 6,
      "endLine": 7,
      "methodCode": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream) throws IOException {\n    if (compressMonitor == null)\n        compressMonitor = NullProgressMonitor.INSTANCE;\n    if (writeMonitor == null)\n        writeMonitor = NullProgressMonitor.INSTANCE;\n    if ((reuseDeltas || reuseObjects) && reuseSupport != null)\n        searchForReuse(compressMonitor);\n    final PackOutputStream out = new PackOutputStream(writeMonitor, packStream, isDeltaBaseAsOffset());\n    writeMonitor.beginTask(WRITING_OBJECTS_PROGRESS, getObjectsNumber());\n    out.writeFileHeader(PACK_VERSION_GENERATED, getObjectsNumber());\n    writeObjects(writeMonitor, out);\n    writeChecksum(out);\n    reader.release();\n    writeMonitor.endTask();\n}"
    },
    {
      "commit": "f288c27e465a91e80b53c4100c0d9b2f2341a9aa",
      "startLine": 2,
      "endLine": 3,
      "methodCode": "public void writePack(OutputStream packStream) throws IOException {\n    if ((reuseDeltas || reuseObjects) && reuseSupport != null)\n        searchForReuse();\n    final PackOutputStream out = new PackOutputStream(packStream, isDeltaBaseAsOffset());\n    writeMonitor.beginTask(WRITING_OBJECTS_PROGRESS, getObjectsNumber());\n    out.writeFileHeader(PACK_VERSION_GENERATED, getObjectsNumber());\n    writeObjects(out);\n    writeChecksum(out);\n    reader.release();\n    writeMonitor.endTask();\n}"
    },
    {
      "commit": "a45728d7a4fe1b83953ba38ec980caa6a3f1d3c4",
      "startLine": 2,
      "endLine": 3,
      "methodCode": "public void writePack(OutputStream packStream) throws IOException {\n    if ((reuseDeltas || reuseObjects) && reuseSupport != null)\n        searchForReuse();\n    out = new PackOutputStream(packStream, isDeltaBaseAsOffset());\n    writeMonitor.beginTask(WRITING_OBJECTS_PROGRESS, getObjectsNumber());\n    out.writeFileHeader(PACK_VERSION_GENERATED, getObjectsNumber());\n    writeObjects();\n    writeChecksum();\n    out = null;\n    reader.release();\n    writeMonitor.endTask();\n}"
    },
    {
      "commit": "b5aa52e98a8e1ee9b8530fc2c37a04df224aa0c1",
      "startLine": 3,
      "endLine": 4,
      "methodCode": "public void writePack(OutputStream packStream) throws IOException {\n    try {\n        if ((reuseDeltas || reuseObjects) && reuseSupport != null)\n            searchForReuse();\n        out = new PackOutputStream(packStream, isDeltaBaseAsOffset());\n        int cnt = getObjectsNumber();\n        writeMonitor.beginTask(WRITING_OBJECTS_PROGRESS, cnt);\n        out.writeFileHeader(PACK_VERSION_GENERATED, cnt);\n        writeObjects();\n        writeChecksum();\n        writeMonitor.endTask();\n    } finally {\n        out = null;\n        reader.release();\n    }\n}"
    },
    {
      "commit": "ea21c111cb7ac0c8dc39c4df3fe90c08ddcce066",
      "startLine": 2,
      "endLine": 3,
      "methodCode": "public void writePack(OutputStream packStream) throws IOException {\n    if ((reuseDeltas || reuseObjects) && reuseSupport != null)\n        searchForReuse();\n    out = new PackOutputStream(packStream, isDeltaBaseAsOffset());\n    writeMonitor.beginTask(WRITING_OBJECTS_PROGRESS, getObjectsNumber());\n    out.writeFileHeader(PACK_VERSION_GENERATED, getObjectsNumber());\n    writeObjects();\n    writeChecksum();\n    out = null;\n    reader.release();\n    writeMonitor.endTask();\n}"
    },
    {
      "commit": "ece88b99eb2ea6541b667aa066573184c25b6a8b",
      "startLine": 2,
      "endLine": 3,
      "methodCode": "public void writePack(OutputStream packStream) throws IOException {\n    if ((reuseDeltas || reuseObjects) && reuseSupport != null)\n        searchForReuse();\n    out = new PackOutputStream(packStream, isDeltaBaseAsOffset());\n    writeMonitor.beginTask(WRITING_OBJECTS_PROGRESS, getObjectsNumber());\n    out.writeFileHeader(PACK_VERSION_GENERATED, getObjectsNumber());\n    writeObjects();\n    writeChecksum();\n    out = null;\n    reader.release();\n    writeMonitor.endTask();\n}"
    },
    {
      "commit": "2156aa894cefbabd322fc405138c306bb4e939cd",
      "startLine": 2,
      "endLine": 3,
      "methodCode": "public void writePack(OutputStream packStream) throws IOException {\n    if (reuseDeltas || reuseObjects)\n        searchForReuse();\n    out = new PackOutputStream(packStream);\n    writeMonitor.beginTask(WRITING_OBJECTS_PROGRESS, getObjectsNumber());\n    writeHeader();\n    writeObjects();\n    writeChecksum();\n    windowCursor.release();\n    writeMonitor.endTask();\n}"
    },
    {
      "commit": "1a6964c8274c50f0253db75f010d78ef0e739343",
      "startLine": 2,
      "endLine": 3,
      "methodCode": "public void writePack(OutputStream packStream) throws IOException {\n    if (reuseDeltas || reuseObjects)\n        searchForReuse();\n    if (!(packStream instanceof BufferedOutputStream))\n        packStream = new BufferedOutputStream(packStream);\n    out = new PackOutputStream(packStream);\n    writeMonitor.beginTask(WRITING_OBJECTS_PROGRESS, getObjectsNumber());\n    writeHeader();\n    writeObjects();\n    writeChecksum();\n    out.flush();\n    windowCursor.release();\n    writeMonitor.endTask();\n}"
    }
  ]
}