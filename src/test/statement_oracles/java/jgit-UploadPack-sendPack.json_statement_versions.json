{
  "statementVersions": [
    {
      "commit": "cd0d69ffec9eedff24a2692d18024e752cadc7c8",
      "startLine": 90,
      "endLine": 96,
      "methodCode": "private void sendPack(final boolean sideband, PackStatistics.Accumulator accumulator, @Nullable Collection<Ref> allTags, List<ObjectId> unshallowCommits) throws IOException {\n    ProgressMonitor pm = NullProgressMonitor.INSTANCE;\n    OutputStream packOut = rawOut;\n    if (sideband) {\n        int bufsz = SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz = SideBandOutputStream.MAX_BUF;\n        packOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut = new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm = new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n        msgOut.flush();\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband && noPack.getMessage() != null) {\n            noPack.setOutput();\n            @SuppressWarnings(\"resource\") SideBandOutputStream err = new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg = packConfig;\n    if (cfg == null)\n        cfg = new PackConfig(db);\n    @SuppressWarnings(\"resource\") final PackWriter pw = new PackWriter(cfg, walk.getObjectReader(), accumulator);\n    try {\n        pw.setIndexDisabled(true);\n        if (filterBlobLimit >= 0) {\n            pw.setFilterBlobLimit(filterBlobLimit);\n            pw.setUseCachedPacks(false);\n        } else {\n            pw.setUseCachedPacks(true);\n        }\n        pw.setUseBitmaps(depth == 0 && clientShallowCommits.isEmpty());\n        pw.setClientShallowCommits(clientShallowCommits);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() && refs != null) {\n            Set<ObjectId> tagTargets = new HashSet<>();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() != null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() == null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        RevWalk rw = walk;\n        if (depth > 0) {\n            pw.setShallowPack(depth, unshallowCommits);\n            rw = new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n            rw.assumeShallow(clientShallowCommits);\n        }\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n        } else {\n            walk.reset();\n            ObjectWalk ow = rw.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n            rw = ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) && allTags != null) {\n            for (Ref ref : allTags) {\n                ObjectId objectId = ref.getObjectId();\n                if (objectId == null) {\n                    continue;\n                }\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj = rw.lookupOrNull(objectId);\n                    if (obj != null && obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref = db.getRefDatabase().peel(ref);\n                ObjectId peeledId = ref.getPeeledObjectId();\n                objectId = ref.getObjectId();\n                if (peeledId == null || objectId == null)\n                    continue;\n                if (pw.willInclude(peeledId) && !pw.willInclude(objectId)) {\n                    pw.addObject(rw.parseAny(objectId));\n                }\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        if (msgOut != NullOutputStream.INSTANCE) {\n            String msg = pw.getStatistics().getMessage() + '\\n';\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        statistics = pw.getStatistics();\n        if (statistics != null) {\n            postUploadHook.onPostUpload(statistics);\n        }\n        pw.close();\n    }\n    if (sideband)\n        pckOut.end();\n}"
    },
    {
      "commit": "f6c4a492d06e0dd345679bfba3399dabbf778f41",
      "startLine": 90,
      "endLine": 96,
      "methodCode": "private void sendPack(final boolean sideband, PackStatistics.Accumulator accumulator, @Nullable Collection<Ref> allTags) throws IOException {\n    ProgressMonitor pm = NullProgressMonitor.INSTANCE;\n    OutputStream packOut = rawOut;\n    if (sideband) {\n        int bufsz = SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz = SideBandOutputStream.MAX_BUF;\n        packOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut = new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm = new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n        msgOut.flush();\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband && noPack.getMessage() != null) {\n            noPack.setOutput();\n            @SuppressWarnings(\"resource\") SideBandOutputStream err = new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg = packConfig;\n    if (cfg == null)\n        cfg = new PackConfig(db);\n    @SuppressWarnings(\"resource\") final PackWriter pw = new PackWriter(cfg, walk.getObjectReader(), accumulator);\n    try {\n        pw.setIndexDisabled(true);\n        if (filterBlobLimit >= 0) {\n            pw.setFilterBlobLimit(filterBlobLimit);\n            pw.setUseCachedPacks(false);\n        } else {\n            pw.setUseCachedPacks(true);\n        }\n        pw.setUseBitmaps(depth == 0 && clientShallowCommits.isEmpty());\n        pw.setClientShallowCommits(clientShallowCommits);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() && refs != null) {\n            Set<ObjectId> tagTargets = new HashSet<>();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() != null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() == null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        RevWalk rw = walk;\n        if (depth > 0) {\n            pw.setShallowPack(depth, unshallowCommits);\n            rw = new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n            rw.assumeShallow(clientShallowCommits);\n        }\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n        } else {\n            walk.reset();\n            ObjectWalk ow = rw.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n            rw = ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) && allTags != null) {\n            for (Ref ref : allTags) {\n                ObjectId objectId = ref.getObjectId();\n                if (objectId == null) {\n                    continue;\n                }\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj = rw.lookupOrNull(objectId);\n                    if (obj != null && obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref = db.getRefDatabase().peel(ref);\n                ObjectId peeledId = ref.getPeeledObjectId();\n                objectId = ref.getObjectId();\n                if (peeledId == null || objectId == null)\n                    continue;\n                if (pw.willInclude(peeledId) && !pw.willInclude(objectId)) {\n                    pw.addObject(rw.parseAny(objectId));\n                }\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        if (msgOut != NullOutputStream.INSTANCE) {\n            String msg = pw.getStatistics().getMessage() + '\\n';\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        statistics = pw.getStatistics();\n        if (statistics != null) {\n            postUploadHook.onPostUpload(statistics);\n        }\n        pw.close();\n    }\n    if (sideband)\n        pckOut.end();\n}"
    },
    {
      "commit": "c79e7f1c27c73732310bc64c2071a79902447dcc",
      "startLine": 90,
      "endLine": 96,
      "methodCode": "private void sendPack(final boolean sideband, PackStatistics.Accumulator accumulator, @Nullable Collection<Ref> allTags) throws IOException {\n    ProgressMonitor pm = NullProgressMonitor.INSTANCE;\n    OutputStream packOut = rawOut;\n    if (sideband) {\n        int bufsz = SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz = SideBandOutputStream.MAX_BUF;\n        packOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut = new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm = new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n        msgOut.flush();\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband && noPack.getMessage() != null) {\n            noPack.setOutput();\n            @SuppressWarnings(\"resource\") SideBandOutputStream err = new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg = packConfig;\n    if (cfg == null)\n        cfg = new PackConfig(db);\n    @SuppressWarnings(\"resource\") final PackWriter pw = new PackWriter(cfg, walk.getObjectReader(), accumulator);\n    try {\n        pw.setIndexDisabled(true);\n        if (filterBlobLimit >= 0) {\n            pw.setFilterBlobLimit(filterBlobLimit);\n            pw.setUseCachedPacks(false);\n        } else {\n            pw.setUseCachedPacks(true);\n        }\n        pw.setUseBitmaps(depth == 0 && clientShallowCommits.isEmpty());\n        pw.setClientShallowCommits(clientShallowCommits);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() && refs != null) {\n            Set<ObjectId> tagTargets = new HashSet<>();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() != null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() == null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        RevWalk rw = walk;\n        if (depth > 0) {\n            pw.setShallowPack(depth, unshallowCommits);\n            rw = new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n            rw.assumeShallow(clientShallowCommits);\n        }\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n        } else {\n            walk.reset();\n            ObjectWalk ow = rw.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n            rw = ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) && allTags != null) {\n            for (Ref ref : allTags) {\n                ObjectId objectId = ref.getObjectId();\n                if (objectId == null) {\n                    continue;\n                }\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj = rw.lookupOrNull(objectId);\n                    if (obj != null && obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref = db.peel(ref);\n                ObjectId peeledId = ref.getPeeledObjectId();\n                objectId = ref.getObjectId();\n                if (peeledId == null || objectId == null)\n                    continue;\n                if (pw.willInclude(peeledId) && !pw.willInclude(objectId)) {\n                    pw.addObject(rw.parseAny(objectId));\n                }\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        if (msgOut != NullOutputStream.INSTANCE) {\n            String msg = pw.getStatistics().getMessage() + '\\n';\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        statistics = pw.getStatistics();\n        if (statistics != null) {\n            postUploadHook.onPostUpload(statistics);\n        }\n        pw.close();\n    }\n    if (sideband)\n        pckOut.end();\n}"
    },
    {
      "commit": "4ac32e79b751944107470d5f4cb290eacd1b7cf9",
      "startLine": 90,
      "endLine": 96,
      "methodCode": "private void sendPack(final boolean sideband, PackStatistics.Accumulator accumulator) throws IOException {\n    ProgressMonitor pm = NullProgressMonitor.INSTANCE;\n    OutputStream packOut = rawOut;\n    if (sideband) {\n        int bufsz = SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz = SideBandOutputStream.MAX_BUF;\n        packOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut = new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm = new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n        msgOut.flush();\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband && noPack.getMessage() != null) {\n            noPack.setOutput();\n            @SuppressWarnings(\"resource\") SideBandOutputStream err = new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg = packConfig;\n    if (cfg == null)\n        cfg = new PackConfig(db);\n    @SuppressWarnings(\"resource\") final PackWriter pw = new PackWriter(cfg, walk.getObjectReader(), accumulator);\n    try {\n        pw.setIndexDisabled(true);\n        if (filterBlobLimit >= 0) {\n            pw.setFilterBlobLimit(filterBlobLimit);\n            pw.setUseCachedPacks(false);\n        } else {\n            pw.setUseCachedPacks(true);\n        }\n        pw.setUseBitmaps(depth == 0 && clientShallowCommits.isEmpty());\n        pw.setClientShallowCommits(clientShallowCommits);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() && refs != null) {\n            Set<ObjectId> tagTargets = new HashSet<>();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() != null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() == null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        RevWalk rw = walk;\n        if (depth > 0) {\n            pw.setShallowPack(depth, unshallowCommits);\n            rw = new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n            rw.assumeShallow(clientShallowCommits);\n        }\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n        } else {\n            walk.reset();\n            ObjectWalk ow = rw.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n            rw = ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) && refs != null) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId = ref.getObjectId();\n                if (objectId == null) {\n                    continue;\n                }\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj = rw.lookupOrNull(objectId);\n                    if (obj != null && obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref = db.peel(ref);\n                ObjectId peeledId = ref.getPeeledObjectId();\n                objectId = ref.getObjectId();\n                if (peeledId == null || objectId == null)\n                    continue;\n                if (pw.willInclude(peeledId) && !pw.willInclude(objectId)) {\n                    pw.addObject(rw.parseAny(objectId));\n                }\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        if (msgOut != NullOutputStream.INSTANCE) {\n            String msg = pw.getStatistics().getMessage() + '\\n';\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        statistics = pw.getStatistics();\n        if (statistics != null) {\n            postUploadHook.onPostUpload(statistics);\n        }\n        pw.close();\n    }\n    if (sideband)\n        pckOut.end();\n}"
    },
    {
      "commit": "67df4986cef270144c7cae3485dc8541ca180649",
      "startLine": 85,
      "endLine": 91,
      "methodCode": "private void sendPack(final boolean sideband, PackStatistics.Accumulator accumulator) throws IOException {\n    ProgressMonitor pm = NullProgressMonitor.INSTANCE;\n    OutputStream packOut = rawOut;\n    if (sideband) {\n        int bufsz = SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz = SideBandOutputStream.MAX_BUF;\n        packOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut = new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm = new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n        msgOut.flush();\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband && noPack.getMessage() != null) {\n            noPack.setOutput();\n            @SuppressWarnings(\"resource\") SideBandOutputStream err = new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg = packConfig;\n    if (cfg == null)\n        cfg = new PackConfig(db);\n    @SuppressWarnings(\"resource\") final PackWriter pw = new PackWriter(cfg, walk.getObjectReader(), accumulator);\n    try {\n        pw.setIndexDisabled(true);\n        pw.setUseCachedPacks(true);\n        pw.setUseBitmaps(depth == 0 && clientShallowCommits.isEmpty());\n        pw.setClientShallowCommits(clientShallowCommits);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() && refs != null) {\n            Set<ObjectId> tagTargets = new HashSet<>();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() != null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() == null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        RevWalk rw = walk;\n        if (depth > 0) {\n            pw.setShallowPack(depth, unshallowCommits);\n            rw = new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n            rw.assumeShallow(clientShallowCommits);\n        }\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n        } else {\n            walk.reset();\n            ObjectWalk ow = rw.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n            rw = ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) && refs != null) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId = ref.getObjectId();\n                if (objectId == null) {\n                    continue;\n                }\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj = rw.lookupOrNull(objectId);\n                    if (obj != null && obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref = db.peel(ref);\n                ObjectId peeledId = ref.getPeeledObjectId();\n                objectId = ref.getObjectId();\n                if (peeledId == null || objectId == null)\n                    continue;\n                if (pw.willInclude(peeledId) && !pw.willInclude(objectId)) {\n                    pw.addObject(rw.parseAny(objectId));\n                }\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        if (msgOut != NullOutputStream.INSTANCE) {\n            String msg = pw.getStatistics().getMessage() + '\\n';\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        statistics = pw.getStatistics();\n        if (statistics != null) {\n            postUploadHook.onPostUpload(statistics);\n        }\n        pw.close();\n    }\n    if (sideband)\n        pckOut.end();\n}"
    },
    {
      "commit": "d88d5b94c669b4c23af4e1de797a4d130b6612f8",
      "startLine": 85,
      "endLine": 91,
      "methodCode": "private void sendPack(final boolean sideband, PackStatistics.Accumulator accumulator) throws IOException {\n    ProgressMonitor pm = NullProgressMonitor.INSTANCE;\n    OutputStream packOut = rawOut;\n    if (sideband) {\n        int bufsz = SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz = SideBandOutputStream.MAX_BUF;\n        packOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut = new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm = new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n        msgOut.flush();\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband && noPack.getMessage() != null) {\n            noPack.setOutput();\n            @SuppressWarnings(\"resource\") SideBandOutputStream err = new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg = packConfig;\n    if (cfg == null)\n        cfg = new PackConfig(db);\n    final PackWriter pw = new PackWriter(cfg, walk.getObjectReader(), accumulator);\n    try {\n        pw.setIndexDisabled(true);\n        pw.setUseCachedPacks(true);\n        pw.setUseBitmaps(depth == 0 && clientShallowCommits.isEmpty());\n        pw.setClientShallowCommits(clientShallowCommits);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() && refs != null) {\n            Set<ObjectId> tagTargets = new HashSet<>();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() != null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() == null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        RevWalk rw = walk;\n        if (depth > 0) {\n            pw.setShallowPack(depth, unshallowCommits);\n            rw = new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n            rw.assumeShallow(clientShallowCommits);\n        }\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n        } else {\n            walk.reset();\n            ObjectWalk ow = rw.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n            rw = ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) && refs != null) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId = ref.getObjectId();\n                if (objectId == null) {\n                    continue;\n                }\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj = rw.lookupOrNull(objectId);\n                    if (obj != null && obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref = db.peel(ref);\n                ObjectId peeledId = ref.getPeeledObjectId();\n                objectId = ref.getObjectId();\n                if (peeledId == null || objectId == null)\n                    continue;\n                if (pw.willInclude(peeledId) && !pw.willInclude(objectId)) {\n                    pw.addObject(rw.parseAny(objectId));\n                }\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        if (msgOut != NullOutputStream.INSTANCE) {\n            String msg = pw.getStatistics().getMessage() + '\\n';\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        statistics = pw.getStatistics();\n        if (statistics != null) {\n            postUploadHook.onPostUpload(statistics);\n        }\n        pw.close();\n    }\n    if (sideband)\n        pckOut.end();\n}"
    },
    {
      "commit": "cc19f649666704e5bf0184d3839be0c0c17439fc",
      "startLine": 86,
      "endLine": 92,
      "methodCode": "@SuppressWarnings(\"deprecation\")\nprivate void sendPack(final boolean sideband, PackStatistics.Accumulator accumulator) throws IOException {\n    ProgressMonitor pm = NullProgressMonitor.INSTANCE;\n    OutputStream packOut = rawOut;\n    if (sideband) {\n        int bufsz = SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz = SideBandOutputStream.MAX_BUF;\n        packOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut = new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm = new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n        msgOut.flush();\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband && noPack.getMessage() != null) {\n            noPack.setOutput();\n            @SuppressWarnings(\"resource\") SideBandOutputStream err = new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg = packConfig;\n    if (cfg == null)\n        cfg = new PackConfig(db);\n    final PackWriter pw = new PackWriter(cfg, walk.getObjectReader(), accumulator);\n    try {\n        pw.setIndexDisabled(true);\n        pw.setUseCachedPacks(true);\n        pw.setUseBitmaps(depth == 0 && clientShallowCommits.isEmpty());\n        pw.setClientShallowCommits(clientShallowCommits);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() && refs != null) {\n            Set<ObjectId> tagTargets = new HashSet<>();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() != null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() == null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        RevWalk rw = walk;\n        if (depth > 0) {\n            pw.setShallowPack(depth, unshallowCommits);\n            rw = new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n            rw.assumeShallow(clientShallowCommits);\n        }\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n        } else {\n            walk.reset();\n            ObjectWalk ow = rw.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n            rw = ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) && refs != null) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId = ref.getObjectId();\n                if (objectId == null) {\n                    continue;\n                }\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj = rw.lookupOrNull(objectId);\n                    if (obj != null && obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref = db.peel(ref);\n                ObjectId peeledId = ref.getPeeledObjectId();\n                objectId = ref.getObjectId();\n                if (peeledId == null || objectId == null)\n                    continue;\n                if (pw.willInclude(peeledId) && !pw.willInclude(objectId)) {\n                    pw.addObject(rw.parseAny(objectId));\n                }\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        if (msgOut != NullOutputStream.INSTANCE) {\n            String msg = pw.getStatistics().getMessage() + '\\n';\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        statistics = pw.getStatistics();\n        if (statistics != null) {\n            postUploadHook.onPostUpload(statistics);\n        }\n        pw.close();\n    }\n    if (sideband)\n        pckOut.end();\n}"
    },
    {
      "commit": "302596cc675d00e41f0ff07efef58063afe20c79",
      "startLine": 86,
      "endLine": 92,
      "methodCode": "@SuppressWarnings(\"deprecation\")\nprivate void sendPack(final boolean sideband, PackStatistics.Accumulator accumulator) throws IOException {\n    ProgressMonitor pm = NullProgressMonitor.INSTANCE;\n    OutputStream packOut = rawOut;\n    if (sideband) {\n        int bufsz = SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz = SideBandOutputStream.MAX_BUF;\n        packOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut = new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm = new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n        msgOut.flush();\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband && noPack.getMessage() != null) {\n            noPack.setOutput();\n            @SuppressWarnings(\"resource\") SideBandOutputStream err = new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg = packConfig;\n    if (cfg == null)\n        cfg = new PackConfig(db);\n    final PackWriter pw = new PackWriter(cfg, walk.getObjectReader(), accumulator);\n    try {\n        pw.setIndexDisabled(true);\n        pw.setUseCachedPacks(true);\n        pw.setUseBitmaps(depth == 0 && clientShallowCommits.isEmpty());\n        pw.setClientShallowCommits(clientShallowCommits);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() && refs != null) {\n            Set<ObjectId> tagTargets = new HashSet<>();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() != null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() == null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        RevWalk rw = walk;\n        if (depth > 0) {\n            pw.setShallowPack(depth, unshallowCommits);\n            rw = new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n            rw.assumeShallow(clientShallowCommits);\n        }\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n        } else {\n            walk.reset();\n            ObjectWalk ow = rw.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n            rw = ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) && refs != null) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId = ref.getObjectId();\n                if (objectId == null) {\n                    continue;\n                }\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj = rw.lookupOrNull(objectId);\n                    if (obj != null && obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref = db.peel(ref);\n                ObjectId peeledId = ref.getPeeledObjectId();\n                objectId = ref.getObjectId();\n                if (peeledId == null || objectId == null)\n                    continue;\n                if (pw.willInclude(peeledId) && !pw.willInclude(objectId)) {\n                    pw.addObject(rw.parseAny(objectId));\n                }\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        if (msgOut != NullOutputStream.INSTANCE) {\n            String msg = pw.getStatistics().getMessage() + '\\n';\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        statistics = pw.getStatistics();\n        if (statistics != null) {\n            postUploadHook.onPostUpload(statistics);\n            logger.onPackStatistics(new PackWriter.Statistics(statistics));\n        }\n        pw.close();\n    }\n    if (sideband)\n        pckOut.end();\n}"
    },
    {
      "commit": "21d22e6f63a1adcfaeaee155f1be32f8123fd789",
      "startLine": 86,
      "endLine": 92,
      "methodCode": "@SuppressWarnings(\"deprecation\")\nprivate void sendPack(final boolean sideband) throws IOException {\n    ProgressMonitor pm = NullProgressMonitor.INSTANCE;\n    OutputStream packOut = rawOut;\n    if (sideband) {\n        int bufsz = SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz = SideBandOutputStream.MAX_BUF;\n        packOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut = new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm = new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n        msgOut.flush();\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband && noPack.getMessage() != null) {\n            noPack.setOutput();\n            @SuppressWarnings(\"resource\") SideBandOutputStream err = new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg = packConfig;\n    if (cfg == null)\n        cfg = new PackConfig(db);\n    final PackWriter pw = new PackWriter(cfg, walk.getObjectReader());\n    try {\n        pw.setIndexDisabled(true);\n        pw.setUseCachedPacks(true);\n        pw.setUseBitmaps(depth == 0 && clientShallowCommits.isEmpty());\n        pw.setClientShallowCommits(clientShallowCommits);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() && refs != null) {\n            Set<ObjectId> tagTargets = new HashSet<>();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() != null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() == null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        RevWalk rw = walk;\n        if (depth > 0) {\n            pw.setShallowPack(depth, unshallowCommits);\n            rw = new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n            rw.assumeShallow(clientShallowCommits);\n        }\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n        } else {\n            walk.reset();\n            ObjectWalk ow = rw.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n            rw = ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) && refs != null) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId = ref.getObjectId();\n                if (objectId == null) {\n                    continue;\n                }\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj = rw.lookupOrNull(objectId);\n                    if (obj != null && obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref = db.peel(ref);\n                ObjectId peeledId = ref.getPeeledObjectId();\n                objectId = ref.getObjectId();\n                if (peeledId == null || objectId == null)\n                    continue;\n                if (pw.willInclude(peeledId) && !pw.willInclude(objectId)) {\n                    pw.addObject(rw.parseAny(objectId));\n                }\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        if (msgOut != NullOutputStream.INSTANCE) {\n            String msg = pw.getStatistics().getMessage() + '\\n';\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        statistics = pw.getStatistics();\n        if (statistics != null) {\n            postUploadHook.onPostUpload(statistics);\n            logger.onPackStatistics(new PackWriter.Statistics(statistics));\n        }\n        pw.close();\n    }\n    if (sideband)\n        pckOut.end();\n}"
    },
    {
      "commit": "c46c720e99baa081bff0dd7bcc1ae8ca48b5e3d1",
      "startLine": 83,
      "endLine": 88,
      "methodCode": "@SuppressWarnings(\"deprecation\")\nprivate void sendPack(final boolean sideband) throws IOException {\n    ProgressMonitor pm = NullProgressMonitor.INSTANCE;\n    OutputStream packOut = rawOut;\n    if (sideband) {\n        int bufsz = SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz = SideBandOutputStream.MAX_BUF;\n        packOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut = new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm = new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n        msgOut.flush();\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband && noPack.getMessage() != null) {\n            noPack.setOutput();\n            @SuppressWarnings(\"resource\") SideBandOutputStream err = new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg = packConfig;\n    if (cfg == null)\n        cfg = new PackConfig(db);\n    final PackWriter pw = new PackWriter(cfg, walk.getObjectReader());\n    try {\n        pw.setIndexDisabled(true);\n        pw.setUseCachedPacks(true);\n        pw.setUseBitmaps(depth == 0 && clientShallowCommits.isEmpty());\n        pw.setClientShallowCommits(clientShallowCommits);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() && refs != null) {\n            Set<ObjectId> tagTargets = new HashSet<>();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() != null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() == null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        RevWalk rw = walk;\n        if (depth > 0) {\n            pw.setShallowPack(depth, unshallowCommits);\n            rw = new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n            rw.assumeShallow(clientShallowCommits);\n        }\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n        } else {\n            walk.reset();\n            ObjectWalk ow = rw.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n            rw = ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) && refs != null) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId = ref.getObjectId();\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj = rw.lookupOrNull(objectId);\n                    if (obj != null && obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref = db.peel(ref);\n                ObjectId peeledId = ref.getPeeledObjectId();\n                if (peeledId == null)\n                    continue;\n                objectId = ref.getObjectId();\n                if (pw.willInclude(peeledId) && !pw.willInclude(objectId))\n                    pw.addObject(rw.parseAny(objectId));\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        if (msgOut != NullOutputStream.INSTANCE) {\n            String msg = pw.getStatistics().getMessage() + '\\n';\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        statistics = pw.getStatistics();\n        if (statistics != null) {\n            postUploadHook.onPostUpload(statistics);\n            logger.onPackStatistics(new PackWriter.Statistics(statistics));\n        }\n        pw.close();\n    }\n    if (sideband)\n        pckOut.end();\n}"
    },
    {
      "commit": "3b4448637fbb9d74e0c9d44048ba76bb7c1214ce",
      "startLine": 83,
      "endLine": 88,
      "methodCode": "@SuppressWarnings(\"deprecation\")\nprivate void sendPack(final boolean sideband) throws IOException {\n    ProgressMonitor pm = NullProgressMonitor.INSTANCE;\n    OutputStream packOut = rawOut;\n    if (sideband) {\n        int bufsz = SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz = SideBandOutputStream.MAX_BUF;\n        packOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut = new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm = new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n        msgOut.flush();\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband && noPack.getMessage() != null) {\n            noPack.setOutput();\n            @SuppressWarnings(\"resource\") SideBandOutputStream err = new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg = packConfig;\n    if (cfg == null)\n        cfg = new PackConfig(db);\n    final PackWriter pw = new PackWriter(cfg, walk.getObjectReader());\n    try {\n        pw.setIndexDisabled(true);\n        pw.setUseCachedPacks(true);\n        pw.setUseBitmaps(depth == 0 && clientShallowCommits.isEmpty());\n        pw.setClientShallowCommits(clientShallowCommits);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() && refs != null) {\n            Set<ObjectId> tagTargets = new HashSet<>();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() != null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() == null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        RevWalk rw = walk;\n        if (depth > 0) {\n            pw.setShallowPack(depth, unshallowCommits);\n            rw = new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n            rw.assumeShallow(clientShallowCommits);\n        }\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n        } else {\n            walk.reset();\n            ObjectWalk ow = rw.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase);\n            rw = ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) && refs != null) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId = ref.getObjectId();\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj = rw.lookupOrNull(objectId);\n                    if (obj != null && obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref = db.peel(ref);\n                ObjectId peeledId = ref.getPeeledObjectId();\n                if (peeledId == null)\n                    continue;\n                objectId = ref.getObjectId();\n                if (pw.willInclude(peeledId) && !pw.willInclude(objectId))\n                    pw.addObject(rw.parseAny(objectId));\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        if (msgOut != NullOutputStream.INSTANCE) {\n            String msg = pw.getStatistics().getMessage() + '\\n';\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        statistics = pw.getStatistics();\n        if (statistics != null) {\n            postUploadHook.onPostUpload(statistics);\n            logger.onPackStatistics(new PackWriter.Statistics(statistics));\n        }\n        pw.close();\n    }\n    if (sideband)\n        pckOut.end();\n}"
    },
    {
      "commit": "01935f8f50699db09e9e6f4e725913b907d7cbd5",
      "startLine": 83,
      "endLine": 88,
      "methodCode": "@SuppressWarnings(\"deprecation\")\nprivate void sendPack(final boolean sideband) throws IOException {\n    ProgressMonitor pm = NullProgressMonitor.INSTANCE;\n    OutputStream packOut = rawOut;\n    if (sideband) {\n        int bufsz = SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz = SideBandOutputStream.MAX_BUF;\n        packOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut = new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm = new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n        msgOut.flush();\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband && noPack.getMessage() != null) {\n            noPack.setOutput();\n            @SuppressWarnings(\"resource\") SideBandOutputStream err = new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg = packConfig;\n    if (cfg == null)\n        cfg = new PackConfig(db);\n    final PackWriter pw = new PackWriter(cfg, walk.getObjectReader());\n    try {\n        pw.setIndexDisabled(true);\n        pw.setUseCachedPacks(true);\n        pw.setUseBitmaps(depth == 0 && clientShallowCommits.isEmpty());\n        pw.setClientShallowCommits(clientShallowCommits);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() && refs != null) {\n            Set<ObjectId> tagTargets = new HashSet<ObjectId>();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() != null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() == null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        RevWalk rw = walk;\n        if (depth > 0) {\n            pw.setShallowPack(depth, unshallowCommits);\n            rw = new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n            rw.assumeShallow(clientShallowCommits);\n        }\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n        } else {\n            walk.reset();\n            ObjectWalk ow = rw.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase);\n            rw = ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) && refs != null) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId = ref.getObjectId();\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj = rw.lookupOrNull(objectId);\n                    if (obj != null && obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref = db.peel(ref);\n                ObjectId peeledId = ref.getPeeledObjectId();\n                if (peeledId == null)\n                    continue;\n                objectId = ref.getObjectId();\n                if (pw.willInclude(peeledId) && !pw.willInclude(objectId))\n                    pw.addObject(rw.parseAny(objectId));\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        if (msgOut != NullOutputStream.INSTANCE) {\n            String msg = pw.getStatistics().getMessage() + '\\n';\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        statistics = pw.getStatistics();\n        if (statistics != null) {\n            postUploadHook.onPostUpload(statistics);\n            logger.onPackStatistics(new PackWriter.Statistics(statistics));\n        }\n        pw.close();\n    }\n    if (sideband)\n        pckOut.end();\n}"
    },
    {
      "commit": "b16e207742beb6a82b2b74df7bb87893a38bdd04",
      "startLine": 82,
      "endLine": 87,
      "methodCode": "private void sendPack(final boolean sideband) throws IOException {\n    ProgressMonitor pm = NullProgressMonitor.INSTANCE;\n    OutputStream packOut = rawOut;\n    if (sideband) {\n        int bufsz = SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz = SideBandOutputStream.MAX_BUF;\n        packOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut = new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm = new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n        msgOut.flush();\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband && noPack.getMessage() != null) {\n            noPack.setOutput();\n            @SuppressWarnings(\"resource\") SideBandOutputStream err = new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg = packConfig;\n    if (cfg == null)\n        cfg = new PackConfig(db);\n    final PackWriter pw = new PackWriter(cfg, walk.getObjectReader());\n    try {\n        pw.setIndexDisabled(true);\n        pw.setUseCachedPacks(true);\n        pw.setUseBitmaps(depth == 0 && clientShallowCommits.isEmpty());\n        pw.setClientShallowCommits(clientShallowCommits);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() && refs != null) {\n            Set<ObjectId> tagTargets = new HashSet<ObjectId>();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() != null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() == null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        RevWalk rw = walk;\n        if (depth > 0) {\n            pw.setShallowPack(depth, unshallowCommits);\n            rw = new DepthWalk.RevWalk(walk.getObjectReader(), depth);\n            rw.assumeShallow(clientShallowCommits);\n        }\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n        } else {\n            walk.reset();\n            ObjectWalk ow = rw.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase);\n            rw = ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) && refs != null) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId = ref.getObjectId();\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj = rw.lookupOrNull(objectId);\n                    if (obj != null && obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref = db.peel(ref);\n                ObjectId peeledId = ref.getPeeledObjectId();\n                if (peeledId == null)\n                    continue;\n                objectId = ref.getObjectId();\n                if (pw.willInclude(peeledId) && !pw.willInclude(objectId))\n                    pw.addObject(rw.parseAny(objectId));\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        if (msgOut != NullOutputStream.INSTANCE) {\n            String msg = pw.getStatistics().getMessage() + '\\n';\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        statistics = pw.getStatistics();\n        if (statistics != null) {\n            postUploadHook.onPostUpload(statistics);\n            logger.onPackStatistics(new PackWriter.Statistics(statistics));\n        }\n        pw.close();\n    }\n    if (sideband)\n        pckOut.end();\n}"
    },
    {
      "commit": "f84370feaaf319b7fe9bd272a7ceba235cc1e86a",
      "startLine": 82,
      "endLine": 87,
      "methodCode": "private void sendPack(final boolean sideband) throws IOException {\n    ProgressMonitor pm = NullProgressMonitor.INSTANCE;\n    OutputStream packOut = rawOut;\n    if (sideband) {\n        int bufsz = SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz = SideBandOutputStream.MAX_BUF;\n        packOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut = new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm = new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n        msgOut.flush();\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband && noPack.getMessage() != null) {\n            noPack.setOutput();\n            @SuppressWarnings(\"resource\") SideBandOutputStream err = new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg = packConfig;\n    if (cfg == null)\n        cfg = new PackConfig(db);\n    final PackWriter pw = new PackWriter(cfg, walk.getObjectReader());\n    try {\n        pw.setIndexDisabled(true);\n        pw.setUseCachedPacks(true);\n        pw.setUseBitmaps(depth == 0 && clientShallowCommits.isEmpty());\n        pw.setClientShallowCommits(clientShallowCommits);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() && refs != null) {\n            Set<ObjectId> tagTargets = new HashSet<ObjectId>();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() != null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() == null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        RevWalk rw = walk;\n        if (depth > 0) {\n            pw.setShallowPack(depth, unshallowCommits);\n            rw = new DepthWalk.RevWalk(walk.getObjectReader(), depth);\n            rw.assumeShallow(clientShallowCommits);\n        }\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase);\n        } else {\n            walk.reset();\n            ObjectWalk ow = rw.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase);\n            rw = ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) && refs != null) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId = ref.getObjectId();\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj = rw.lookupOrNull(objectId);\n                    if (obj != null && obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref = db.peel(ref);\n                ObjectId peeledId = ref.getPeeledObjectId();\n                if (peeledId == null)\n                    continue;\n                objectId = ref.getObjectId();\n                if (pw.willInclude(peeledId) && !pw.willInclude(objectId))\n                    pw.addObject(rw.parseAny(objectId));\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        if (msgOut != NullOutputStream.INSTANCE) {\n            String msg = pw.getStatistics().getMessage() + '\\n';\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        statistics = pw.getStatistics();\n        if (statistics != null) {\n            postUploadHook.onPostUpload(statistics);\n            logger.onPackStatistics(new PackWriter.Statistics(statistics));\n        }\n        pw.close();\n    }\n    if (sideband)\n        pckOut.end();\n}"
    },
    {
      "commit": "1fa6f3a7509dc937551006e11dfd3bdaea921cd0",
      "startLine": 79,
      "endLine": 84,
      "methodCode": "private void sendPack(final boolean sideband) throws IOException {\n    ProgressMonitor pm = NullProgressMonitor.INSTANCE;\n    OutputStream packOut = rawOut;\n    if (sideband) {\n        int bufsz = SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz = SideBandOutputStream.MAX_BUF;\n        packOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut = new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm = new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n        msgOut.flush();\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband && noPack.getMessage() != null) {\n            noPack.setOutput();\n            @SuppressWarnings(\"resource\") SideBandOutputStream err = new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg = packConfig;\n    if (cfg == null)\n        cfg = new PackConfig(db);\n    final PackWriter pw = new PackWriter(cfg, walk.getObjectReader());\n    try {\n        pw.setIndexDisabled(true);\n        pw.setUseCachedPacks(true);\n        pw.setUseBitmaps(depth == 0 && clientShallowCommits.isEmpty());\n        pw.setClientShallowCommits(clientShallowCommits);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() && refs != null) {\n            Set<ObjectId> tagTargets = new HashSet<ObjectId>();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() != null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() == null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        if (depth > 0)\n            pw.setShallowPack(depth, unshallowCommits);\n        RevWalk rw = walk;\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase);\n        } else {\n            walk.reset();\n            ObjectWalk ow = walk.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase);\n            rw = ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) && refs != null) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId = ref.getObjectId();\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj = rw.lookupOrNull(objectId);\n                    if (obj != null && obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref = db.peel(ref);\n                ObjectId peeledId = ref.getPeeledObjectId();\n                if (peeledId == null)\n                    continue;\n                objectId = ref.getObjectId();\n                if (pw.willInclude(peeledId) && !pw.willInclude(objectId))\n                    pw.addObject(rw.parseAny(objectId));\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        if (msgOut != NullOutputStream.INSTANCE) {\n            String msg = pw.getStatistics().getMessage() + '\\n';\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        statistics = pw.getStatistics();\n        if (statistics != null) {\n            postUploadHook.onPostUpload(statistics);\n            logger.onPackStatistics(new PackWriter.Statistics(statistics));\n        }\n        pw.close();\n    }\n    if (sideband)\n        pckOut.end();\n}"
    },
    {
      "commit": "bbcbcab8d39dd4bdf194cdba02c97a9eb70b2379",
      "startLine": 79,
      "endLine": 84,
      "methodCode": "private void sendPack(final boolean sideband) throws IOException {\n    ProgressMonitor pm = NullProgressMonitor.INSTANCE;\n    OutputStream packOut = rawOut;\n    if (sideband) {\n        int bufsz = SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz = SideBandOutputStream.MAX_BUF;\n        packOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut = new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm = new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n        msgOut.flush();\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband && noPack.getMessage() != null) {\n            noPack.setOutput();\n            @SuppressWarnings(\"resource\") SideBandOutputStream err = new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg = packConfig;\n    if (cfg == null)\n        cfg = new PackConfig(db);\n    final PackWriter pw = new PackWriter(cfg, walk.getObjectReader());\n    try {\n        pw.setIndexDisabled(true);\n        pw.setUseCachedPacks(true);\n        pw.setUseBitmaps(depth == 0 && clientShallowCommits.isEmpty());\n        pw.setClientShallowCommits(clientShallowCommits);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() && refs != null) {\n            Set<ObjectId> tagTargets = new HashSet<ObjectId>();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() != null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() == null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        if (depth > 0)\n            pw.setShallowPack(depth, unshallowCommits);\n        RevWalk rw = walk;\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase);\n        } else {\n            walk.reset();\n            ObjectWalk ow = walk.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase);\n            rw = ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) && refs != null) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId = ref.getObjectId();\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj = rw.lookupOrNull(objectId);\n                    if (obj != null && obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref = db.peel(ref);\n                ObjectId peeledId = ref.getPeeledObjectId();\n                if (peeledId == null)\n                    continue;\n                objectId = ref.getObjectId();\n                if (pw.willInclude(peeledId) && !pw.willInclude(objectId))\n                    pw.addObject(rw.parseAny(objectId));\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        if (msgOut != NullOutputStream.INSTANCE) {\n            String msg = pw.getStatistics().getMessage() + '\\n';\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        statistics = pw.getStatistics();\n        if (statistics != null) {\n            postUploadHook.onPostUpload(statistics);\n        }\n        pw.close();\n    }\n    if (sideband)\n        pckOut.end();\n}"
    },
    {
      "commit": "6a415915c2dab31f9e69b9a55dcb87c579649bf5",
      "startLine": 79,
      "endLine": 84,
      "methodCode": "private void sendPack(final boolean sideband) throws IOException {\n    ProgressMonitor pm = NullProgressMonitor.INSTANCE;\n    OutputStream packOut = rawOut;\n    if (sideband) {\n        int bufsz = SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz = SideBandOutputStream.MAX_BUF;\n        packOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut = new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm = new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n        msgOut.flush();\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband && noPack.getMessage() != null) {\n            noPack.setOutput();\n            @SuppressWarnings(\"resource\") SideBandOutputStream err = new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg = packConfig;\n    if (cfg == null)\n        cfg = new PackConfig(db);\n    final PackWriter pw = new PackWriter(cfg, walk.getObjectReader());\n    try {\n        pw.setIndexDisabled(true);\n        pw.setUseCachedPacks(true);\n        pw.setUseBitmaps(depth == 0 && clientShallowCommits.isEmpty());\n        pw.setClientShallowCommits(clientShallowCommits);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() && refs != null) {\n            Set<ObjectId> tagTargets = new HashSet<ObjectId>();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() != null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() == null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        if (depth > 0)\n            pw.setShallowPack(depth, unshallowCommits);\n        RevWalk rw = walk;\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase);\n        } else {\n            walk.reset();\n            ObjectWalk ow = walk.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase);\n            rw = ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) && refs != null) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId = ref.getObjectId();\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj = rw.lookupOrNull(objectId);\n                    if (obj != null && obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref = db.peel(ref);\n                ObjectId peeledId = ref.getPeeledObjectId();\n                if (peeledId == null)\n                    continue;\n                objectId = ref.getObjectId();\n                if (pw.willInclude(peeledId) && !pw.willInclude(objectId))\n                    pw.addObject(rw.parseAny(objectId));\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        if (msgOut != NullOutputStream.INSTANCE) {\n            String msg = pw.getStatistics().getMessage() + '\\n';\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        statistics = pw.getStatistics();\n        if (statistics != null) {\n            postUploadHook.onPostUpload(statistics);\n            logger.onPackStatistics(new PackWriter.Statistics(statistics));\n        }\n        pw.close();\n    }\n    if (sideband)\n        pckOut.end();\n}"
    },
    {
      "commit": "d9bbb04c3ef28db1d2e492506a819b7ac5c5f9df",
      "startLine": 78,
      "endLine": 83,
      "methodCode": "private void sendPack(final boolean sideband) throws IOException {\n    ProgressMonitor pm = NullProgressMonitor.INSTANCE;\n    OutputStream packOut = rawOut;\n    if (sideband) {\n        int bufsz = SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz = SideBandOutputStream.MAX_BUF;\n        packOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut = new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm = new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n        msgOut.flush();\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband && noPack.getMessage() != null) {\n            noPack.setOutput();\n            @SuppressWarnings(\"resource\") SideBandOutputStream err = new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg = packConfig;\n    if (cfg == null)\n        cfg = new PackConfig(db);\n    final PackWriter pw = new PackWriter(cfg, walk.getObjectReader());\n    try {\n        pw.setIndexDisabled(true);\n        pw.setUseCachedPacks(true);\n        pw.setUseBitmaps(depth == 0 && clientShallowCommits.isEmpty());\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() && refs != null) {\n            Set<ObjectId> tagTargets = new HashSet<ObjectId>();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() != null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() == null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        if (depth > 0)\n            pw.setShallowPack(depth, unshallowCommits);\n        RevWalk rw = walk;\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase);\n        } else {\n            walk.reset();\n            ObjectWalk ow = walk.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase);\n            rw = ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) && refs != null) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId = ref.getObjectId();\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj = rw.lookupOrNull(objectId);\n                    if (obj != null && obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref = db.peel(ref);\n                ObjectId peeledId = ref.getPeeledObjectId();\n                if (peeledId == null)\n                    continue;\n                objectId = ref.getObjectId();\n                if (pw.willInclude(peeledId) && !pw.willInclude(objectId))\n                    pw.addObject(rw.parseAny(objectId));\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        if (msgOut != NullOutputStream.INSTANCE) {\n            String msg = pw.getStatistics().getMessage() + '\\n';\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        statistics = pw.getStatistics();\n        if (statistics != null) {\n            postUploadHook.onPostUpload(statistics);\n            logger.onPackStatistics(new PackWriter.Statistics(statistics));\n        }\n        pw.close();\n    }\n    if (sideband)\n        pckOut.end();\n}"
    },
    {
      "commit": "0e73d395061d1bfee365acaa2f79c392175d13bf",
      "startLine": 78,
      "endLine": 83,
      "methodCode": "private void sendPack(final boolean sideband) throws IOException {\n    ProgressMonitor pm = NullProgressMonitor.INSTANCE;\n    OutputStream packOut = rawOut;\n    if (sideband) {\n        int bufsz = SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz = SideBandOutputStream.MAX_BUF;\n        packOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut = new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm = new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n        msgOut.flush();\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband && noPack.getMessage() != null) {\n            noPack.setOutput();\n            @SuppressWarnings(\"resource\") SideBandOutputStream err = new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg = packConfig;\n    if (cfg == null)\n        cfg = new PackConfig(db);\n    final PackWriter pw = new PackWriter(cfg, walk.getObjectReader());\n    try {\n        pw.setIndexDisabled(true);\n        pw.setUseCachedPacks(true);\n        pw.setUseBitmaps(depth == 0 && clientShallowCommits.isEmpty());\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() && refs != null) {\n            Set<ObjectId> tagTargets = new HashSet<ObjectId>();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() != null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() == null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        if (depth > 0)\n            pw.setShallowPack(depth, unshallowCommits);\n        RevWalk rw = walk;\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase);\n        } else {\n            walk.reset();\n            ObjectWalk ow = walk.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase);\n            rw = ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) && refs != null) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId = ref.getObjectId();\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj = rw.lookupOrNull(objectId);\n                    if (obj != null && obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref = db.peel(ref);\n                ObjectId peeledId = ref.getPeeledObjectId();\n                if (peeledId == null)\n                    continue;\n                objectId = ref.getObjectId();\n                if (pw.willInclude(peeledId) && !pw.willInclude(objectId))\n                    pw.addObject(rw.parseAny(objectId));\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        if (msgOut != NullOutputStream.INSTANCE) {\n            String msg = pw.getStatistics().getMessage() + '\\n';\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        statistics = pw.getStatistics();\n        if (statistics != null)\n            logger.onPackStatistics(statistics);\n        pw.close();\n    }\n    if (sideband)\n        pckOut.end();\n}"
    },
    {
      "commit": "7b7d033ee1fdd8e81ae2ad7dc9e1ae12cbd9ddfa",
      "startLine": 78,
      "endLine": 83,
      "methodCode": "private void sendPack(final boolean sideband) throws IOException {\n    ProgressMonitor pm = NullProgressMonitor.INSTANCE;\n    OutputStream packOut = rawOut;\n    if (sideband) {\n        int bufsz = SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz = SideBandOutputStream.MAX_BUF;\n        packOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut = new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm = new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n        msgOut.flush();\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband && noPack.getMessage() != null) {\n            noPack.setOutput();\n            @SuppressWarnings(\"resource\") SideBandOutputStream err = new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg = packConfig;\n    if (cfg == null)\n        cfg = new PackConfig(db);\n    final PackWriter pw = new PackWriter(cfg, walk.getObjectReader());\n    try {\n        pw.setIndexDisabled(true);\n        pw.setUseCachedPacks(true);\n        pw.setUseBitmaps(depth == 0 && clientShallowCommits.isEmpty());\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() && refs != null) {\n            Set<ObjectId> tagTargets = new HashSet<ObjectId>();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() != null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() == null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        if (depth > 0)\n            pw.setShallowPack(depth, unshallowCommits);\n        RevWalk rw = walk;\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase);\n        } else {\n            walk.reset();\n            ObjectWalk ow = walk.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase);\n            rw = ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) && refs != null) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId = ref.getObjectId();\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj = rw.lookupOrNull(objectId);\n                    if (obj != null && obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref = db.peel(ref);\n                ObjectId peeledId = ref.getPeeledObjectId();\n                if (peeledId == null)\n                    continue;\n                objectId = ref.getObjectId();\n                if (pw.willInclude(peeledId) && !pw.willInclude(objectId))\n                    pw.addObject(rw.parseAny(objectId));\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        if (msgOut != NullOutputStream.INSTANCE) {\n            String msg = pw.getStatistics().getMessage() + '\\n';\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        statistics = pw.getStatistics();\n        if (statistics != null)\n            logger.onPackStatistics(statistics);\n        pw.release();\n    }\n    if (sideband)\n        pckOut.end();\n}"
    },
    {
      "commit": "b0174a089ce886d02c8d7fb80d63f0e50329bec3",
      "startLine": 78,
      "endLine": 83,
      "methodCode": "private void sendPack(final boolean sideband) throws IOException {\n    ProgressMonitor pm = NullProgressMonitor.INSTANCE;\n    OutputStream packOut = rawOut;\n    if (sideband) {\n        int bufsz = SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz = SideBandOutputStream.MAX_BUF;\n        packOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut = new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm = new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n        msgOut.flush();\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband && noPack.getMessage() != null) {\n            noPack.setOutput();\n            @SuppressWarnings(\"resource\") SideBandOutputStream err = new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg = packConfig;\n    if (cfg == null)\n        cfg = new PackConfig(db);\n    final PackWriter pw = new PackWriter(cfg, walk.getObjectReader());\n    try {\n        pw.setIndexDisabled(true);\n        pw.setUseCachedPacks(true);\n        pw.setUseBitmaps(depth == 0 && clientShallowCommits.isEmpty());\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() && refs != null) {\n            Set<ObjectId> tagTargets = new HashSet<ObjectId>();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() != null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() == null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        if (depth > 0)\n            pw.setShallowPack(depth, unshallowCommits);\n        RevWalk rw = walk;\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase);\n        } else {\n            walk.reset();\n            ObjectWalk ow = walk.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase);\n            rw = ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) && refs != null) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId = ref.getObjectId();\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj = rw.lookupOrNull(objectId);\n                    if (obj != null && obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref = db.peel(ref);\n                ObjectId peeledId = ref.getPeeledObjectId();\n                if (peeledId == null)\n                    continue;\n                objectId = ref.getObjectId();\n                if (pw.willInclude(peeledId) && !pw.willInclude(objectId))\n                    pw.addObject(rw.parseAny(objectId));\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        statistics = pw.getStatistics();\n        if (msgOut != NullOutputStream.INSTANCE) {\n            String msg = pw.getStatistics().getMessage() + '\\n';\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        pw.release();\n    }\n    if (sideband)\n        pckOut.end();\n    if (statistics != null)\n        logger.onPackStatistics(statistics);\n}"
    },
    {
      "commit": "557471da2eee6752ad4305a883843bcdc8d66536",
      "startLine": 78,
      "endLine": 83,
      "methodCode": "private void sendPack(final boolean sideband) throws IOException {\n    ProgressMonitor pm = NullProgressMonitor.INSTANCE;\n    OutputStream packOut = rawOut;\n    if (sideband) {\n        int bufsz = SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz = SideBandOutputStream.MAX_BUF;\n        packOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut = new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm = new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n        msgOut.flush();\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband && noPack.getMessage() != null) {\n            noPack.setOutput();\n            @SuppressWarnings(\"resource\") SideBandOutputStream err = new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg = packConfig;\n    if (cfg == null)\n        cfg = new PackConfig(db);\n    final PackWriter pw = new PackWriter(cfg, walk.getObjectReader());\n    try {\n        pw.setIndexDisabled(true);\n        pw.setUseCachedPacks(true);\n        pw.setUseBitmaps(true);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() && refs != null) {\n            Set<ObjectId> tagTargets = new HashSet<ObjectId>();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() != null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() == null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        if (depth > 0)\n            pw.setShallowPack(depth, unshallowCommits);\n        RevWalk rw = walk;\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase);\n        } else {\n            walk.reset();\n            ObjectWalk ow = walk.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase);\n            rw = ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) && refs != null) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId = ref.getObjectId();\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj = rw.lookupOrNull(objectId);\n                    if (obj != null && obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref = db.peel(ref);\n                ObjectId peeledId = ref.getPeeledObjectId();\n                if (peeledId == null)\n                    continue;\n                objectId = ref.getObjectId();\n                if (pw.willInclude(peeledId) && !pw.willInclude(objectId))\n                    pw.addObject(rw.parseAny(objectId));\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        statistics = pw.getStatistics();\n        if (msgOut != NullOutputStream.INSTANCE) {\n            String msg = pw.getStatistics().getMessage() + '\\n';\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        pw.release();\n    }\n    if (sideband)\n        pckOut.end();\n    if (statistics != null)\n        logger.onPackStatistics(statistics);\n}"
    },
    {
      "commit": "6e896ba66ba095b97a89a622d43f05ce9ad501e7",
      "startLine": 77,
      "endLine": 82,
      "methodCode": "private void sendPack(final boolean sideband) throws IOException {\n    ProgressMonitor pm = NullProgressMonitor.INSTANCE;\n    OutputStream packOut = rawOut;\n    if (sideband) {\n        int bufsz = SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz = SideBandOutputStream.MAX_BUF;\n        packOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut = new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm = new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband && noPack.getMessage() != null) {\n            noPack.setOutput();\n            @SuppressWarnings(\"resource\") SideBandOutputStream err = new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg = packConfig;\n    if (cfg == null)\n        cfg = new PackConfig(db);\n    final PackWriter pw = new PackWriter(cfg, walk.getObjectReader());\n    try {\n        pw.setIndexDisabled(true);\n        pw.setUseCachedPacks(true);\n        pw.setUseBitmaps(true);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() && refs != null) {\n            Set<ObjectId> tagTargets = new HashSet<ObjectId>();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() != null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() == null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        if (depth > 0)\n            pw.setShallowPack(depth, unshallowCommits);\n        RevWalk rw = walk;\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase);\n        } else {\n            walk.reset();\n            ObjectWalk ow = walk.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase);\n            rw = ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) && refs != null) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId = ref.getObjectId();\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj = rw.lookupOrNull(objectId);\n                    if (obj != null && obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref = db.peel(ref);\n                ObjectId peeledId = ref.getPeeledObjectId();\n                if (peeledId == null)\n                    continue;\n                objectId = ref.getObjectId();\n                if (pw.willInclude(peeledId) && !pw.willInclude(objectId))\n                    pw.addObject(rw.parseAny(objectId));\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        statistics = pw.getStatistics();\n        if (msgOut != DisabledOutputStream.INSTANCE) {\n            String msg = pw.getStatistics().getMessage() + '\\n';\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        pw.release();\n    }\n    if (sideband)\n        pckOut.end();\n    if (statistics != null)\n        logger.onPackStatistics(statistics);\n}"
    },
    {
      "commit": "eb17495ca4ce95c63bacf81af16ab19ff042b65c",
      "startLine": 78,
      "endLine": 83,
      "methodCode": "private void sendPack(final boolean sideband) throws IOException {\n    ProgressMonitor pm = NullProgressMonitor.INSTANCE;\n    OutputStream packOut = rawOut;\n    SideBandOutputStream msgOut = null;\n    if (sideband) {\n        int bufsz = SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz = SideBandOutputStream.MAX_BUF;\n        packOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut = new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm = new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband && noPack.getMessage() != null) {\n            noPack.setOutput();\n            @SuppressWarnings(\"resource\") SideBandOutputStream err = new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg = packConfig;\n    if (cfg == null)\n        cfg = new PackConfig(db);\n    final PackWriter pw = new PackWriter(cfg, walk.getObjectReader());\n    try {\n        pw.setIndexDisabled(true);\n        pw.setUseCachedPacks(true);\n        pw.setUseBitmaps(true);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() && refs != null) {\n            Set<ObjectId> tagTargets = new HashSet<ObjectId>();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() != null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() == null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        if (depth > 0)\n            pw.setShallowPack(depth, unshallowCommits);\n        RevWalk rw = walk;\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase);\n        } else {\n            walk.reset();\n            ObjectWalk ow = walk.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase);\n            rw = ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) && refs != null) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId = ref.getObjectId();\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj = rw.lookupOrNull(objectId);\n                    if (obj != null && obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref = db.peel(ref);\n                ObjectId peeledId = ref.getPeeledObjectId();\n                if (peeledId == null)\n                    continue;\n                objectId = ref.getObjectId();\n                if (pw.willInclude(peeledId) && !pw.willInclude(objectId))\n                    pw.addObject(rw.parseAny(objectId));\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        statistics = pw.getStatistics();\n        if (msgOut != null) {\n            String msg = pw.getStatistics().getMessage() + '\\n';\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        pw.release();\n    }\n    if (sideband)\n        pckOut.end();\n    if (statistics != null)\n        logger.onPackStatistics(statistics);\n}"
    },
    {
      "commit": "43ea887c8b43de26a6b7a9ea547033d3c04022e7",
      "startLine": 77,
      "endLine": 82,
      "methodCode": "private void sendPack(final boolean sideband) throws IOException {\n    ProgressMonitor pm = NullProgressMonitor.INSTANCE;\n    OutputStream packOut = rawOut;\n    SideBandOutputStream msgOut = null;\n    if (sideband) {\n        int bufsz = SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz = SideBandOutputStream.MAX_BUF;\n        packOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut = new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm = new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband && noPack.getMessage() != null) {\n            noPack.setOutput();\n            @SuppressWarnings(\"resource\") SideBandOutputStream err = new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg = packConfig;\n    if (cfg == null)\n        cfg = new PackConfig(db);\n    final PackWriter pw = new PackWriter(cfg, walk.getObjectReader());\n    try {\n        pw.setUseCachedPacks(true);\n        pw.setUseBitmaps(true);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() && refs != null) {\n            Set<ObjectId> tagTargets = new HashSet<ObjectId>();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() != null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() == null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        if (depth > 0)\n            pw.setShallowPack(depth, unshallowCommits);\n        RevWalk rw = walk;\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase);\n        } else {\n            walk.reset();\n            ObjectWalk ow = walk.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase);\n            rw = ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) && refs != null) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId = ref.getObjectId();\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj = rw.lookupOrNull(objectId);\n                    if (obj != null && obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref = db.peel(ref);\n                ObjectId peeledId = ref.getPeeledObjectId();\n                if (peeledId == null)\n                    continue;\n                objectId = ref.getObjectId();\n                if (pw.willInclude(peeledId) && !pw.willInclude(objectId))\n                    pw.addObject(rw.parseAny(objectId));\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        statistics = pw.getStatistics();\n        if (msgOut != null) {\n            String msg = pw.getStatistics().getMessage() + '\\n';\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        pw.release();\n    }\n    if (sideband)\n        pckOut.end();\n    if (statistics != null)\n        logger.onPackStatistics(statistics);\n}"
    },
    {
      "commit": "9b86cf574b230a9b3a71d7cb53a4f6712bfa33eb",
      "startLine": 76,
      "endLine": 81,
      "methodCode": "private void sendPack(final boolean sideband) throws IOException {\n    ProgressMonitor pm = NullProgressMonitor.INSTANCE;\n    OutputStream packOut = rawOut;\n    SideBandOutputStream msgOut = null;\n    if (sideband) {\n        int bufsz = SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz = SideBandOutputStream.MAX_BUF;\n        packOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut = new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm = new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband && noPack.getMessage() != null) {\n            noPack.setOutput();\n            @SuppressWarnings(\"resource\") SideBandOutputStream err = new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg = packConfig;\n    if (cfg == null)\n        cfg = new PackConfig(db);\n    final PackWriter pw = new PackWriter(cfg, walk.getObjectReader());\n    try {\n        pw.setUseCachedPacks(true);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() && refs != null) {\n            Set<ObjectId> tagTargets = new HashSet<ObjectId>();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() != null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() == null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        if (depth > 0)\n            pw.setShallowPack(depth, unshallowCommits);\n        RevWalk rw = walk;\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase);\n        } else {\n            walk.reset();\n            ObjectWalk ow = walk.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase);\n            rw = ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) && refs != null) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId = ref.getObjectId();\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj = rw.lookupOrNull(objectId);\n                    if (obj != null && obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref = db.peel(ref);\n                ObjectId peeledId = ref.getPeeledObjectId();\n                if (peeledId == null)\n                    continue;\n                objectId = ref.getObjectId();\n                if (pw.willInclude(peeledId) && !pw.willInclude(objectId))\n                    pw.addObject(rw.parseAny(objectId));\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        statistics = pw.getStatistics();\n        if (msgOut != null) {\n            String msg = pw.getStatistics().getMessage() + '\\n';\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        pw.release();\n    }\n    if (sideband)\n        pckOut.end();\n    if (statistics != null)\n        logger.onPackStatistics(statistics);\n}"
    },
    {
      "commit": "1f2022e3a7e9482caa4823e031504b6bbe8246af",
      "startLine": 76,
      "endLine": 81,
      "methodCode": "private void sendPack(final boolean sideband) throws IOException {\n    ProgressMonitor pm = NullProgressMonitor.INSTANCE;\n    OutputStream packOut = rawOut;\n    SideBandOutputStream msgOut = null;\n    if (sideband) {\n        int bufsz = SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz = SideBandOutputStream.MAX_BUF;\n        packOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut = new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm = new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n    } catch (ServiceMayNotContinueException noPack) {\n        if (sideband && noPack.getMessage() != null) {\n            noPack.setOutput();\n            SideBandOutputStream err = new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg = packConfig;\n    if (cfg == null)\n        cfg = new PackConfig(db);\n    final PackWriter pw = new PackWriter(cfg, walk.getObjectReader());\n    try {\n        pw.setUseCachedPacks(true);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() && refs != null) {\n            Set<ObjectId> tagTargets = new HashSet<ObjectId>();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() != null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() == null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        if (depth > 0)\n            pw.setShallowPack(depth, unshallowCommits);\n        RevWalk rw = walk;\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase);\n        } else {\n            walk.reset();\n            ObjectWalk ow = walk.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase);\n            rw = ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) && refs != null) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId = ref.getObjectId();\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj = rw.lookupOrNull(objectId);\n                    if (obj != null && obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref = db.peel(ref);\n                ObjectId peeledId = ref.getPeeledObjectId();\n                if (peeledId == null)\n                    continue;\n                objectId = ref.getObjectId();\n                if (pw.willInclude(peeledId) && !pw.willInclude(objectId))\n                    pw.addObject(rw.parseAny(objectId));\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        statistics = pw.getStatistics();\n        if (msgOut != null) {\n            String msg = pw.getStatistics().getMessage() + '\\n';\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        pw.release();\n    }\n    if (sideband)\n        pckOut.end();\n    if (statistics != null)\n        logger.onPackStatistics(statistics);\n}"
    },
    {
      "commit": "d6172dc0de2cbaeb0bd38a9d30278dd5f9b140b3",
      "startLine": 76,
      "endLine": 81,
      "methodCode": "private void sendPack(final boolean sideband) throws IOException {\n    ProgressMonitor pm = NullProgressMonitor.INSTANCE;\n    OutputStream packOut = rawOut;\n    SideBandOutputStream msgOut = null;\n    if (sideband) {\n        int bufsz = SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz = SideBandOutputStream.MAX_BUF;\n        packOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut = new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm = new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n    } catch (UploadPackMayNotContinueException noPack) {\n        if (sideband && noPack.getMessage() != null) {\n            noPack.setOutput();\n            SideBandOutputStream err = new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg = packConfig;\n    if (cfg == null)\n        cfg = new PackConfig(db);\n    final PackWriter pw = new PackWriter(cfg, walk.getObjectReader());\n    try {\n        pw.setUseCachedPacks(true);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() && refs != null) {\n            Set<ObjectId> tagTargets = new HashSet<ObjectId>();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() != null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() == null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        if (depth > 0)\n            pw.setShallowPack(depth, unshallowCommits);\n        RevWalk rw = walk;\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase);\n        } else {\n            walk.reset();\n            ObjectWalk ow = walk.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase);\n            rw = ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) && refs != null) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId = ref.getObjectId();\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj = rw.lookupOrNull(objectId);\n                    if (obj != null && obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref = db.peel(ref);\n                ObjectId peeledId = ref.getPeeledObjectId();\n                if (peeledId == null)\n                    continue;\n                objectId = ref.getObjectId();\n                if (pw.willInclude(peeledId) && !pw.willInclude(objectId))\n                    pw.addObject(rw.parseAny(objectId));\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        statistics = pw.getStatistics();\n        if (msgOut != null) {\n            String msg = pw.getStatistics().getMessage() + '\\n';\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        pw.release();\n    }\n    if (sideband)\n        pckOut.end();\n    if (statistics != null)\n        logger.onPackStatistics(statistics);\n}"
    },
    {
      "commit": "01888db892aa9590862d886c01f3b293140db153",
      "startLine": 76,
      "endLine": 81,
      "methodCode": "private void sendPack(final boolean sideband) throws IOException {\n    ProgressMonitor pm = NullProgressMonitor.INSTANCE;\n    OutputStream packOut = rawOut;\n    SideBandOutputStream msgOut = null;\n    if (sideband) {\n        int bufsz = SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz = SideBandOutputStream.MAX_BUF;\n        packOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut = new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm = new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n    } catch (UploadPackMayNotContinueException noPack) {\n        if (sideband && noPack.getMessage() != null) {\n            noPack.setOutput();\n            SideBandOutputStream err = new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg = packConfig;\n    if (cfg == null)\n        cfg = new PackConfig(db);\n    final PackWriter pw = new PackWriter(cfg, walk.getObjectReader());\n    try {\n        pw.setUseCachedPacks(true);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty() && refs != null) {\n            Set<ObjectId> tagTargets = new HashSet<ObjectId>();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() != null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() == null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        if (depth > 0)\n            pw.setShallowPack(depth, unshallowCommits);\n        RevWalk rw = walk;\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase);\n        } else {\n            walk.reset();\n            ObjectWalk ow = walk.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase);\n            rw = ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG) && refs != null) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId = ref.getObjectId();\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj = rw.lookupOrNull(objectId);\n                    if (obj != null && obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref = db.peel(ref);\n                ObjectId peeledId = ref.getPeeledObjectId();\n                if (peeledId == null)\n                    continue;\n                objectId = ref.getObjectId();\n                if (pw.willInclude(peeledId) && !pw.willInclude(objectId))\n                    pw.addObject(rw.parseAny(objectId));\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        statistics = pw.getStatistics();\n        if (msgOut != null) {\n            String msg = pw.getStatistics().getMessage() + '\\n';\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        pw.release();\n    }\n    if (sideband)\n        pckOut.end();\n    if (logger != null && statistics != null)\n        logger.onPackStatistics(statistics);\n}"
    },
    {
      "commit": "9952223e0645fd7a8cddc6093a7f449c6390238d",
      "startLine": 76,
      "endLine": 81,
      "methodCode": "private void sendPack(final boolean sideband) throws IOException {\n    ProgressMonitor pm = NullProgressMonitor.INSTANCE;\n    OutputStream packOut = rawOut;\n    SideBandOutputStream msgOut = null;\n    if (sideband) {\n        int bufsz = SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz = SideBandOutputStream.MAX_BUF;\n        packOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut = new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm = new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n    } catch (UploadPackMayNotContinueException noPack) {\n        if (sideband && noPack.getMessage() != null) {\n            noPack.setOutput();\n            SideBandOutputStream err = new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg = packConfig;\n    if (cfg == null)\n        cfg = new PackConfig(db);\n    final PackWriter pw = new PackWriter(cfg, walk.getObjectReader());\n    try {\n        pw.setUseCachedPacks(true);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty()) {\n            Set<ObjectId> tagTargets = new HashSet<ObjectId>();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() != null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() == null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        if (depth > 0)\n            pw.setShallowPack(depth, unshallowCommits);\n        RevWalk rw = walk;\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase);\n        } else {\n            walk.reset();\n            ObjectWalk ow = walk.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase);\n            rw = ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG)) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId = ref.getObjectId();\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj = rw.lookupOrNull(objectId);\n                    if (obj != null && obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref = db.peel(ref);\n                ObjectId peeledId = ref.getPeeledObjectId();\n                if (peeledId == null)\n                    continue;\n                objectId = ref.getObjectId();\n                if (pw.willInclude(peeledId) && !pw.willInclude(objectId))\n                    pw.addObject(rw.parseAny(objectId));\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        statistics = pw.getStatistics();\n        if (msgOut != null) {\n            String msg = pw.getStatistics().getMessage() + '\\n';\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        pw.release();\n    }\n    if (sideband)\n        pckOut.end();\n    if (logger != null && statistics != null)\n        logger.onPackStatistics(statistics);\n}"
    },
    {
      "commit": "7ff6eb584cf8b83f83a3b5edf897feb53dbf42c0",
      "startLine": 74,
      "endLine": 79,
      "methodCode": "private void sendPack(final boolean sideband) throws IOException {\n    ProgressMonitor pm = NullProgressMonitor.INSTANCE;\n    OutputStream packOut = rawOut;\n    SideBandOutputStream msgOut = null;\n    if (sideband) {\n        int bufsz = SideBandOutputStream.SMALL_BUF;\n        if (options.contains(OPTION_SIDE_BAND_64K))\n            bufsz = SideBandOutputStream.MAX_BUF;\n        packOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA, bufsz, rawOut);\n        if (!options.contains(OPTION_NO_PROGRESS)) {\n            msgOut = new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n            pm = new SideBandProgressMonitor(msgOut);\n        }\n    }\n    try {\n        if (wantAll.isEmpty()) {\n            preUploadHook.onSendPack(this, wantIds, commonBase);\n        } else {\n            preUploadHook.onSendPack(this, wantAll, commonBase);\n        }\n    } catch (UploadPackMayNotContinueException noPack) {\n        if (sideband && noPack.getMessage() != null) {\n            noPack.setOutput();\n            SideBandOutputStream err = new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.SMALL_BUF, rawOut);\n            err.write(Constants.encode(noPack.getMessage()));\n            err.flush();\n        }\n        throw noPack;\n    }\n    PackConfig cfg = packConfig;\n    if (cfg == null)\n        cfg = new PackConfig(db);\n    final PackWriter pw = new PackWriter(cfg, walk.getObjectReader());\n    try {\n        pw.setUseCachedPacks(true);\n        pw.setReuseDeltaCommits(true);\n        pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n        pw.setThin(options.contains(OPTION_THIN_PACK));\n        pw.setReuseValidatingObjects(false);\n        if (commonBase.isEmpty()) {\n            Set<ObjectId> tagTargets = new HashSet<ObjectId>();\n            for (Ref ref : refs.values()) {\n                if (ref.getPeeledObjectId() != null)\n                    tagTargets.add(ref.getPeeledObjectId());\n                else if (ref.getObjectId() == null)\n                    continue;\n                else if (ref.getName().startsWith(Constants.R_HEADS))\n                    tagTargets.add(ref.getObjectId());\n            }\n            pw.setTagTargets(tagTargets);\n        }\n        RevWalk rw = walk;\n        if (wantAll.isEmpty()) {\n            pw.preparePack(pm, wantIds, commonBase);\n        } else {\n            walk.reset();\n            ObjectWalk ow = walk.toObjectWalkWithSameObjects();\n            pw.preparePack(pm, ow, wantAll, commonBase);\n            rw = ow;\n        }\n        if (options.contains(OPTION_INCLUDE_TAG)) {\n            for (Ref ref : refs.values()) {\n                ObjectId objectId = ref.getObjectId();\n                if (wantAll.isEmpty()) {\n                    if (wantIds.contains(objectId))\n                        continue;\n                } else {\n                    RevObject obj = rw.lookupOrNull(objectId);\n                    if (obj != null && obj.has(WANT))\n                        continue;\n                }\n                if (!ref.isPeeled())\n                    ref = db.peel(ref);\n                ObjectId peeledId = ref.getPeeledObjectId();\n                if (peeledId == null)\n                    continue;\n                objectId = ref.getObjectId();\n                if (pw.willInclude(peeledId) && !pw.willInclude(objectId))\n                    pw.addObject(rw.parseAny(objectId));\n            }\n        }\n        pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n        statistics = pw.getStatistics();\n        if (msgOut != null) {\n            String msg = pw.getStatistics().getMessage() + '\\n';\n            msgOut.write(Constants.encode(msg));\n            msgOut.flush();\n        }\n    } finally {\n        pw.release();\n    }\n    if (sideband)\n        pckOut.end();\n    if (logger != null && statistics != null)\n        logger.onPackStatistics(statistics);\n}"
    }
  ]
}