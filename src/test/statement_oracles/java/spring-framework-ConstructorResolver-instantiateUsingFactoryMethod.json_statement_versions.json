{
  "statementVersions": [
    {
      "commit": "1603c4ab2fc49d1bd65f55e35ca899044835ca94",
      "startLine": 2,
      "endLine": 25,
      "methodCode": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, @Nullable final Object[] explicitArgs) {\n    BeanWrapperImpl bw = new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class<?> factoryClass;\n    boolean isStatic;\n    String factoryBeanName = mbd.getFactoryBeanName();\n    if (factoryBeanName != null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean = this.beanFactory.getBean(factoryBeanName);\n        if (mbd.isSingleton() && this.beanFactory.containsSingleton(beanName)) {\n            throw new ImplicitlyAppearedSingletonException();\n        }\n        factoryClass = factoryBean.getClass();\n        isStatic = false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean = null;\n        factoryClass = mbd.getBeanClass();\n        isStatic = true;\n    }\n    Method factoryMethodToUse = null;\n    ArgumentsHolder argsHolderToUse = null;\n    Object[] argsToUse = null;\n    if (explicitArgs != null) {\n        argsToUse = explicitArgs;\n    } else {\n        Object[] argsToResolve = null;\n        synchronized (mbd.constructorArgumentLock) {\n            factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n            if (factoryMethodToUse != null && mbd.constructorArgumentsResolved) {\n                argsToUse = mbd.resolvedConstructorArguments;\n                if (argsToUse == null) {\n                    argsToResolve = mbd.preparedConstructorArguments;\n                }\n            }\n        }\n        if (argsToResolve != null) {\n            argsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve, true);\n        }\n    }\n    if (factoryMethodToUse == null || argsToUse == null) {\n        factoryClass = ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates = getCandidateMethods(factoryClass, mbd);\n        List<Method> candidateSet = new ArrayList<>();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) == isStatic && mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates = candidateSet.toArray(new Method[0]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues = null;\n        boolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight = Integer.MAX_VALUE;\n        Set<Method> ambiguousFactoryMethods = null;\n        int minNrOfArgs;\n        if (explicitArgs != null) {\n            minNrOfArgs = explicitArgs.length;\n        } else {\n            if (mbd.hasConstructorArgumentValues()) {\n                ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n                resolvedValues = new ConstructorArgumentValues();\n                minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n            } else {\n                minNrOfArgs = 0;\n            }\n        }\n        LinkedList<UnsatisfiedDependencyException> causes = null;\n        for (Method candidate : candidates) {\n            Class<?>[] paramTypes = candidate.getParameterTypes();\n            if (paramTypes.length >= minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (explicitArgs != null) {\n                    if (paramTypes.length != explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder = new ArgumentsHolder(explicitArgs);\n                } else {\n                    try {\n                        String[] paramNames = null;\n                        ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd != null) {\n                            paramNames = pnd.getParameterNames(candidate);\n                        }\n                        argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring, candidates.length == 1);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean '\" + beanName + \"': \" + ex);\n                        }\n                        if (causes == null) {\n                            causes = new LinkedList<>();\n                        }\n                        causes.add(ex);\n                        continue;\n                    }\n                }\n                int typeDiffWeight = (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight < minTypeDiffWeight) {\n                    factoryMethodToUse = candidate;\n                    argsHolderToUse = argsHolder;\n                    argsToUse = argsHolder.arguments;\n                    minTypeDiffWeight = typeDiffWeight;\n                    ambiguousFactoryMethods = null;\n                } else if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight && !mbd.isLenientConstructorResolution() && paramTypes.length == factoryMethodToUse.getParameterCount() && !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                    if (ambiguousFactoryMethods == null) {\n                        ambiguousFactoryMethods = new LinkedHashSet<>();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse == null) {\n            if (causes != null) {\n                UnsatisfiedDependencyException ex = causes.removeLast();\n                for (Exception cause : causes) {\n                    this.beanFactory.onSuppressedException(cause);\n                }\n                throw ex;\n            }\n            List<String> argTypes = new ArrayList<>(minNrOfArgs);\n            if (explicitArgs != null) {\n                for (Object arg : explicitArgs) {\n                    argTypes.add(arg != null ? arg.getClass().getSimpleName() : \"null\");\n                }\n            } else if (resolvedValues != null) {\n                Set<ValueHolder> valueHolders = new LinkedHashSet<>(resolvedValues.getArgumentCount());\n                valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                for (ValueHolder value : valueHolders) {\n                    String argType = (value.getType() != null ? ClassUtils.getShortName(value.getType()) : (value.getValue() != null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                    argTypes.add(argType);\n                }\n            }\n            String argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() != null ? \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") + \"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" + \"Check that a method with the specified name \" + (minNrOfArgs > 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class == factoryMethodToUse.getReturnType()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method '\" + mbd.getFactoryMethodName() + \"': needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods != null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean '\" + beanName + \"' \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs == null && argsHolderToUse != null) {\n            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() != null) {\n            final Object fb = factoryBean;\n            final Method factoryMethod = factoryMethodToUse;\n            final Object[] args = argsToUse;\n            beanInstance = AccessController.doPrivileged((PrivilegedAction<Object>) () -> this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, fb, factoryMethod, args), this.beanFactory.getAccessControlContext());\n        } else {\n            beanInstance = this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        bw.setBeanInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean instantiation via factory method failed\", ex);\n    }\n}"
    },
    {
      "commit": "0b53c1096af41ed25e8a5f9bd3f194f4d4f8513d",
      "startLine": 2,
      "endLine": 25,
      "methodCode": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, @Nullable final Object[] explicitArgs) {\n    BeanWrapperImpl bw = new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class<?> factoryClass;\n    boolean isStatic;\n    String factoryBeanName = mbd.getFactoryBeanName();\n    if (factoryBeanName != null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean = this.beanFactory.getBean(factoryBeanName);\n        if (mbd.isSingleton() && this.beanFactory.containsSingleton(beanName)) {\n            throw new ImplicitlyAppearedSingletonException();\n        }\n        factoryClass = factoryBean.getClass();\n        isStatic = false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean = null;\n        factoryClass = mbd.getBeanClass();\n        isStatic = true;\n    }\n    Method factoryMethodToUse = null;\n    ArgumentsHolder argsHolderToUse = null;\n    Object[] argsToUse = null;\n    if (explicitArgs != null) {\n        argsToUse = explicitArgs;\n    } else {\n        Object[] argsToResolve = null;\n        synchronized (mbd.constructorArgumentLock) {\n            factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n            if (factoryMethodToUse != null && mbd.constructorArgumentsResolved) {\n                argsToUse = mbd.resolvedConstructorArguments;\n                if (argsToUse == null) {\n                    argsToResolve = mbd.preparedConstructorArguments;\n                }\n            }\n        }\n        if (argsToResolve != null) {\n            argsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n        }\n    }\n    if (factoryMethodToUse == null || argsToUse == null) {\n        factoryClass = ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates = getCandidateMethods(factoryClass, mbd);\n        List<Method> candidateSet = new ArrayList<>();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) == isStatic && mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates = candidateSet.toArray(new Method[0]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues = null;\n        boolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight = Integer.MAX_VALUE;\n        Set<Method> ambiguousFactoryMethods = null;\n        int minNrOfArgs;\n        if (explicitArgs != null) {\n            minNrOfArgs = explicitArgs.length;\n        } else {\n            if (mbd.hasConstructorArgumentValues()) {\n                ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n                resolvedValues = new ConstructorArgumentValues();\n                minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n            } else {\n                minNrOfArgs = 0;\n            }\n        }\n        LinkedList<UnsatisfiedDependencyException> causes = null;\n        for (Method candidate : candidates) {\n            Class<?>[] paramTypes = candidate.getParameterTypes();\n            if (paramTypes.length >= minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (explicitArgs != null) {\n                    if (paramTypes.length != explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder = new ArgumentsHolder(explicitArgs);\n                } else {\n                    try {\n                        String[] paramNames = null;\n                        ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd != null) {\n                            paramNames = pnd.getParameterNames(candidate);\n                        }\n                        argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean '\" + beanName + \"': \" + ex);\n                        }\n                        if (causes == null) {\n                            causes = new LinkedList<>();\n                        }\n                        causes.add(ex);\n                        continue;\n                    }\n                }\n                int typeDiffWeight = (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight < minTypeDiffWeight) {\n                    factoryMethodToUse = candidate;\n                    argsHolderToUse = argsHolder;\n                    argsToUse = argsHolder.arguments;\n                    minTypeDiffWeight = typeDiffWeight;\n                    ambiguousFactoryMethods = null;\n                } else if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight && !mbd.isLenientConstructorResolution() && paramTypes.length == factoryMethodToUse.getParameterCount() && !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                    if (ambiguousFactoryMethods == null) {\n                        ambiguousFactoryMethods = new LinkedHashSet<>();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse == null) {\n            if (causes != null) {\n                UnsatisfiedDependencyException ex = causes.removeLast();\n                for (Exception cause : causes) {\n                    this.beanFactory.onSuppressedException(cause);\n                }\n                throw ex;\n            }\n            List<String> argTypes = new ArrayList<>(minNrOfArgs);\n            if (explicitArgs != null) {\n                for (Object arg : explicitArgs) {\n                    argTypes.add(arg != null ? arg.getClass().getSimpleName() : \"null\");\n                }\n            } else if (resolvedValues != null) {\n                Set<ValueHolder> valueHolders = new LinkedHashSet<>(resolvedValues.getArgumentCount());\n                valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                for (ValueHolder value : valueHolders) {\n                    String argType = (value.getType() != null ? ClassUtils.getShortName(value.getType()) : (value.getValue() != null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                    argTypes.add(argType);\n                }\n            }\n            String argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() != null ? \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") + \"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" + \"Check that a method with the specified name \" + (minNrOfArgs > 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class == factoryMethodToUse.getReturnType()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method '\" + mbd.getFactoryMethodName() + \"': needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods != null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean '\" + beanName + \"' \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs == null && argsHolderToUse != null) {\n            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() != null) {\n            final Object fb = factoryBean;\n            final Method factoryMethod = factoryMethodToUse;\n            final Object[] args = argsToUse;\n            beanInstance = AccessController.doPrivileged((PrivilegedAction<Object>) () -> this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, fb, factoryMethod, args), this.beanFactory.getAccessControlContext());\n        } else {\n            beanInstance = this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        bw.setBeanInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean instantiation via factory method failed\", ex);\n    }\n}"
    },
    {
      "commit": "74fcdea2d96e6c88d232c487e6e2ca6b9978773a",
      "startLine": 2,
      "endLine": 25,
      "methodCode": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, @Nullable final Object[] explicitArgs) {\n    BeanWrapperImpl bw = new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class<?> factoryClass;\n    boolean isStatic;\n    String factoryBeanName = mbd.getFactoryBeanName();\n    if (factoryBeanName != null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean = this.beanFactory.getBean(factoryBeanName);\n        if (mbd.isSingleton() && this.beanFactory.containsSingleton(beanName)) {\n            throw new ImplicitlyAppearedSingletonException();\n        }\n        factoryClass = factoryBean.getClass();\n        isStatic = false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean = null;\n        factoryClass = mbd.getBeanClass();\n        isStatic = true;\n    }\n    Method factoryMethodToUse = null;\n    ArgumentsHolder argsHolderToUse = null;\n    Object[] argsToUse = null;\n    if (explicitArgs != null) {\n        argsToUse = explicitArgs;\n    } else {\n        Object[] argsToResolve = null;\n        synchronized (mbd.constructorArgumentLock) {\n            factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n            if (factoryMethodToUse != null && mbd.constructorArgumentsResolved) {\n                argsToUse = mbd.resolvedConstructorArguments;\n                if (argsToUse == null) {\n                    argsToResolve = mbd.preparedConstructorArguments;\n                }\n            }\n        }\n        if (argsToResolve != null) {\n            argsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n        }\n    }\n    if (factoryMethodToUse == null || argsToUse == null) {\n        factoryClass = ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates = getCandidateMethods(factoryClass, mbd);\n        List<Method> candidateSet = new ArrayList<>();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) == isStatic && mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates = candidateSet.toArray(new Method[0]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues = null;\n        boolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight = Integer.MAX_VALUE;\n        Set<Method> ambiguousFactoryMethods = null;\n        int minNrOfArgs;\n        if (explicitArgs != null) {\n            minNrOfArgs = explicitArgs.length;\n        } else {\n            if (mbd.hasConstructorArgumentValues()) {\n                ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n                resolvedValues = new ConstructorArgumentValues();\n                minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n            } else {\n                minNrOfArgs = 0;\n            }\n        }\n        LinkedList<UnsatisfiedDependencyException> causes = null;\n        for (Method candidate : candidates) {\n            Class<?>[] paramTypes = candidate.getParameterTypes();\n            if (paramTypes.length >= minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (explicitArgs != null) {\n                    if (paramTypes.length != explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder = new ArgumentsHolder(explicitArgs);\n                } else {\n                    try {\n                        String[] paramNames = null;\n                        ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd != null) {\n                            paramNames = pnd.getParameterNames(candidate);\n                        }\n                        argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean '\" + beanName + \"': \" + ex);\n                        }\n                        if (causes == null) {\n                            causes = new LinkedList<>();\n                        }\n                        causes.add(ex);\n                        continue;\n                    }\n                }\n                int typeDiffWeight = (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight < minTypeDiffWeight) {\n                    factoryMethodToUse = candidate;\n                    argsHolderToUse = argsHolder;\n                    argsToUse = argsHolder.arguments;\n                    minTypeDiffWeight = typeDiffWeight;\n                    ambiguousFactoryMethods = null;\n                } else if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight && !mbd.isLenientConstructorResolution() && paramTypes.length == factoryMethodToUse.getParameterCount() && !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                    if (ambiguousFactoryMethods == null) {\n                        ambiguousFactoryMethods = new LinkedHashSet<>();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse == null) {\n            if (causes != null) {\n                UnsatisfiedDependencyException ex = causes.removeLast();\n                for (Exception cause : causes) {\n                    this.beanFactory.onSuppressedException(cause);\n                }\n                throw ex;\n            }\n            List<String> argTypes = new ArrayList<>(minNrOfArgs);\n            if (explicitArgs != null) {\n                for (Object arg : explicitArgs) {\n                    argTypes.add(arg != null ? arg.getClass().getSimpleName() : \"null\");\n                }\n            } else if (resolvedValues != null) {\n                Set<ValueHolder> valueHolders = new LinkedHashSet<>(resolvedValues.getArgumentCount());\n                valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                for (ValueHolder value : valueHolders) {\n                    String argType = (value.getType() != null ? ClassUtils.getShortName(value.getType()) : (value.getValue() != null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                    argTypes.add(argType);\n                }\n            }\n            String argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() != null ? \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") + \"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" + \"Check that a method with the specified name \" + (minNrOfArgs > 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class == factoryMethodToUse.getReturnType()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method '\" + mbd.getFactoryMethodName() + \"': needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods != null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean '\" + beanName + \"' \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs == null && argsHolderToUse != null) {\n            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() != null) {\n            final Object fb = factoryBean;\n            final Method factoryMethod = factoryMethodToUse;\n            final Object[] args = argsToUse;\n            beanInstance = AccessController.doPrivileged((PrivilegedAction<Object>) () -> beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args), beanFactory.getAccessControlContext());\n        } else {\n            beanInstance = this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        bw.setBeanInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean instantiation via factory method failed\", ex);\n    }\n}"
    },
    {
      "commit": "a5cbf5fe246e362c939db006cb44793b22bdc741",
      "startLine": 2,
      "endLine": 25,
      "methodCode": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, @Nullable final Object[] explicitArgs) {\n    BeanWrapperImpl bw = new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class<?> factoryClass;\n    boolean isStatic;\n    String factoryBeanName = mbd.getFactoryBeanName();\n    if (factoryBeanName != null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean = this.beanFactory.getBean(factoryBeanName);\n        if (mbd.isSingleton() && this.beanFactory.containsSingleton(beanName)) {\n            throw new ImplicitlyAppearedSingletonException();\n        }\n        factoryClass = factoryBean.getClass();\n        isStatic = false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean = null;\n        factoryClass = mbd.getBeanClass();\n        isStatic = true;\n    }\n    Method factoryMethodToUse = null;\n    ArgumentsHolder argsHolderToUse = null;\n    Object[] argsToUse = null;\n    if (explicitArgs != null) {\n        argsToUse = explicitArgs;\n    } else {\n        Object[] argsToResolve = null;\n        synchronized (mbd.constructorArgumentLock) {\n            factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n            if (factoryMethodToUse != null && mbd.constructorArgumentsResolved) {\n                argsToUse = mbd.resolvedConstructorArguments;\n                if (argsToUse == null) {\n                    argsToResolve = mbd.preparedConstructorArguments;\n                }\n            }\n        }\n        if (argsToResolve != null) {\n            argsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n        }\n    }\n    if (factoryMethodToUse == null || argsToUse == null) {\n        factoryClass = ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates = getCandidateMethods(factoryClass, mbd);\n        List<Method> candidateSet = new ArrayList<>();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) == isStatic && mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates = candidateSet.toArray(new Method[0]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues = null;\n        boolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight = Integer.MAX_VALUE;\n        Set<Method> ambiguousFactoryMethods = null;\n        int minNrOfArgs;\n        if (explicitArgs != null) {\n            minNrOfArgs = explicitArgs.length;\n        } else {\n            if (mbd.hasConstructorArgumentValues()) {\n                ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n                resolvedValues = new ConstructorArgumentValues();\n                minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n            } else {\n                minNrOfArgs = 0;\n            }\n        }\n        LinkedList<UnsatisfiedDependencyException> causes = null;\n        for (Method candidate : candidates) {\n            Class<?>[] paramTypes = candidate.getParameterTypes();\n            if (paramTypes.length >= minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (explicitArgs != null) {\n                    if (paramTypes.length != explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder = new ArgumentsHolder(explicitArgs);\n                } else {\n                    try {\n                        String[] paramNames = null;\n                        ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd != null) {\n                            paramNames = pnd.getParameterNames(candidate);\n                        }\n                        argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean '\" + beanName + \"': \" + ex);\n                        }\n                        if (causes == null) {\n                            causes = new LinkedList<>();\n                        }\n                        causes.add(ex);\n                        continue;\n                    }\n                }\n                int typeDiffWeight = (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight < minTypeDiffWeight) {\n                    factoryMethodToUse = candidate;\n                    argsHolderToUse = argsHolder;\n                    argsToUse = argsHolder.arguments;\n                    minTypeDiffWeight = typeDiffWeight;\n                    ambiguousFactoryMethods = null;\n                } else if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight && !mbd.isLenientConstructorResolution() && paramTypes.length == factoryMethodToUse.getParameterCount() && !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                    if (ambiguousFactoryMethods == null) {\n                        ambiguousFactoryMethods = new LinkedHashSet<>();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse == null) {\n            if (causes != null) {\n                UnsatisfiedDependencyException ex = causes.removeLast();\n                for (Exception cause : causes) {\n                    this.beanFactory.onSuppressedException(cause);\n                }\n                throw ex;\n            }\n            List<String> argTypes = new ArrayList<>(minNrOfArgs);\n            if (explicitArgs != null) {\n                for (Object arg : explicitArgs) {\n                    argTypes.add(arg != null ? arg.getClass().getSimpleName() : \"null\");\n                }\n            } else if (resolvedValues != null) {\n                Set<ValueHolder> valueHolders = new LinkedHashSet<>(resolvedValues.getArgumentCount());\n                valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                for (ValueHolder value : valueHolders) {\n                    String argType = (value.getType() != null ? ClassUtils.getShortName(value.getType()) : (value.getValue() != null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                    argTypes.add(argType);\n                }\n            }\n            String argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() != null ? \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") + \"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" + \"Check that a method with the specified name \" + (minNrOfArgs > 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class == factoryMethodToUse.getReturnType()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method '\" + mbd.getFactoryMethodName() + \"': needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods != null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean '\" + beanName + \"' \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs == null && argsHolderToUse != null) {\n            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() != null) {\n            final Object fb = factoryBean;\n            final Method factoryMethod = factoryMethodToUse;\n            final Object[] args = argsToUse;\n            beanInstance = AccessController.doPrivileged((PrivilegedAction<Object>) () -> beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args), beanFactory.getAccessControlContext());\n        } else {\n            beanInstance = this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        bw.setBeanInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean instantiation via factory method failed\", ex);\n    }\n}"
    },
    {
      "commit": "b5cedd43eb2b70510729696554bbc1f99003ac10",
      "startLine": 2,
      "endLine": 25,
      "methodCode": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, @Nullable final Object[] explicitArgs) {\n    BeanWrapperImpl bw = new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class<?> factoryClass;\n    boolean isStatic;\n    String factoryBeanName = mbd.getFactoryBeanName();\n    if (factoryBeanName != null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean = this.beanFactory.getBean(factoryBeanName);\n        if (mbd.isSingleton() && this.beanFactory.containsSingleton(beanName)) {\n            throw new ImplicitlyAppearedSingletonException();\n        }\n        factoryClass = factoryBean.getClass();\n        isStatic = false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean = null;\n        factoryClass = mbd.getBeanClass();\n        isStatic = true;\n    }\n    Method factoryMethodToUse = null;\n    ArgumentsHolder argsHolderToUse = null;\n    Object[] argsToUse = null;\n    if (explicitArgs != null) {\n        argsToUse = explicitArgs;\n    } else {\n        Object[] argsToResolve = null;\n        synchronized (mbd.constructorArgumentLock) {\n            factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n            if (factoryMethodToUse != null && mbd.constructorArgumentsResolved) {\n                argsToUse = mbd.resolvedConstructorArguments;\n                if (argsToUse == null) {\n                    argsToResolve = mbd.preparedConstructorArguments;\n                }\n            }\n        }\n        if (argsToResolve != null) {\n            argsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n        }\n    }\n    if (factoryMethodToUse == null || argsToUse == null) {\n        factoryClass = ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates = getCandidateMethods(factoryClass, mbd);\n        List<Method> candidateSet = new ArrayList<>();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) == isStatic && mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues = null;\n        boolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight = Integer.MAX_VALUE;\n        Set<Method> ambiguousFactoryMethods = null;\n        int minNrOfArgs;\n        if (explicitArgs != null) {\n            minNrOfArgs = explicitArgs.length;\n        } else {\n            if (mbd.hasConstructorArgumentValues()) {\n                ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n                resolvedValues = new ConstructorArgumentValues();\n                minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n            } else {\n                minNrOfArgs = 0;\n            }\n        }\n        LinkedList<UnsatisfiedDependencyException> causes = null;\n        for (Method candidate : candidates) {\n            Class<?>[] paramTypes = candidate.getParameterTypes();\n            if (paramTypes.length >= minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (explicitArgs != null) {\n                    if (paramTypes.length != explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder = new ArgumentsHolder(explicitArgs);\n                } else {\n                    try {\n                        String[] paramNames = null;\n                        ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd != null) {\n                            paramNames = pnd.getParameterNames(candidate);\n                        }\n                        argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean '\" + beanName + \"': \" + ex);\n                        }\n                        if (causes == null) {\n                            causes = new LinkedList<>();\n                        }\n                        causes.add(ex);\n                        continue;\n                    }\n                }\n                int typeDiffWeight = (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight < minTypeDiffWeight) {\n                    factoryMethodToUse = candidate;\n                    argsHolderToUse = argsHolder;\n                    argsToUse = argsHolder.arguments;\n                    minTypeDiffWeight = typeDiffWeight;\n                    ambiguousFactoryMethods = null;\n                } else if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight && !mbd.isLenientConstructorResolution() && paramTypes.length == factoryMethodToUse.getParameterCount() && !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                    if (ambiguousFactoryMethods == null) {\n                        ambiguousFactoryMethods = new LinkedHashSet<>();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse == null) {\n            if (causes != null) {\n                UnsatisfiedDependencyException ex = causes.removeLast();\n                for (Exception cause : causes) {\n                    this.beanFactory.onSuppressedException(cause);\n                }\n                throw ex;\n            }\n            List<String> argTypes = new ArrayList<>(minNrOfArgs);\n            if (explicitArgs != null) {\n                for (Object arg : explicitArgs) {\n                    argTypes.add(arg != null ? arg.getClass().getSimpleName() : \"null\");\n                }\n            } else if (resolvedValues != null) {\n                Set<ValueHolder> valueHolders = new LinkedHashSet<>(resolvedValues.getArgumentCount());\n                valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                for (ValueHolder value : valueHolders) {\n                    String argType = (value.getType() != null ? ClassUtils.getShortName(value.getType()) : (value.getValue() != null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                    argTypes.add(argType);\n                }\n            }\n            String argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() != null ? \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") + \"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" + \"Check that a method with the specified name \" + (minNrOfArgs > 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class == factoryMethodToUse.getReturnType()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method '\" + mbd.getFactoryMethodName() + \"': needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods != null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean '\" + beanName + \"' \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs == null && argsHolderToUse != null) {\n            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() != null) {\n            final Object fb = factoryBean;\n            final Method factoryMethod = factoryMethodToUse;\n            final Object[] args = argsToUse;\n            beanInstance = AccessController.doPrivileged((PrivilegedAction<Object>) () -> beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args), beanFactory.getAccessControlContext());\n        } else {\n            beanInstance = this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        bw.setBeanInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean instantiation via factory method failed\", ex);\n    }\n}"
    },
    {
      "commit": "b94302b5bde7475b9926dacb9fb69f3c8c894444",
      "startLine": 2,
      "endLine": 25,
      "methodCode": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, @Nullable final Object[] explicitArgs) {\n    BeanWrapperImpl bw = new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class<?> factoryClass;\n    boolean isStatic;\n    String factoryBeanName = mbd.getFactoryBeanName();\n    if (factoryBeanName != null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean = this.beanFactory.getBean(factoryBeanName);\n        if (mbd.isSingleton() && this.beanFactory.containsSingleton(beanName)) {\n            throw new ImplicitlyAppearedSingletonException();\n        }\n        factoryClass = factoryBean.getClass();\n        isStatic = false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean = null;\n        factoryClass = mbd.getBeanClass();\n        isStatic = true;\n    }\n    Method factoryMethodToUse = null;\n    ArgumentsHolder argsHolderToUse = null;\n    Object[] argsToUse = null;\n    if (explicitArgs != null) {\n        argsToUse = explicitArgs;\n    } else {\n        Object[] argsToResolve = null;\n        synchronized (mbd.constructorArgumentLock) {\n            factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n            if (factoryMethodToUse != null && mbd.constructorArgumentsResolved) {\n                argsToUse = mbd.resolvedConstructorArguments;\n                if (argsToUse == null) {\n                    argsToResolve = mbd.preparedConstructorArguments;\n                }\n            }\n        }\n        if (argsToResolve != null) {\n            argsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n        }\n    }\n    if (factoryMethodToUse == null || argsToUse == null) {\n        factoryClass = ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates = getCandidateMethods(factoryClass, mbd);\n        List<Method> candidateSet = new ArrayList<>();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) == isStatic && mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues = null;\n        boolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight = Integer.MAX_VALUE;\n        Set<Method> ambiguousFactoryMethods = null;\n        int minNrOfArgs;\n        if (explicitArgs != null) {\n            minNrOfArgs = explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n            resolvedValues = new ConstructorArgumentValues();\n            minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        LinkedList<UnsatisfiedDependencyException> causes = null;\n        for (Method candidate : candidates) {\n            Class<?>[] paramTypes = candidate.getParameterTypes();\n            if (paramTypes.length >= minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (resolvedValues != null) {\n                    try {\n                        String[] paramNames = null;\n                        ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd != null) {\n                            paramNames = pnd.getParameterNames(candidate);\n                        }\n                        argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean '\" + beanName + \"': \" + ex);\n                        }\n                        if (causes == null) {\n                            causes = new LinkedList<>();\n                        }\n                        causes.add(ex);\n                        continue;\n                    }\n                } else {\n                    if (paramTypes.length != explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder = new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight = (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight < minTypeDiffWeight) {\n                    factoryMethodToUse = candidate;\n                    argsHolderToUse = argsHolder;\n                    argsToUse = argsHolder.arguments;\n                    minTypeDiffWeight = typeDiffWeight;\n                    ambiguousFactoryMethods = null;\n                } else if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight && !mbd.isLenientConstructorResolution() && paramTypes.length == factoryMethodToUse.getParameterCount() && !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                    if (ambiguousFactoryMethods == null) {\n                        ambiguousFactoryMethods = new LinkedHashSet<>();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse == null) {\n            if (causes != null) {\n                UnsatisfiedDependencyException ex = causes.removeLast();\n                for (Exception cause : causes) {\n                    this.beanFactory.onSuppressedException(cause);\n                }\n                throw ex;\n            }\n            List<String> argTypes = new ArrayList<>(minNrOfArgs);\n            if (explicitArgs != null) {\n                for (Object arg : explicitArgs) {\n                    argTypes.add(arg != null ? arg.getClass().getSimpleName() : \"null\");\n                }\n            } else {\n                Set<ValueHolder> valueHolders = new LinkedHashSet<>(resolvedValues.getArgumentCount());\n                valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                for (ValueHolder value : valueHolders) {\n                    String argType = (value.getType() != null ? ClassUtils.getShortName(value.getType()) : (value.getValue() != null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                    argTypes.add(argType);\n                }\n            }\n            String argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() != null ? \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") + \"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" + \"Check that a method with the specified name \" + (minNrOfArgs > 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class == factoryMethodToUse.getReturnType()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method '\" + mbd.getFactoryMethodName() + \"': needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods != null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean '\" + beanName + \"' \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs == null && argsHolderToUse != null) {\n            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() != null) {\n            final Object fb = factoryBean;\n            final Method factoryMethod = factoryMethodToUse;\n            final Object[] args = argsToUse;\n            beanInstance = AccessController.doPrivileged((PrivilegedAction<Object>) () -> beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args), beanFactory.getAccessControlContext());\n        } else {\n            beanInstance = this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        bw.setBeanInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean instantiation via factory method failed\", ex);\n    }\n}"
    },
    {
      "commit": "f813712f5b413b354560cd7cc006352e9defa9a3",
      "startLine": 3,
      "endLine": 26,
      "methodCode": "@Nullable\npublic BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, @Nullable final Object[] explicitArgs) {\n    BeanWrapperImpl bw = new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class<?> factoryClass;\n    boolean isStatic;\n    String factoryBeanName = mbd.getFactoryBeanName();\n    if (factoryBeanName != null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean = this.beanFactory.getBean(factoryBeanName);\n        if (mbd.isSingleton() && this.beanFactory.containsSingleton(beanName)) {\n            throw new ImplicitlyAppearedSingletonException();\n        }\n        factoryClass = factoryBean.getClass();\n        isStatic = false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean = null;\n        factoryClass = mbd.getBeanClass();\n        isStatic = true;\n    }\n    Method factoryMethodToUse = null;\n    ArgumentsHolder argsHolderToUse = null;\n    Object[] argsToUse = null;\n    if (explicitArgs != null) {\n        argsToUse = explicitArgs;\n    } else {\n        Object[] argsToResolve = null;\n        synchronized (mbd.constructorArgumentLock) {\n            factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n            if (factoryMethodToUse != null && mbd.constructorArgumentsResolved) {\n                argsToUse = mbd.resolvedConstructorArguments;\n                if (argsToUse == null) {\n                    argsToResolve = mbd.preparedConstructorArguments;\n                }\n            }\n        }\n        if (argsToResolve != null) {\n            argsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n        }\n    }\n    if (factoryMethodToUse == null || argsToUse == null) {\n        factoryClass = ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates = getCandidateMethods(factoryClass, mbd);\n        List<Method> candidateSet = new ArrayList<>();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) == isStatic && mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues = null;\n        boolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight = Integer.MAX_VALUE;\n        Set<Method> ambiguousFactoryMethods = null;\n        int minNrOfArgs;\n        if (explicitArgs != null) {\n            minNrOfArgs = explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n            resolvedValues = new ConstructorArgumentValues();\n            minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        LinkedList<UnsatisfiedDependencyException> causes = null;\n        for (Method candidate : candidates) {\n            Class<?>[] paramTypes = candidate.getParameterTypes();\n            if (paramTypes.length >= minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (resolvedValues != null) {\n                    try {\n                        String[] paramNames = null;\n                        ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd != null) {\n                            paramNames = pnd.getParameterNames(candidate);\n                        }\n                        argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean '\" + beanName + \"': \" + ex);\n                        }\n                        if (causes == null) {\n                            causes = new LinkedList<>();\n                        }\n                        causes.add(ex);\n                        continue;\n                    }\n                } else {\n                    if (paramTypes.length != explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder = new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight = (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight < minTypeDiffWeight) {\n                    factoryMethodToUse = candidate;\n                    argsHolderToUse = argsHolder;\n                    argsToUse = argsHolder.arguments;\n                    minTypeDiffWeight = typeDiffWeight;\n                    ambiguousFactoryMethods = null;\n                } else if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight && !mbd.isLenientConstructorResolution() && paramTypes.length == factoryMethodToUse.getParameterCount() && !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                    if (ambiguousFactoryMethods == null) {\n                        ambiguousFactoryMethods = new LinkedHashSet<>();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse == null) {\n            if (causes != null) {\n                UnsatisfiedDependencyException ex = causes.removeLast();\n                for (Exception cause : causes) {\n                    this.beanFactory.onSuppressedException(cause);\n                }\n                throw ex;\n            }\n            List<String> argTypes = new ArrayList<>(minNrOfArgs);\n            if (explicitArgs != null) {\n                for (Object arg : explicitArgs) {\n                    argTypes.add(arg != null ? arg.getClass().getSimpleName() : \"null\");\n                }\n            } else {\n                Set<ValueHolder> valueHolders = new LinkedHashSet<>(resolvedValues.getArgumentCount());\n                valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                for (ValueHolder value : valueHolders) {\n                    String argType = (value.getType() != null ? ClassUtils.getShortName(value.getType()) : (value.getValue() != null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                    argTypes.add(argType);\n                }\n            }\n            String argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() != null ? \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") + \"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" + \"Check that a method with the specified name \" + (minNrOfArgs > 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class == factoryMethodToUse.getReturnType()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method '\" + mbd.getFactoryMethodName() + \"': needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods != null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean '\" + beanName + \"' \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs == null && argsHolderToUse != null) {\n            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() != null) {\n            final Object fb = factoryBean;\n            final Method factoryMethod = factoryMethodToUse;\n            final Object[] args = argsToUse;\n            beanInstance = AccessController.doPrivileged((PrivilegedAction<Object>) () -> beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args), beanFactory.getAccessControlContext());\n        } else {\n            beanInstance = this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance == null) {\n            return null;\n        }\n        bw.setBeanInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean instantiation via factory method failed\", ex);\n    }\n}"
    },
    {
      "commit": "87598f48e41d483745aba56cbf4e998c6f6d680c",
      "startLine": 3,
      "endLine": 29,
      "methodCode": "@Nullable\npublic BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, @Nullable final Object[] explicitArgs) {\n    BeanWrapperImpl bw = new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class<?> factoryClass;\n    boolean isStatic;\n    String factoryBeanName = mbd.getFactoryBeanName();\n    if (factoryBeanName != null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean = this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean == null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean '\" + factoryBeanName + \"' (or a BeanPostProcessor involved) returned null\");\n        }\n        if (mbd.isSingleton() && this.beanFactory.containsSingleton(beanName)) {\n            throw new ImplicitlyAppearedSingletonException();\n        }\n        factoryClass = factoryBean.getClass();\n        isStatic = false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean = null;\n        factoryClass = mbd.getBeanClass();\n        isStatic = true;\n    }\n    Method factoryMethodToUse = null;\n    ArgumentsHolder argsHolderToUse = null;\n    Object[] argsToUse = null;\n    if (explicitArgs != null) {\n        argsToUse = explicitArgs;\n    } else {\n        Object[] argsToResolve = null;\n        synchronized (mbd.constructorArgumentLock) {\n            factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n            if (factoryMethodToUse != null && mbd.constructorArgumentsResolved) {\n                argsToUse = mbd.resolvedConstructorArguments;\n                if (argsToUse == null) {\n                    argsToResolve = mbd.preparedConstructorArguments;\n                }\n            }\n        }\n        if (argsToResolve != null) {\n            argsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n        }\n    }\n    if (factoryMethodToUse == null || argsToUse == null) {\n        factoryClass = ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates = getCandidateMethods(factoryClass, mbd);\n        List<Method> candidateSet = new ArrayList<>();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) == isStatic && mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues = null;\n        boolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight = Integer.MAX_VALUE;\n        Set<Method> ambiguousFactoryMethods = null;\n        int minNrOfArgs;\n        if (explicitArgs != null) {\n            minNrOfArgs = explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n            resolvedValues = new ConstructorArgumentValues();\n            minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        LinkedList<UnsatisfiedDependencyException> causes = null;\n        for (Method candidate : candidates) {\n            Class<?>[] paramTypes = candidate.getParameterTypes();\n            if (paramTypes.length >= minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (resolvedValues != null) {\n                    try {\n                        String[] paramNames = null;\n                        ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd != null) {\n                            paramNames = pnd.getParameterNames(candidate);\n                        }\n                        argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean '\" + beanName + \"': \" + ex);\n                        }\n                        if (causes == null) {\n                            causes = new LinkedList<>();\n                        }\n                        causes.add(ex);\n                        continue;\n                    }\n                } else {\n                    if (paramTypes.length != explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder = new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight = (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight < minTypeDiffWeight) {\n                    factoryMethodToUse = candidate;\n                    argsHolderToUse = argsHolder;\n                    argsToUse = argsHolder.arguments;\n                    minTypeDiffWeight = typeDiffWeight;\n                    ambiguousFactoryMethods = null;\n                } else if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight && !mbd.isLenientConstructorResolution() && paramTypes.length == factoryMethodToUse.getParameterCount() && !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                    if (ambiguousFactoryMethods == null) {\n                        ambiguousFactoryMethods = new LinkedHashSet<>();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse == null) {\n            if (causes != null) {\n                UnsatisfiedDependencyException ex = causes.removeLast();\n                for (Exception cause : causes) {\n                    this.beanFactory.onSuppressedException(cause);\n                }\n                throw ex;\n            }\n            List<String> argTypes = new ArrayList<>(minNrOfArgs);\n            if (explicitArgs != null) {\n                for (Object arg : explicitArgs) {\n                    argTypes.add(arg != null ? arg.getClass().getSimpleName() : \"null\");\n                }\n            } else {\n                Set<ValueHolder> valueHolders = new LinkedHashSet<>(resolvedValues.getArgumentCount());\n                valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                for (ValueHolder value : valueHolders) {\n                    String argType = (value.getType() != null ? ClassUtils.getShortName(value.getType()) : (value.getValue() != null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                    argTypes.add(argType);\n                }\n            }\n            String argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() != null ? \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") + \"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" + \"Check that a method with the specified name \" + (minNrOfArgs > 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class == factoryMethodToUse.getReturnType()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method '\" + mbd.getFactoryMethodName() + \"': needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods != null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean '\" + beanName + \"' \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs == null && argsHolderToUse != null) {\n            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() != null) {\n            final Object fb = factoryBean;\n            final Method factoryMethod = factoryMethodToUse;\n            final Object[] args = argsToUse;\n            beanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n\n                @Override\n                public Object run() {\n                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                }\n            }, beanFactory.getAccessControlContext());\n        } else {\n            beanInstance = this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance == null) {\n            return null;\n        }\n        bw.setBeanInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean instantiation via factory method failed\", ex);\n    }\n}"
    },
    {
      "commit": "cf479bf893df758b54f1a7117a7eae9a32728ab7",
      "startLine": 2,
      "endLine": 28,
      "methodCode": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n    BeanWrapperImpl bw = new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class<?> factoryClass;\n    boolean isStatic;\n    String factoryBeanName = mbd.getFactoryBeanName();\n    if (factoryBeanName != null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean = this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean == null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean '\" + factoryBeanName + \"' (or a BeanPostProcessor involved) returned null\");\n        }\n        if (mbd.isSingleton() && this.beanFactory.containsSingleton(beanName)) {\n            throw new ImplicitlyAppearedSingletonException();\n        }\n        factoryClass = factoryBean.getClass();\n        isStatic = false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean = null;\n        factoryClass = mbd.getBeanClass();\n        isStatic = true;\n    }\n    Method factoryMethodToUse = null;\n    ArgumentsHolder argsHolderToUse = null;\n    Object[] argsToUse = null;\n    if (explicitArgs != null) {\n        argsToUse = explicitArgs;\n    } else {\n        Object[] argsToResolve = null;\n        synchronized (mbd.constructorArgumentLock) {\n            factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n            if (factoryMethodToUse != null && mbd.constructorArgumentsResolved) {\n                argsToUse = mbd.resolvedConstructorArguments;\n                if (argsToUse == null) {\n                    argsToResolve = mbd.preparedConstructorArguments;\n                }\n            }\n        }\n        if (argsToResolve != null) {\n            argsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n        }\n    }\n    if (factoryMethodToUse == null || argsToUse == null) {\n        factoryClass = ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates = getCandidateMethods(factoryClass, mbd);\n        List<Method> candidateSet = new ArrayList<>();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) == isStatic && mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues = null;\n        boolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight = Integer.MAX_VALUE;\n        Set<Method> ambiguousFactoryMethods = null;\n        int minNrOfArgs;\n        if (explicitArgs != null) {\n            minNrOfArgs = explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n            resolvedValues = new ConstructorArgumentValues();\n            minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        LinkedList<UnsatisfiedDependencyException> causes = null;\n        for (Method candidate : candidates) {\n            Class<?>[] paramTypes = candidate.getParameterTypes();\n            if (paramTypes.length >= minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (resolvedValues != null) {\n                    try {\n                        String[] paramNames = null;\n                        ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd != null) {\n                            paramNames = pnd.getParameterNames(candidate);\n                        }\n                        argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean '\" + beanName + \"': \" + ex);\n                        }\n                        if (causes == null) {\n                            causes = new LinkedList<>();\n                        }\n                        causes.add(ex);\n                        continue;\n                    }\n                } else {\n                    if (paramTypes.length != explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder = new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight = (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight < minTypeDiffWeight) {\n                    factoryMethodToUse = candidate;\n                    argsHolderToUse = argsHolder;\n                    argsToUse = argsHolder.arguments;\n                    minTypeDiffWeight = typeDiffWeight;\n                    ambiguousFactoryMethods = null;\n                } else if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight && !mbd.isLenientConstructorResolution() && paramTypes.length == factoryMethodToUse.getParameterCount() && !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                    if (ambiguousFactoryMethods == null) {\n                        ambiguousFactoryMethods = new LinkedHashSet<>();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse == null) {\n            if (causes != null) {\n                UnsatisfiedDependencyException ex = causes.removeLast();\n                for (Exception cause : causes) {\n                    this.beanFactory.onSuppressedException(cause);\n                }\n                throw ex;\n            }\n            List<String> argTypes = new ArrayList<>(minNrOfArgs);\n            if (explicitArgs != null) {\n                for (Object arg : explicitArgs) {\n                    argTypes.add(arg != null ? arg.getClass().getSimpleName() : \"null\");\n                }\n            } else {\n                Set<ValueHolder> valueHolders = new LinkedHashSet<>(resolvedValues.getArgumentCount());\n                valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                for (ValueHolder value : valueHolders) {\n                    String argType = (value.getType() != null ? ClassUtils.getShortName(value.getType()) : (value.getValue() != null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                    argTypes.add(argType);\n                }\n            }\n            String argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() != null ? \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") + \"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" + \"Check that a method with the specified name \" + (minNrOfArgs > 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class == factoryMethodToUse.getReturnType()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method '\" + mbd.getFactoryMethodName() + \"': needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods != null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean '\" + beanName + \"' \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs == null && argsHolderToUse != null) {\n            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() != null) {\n            final Object fb = factoryBean;\n            final Method factoryMethod = factoryMethodToUse;\n            final Object[] args = argsToUse;\n            beanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n\n                @Override\n                public Object run() {\n                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                }\n            }, beanFactory.getAccessControlContext());\n        } else {\n            beanInstance = this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance == null) {\n            return null;\n        }\n        bw.setBeanInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean instantiation via factory method failed\", ex);\n    }\n}"
    },
    {
      "commit": "39e3f2ebf6690b72b7a8af852a35df6ff6229515",
      "startLine": 2,
      "endLine": 28,
      "methodCode": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n    BeanWrapperImpl bw = new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class<?> factoryClass;\n    boolean isStatic;\n    String factoryBeanName = mbd.getFactoryBeanName();\n    if (factoryBeanName != null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean = this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean == null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean '\" + factoryBeanName + \"' (or a BeanPostProcessor involved) returned null\");\n        }\n        if (mbd.isSingleton() && this.beanFactory.containsSingleton(beanName)) {\n            throw new IllegalStateException(\"About-to-be-created singleton instance implicitly appeared \" + \"through the creation of the factory bean that its bean definition points to\");\n        }\n        factoryClass = factoryBean.getClass();\n        isStatic = false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean = null;\n        factoryClass = mbd.getBeanClass();\n        isStatic = true;\n    }\n    Method factoryMethodToUse = null;\n    ArgumentsHolder argsHolderToUse = null;\n    Object[] argsToUse = null;\n    if (explicitArgs != null) {\n        argsToUse = explicitArgs;\n    } else {\n        Object[] argsToResolve = null;\n        synchronized (mbd.constructorArgumentLock) {\n            factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n            if (factoryMethodToUse != null && mbd.constructorArgumentsResolved) {\n                argsToUse = mbd.resolvedConstructorArguments;\n                if (argsToUse == null) {\n                    argsToResolve = mbd.preparedConstructorArguments;\n                }\n            }\n        }\n        if (argsToResolve != null) {\n            argsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n        }\n    }\n    if (factoryMethodToUse == null || argsToUse == null) {\n        factoryClass = ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates = getCandidateMethods(factoryClass, mbd);\n        List<Method> candidateSet = new ArrayList<>();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) == isStatic && mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues = null;\n        boolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight = Integer.MAX_VALUE;\n        Set<Method> ambiguousFactoryMethods = null;\n        int minNrOfArgs;\n        if (explicitArgs != null) {\n            minNrOfArgs = explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n            resolvedValues = new ConstructorArgumentValues();\n            minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        LinkedList<UnsatisfiedDependencyException> causes = null;\n        for (Method candidate : candidates) {\n            Class<?>[] paramTypes = candidate.getParameterTypes();\n            if (paramTypes.length >= minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (resolvedValues != null) {\n                    try {\n                        String[] paramNames = null;\n                        ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd != null) {\n                            paramNames = pnd.getParameterNames(candidate);\n                        }\n                        argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean '\" + beanName + \"': \" + ex);\n                        }\n                        if (causes == null) {\n                            causes = new LinkedList<>();\n                        }\n                        causes.add(ex);\n                        continue;\n                    }\n                } else {\n                    if (paramTypes.length != explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder = new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight = (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight < minTypeDiffWeight) {\n                    factoryMethodToUse = candidate;\n                    argsHolderToUse = argsHolder;\n                    argsToUse = argsHolder.arguments;\n                    minTypeDiffWeight = typeDiffWeight;\n                    ambiguousFactoryMethods = null;\n                } else if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight && !mbd.isLenientConstructorResolution() && paramTypes.length == factoryMethodToUse.getParameterCount() && !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                    if (ambiguousFactoryMethods == null) {\n                        ambiguousFactoryMethods = new LinkedHashSet<>();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse == null) {\n            if (causes != null) {\n                UnsatisfiedDependencyException ex = causes.removeLast();\n                for (Exception cause : causes) {\n                    this.beanFactory.onSuppressedException(cause);\n                }\n                throw ex;\n            }\n            List<String> argTypes = new ArrayList<>(minNrOfArgs);\n            if (explicitArgs != null) {\n                for (Object arg : explicitArgs) {\n                    argTypes.add(arg != null ? arg.getClass().getSimpleName() : \"null\");\n                }\n            } else {\n                Set<ValueHolder> valueHolders = new LinkedHashSet<>(resolvedValues.getArgumentCount());\n                valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                for (ValueHolder value : valueHolders) {\n                    String argType = (value.getType() != null ? ClassUtils.getShortName(value.getType()) : (value.getValue() != null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                    argTypes.add(argType);\n                }\n            }\n            String argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() != null ? \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") + \"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" + \"Check that a method with the specified name \" + (minNrOfArgs > 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class == factoryMethodToUse.getReturnType()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method '\" + mbd.getFactoryMethodName() + \"': needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods != null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean '\" + beanName + \"' \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs == null && argsHolderToUse != null) {\n            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() != null) {\n            final Object fb = factoryBean;\n            final Method factoryMethod = factoryMethodToUse;\n            final Object[] args = argsToUse;\n            beanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n\n                @Override\n                public Object run() {\n                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                }\n            }, beanFactory.getAccessControlContext());\n        } else {\n            beanInstance = this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance == null) {\n            return null;\n        }\n        bw.setBeanInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean instantiation via factory method failed\", ex);\n    }\n}"
    },
    {
      "commit": "00d2606b000f9bdafbd7f4a16b6599fb51b53fa4",
      "startLine": 2,
      "endLine": 28,
      "methodCode": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n    BeanWrapperImpl bw = new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class<?> factoryClass;\n    boolean isStatic;\n    String factoryBeanName = mbd.getFactoryBeanName();\n    if (factoryBeanName != null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean = this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean == null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean '\" + factoryBeanName + \"' (or a BeanPostProcessor involved) returned null\");\n        }\n        if (mbd.isSingleton() && this.beanFactory.containsSingleton(beanName)) {\n            throw new IllegalStateException(\"About-to-be-created singleton instance implicitly appeared \" + \"through the creation of the factory bean that its bean definition points to\");\n        }\n        factoryClass = factoryBean.getClass();\n        isStatic = false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean = null;\n        factoryClass = mbd.getBeanClass();\n        isStatic = true;\n    }\n    Method factoryMethodToUse = null;\n    ArgumentsHolder argsHolderToUse = null;\n    Object[] argsToUse = null;\n    if (explicitArgs != null) {\n        argsToUse = explicitArgs;\n    } else {\n        Object[] argsToResolve = null;\n        synchronized (mbd.constructorArgumentLock) {\n            factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n            if (factoryMethodToUse != null && mbd.constructorArgumentsResolved) {\n                argsToUse = mbd.resolvedConstructorArguments;\n                if (argsToUse == null) {\n                    argsToResolve = mbd.preparedConstructorArguments;\n                }\n            }\n        }\n        if (argsToResolve != null) {\n            argsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n        }\n    }\n    if (factoryMethodToUse == null || argsToUse == null) {\n        factoryClass = ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates = getCandidateMethods(factoryClass, mbd);\n        List<Method> candidateSet = new ArrayList<>();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) == isStatic && mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues = null;\n        boolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight = Integer.MAX_VALUE;\n        Set<Method> ambiguousFactoryMethods = null;\n        int minNrOfArgs;\n        if (explicitArgs != null) {\n            minNrOfArgs = explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n            resolvedValues = new ConstructorArgumentValues();\n            minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        LinkedList<UnsatisfiedDependencyException> causes = null;\n        for (Method candidate : candidates) {\n            Class<?>[] paramTypes = candidate.getParameterTypes();\n            if (paramTypes.length >= minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (resolvedValues != null) {\n                    try {\n                        String[] paramNames = null;\n                        ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd != null) {\n                            paramNames = pnd.getParameterNames(candidate);\n                        }\n                        argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean '\" + beanName + \"': \" + ex);\n                        }\n                        if (causes == null) {\n                            causes = new LinkedList<>();\n                        }\n                        causes.add(ex);\n                        continue;\n                    }\n                } else {\n                    if (paramTypes.length != explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder = new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight = (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight < minTypeDiffWeight) {\n                    factoryMethodToUse = candidate;\n                    argsHolderToUse = argsHolder;\n                    argsToUse = argsHolder.arguments;\n                    minTypeDiffWeight = typeDiffWeight;\n                    ambiguousFactoryMethods = null;\n                } else if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight && !mbd.isLenientConstructorResolution() && paramTypes.length == factoryMethodToUse.getParameterTypes().length && !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                    if (ambiguousFactoryMethods == null) {\n                        ambiguousFactoryMethods = new LinkedHashSet<>();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse == null) {\n            if (causes != null) {\n                UnsatisfiedDependencyException ex = causes.removeLast();\n                for (Exception cause : causes) {\n                    this.beanFactory.onSuppressedException(cause);\n                }\n                throw ex;\n            }\n            List<String> argTypes = new ArrayList<>(minNrOfArgs);\n            if (explicitArgs != null) {\n                for (Object arg : explicitArgs) {\n                    argTypes.add(arg != null ? arg.getClass().getSimpleName() : \"null\");\n                }\n            } else {\n                Set<ValueHolder> valueHolders = new LinkedHashSet<>(resolvedValues.getArgumentCount());\n                valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                for (ValueHolder value : valueHolders) {\n                    String argType = (value.getType() != null ? ClassUtils.getShortName(value.getType()) : (value.getValue() != null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                    argTypes.add(argType);\n                }\n            }\n            String argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() != null ? \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") + \"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" + \"Check that a method with the specified name \" + (minNrOfArgs > 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class == factoryMethodToUse.getReturnType()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method '\" + mbd.getFactoryMethodName() + \"': needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods != null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean '\" + beanName + \"' \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs == null && argsHolderToUse != null) {\n            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() != null) {\n            final Object fb = factoryBean;\n            final Method factoryMethod = factoryMethodToUse;\n            final Object[] args = argsToUse;\n            beanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n\n                @Override\n                public Object run() {\n                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                }\n            }, beanFactory.getAccessControlContext());\n        } else {\n            beanInstance = this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance == null) {\n            return null;\n        }\n        bw.setBeanInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean instantiation via factory method failed\", ex);\n    }\n}"
    },
    {
      "commit": "5c1d3fca15d9c020a07a0130a3992926d7087f1a",
      "startLine": 2,
      "endLine": 28,
      "methodCode": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n    BeanWrapperImpl bw = new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class<?> factoryClass;\n    boolean isStatic;\n    String factoryBeanName = mbd.getFactoryBeanName();\n    if (factoryBeanName != null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean = this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean == null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean '\" + factoryBeanName + \"' (or a BeanPostProcessor involved) returned null\");\n        }\n        if (mbd.isSingleton() && this.beanFactory.containsSingleton(beanName)) {\n            throw new IllegalStateException(\"About-to-be-created singleton instance implicitly appeared \" + \"through the creation of the factory bean that its bean definition points to\");\n        }\n        factoryClass = factoryBean.getClass();\n        isStatic = false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean = null;\n        factoryClass = mbd.getBeanClass();\n        isStatic = true;\n    }\n    Method factoryMethodToUse = null;\n    ArgumentsHolder argsHolderToUse = null;\n    Object[] argsToUse = null;\n    if (explicitArgs != null) {\n        argsToUse = explicitArgs;\n    } else {\n        Object[] argsToResolve = null;\n        synchronized (mbd.constructorArgumentLock) {\n            factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n            if (factoryMethodToUse != null && mbd.constructorArgumentsResolved) {\n                argsToUse = mbd.resolvedConstructorArguments;\n                if (argsToUse == null) {\n                    argsToResolve = mbd.preparedConstructorArguments;\n                }\n            }\n        }\n        if (argsToResolve != null) {\n            argsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n        }\n    }\n    if (factoryMethodToUse == null || argsToUse == null) {\n        factoryClass = ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates = getCandidateMethods(factoryClass, mbd);\n        List<Method> candidateSet = new ArrayList<Method>();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) == isStatic && mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues = null;\n        boolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight = Integer.MAX_VALUE;\n        Set<Method> ambiguousFactoryMethods = null;\n        int minNrOfArgs;\n        if (explicitArgs != null) {\n            minNrOfArgs = explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n            resolvedValues = new ConstructorArgumentValues();\n            minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        LinkedList<UnsatisfiedDependencyException> causes = null;\n        for (Method candidate : candidates) {\n            Class<?>[] paramTypes = candidate.getParameterTypes();\n            if (paramTypes.length >= minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (resolvedValues != null) {\n                    try {\n                        String[] paramNames = null;\n                        ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd != null) {\n                            paramNames = pnd.getParameterNames(candidate);\n                        }\n                        argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean '\" + beanName + \"': \" + ex);\n                        }\n                        if (causes == null) {\n                            causes = new LinkedList<UnsatisfiedDependencyException>();\n                        }\n                        causes.add(ex);\n                        continue;\n                    }\n                } else {\n                    if (paramTypes.length != explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder = new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight = (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight < minTypeDiffWeight) {\n                    factoryMethodToUse = candidate;\n                    argsHolderToUse = argsHolder;\n                    argsToUse = argsHolder.arguments;\n                    minTypeDiffWeight = typeDiffWeight;\n                    ambiguousFactoryMethods = null;\n                } else if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight && !mbd.isLenientConstructorResolution() && paramTypes.length == factoryMethodToUse.getParameterTypes().length && !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                    if (ambiguousFactoryMethods == null) {\n                        ambiguousFactoryMethods = new LinkedHashSet<Method>();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse == null) {\n            if (causes != null) {\n                UnsatisfiedDependencyException ex = causes.removeLast();\n                for (Exception cause : causes) {\n                    this.beanFactory.onSuppressedException(cause);\n                }\n                throw ex;\n            }\n            List<String> argTypes = new ArrayList<String>(minNrOfArgs);\n            if (explicitArgs != null) {\n                for (Object arg : explicitArgs) {\n                    argTypes.add(arg != null ? arg.getClass().getSimpleName() : \"null\");\n                }\n            } else {\n                Set<ValueHolder> valueHolders = new LinkedHashSet<ValueHolder>(resolvedValues.getArgumentCount());\n                valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                for (ValueHolder value : valueHolders) {\n                    String argType = (value.getType() != null ? ClassUtils.getShortName(value.getType()) : (value.getValue() != null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                    argTypes.add(argType);\n                }\n            }\n            String argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() != null ? \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") + \"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" + \"Check that a method with the specified name \" + (minNrOfArgs > 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class == factoryMethodToUse.getReturnType()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method '\" + mbd.getFactoryMethodName() + \"': needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods != null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean '\" + beanName + \"' \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs == null && argsHolderToUse != null) {\n            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() != null) {\n            final Object fb = factoryBean;\n            final Method factoryMethod = factoryMethodToUse;\n            final Object[] args = argsToUse;\n            beanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n\n                @Override\n                public Object run() {\n                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                }\n            }, beanFactory.getAccessControlContext());\n        } else {\n            beanInstance = this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance == null) {\n            return null;\n        }\n        bw.setBeanInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean instantiation via factory method failed\", ex);\n    }\n}"
    },
    {
      "commit": "b944283354f0f340ffc7ec74b430d79703a4294a",
      "startLine": 2,
      "endLine": 28,
      "methodCode": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n    BeanWrapperImpl bw = new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class<?> factoryClass;\n    boolean isStatic;\n    String factoryBeanName = mbd.getFactoryBeanName();\n    if (factoryBeanName != null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean = this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean == null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean '\" + factoryBeanName + \"' (or a BeanPostProcessor involved) returned null\");\n        }\n        if (mbd.isSingleton() && this.beanFactory.containsSingleton(beanName)) {\n            throw new IllegalStateException(\"About-to-be-created singleton instance implicitly appeared \" + \"through the creation of the factory bean that its bean definition points to\");\n        }\n        factoryClass = factoryBean.getClass();\n        isStatic = false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean = null;\n        factoryClass = mbd.getBeanClass();\n        isStatic = true;\n    }\n    Method factoryMethodToUse = null;\n    ArgumentsHolder argsHolderToUse = null;\n    Object[] argsToUse = null;\n    if (explicitArgs != null) {\n        argsToUse = explicitArgs;\n    } else {\n        Object[] argsToResolve = null;\n        synchronized (mbd.constructorArgumentLock) {\n            factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n            if (factoryMethodToUse != null && mbd.constructorArgumentsResolved) {\n                argsToUse = mbd.resolvedConstructorArguments;\n                if (argsToUse == null) {\n                    argsToResolve = mbd.preparedConstructorArguments;\n                }\n            }\n        }\n        if (argsToResolve != null) {\n            argsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n        }\n    }\n    if (factoryMethodToUse == null || argsToUse == null) {\n        factoryClass = ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates = getCandidateMethods(factoryClass, mbd);\n        List<Method> candidateSet = new ArrayList<Method>();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) == isStatic && mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues = null;\n        boolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight = Integer.MAX_VALUE;\n        Set<Method> ambiguousFactoryMethods = null;\n        int minNrOfArgs;\n        if (explicitArgs != null) {\n            minNrOfArgs = explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n            resolvedValues = new ConstructorArgumentValues();\n            minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        LinkedList<UnsatisfiedDependencyException> causes = null;\n        for (Method candidate : candidates) {\n            Class<?>[] paramTypes = candidate.getParameterTypes();\n            if (paramTypes.length >= minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (resolvedValues != null) {\n                    try {\n                        String[] paramNames = null;\n                        ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd != null) {\n                            paramNames = pnd.getParameterNames(candidate);\n                        }\n                        argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean '\" + beanName + \"': \" + ex);\n                        }\n                        if (causes == null) {\n                            causes = new LinkedList<UnsatisfiedDependencyException>();\n                        }\n                        causes.add(ex);\n                        continue;\n                    }\n                } else {\n                    if (paramTypes.length != explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder = new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight = (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight < minTypeDiffWeight) {\n                    factoryMethodToUse = candidate;\n                    argsHolderToUse = argsHolder;\n                    argsToUse = argsHolder.arguments;\n                    minTypeDiffWeight = typeDiffWeight;\n                    ambiguousFactoryMethods = null;\n                } else if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight && !mbd.isLenientConstructorResolution() && paramTypes.length == factoryMethodToUse.getParameterTypes().length && !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                    if (ambiguousFactoryMethods == null) {\n                        ambiguousFactoryMethods = new LinkedHashSet<Method>();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse == null) {\n            if (causes != null) {\n                UnsatisfiedDependencyException ex = causes.removeLast();\n                for (Exception cause : causes) {\n                    this.beanFactory.onSuppressedException(cause);\n                }\n                throw ex;\n            }\n            List<String> argTypes = new ArrayList<String>(minNrOfArgs);\n            if (explicitArgs != null) {\n                for (Object arg : explicitArgs) {\n                    argTypes.add(arg != null ? arg.getClass().getSimpleName() : \"null\");\n                }\n            } else {\n                Set<ValueHolder> valueHolders = new LinkedHashSet<ValueHolder>(resolvedValues.getArgumentCount());\n                valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                for (ValueHolder value : valueHolders) {\n                    String argType = (value.getType() != null ? ClassUtils.getShortName(value.getType()) : (value.getValue() != null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                    argTypes.add(argType);\n                }\n            }\n            String argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() != null ? \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") + \"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" + \"Check that a method with the specified name \" + (minNrOfArgs > 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class == factoryMethodToUse.getReturnType()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method '\" + mbd.getFactoryMethodName() + \"': needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods != null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean '\" + beanName + \"' \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs == null && argsHolderToUse != null) {\n            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() != null) {\n            final Object fb = factoryBean;\n            final Method factoryMethod = factoryMethodToUse;\n            final Object[] args = argsToUse;\n            beanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n\n                @Override\n                public Object run() {\n                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                }\n            }, beanFactory.getAccessControlContext());\n        } else {\n            beanInstance = this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance == null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean instantiation via factory method failed\", ex);\n    }\n}"
    },
    {
      "commit": "8a83af55b8adf833683b8d9a6924eecf69709a12",
      "startLine": 2,
      "endLine": 28,
      "methodCode": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n    BeanWrapperImpl bw = new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class<?> factoryClass;\n    boolean isStatic;\n    String factoryBeanName = mbd.getFactoryBeanName();\n    if (factoryBeanName != null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean = this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean == null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean '\" + factoryBeanName + \"' (or a BeanPostProcessor involved) returned null\");\n        }\n        if (mbd.isSingleton() && this.beanFactory.containsSingleton(beanName)) {\n            throw new IllegalStateException(\"About-to-be-created singleton instance implicitly appeared \" + \"through the creation of the factory bean that its bean definition points to\");\n        }\n        factoryClass = factoryBean.getClass();\n        isStatic = false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean = null;\n        factoryClass = mbd.getBeanClass();\n        isStatic = true;\n    }\n    Method factoryMethodToUse = null;\n    ArgumentsHolder argsHolderToUse = null;\n    Object[] argsToUse = null;\n    if (explicitArgs != null) {\n        argsToUse = explicitArgs;\n    } else {\n        Object[] argsToResolve = null;\n        synchronized (mbd.constructorArgumentLock) {\n            factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n            if (factoryMethodToUse != null && mbd.constructorArgumentsResolved) {\n                argsToUse = mbd.resolvedConstructorArguments;\n                if (argsToUse == null) {\n                    argsToResolve = mbd.preparedConstructorArguments;\n                }\n            }\n        }\n        if (argsToResolve != null) {\n            argsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n        }\n    }\n    if (factoryMethodToUse == null || argsToUse == null) {\n        factoryClass = ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates = getCandidateMethods(factoryClass, mbd);\n        List<Method> candidateSet = new ArrayList<Method>();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) == isStatic && mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues = null;\n        boolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight = Integer.MAX_VALUE;\n        Set<Method> ambiguousFactoryMethods = null;\n        int minNrOfArgs;\n        if (explicitArgs != null) {\n            minNrOfArgs = explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n            resolvedValues = new ConstructorArgumentValues();\n            minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        LinkedList<UnsatisfiedDependencyException> causes = null;\n        for (int i = 0; i < candidates.length; i++) {\n            Method candidate = candidates[i];\n            Class<?>[] paramTypes = candidate.getParameterTypes();\n            if (paramTypes.length >= minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (resolvedValues != null) {\n                    try {\n                        String[] paramNames = null;\n                        ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd != null) {\n                            paramNames = pnd.getParameterNames(candidate);\n                        }\n                        argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean '\" + beanName + \"': \" + ex);\n                        }\n                        if (causes == null) {\n                            causes = new LinkedList<UnsatisfiedDependencyException>();\n                        }\n                        causes.add(ex);\n                        continue;\n                    }\n                } else {\n                    if (paramTypes.length != explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder = new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight = (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight < minTypeDiffWeight) {\n                    factoryMethodToUse = candidate;\n                    argsHolderToUse = argsHolder;\n                    argsToUse = argsHolder.arguments;\n                    minTypeDiffWeight = typeDiffWeight;\n                    ambiguousFactoryMethods = null;\n                } else if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight && !mbd.isLenientConstructorResolution() && paramTypes.length == factoryMethodToUse.getParameterTypes().length && !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                    if (ambiguousFactoryMethods == null) {\n                        ambiguousFactoryMethods = new LinkedHashSet<Method>();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse == null) {\n            if (causes != null) {\n                UnsatisfiedDependencyException ex = causes.removeLast();\n                for (Exception cause : causes) {\n                    this.beanFactory.onSuppressedException(cause);\n                }\n                throw ex;\n            }\n            List<String> argTypes = new ArrayList<String>(minNrOfArgs);\n            if (explicitArgs != null) {\n                for (Object arg : explicitArgs) {\n                    argTypes.add(arg != null ? arg.getClass().getSimpleName() : \"null\");\n                }\n            } else {\n                Set<ValueHolder> valueHolders = new LinkedHashSet<ValueHolder>(resolvedValues.getArgumentCount());\n                valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                for (ValueHolder value : valueHolders) {\n                    String argType = (value.getType() != null ? ClassUtils.getShortName(value.getType()) : (value.getValue() != null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                    argTypes.add(argType);\n                }\n            }\n            String argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() != null ? \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") + \"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" + \"Check that a method with the specified name \" + (minNrOfArgs > 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class == factoryMethodToUse.getReturnType()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method '\" + mbd.getFactoryMethodName() + \"': needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods != null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean '\" + beanName + \"' \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs == null && argsHolderToUse != null) {\n            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() != null) {\n            final Object fb = factoryBean;\n            final Method factoryMethod = factoryMethodToUse;\n            final Object[] args = argsToUse;\n            beanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n\n                @Override\n                public Object run() {\n                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                }\n            }, beanFactory.getAccessControlContext());\n        } else {\n            beanInstance = this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance == null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean instantiation via factory method failed\", ex);\n    }\n}"
    },
    {
      "commit": "b4095c3e1d61fc7279e6b2ca105ec60c3cd7128c",
      "startLine": 2,
      "endLine": 28,
      "methodCode": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n    BeanWrapperImpl bw = new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class<?> factoryClass;\n    boolean isStatic;\n    String factoryBeanName = mbd.getFactoryBeanName();\n    if (factoryBeanName != null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean = this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean == null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean '\" + factoryBeanName + \"' (or a BeanPostProcessor involved) returned null\");\n        }\n        if (mbd.isSingleton() && this.beanFactory.containsSingleton(beanName)) {\n            throw new IllegalStateException(\"About-to-be-created singleton instance implicitly appeared \" + \"through the creation of the factory bean that its bean definition points to\");\n        }\n        factoryClass = factoryBean.getClass();\n        isStatic = false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean = null;\n        factoryClass = mbd.getBeanClass();\n        isStatic = true;\n    }\n    Method factoryMethodToUse = null;\n    ArgumentsHolder argsHolderToUse = null;\n    Object[] argsToUse = null;\n    if (explicitArgs != null) {\n        argsToUse = explicitArgs;\n    } else {\n        Object[] argsToResolve = null;\n        synchronized (mbd.constructorArgumentLock) {\n            factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n            if (factoryMethodToUse != null && mbd.constructorArgumentsResolved) {\n                argsToUse = mbd.resolvedConstructorArguments;\n                if (argsToUse == null) {\n                    argsToResolve = mbd.preparedConstructorArguments;\n                }\n            }\n        }\n        if (argsToResolve != null) {\n            argsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n        }\n    }\n    if (factoryMethodToUse == null || argsToUse == null) {\n        factoryClass = ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates = getCandidateMethods(factoryClass, mbd);\n        List<Method> candidateSet = new ArrayList<Method>();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) == isStatic && mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues = null;\n        boolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight = Integer.MAX_VALUE;\n        Set<Method> ambiguousFactoryMethods = null;\n        int minNrOfArgs;\n        if (explicitArgs != null) {\n            minNrOfArgs = explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n            resolvedValues = new ConstructorArgumentValues();\n            minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List<Exception> causes = null;\n        for (int i = 0; i < candidates.length; i++) {\n            Method candidate = candidates[i];\n            Class<?>[] paramTypes = candidate.getParameterTypes();\n            if (paramTypes.length >= minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (resolvedValues != null) {\n                    try {\n                        String[] paramNames = null;\n                        ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd != null) {\n                            paramNames = pnd.getParameterNames(candidate);\n                        }\n                        argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean '\" + beanName + \"': \" + ex);\n                        }\n                        if (i == candidates.length - 1 && argsHolderToUse == null) {\n                            if (causes != null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes == null) {\n                                causes = new LinkedList<Exception>();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length != explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder = new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight = (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight < minTypeDiffWeight) {\n                    factoryMethodToUse = candidate;\n                    argsHolderToUse = argsHolder;\n                    argsToUse = argsHolder.arguments;\n                    minTypeDiffWeight = typeDiffWeight;\n                    ambiguousFactoryMethods = null;\n                } else if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight && !mbd.isLenientConstructorResolution() && paramTypes.length == factoryMethodToUse.getParameterTypes().length && !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                    if (ambiguousFactoryMethods == null) {\n                        ambiguousFactoryMethods = new LinkedHashSet<Method>();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse == null) {\n            List<String> argTypes = new ArrayList<String>(minNrOfArgs);\n            if (explicitArgs != null) {\n                for (Object arg : explicitArgs) {\n                    argTypes.add(arg != null ? arg.getClass().getSimpleName() : \"null\");\n                }\n            } else {\n                Set<ValueHolder> valueHolders = new LinkedHashSet<ValueHolder>(resolvedValues.getArgumentCount());\n                valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                for (ValueHolder value : valueHolders) {\n                    String argType = (value.getType() != null ? ClassUtils.getShortName(value.getType()) : (value.getValue() != null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                    argTypes.add(argType);\n                }\n            }\n            String argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() != null ? \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") + \"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" + \"Check that a method with the specified name \" + (minNrOfArgs > 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class == factoryMethodToUse.getReturnType()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method '\" + mbd.getFactoryMethodName() + \"': needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods != null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean '\" + beanName + \"' \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs == null && argsHolderToUse != null) {\n            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() != null) {\n            final Object fb = factoryBean;\n            final Method factoryMethod = factoryMethodToUse;\n            final Object[] args = argsToUse;\n            beanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n\n                @Override\n                public Object run() {\n                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                }\n            }, beanFactory.getAccessControlContext());\n        } else {\n            beanInstance = this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance == null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean instantiation via factory method failed\", ex);\n    }\n}"
    },
    {
      "commit": "ad62b2afb145499d384cb76c5f254113db99796c",
      "startLine": 2,
      "endLine": 28,
      "methodCode": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n    BeanWrapperImpl bw = new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class<?> factoryClass;\n    boolean isStatic;\n    String factoryBeanName = mbd.getFactoryBeanName();\n    if (factoryBeanName != null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean = this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean == null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean '\" + factoryBeanName + \"' (or a BeanPostProcessor involved) returned null\");\n        }\n        if (mbd.isSingleton() && this.beanFactory.containsSingleton(beanName)) {\n            throw new IllegalStateException(\"About-to-be-created singleton instance implicitly appeared \" + \"through the creation of the factory bean that its bean definition points to\");\n        }\n        factoryClass = factoryBean.getClass();\n        isStatic = false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean = null;\n        factoryClass = mbd.getBeanClass();\n        isStatic = true;\n    }\n    Method factoryMethodToUse = null;\n    ArgumentsHolder argsHolderToUse = null;\n    Object[] argsToUse = null;\n    if (explicitArgs != null) {\n        argsToUse = explicitArgs;\n    } else {\n        Object[] argsToResolve = null;\n        synchronized (mbd.constructorArgumentLock) {\n            factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n            if (factoryMethodToUse != null && mbd.constructorArgumentsResolved) {\n                argsToUse = mbd.resolvedConstructorArguments;\n                if (argsToUse == null) {\n                    argsToResolve = mbd.preparedConstructorArguments;\n                }\n            }\n        }\n        if (argsToResolve != null) {\n            argsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n        }\n    }\n    if (factoryMethodToUse == null || argsToUse == null) {\n        factoryClass = ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates = getCandidateMethods(factoryClass, mbd);\n        List<Method> candidateSet = new ArrayList<Method>();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) == isStatic && mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues = null;\n        boolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight = Integer.MAX_VALUE;\n        Set<Method> ambiguousFactoryMethods = null;\n        int minNrOfArgs;\n        if (explicitArgs != null) {\n            minNrOfArgs = explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n            resolvedValues = new ConstructorArgumentValues();\n            minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List<Exception> causes = null;\n        for (int i = 0; i < candidates.length; i++) {\n            Method candidate = candidates[i];\n            Class<?>[] paramTypes = candidate.getParameterTypes();\n            if (paramTypes.length >= minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (resolvedValues != null) {\n                    try {\n                        String[] paramNames = null;\n                        ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd != null) {\n                            paramNames = pnd.getParameterNames(candidate);\n                        }\n                        argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean '\" + beanName + \"': \" + ex);\n                        }\n                        if (i == candidates.length - 1 && argsHolderToUse == null) {\n                            if (causes != null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes == null) {\n                                causes = new LinkedList<Exception>();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length != explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder = new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight = (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight < minTypeDiffWeight) {\n                    factoryMethodToUse = candidate;\n                    argsHolderToUse = argsHolder;\n                    argsToUse = argsHolder.arguments;\n                    minTypeDiffWeight = typeDiffWeight;\n                    ambiguousFactoryMethods = null;\n                } else if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight && !mbd.isLenientConstructorResolution() && paramTypes.length == factoryMethodToUse.getParameterTypes().length && !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                    if (ambiguousFactoryMethods == null) {\n                        ambiguousFactoryMethods = new LinkedHashSet<Method>();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse == null) {\n            List<String> argTypes = new ArrayList<String>(minNrOfArgs);\n            if (explicitArgs != null) {\n                for (Object arg : explicitArgs) {\n                    argTypes.add(arg != null ? arg.getClass().getSimpleName() : \"null\");\n                }\n            } else {\n                Set<ValueHolder> valueHolders = new LinkedHashSet<ValueHolder>(resolvedValues.getArgumentCount());\n                valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                for (ValueHolder value : valueHolders) {\n                    String argType = (value.getType() != null ? ClassUtils.getShortName(value.getType()) : (value.getValue() != null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                    argTypes.add(argType);\n                }\n            }\n            String argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() != null ? \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") + \"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" + \"Check that a method with the specified name \" + (minNrOfArgs > 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method '\" + mbd.getFactoryMethodName() + \"': needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods != null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean '\" + beanName + \"' \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs == null && argsHolderToUse != null) {\n            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() != null) {\n            final Object fb = factoryBean;\n            final Method factoryMethod = factoryMethodToUse;\n            final Object[] args = argsToUse;\n            beanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n\n                @Override\n                public Object run() {\n                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                }\n            }, beanFactory.getAccessControlContext());\n        } else {\n            beanInstance = this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance == null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean instantiation via factory method failed\", ex);\n    }\n}"
    },
    {
      "commit": "8c9274e01743a87d7fb8519f7772c1b1677ecbe0",
      "startLine": 2,
      "endLine": 28,
      "methodCode": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n    BeanWrapperImpl bw = new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class<?> factoryClass;\n    boolean isStatic;\n    String factoryBeanName = mbd.getFactoryBeanName();\n    if (factoryBeanName != null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean = this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean == null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean '\" + factoryBeanName + \"' (or a BeanPostProcessor involved) returned null\");\n        }\n        if (mbd.isSingleton() && this.beanFactory.containsSingleton(beanName)) {\n            throw new IllegalStateException(\"About-to-be-created singleton instance implicitly appeared \" + \"through the creation of the factory bean that its bean definition points to\");\n        }\n        factoryClass = factoryBean.getClass();\n        isStatic = false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean = null;\n        factoryClass = mbd.getBeanClass();\n        isStatic = true;\n    }\n    Method factoryMethodToUse = null;\n    ArgumentsHolder argsHolderToUse = null;\n    Object[] argsToUse = null;\n    if (explicitArgs != null) {\n        argsToUse = explicitArgs;\n    } else {\n        Object[] argsToResolve = null;\n        synchronized (mbd.constructorArgumentLock) {\n            factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n            if (factoryMethodToUse != null && mbd.constructorArgumentsResolved) {\n                argsToUse = mbd.resolvedConstructorArguments;\n                if (argsToUse == null) {\n                    argsToResolve = mbd.preparedConstructorArguments;\n                }\n            }\n        }\n        if (argsToResolve != null) {\n            argsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n        }\n    }\n    if (factoryMethodToUse == null || argsToUse == null) {\n        factoryClass = ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates = getCandidateMethods(factoryClass, mbd);\n        List<Method> candidateSet = new ArrayList<Method>();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) == isStatic && mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues = null;\n        boolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight = Integer.MAX_VALUE;\n        Set<Method> ambiguousFactoryMethods = null;\n        int minNrOfArgs;\n        if (explicitArgs != null) {\n            minNrOfArgs = explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n            resolvedValues = new ConstructorArgumentValues();\n            minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List<Exception> causes = null;\n        for (int i = 0; i < candidates.length; i++) {\n            Method candidate = candidates[i];\n            Class<?>[] paramTypes = candidate.getParameterTypes();\n            if (paramTypes.length >= minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (resolvedValues != null) {\n                    try {\n                        String[] paramNames = null;\n                        ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd != null) {\n                            paramNames = pnd.getParameterNames(candidate);\n                        }\n                        argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean '\" + beanName + \"': \" + ex);\n                        }\n                        if (i == candidates.length - 1 && argsHolderToUse == null) {\n                            if (causes != null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes == null) {\n                                causes = new LinkedList<Exception>();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length != explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder = new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight = (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight < minTypeDiffWeight) {\n                    factoryMethodToUse = candidate;\n                    argsHolderToUse = argsHolder;\n                    argsToUse = argsHolder.arguments;\n                    minTypeDiffWeight = typeDiffWeight;\n                    ambiguousFactoryMethods = null;\n                } else if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight && !mbd.isLenientConstructorResolution() && paramTypes.length == factoryMethodToUse.getParameterTypes().length && !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                    if (ambiguousFactoryMethods == null) {\n                        ambiguousFactoryMethods = new LinkedHashSet<Method>();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse == null) {\n            List<String> argTypes = new ArrayList<String>(minNrOfArgs);\n            if (explicitArgs != null) {\n                for (Object arg : explicitArgs) {\n                    argTypes.add(arg != null ? arg.getClass().getSimpleName() : \"null\");\n                }\n            } else {\n                Set<ValueHolder> valueHolders = new LinkedHashSet<ValueHolder>(resolvedValues.getArgumentCount());\n                valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                for (ValueHolder value : valueHolders) {\n                    String argType = (value.getType() != null ? ClassUtils.getShortName(value.getType()) : (value.getValue() != null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                    argTypes.add(argType);\n                }\n            }\n            String argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() != null ? \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") + \"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" + \"Check that a method with the specified name \" + (minNrOfArgs > 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method '\" + mbd.getFactoryMethodName() + \"': needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods != null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean '\" + beanName + \"' \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs == null && argsHolderToUse != null) {\n            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() != null) {\n            final Object fb = factoryBean;\n            final Method factoryMethod = factoryMethodToUse;\n            final Object[] args = argsToUse;\n            beanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n\n                @Override\n                public Object run() {\n                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                }\n            }, beanFactory.getAccessControlContext());\n        } else {\n            beanInstance = beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance == null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}"
    },
    {
      "commit": "6c41cc354c1e6575ff5f56147c3fcbe5b52c2e9b",
      "startLine": 2,
      "endLine": 25,
      "methodCode": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n    BeanWrapperImpl bw = new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class<?> factoryClass;\n    boolean isStatic;\n    String factoryBeanName = mbd.getFactoryBeanName();\n    if (factoryBeanName != null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean = this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean == null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean '\" + factoryBeanName + \"' (or a BeanPostProcessor involved) returned null\");\n        }\n        factoryClass = factoryBean.getClass();\n        isStatic = false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean = null;\n        factoryClass = mbd.getBeanClass();\n        isStatic = true;\n    }\n    Method factoryMethodToUse = null;\n    ArgumentsHolder argsHolderToUse = null;\n    Object[] argsToUse = null;\n    if (explicitArgs != null) {\n        argsToUse = explicitArgs;\n    } else {\n        Object[] argsToResolve = null;\n        synchronized (mbd.constructorArgumentLock) {\n            factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n            if (factoryMethodToUse != null && mbd.constructorArgumentsResolved) {\n                argsToUse = mbd.resolvedConstructorArguments;\n                if (argsToUse == null) {\n                    argsToResolve = mbd.preparedConstructorArguments;\n                }\n            }\n        }\n        if (argsToResolve != null) {\n            argsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n        }\n    }\n    if (factoryMethodToUse == null || argsToUse == null) {\n        factoryClass = ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates = getCandidateMethods(factoryClass, mbd);\n        List<Method> candidateSet = new ArrayList<Method>();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) == isStatic && mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues = null;\n        boolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight = Integer.MAX_VALUE;\n        Set<Method> ambiguousFactoryMethods = null;\n        int minNrOfArgs;\n        if (explicitArgs != null) {\n            minNrOfArgs = explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n            resolvedValues = new ConstructorArgumentValues();\n            minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List<Exception> causes = null;\n        for (int i = 0; i < candidates.length; i++) {\n            Method candidate = candidates[i];\n            Class<?>[] paramTypes = candidate.getParameterTypes();\n            if (paramTypes.length >= minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (resolvedValues != null) {\n                    try {\n                        String[] paramNames = null;\n                        ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd != null) {\n                            paramNames = pnd.getParameterNames(candidate);\n                        }\n                        argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean '\" + beanName + \"': \" + ex);\n                        }\n                        if (i == candidates.length - 1 && argsHolderToUse == null) {\n                            if (causes != null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes == null) {\n                                causes = new LinkedList<Exception>();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length != explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder = new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight = (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight < minTypeDiffWeight) {\n                    factoryMethodToUse = candidate;\n                    argsHolderToUse = argsHolder;\n                    argsToUse = argsHolder.arguments;\n                    minTypeDiffWeight = typeDiffWeight;\n                    ambiguousFactoryMethods = null;\n                } else if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight && !mbd.isLenientConstructorResolution() && paramTypes.length == factoryMethodToUse.getParameterTypes().length && !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                    if (ambiguousFactoryMethods == null) {\n                        ambiguousFactoryMethods = new LinkedHashSet<Method>();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse == null) {\n            List<String> argTypes = new ArrayList<String>(minNrOfArgs);\n            if (explicitArgs != null) {\n                for (Object arg : explicitArgs) {\n                    argTypes.add(arg != null ? arg.getClass().getSimpleName() : \"null\");\n                }\n            } else {\n                Set<ValueHolder> valueHolders = new LinkedHashSet<ValueHolder>(resolvedValues.getArgumentCount());\n                valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                for (ValueHolder value : valueHolders) {\n                    String argType = (value.getType() != null ? ClassUtils.getShortName(value.getType()) : (value.getValue() != null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                    argTypes.add(argType);\n                }\n            }\n            String argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() != null ? \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") + \"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" + \"Check that a method with the specified name \" + (minNrOfArgs > 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method '\" + mbd.getFactoryMethodName() + \"': needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods != null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean '\" + beanName + \"' \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs == null && argsHolderToUse != null) {\n            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() != null) {\n            final Object fb = factoryBean;\n            final Method factoryMethod = factoryMethodToUse;\n            final Object[] args = argsToUse;\n            beanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n\n                @Override\n                public Object run() {\n                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                }\n            }, beanFactory.getAccessControlContext());\n        } else {\n            beanInstance = beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance == null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}"
    },
    {
      "commit": "ad317774fb8e0b1f70e0135e5786c94c2521fb73",
      "startLine": 2,
      "endLine": 25,
      "methodCode": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n    BeanWrapperImpl bw = new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class<?> factoryClass;\n    boolean isStatic;\n    String factoryBeanName = mbd.getFactoryBeanName();\n    if (factoryBeanName != null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean = this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean == null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean '\" + factoryBeanName + \"' returned null\");\n        }\n        factoryClass = factoryBean.getClass();\n        isStatic = false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean = null;\n        factoryClass = mbd.getBeanClass();\n        isStatic = true;\n    }\n    Method factoryMethodToUse = null;\n    ArgumentsHolder argsHolderToUse = null;\n    Object[] argsToUse = null;\n    if (explicitArgs != null) {\n        argsToUse = explicitArgs;\n    } else {\n        Object[] argsToResolve = null;\n        synchronized (mbd.constructorArgumentLock) {\n            factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n            if (factoryMethodToUse != null && mbd.constructorArgumentsResolved) {\n                argsToUse = mbd.resolvedConstructorArguments;\n                if (argsToUse == null) {\n                    argsToResolve = mbd.preparedConstructorArguments;\n                }\n            }\n        }\n        if (argsToResolve != null) {\n            argsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n        }\n    }\n    if (factoryMethodToUse == null || argsToUse == null) {\n        factoryClass = ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates = getCandidateMethods(factoryClass, mbd);\n        List<Method> candidateSet = new ArrayList<Method>();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) == isStatic && mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues = null;\n        boolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight = Integer.MAX_VALUE;\n        Set<Method> ambiguousFactoryMethods = null;\n        int minNrOfArgs;\n        if (explicitArgs != null) {\n            minNrOfArgs = explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n            resolvedValues = new ConstructorArgumentValues();\n            minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List<Exception> causes = null;\n        for (int i = 0; i < candidates.length; i++) {\n            Method candidate = candidates[i];\n            Class<?>[] paramTypes = candidate.getParameterTypes();\n            if (paramTypes.length >= minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (resolvedValues != null) {\n                    try {\n                        String[] paramNames = null;\n                        ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd != null) {\n                            paramNames = pnd.getParameterNames(candidate);\n                        }\n                        argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean '\" + beanName + \"': \" + ex);\n                        }\n                        if (i == candidates.length - 1 && argsHolderToUse == null) {\n                            if (causes != null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes == null) {\n                                causes = new LinkedList<Exception>();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length != explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder = new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight = (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight < minTypeDiffWeight) {\n                    factoryMethodToUse = candidate;\n                    argsHolderToUse = argsHolder;\n                    argsToUse = argsHolder.arguments;\n                    minTypeDiffWeight = typeDiffWeight;\n                    ambiguousFactoryMethods = null;\n                } else if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight && !mbd.isLenientConstructorResolution() && paramTypes.length == factoryMethodToUse.getParameterTypes().length && !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                    if (ambiguousFactoryMethods == null) {\n                        ambiguousFactoryMethods = new LinkedHashSet<Method>();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse == null) {\n            List<String> argTypes = new ArrayList<String>(minNrOfArgs);\n            if (explicitArgs != null) {\n                for (Object arg : explicitArgs) {\n                    argTypes.add(arg != null ? arg.getClass().getSimpleName() : \"null\");\n                }\n            } else {\n                Set<ValueHolder> valueHolders = new LinkedHashSet<ValueHolder>(resolvedValues.getArgumentCount());\n                valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                for (ValueHolder value : valueHolders) {\n                    String argType = (value.getType() != null ? ClassUtils.getShortName(value.getType()) : (value.getValue() != null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                    argTypes.add(argType);\n                }\n            }\n            String argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() != null ? \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") + \"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" + \"Check that a method with the specified name \" + (minNrOfArgs > 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method '\" + mbd.getFactoryMethodName() + \"': needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods != null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean '\" + beanName + \"' \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs == null && argsHolderToUse != null) {\n            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() != null) {\n            final Object fb = factoryBean;\n            final Method factoryMethod = factoryMethodToUse;\n            final Object[] args = argsToUse;\n            beanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n\n                @Override\n                public Object run() {\n                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                }\n            }, beanFactory.getAccessControlContext());\n        } else {\n            beanInstance = beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance == null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}"
    },
    {
      "commit": "603cdea26e0880a46c697194bf5f1cbe60177f16",
      "startLine": 2,
      "endLine": 25,
      "methodCode": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n    BeanWrapperImpl bw = new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class<?> factoryClass;\n    boolean isStatic;\n    String factoryBeanName = mbd.getFactoryBeanName();\n    if (factoryBeanName != null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean = this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean == null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean '\" + factoryBeanName + \"' returned null\");\n        }\n        factoryClass = factoryBean.getClass();\n        isStatic = false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean = null;\n        factoryClass = mbd.getBeanClass();\n        isStatic = true;\n    }\n    Method factoryMethodToUse = null;\n    ArgumentsHolder argsHolderToUse = null;\n    Object[] argsToUse = null;\n    if (explicitArgs != null) {\n        argsToUse = explicitArgs;\n    } else {\n        Object[] argsToResolve = null;\n        synchronized (mbd.constructorArgumentLock) {\n            factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n            if (factoryMethodToUse != null && mbd.constructorArgumentsResolved) {\n                argsToUse = mbd.resolvedConstructorArguments;\n                if (argsToUse == null) {\n                    argsToResolve = mbd.preparedConstructorArguments;\n                }\n            }\n        }\n        if (argsToResolve != null) {\n            argsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n        }\n    }\n    if (factoryMethodToUse == null || argsToUse == null) {\n        factoryClass = ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates = getCandidateMethods(factoryClass, mbd);\n        List<Method> candidateSet = new ArrayList<Method>();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) == isStatic && mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues = null;\n        boolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight = Integer.MAX_VALUE;\n        Set<Method> ambiguousFactoryMethods = null;\n        int minNrOfArgs;\n        if (explicitArgs != null) {\n            minNrOfArgs = explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n            resolvedValues = new ConstructorArgumentValues();\n            minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List<Exception> causes = null;\n        for (int i = 0; i < candidates.length; i++) {\n            Method candidate = candidates[i];\n            Class<?>[] paramTypes = candidate.getParameterTypes();\n            if (paramTypes.length >= minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (resolvedValues != null) {\n                    try {\n                        String[] paramNames = null;\n                        ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd != null) {\n                            paramNames = pnd.getParameterNames(candidate);\n                        }\n                        argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean '\" + beanName + \"': \" + ex);\n                        }\n                        if (i == candidates.length - 1 && argsHolderToUse == null) {\n                            if (causes != null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes == null) {\n                                causes = new LinkedList<Exception>();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length != explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder = new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight = (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight < minTypeDiffWeight) {\n                    factoryMethodToUse = candidate;\n                    argsHolderToUse = argsHolder;\n                    argsToUse = argsHolder.arguments;\n                    minTypeDiffWeight = typeDiffWeight;\n                    ambiguousFactoryMethods = null;\n                } else if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight && !mbd.isLenientConstructorResolution() && paramTypes.length == factoryMethodToUse.getParameterTypes().length && !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                    if (ambiguousFactoryMethods == null) {\n                        ambiguousFactoryMethods = new LinkedHashSet<Method>();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse == null) {\n            boolean hasArgs = (resolvedValues.getArgumentCount() > 0);\n            String argDesc = \"\";\n            if (hasArgs) {\n                List<String> argTypes = new ArrayList<String>();\n                for (ValueHolder value : resolvedValues.getIndexedArgumentValues().values()) {\n                    String argType = (value.getType() != null ? ClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName());\n                    argTypes.add(argType);\n                }\n                argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n            }\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() != null ? \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") + \"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" + \"Check that a method with the specified name \" + (hasArgs ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method '\" + mbd.getFactoryMethodName() + \"': needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods != null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean '\" + beanName + \"' \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs == null && argsHolderToUse != null) {\n            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() != null) {\n            final Object fb = factoryBean;\n            final Method factoryMethod = factoryMethodToUse;\n            final Object[] args = argsToUse;\n            beanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n\n                @Override\n                public Object run() {\n                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                }\n            }, beanFactory.getAccessControlContext());\n        } else {\n            beanInstance = beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance == null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}"
    },
    {
      "commit": "b093b8495416cd3f05a32add1c671174341bd595",
      "startLine": 2,
      "endLine": 25,
      "methodCode": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n    BeanWrapperImpl bw = new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class<?> factoryClass;\n    boolean isStatic;\n    String factoryBeanName = mbd.getFactoryBeanName();\n    if (factoryBeanName != null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean = this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean == null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean '\" + factoryBeanName + \"' returned null\");\n        }\n        factoryClass = factoryBean.getClass();\n        isStatic = false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean = null;\n        factoryClass = mbd.getBeanClass();\n        isStatic = true;\n    }\n    Method factoryMethodToUse = null;\n    ArgumentsHolder argsHolderToUse = null;\n    Object[] argsToUse = null;\n    if (explicitArgs != null) {\n        argsToUse = explicitArgs;\n    } else {\n        Object[] argsToResolve = null;\n        synchronized (mbd.constructorArgumentLock) {\n            factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n            if (factoryMethodToUse != null && mbd.constructorArgumentsResolved) {\n                argsToUse = mbd.resolvedConstructorArguments;\n                if (argsToUse == null) {\n                    argsToResolve = mbd.preparedConstructorArguments;\n                }\n            }\n        }\n        if (argsToResolve != null) {\n            argsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n        }\n    }\n    if (factoryMethodToUse == null || argsToUse == null) {\n        factoryClass = ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates;\n        final Class<?> factoryClazz = factoryClass;\n        if (System.getSecurityManager() != null) {\n            rawCandidates = AccessController.doPrivileged(new PrivilegedAction<Method[]>() {\n\n                @Override\n                public Method[] run() {\n                    return (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n                }\n            });\n        } else {\n            rawCandidates = (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n        }\n        List<Method> candidateSet = new ArrayList<Method>();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) == isStatic && candidate.getName().equals(mbd.getFactoryMethodName()) && mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues = null;\n        boolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight = Integer.MAX_VALUE;\n        Set<Method> ambiguousFactoryMethods = null;\n        int minNrOfArgs;\n        if (explicitArgs != null) {\n            minNrOfArgs = explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n            resolvedValues = new ConstructorArgumentValues();\n            minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List<Exception> causes = null;\n        for (int i = 0; i < candidates.length; i++) {\n            Method candidate = candidates[i];\n            Class<?>[] paramTypes = candidate.getParameterTypes();\n            if (paramTypes.length >= minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (resolvedValues != null) {\n                    try {\n                        String[] paramNames = null;\n                        ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd != null) {\n                            paramNames = pnd.getParameterNames(candidate);\n                        }\n                        argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean '\" + beanName + \"': \" + ex);\n                        }\n                        if (i == candidates.length - 1 && argsHolderToUse == null) {\n                            if (causes != null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes == null) {\n                                causes = new LinkedList<Exception>();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length != explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder = new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight = (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight < minTypeDiffWeight) {\n                    factoryMethodToUse = candidate;\n                    argsHolderToUse = argsHolder;\n                    argsToUse = argsHolder.arguments;\n                    minTypeDiffWeight = typeDiffWeight;\n                    ambiguousFactoryMethods = null;\n                } else if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight && !mbd.isLenientConstructorResolution() && paramTypes.length == factoryMethodToUse.getParameterTypes().length && !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                    if (ambiguousFactoryMethods == null) {\n                        ambiguousFactoryMethods = new LinkedHashSet<Method>();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse == null) {\n            boolean hasArgs = (resolvedValues.getArgumentCount() > 0);\n            String argDesc = \"\";\n            if (hasArgs) {\n                List<String> argTypes = new ArrayList<String>();\n                for (ValueHolder value : resolvedValues.getIndexedArgumentValues().values()) {\n                    String argType = (value.getType() != null ? ClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName());\n                    argTypes.add(argType);\n                }\n                argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n            }\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() != null ? \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") + \"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" + \"Check that a method with the specified name \" + (hasArgs ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method '\" + mbd.getFactoryMethodName() + \"': needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods != null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean '\" + beanName + \"' \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs == null && argsHolderToUse != null) {\n            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() != null) {\n            final Object fb = factoryBean;\n            final Method factoryMethod = factoryMethodToUse;\n            final Object[] args = argsToUse;\n            beanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n\n                @Override\n                public Object run() {\n                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                }\n            }, beanFactory.getAccessControlContext());\n        } else {\n            beanInstance = beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance == null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}"
    },
    {
      "commit": "94685481162a93666fc2f39b66223833a6bcb418",
      "startLine": 2,
      "endLine": 25,
      "methodCode": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n    BeanWrapperImpl bw = new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class factoryClass;\n    boolean isStatic;\n    String factoryBeanName = mbd.getFactoryBeanName();\n    if (factoryBeanName != null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean = this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean == null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean '\" + factoryBeanName + \"' returned null\");\n        }\n        factoryClass = factoryBean.getClass();\n        isStatic = false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean = null;\n        factoryClass = mbd.getBeanClass();\n        isStatic = true;\n    }\n    Method factoryMethodToUse = null;\n    ArgumentsHolder argsHolderToUse = null;\n    Object[] argsToUse = null;\n    if (explicitArgs != null) {\n        argsToUse = explicitArgs;\n    } else {\n        Object[] argsToResolve = null;\n        synchronized (mbd.constructorArgumentLock) {\n            factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n            if (factoryMethodToUse != null && mbd.constructorArgumentsResolved) {\n                argsToUse = mbd.resolvedConstructorArguments;\n                if (argsToUse == null) {\n                    argsToResolve = mbd.preparedConstructorArguments;\n                }\n            }\n        }\n        if (argsToResolve != null) {\n            argsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n        }\n    }\n    if (factoryMethodToUse == null || argsToUse == null) {\n        factoryClass = ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates;\n        final Class factoryClazz = factoryClass;\n        if (System.getSecurityManager() != null) {\n            rawCandidates = AccessController.doPrivileged(new PrivilegedAction<Method[]>() {\n\n                @Override\n                public Method[] run() {\n                    return (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n                }\n            });\n        } else {\n            rawCandidates = (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n        }\n        List<Method> candidateSet = new ArrayList<Method>();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) == isStatic && candidate.getName().equals(mbd.getFactoryMethodName()) && mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues = null;\n        boolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight = Integer.MAX_VALUE;\n        Set<Method> ambiguousFactoryMethods = null;\n        int minNrOfArgs;\n        if (explicitArgs != null) {\n            minNrOfArgs = explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n            resolvedValues = new ConstructorArgumentValues();\n            minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List<Exception> causes = null;\n        for (int i = 0; i < candidates.length; i++) {\n            Method candidate = candidates[i];\n            Class[] paramTypes = candidate.getParameterTypes();\n            if (paramTypes.length >= minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (resolvedValues != null) {\n                    try {\n                        String[] paramNames = null;\n                        ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd != null) {\n                            paramNames = pnd.getParameterNames(candidate);\n                        }\n                        argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean '\" + beanName + \"': \" + ex);\n                        }\n                        if (i == candidates.length - 1 && argsHolderToUse == null) {\n                            if (causes != null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes == null) {\n                                causes = new LinkedList<Exception>();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length != explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder = new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight = (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight < minTypeDiffWeight) {\n                    factoryMethodToUse = candidate;\n                    argsHolderToUse = argsHolder;\n                    argsToUse = argsHolder.arguments;\n                    minTypeDiffWeight = typeDiffWeight;\n                    ambiguousFactoryMethods = null;\n                } else if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight) {\n                    if (ambiguousFactoryMethods == null) {\n                        ambiguousFactoryMethods = new LinkedHashSet<Method>();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse == null) {\n            boolean hasArgs = (resolvedValues.getArgumentCount() > 0);\n            String argDesc = \"\";\n            if (hasArgs) {\n                List<String> argTypes = new ArrayList<String>();\n                for (ValueHolder value : resolvedValues.getIndexedArgumentValues().values()) {\n                    String argType = (value.getType() != null ? ClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName());\n                    argTypes.add(argType);\n                }\n                argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n            }\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() != null ? \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") + \"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" + \"Check that a method with the specified name \" + (hasArgs ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method '\" + mbd.getFactoryMethodName() + \"': needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods != null && !mbd.isLenientConstructorResolution()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean '\" + beanName + \"' \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs == null && argsHolderToUse != null) {\n            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() != null) {\n            final Object fb = factoryBean;\n            final Method factoryMethod = factoryMethodToUse;\n            final Object[] args = argsToUse;\n            beanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n\n                @Override\n                public Object run() {\n                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                }\n            }, beanFactory.getAccessControlContext());\n        } else {\n            beanInstance = beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance == null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}"
    },
    {
      "commit": "9540d2c81b93b9062faf79d4df998525f3dedb7c",
      "startLine": 2,
      "endLine": 25,
      "methodCode": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n    BeanWrapperImpl bw = new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class factoryClass;\n    boolean isStatic;\n    String factoryBeanName = mbd.getFactoryBeanName();\n    if (factoryBeanName != null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean = this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean == null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean '\" + factoryBeanName + \"' returned null\");\n        }\n        factoryClass = factoryBean.getClass();\n        isStatic = false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean = null;\n        factoryClass = mbd.getBeanClass();\n        isStatic = true;\n    }\n    Method factoryMethodToUse = null;\n    ArgumentsHolder argsHolderToUse = null;\n    Object[] argsToUse = null;\n    if (explicitArgs != null) {\n        argsToUse = explicitArgs;\n    } else {\n        Object[] argsToResolve = null;\n        synchronized (mbd.constructorArgumentLock) {\n            factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n            if (factoryMethodToUse != null && mbd.constructorArgumentsResolved) {\n                argsToUse = mbd.resolvedConstructorArguments;\n                if (argsToUse == null) {\n                    argsToResolve = mbd.preparedConstructorArguments;\n                }\n            }\n        }\n        if (argsToResolve != null) {\n            argsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n        }\n    }\n    if (factoryMethodToUse == null || argsToUse == null) {\n        factoryClass = ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates;\n        final Class factoryClazz = factoryClass;\n        if (System.getSecurityManager() != null) {\n            rawCandidates = AccessController.doPrivileged(new PrivilegedAction<Method[]>() {\n\n                public Method[] run() {\n                    return (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n                }\n            });\n        } else {\n            rawCandidates = (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n        }\n        List<Method> candidateSet = new ArrayList<Method>();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) == isStatic && candidate.getName().equals(mbd.getFactoryMethodName()) && mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues = null;\n        boolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight = Integer.MAX_VALUE;\n        Set<Method> ambiguousFactoryMethods = null;\n        int minNrOfArgs;\n        if (explicitArgs != null) {\n            minNrOfArgs = explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n            resolvedValues = new ConstructorArgumentValues();\n            minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List<Exception> causes = null;\n        for (int i = 0; i < candidates.length; i++) {\n            Method candidate = candidates[i];\n            Class[] paramTypes = candidate.getParameterTypes();\n            if (paramTypes.length >= minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (resolvedValues != null) {\n                    try {\n                        String[] paramNames = null;\n                        ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd != null) {\n                            paramNames = pnd.getParameterNames(candidate);\n                        }\n                        argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean '\" + beanName + \"': \" + ex);\n                        }\n                        if (i == candidates.length - 1 && argsHolderToUse == null) {\n                            if (causes != null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes == null) {\n                                causes = new LinkedList<Exception>();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length != explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder = new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight = (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight < minTypeDiffWeight) {\n                    factoryMethodToUse = candidate;\n                    argsHolderToUse = argsHolder;\n                    argsToUse = argsHolder.arguments;\n                    minTypeDiffWeight = typeDiffWeight;\n                    ambiguousFactoryMethods = null;\n                } else if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight) {\n                    if (ambiguousFactoryMethods == null) {\n                        ambiguousFactoryMethods = new LinkedHashSet<Method>();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse == null) {\n            boolean hasArgs = (resolvedValues.getArgumentCount() > 0);\n            String argDesc = \"\";\n            if (hasArgs) {\n                List<String> argTypes = new ArrayList<String>();\n                for (ValueHolder value : resolvedValues.getIndexedArgumentValues().values()) {\n                    String argType = (value.getType() != null ? ClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName());\n                    argTypes.add(argType);\n                }\n                argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n            }\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() != null ? \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") + \"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" + \"Check that a method with the specified name \" + (hasArgs ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method '\" + mbd.getFactoryMethodName() + \"': needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods != null && !mbd.isLenientConstructorResolution()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean '\" + beanName + \"' \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs == null && argsHolderToUse != null) {\n            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() != null) {\n            final Object fb = factoryBean;\n            final Method factoryMethod = factoryMethodToUse;\n            final Object[] args = argsToUse;\n            beanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n\n                public Object run() {\n                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                }\n            }, beanFactory.getAccessControlContext());\n        } else {\n            beanInstance = beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance == null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}"
    },
    {
      "commit": "02a4473c62d8240837bec297f0a1f3cb67ef8a7b",
      "startLine": 2,
      "endLine": 25,
      "methodCode": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n    BeanWrapperImpl bw = new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class factoryClass;\n    boolean isStatic;\n    String factoryBeanName = mbd.getFactoryBeanName();\n    if (factoryBeanName != null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean = this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean == null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean '\" + factoryBeanName + \"' returned null\");\n        }\n        factoryClass = factoryBean.getClass();\n        isStatic = false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean = null;\n        factoryClass = mbd.getBeanClass();\n        isStatic = true;\n    }\n    Method factoryMethodToUse = null;\n    ArgumentsHolder argsHolderToUse = null;\n    Object[] argsToUse = null;\n    if (explicitArgs != null) {\n        argsToUse = explicitArgs;\n    } else {\n        Object[] argsToResolve = null;\n        synchronized (mbd.constructorArgumentLock) {\n            factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n            if (factoryMethodToUse != null && mbd.constructorArgumentsResolved) {\n                argsToUse = mbd.resolvedConstructorArguments;\n                if (argsToUse == null) {\n                    argsToResolve = mbd.preparedConstructorArguments;\n                }\n            }\n        }\n        if (argsToResolve != null) {\n            argsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n        }\n    }\n    if (factoryMethodToUse == null || argsToUse == null) {\n        factoryClass = ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates;\n        final Class factoryClazz = factoryClass;\n        if (System.getSecurityManager() != null) {\n            rawCandidates = AccessController.doPrivileged(new PrivilegedAction<Method[]>() {\n\n                public Method[] run() {\n                    return (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n                }\n            });\n        } else {\n            rawCandidates = (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n        }\n        List<Method> candidateSet = new ArrayList<Method>();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) == isStatic && candidate.getName().equals(mbd.getFactoryMethodName()) && mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues = null;\n        boolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight = Integer.MAX_VALUE;\n        Set<Method> ambiguousFactoryMethods = null;\n        int minNrOfArgs;\n        if (explicitArgs != null) {\n            minNrOfArgs = explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n            resolvedValues = new ConstructorArgumentValues();\n            minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List<Exception> causes = null;\n        for (int i = 0; i < candidates.length; i++) {\n            Method candidate = candidates[i];\n            Class[] paramTypes = candidate.getParameterTypes();\n            if (paramTypes.length >= minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (resolvedValues != null) {\n                    try {\n                        String[] paramNames = null;\n                        ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd != null) {\n                            paramNames = pnd.getParameterNames(candidate);\n                        }\n                        argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean '\" + beanName + \"': \" + ex);\n                        }\n                        if (i == candidates.length - 1 && argsHolderToUse == null) {\n                            if (causes != null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes == null) {\n                                causes = new LinkedList<Exception>();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length != explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder = new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight = (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight < minTypeDiffWeight) {\n                    factoryMethodToUse = candidate;\n                    argsHolderToUse = argsHolder;\n                    argsToUse = argsHolder.arguments;\n                    minTypeDiffWeight = typeDiffWeight;\n                    ambiguousFactoryMethods = null;\n                } else if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight) {\n                    if (ambiguousFactoryMethods == null) {\n                        ambiguousFactoryMethods = new LinkedHashSet<Method>();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse == null) {\n            boolean hasArgs = (resolvedValues.getArgumentCount() > 0);\n            String argDesc = \"\";\n            if (hasArgs) {\n                List<String> argTypes = new ArrayList<String>();\n                for (ValueHolder value : resolvedValues.getIndexedArgumentValues().values()) {\n                    String argType = (value.getType() != null ? ClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName());\n                    argTypes.add(argType);\n                }\n                argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n            }\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() != null ? \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") + \"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" + \"Check that a method with the specified name \" + (hasArgs ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method '\" + mbd.getFactoryMethodName() + \"': needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods != null && !mbd.isLenientConstructorResolution()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean '\" + beanName + \"' \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs == null && argsHolderToUse != null) {\n            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() != null) {\n            final Object fb = factoryBean;\n            final Method factoryMethod = factoryMethodToUse;\n            final Object[] args = argsToUse;\n            beanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n\n                public Object run() {\n                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                }\n            }, beanFactory.getAccessControlContext());\n        } else {\n            beanInstance = beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance == null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}"
    },
    {
      "commit": "061063257ab8e16786d04eaddb5b5aba61dcd7f1",
      "startLine": 2,
      "endLine": 25,
      "methodCode": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n    BeanWrapperImpl bw = new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class factoryClass;\n    boolean isStatic;\n    String factoryBeanName = mbd.getFactoryBeanName();\n    if (factoryBeanName != null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean = this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean == null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean '\" + factoryBeanName + \"' returned null\");\n        }\n        factoryClass = factoryBean.getClass();\n        isStatic = false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean = null;\n        factoryClass = mbd.getBeanClass();\n        isStatic = true;\n    }\n    Method factoryMethodToUse = null;\n    ArgumentsHolder argsHolderToUse = null;\n    Object[] argsToUse = null;\n    if (explicitArgs != null) {\n        argsToUse = explicitArgs;\n    } else {\n        Object[] argsToResolve = null;\n        synchronized (mbd.constructorArgumentLock) {\n            factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n            if (factoryMethodToUse != null && mbd.constructorArgumentsResolved) {\n                argsToUse = mbd.resolvedConstructorArguments;\n                if (argsToUse == null) {\n                    argsToResolve = mbd.preparedConstructorArguments;\n                }\n            }\n        }\n        if (argsToResolve != null) {\n            argsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n        }\n    }\n    if (factoryMethodToUse == null || argsToUse == null) {\n        factoryClass = ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates;\n        final Class factoryClazz = factoryClass;\n        if (System.getSecurityManager() != null) {\n            rawCandidates = AccessController.doPrivileged(new PrivilegedAction<Method[]>() {\n\n                public Method[] run() {\n                    return (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n                }\n            });\n        } else {\n            rawCandidates = (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n        }\n        List<Method> candidateSet = new ArrayList<Method>();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) == isStatic && candidate.getName().equals(mbd.getFactoryMethodName()) && mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues = null;\n        boolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight = Integer.MAX_VALUE;\n        Set<Method> ambiguousFactoryMethods = null;\n        int minNrOfArgs;\n        if (explicitArgs != null) {\n            minNrOfArgs = explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n            resolvedValues = new ConstructorArgumentValues();\n            minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List<Exception> causes = null;\n        for (int i = 0; i < candidates.length; i++) {\n            Method candidate = candidates[i];\n            Class[] paramTypes = candidate.getParameterTypes();\n            if (paramTypes.length >= minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (resolvedValues != null) {\n                    try {\n                        String[] paramNames = null;\n                        ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd != null) {\n                            paramNames = pnd.getParameterNames(candidate);\n                        }\n                        argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean '\" + beanName + \"': \" + ex);\n                        }\n                        if (i == candidates.length - 1 && argsHolderToUse == null) {\n                            if (causes != null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes == null) {\n                                causes = new LinkedList<Exception>();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length != explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder = new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight = (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight < minTypeDiffWeight) {\n                    factoryMethodToUse = candidate;\n                    argsHolderToUse = argsHolder;\n                    argsToUse = argsHolder.arguments;\n                    minTypeDiffWeight = typeDiffWeight;\n                    ambiguousFactoryMethods = null;\n                } else if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight) {\n                    if (ambiguousFactoryMethods == null) {\n                        ambiguousFactoryMethods = new LinkedHashSet<Method>();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse == null) {\n            boolean hasArgs = (resolvedValues.getArgumentCount() > 0);\n            String argDesc = \"\";\n            if (hasArgs) {\n                List<String> argTypes = new ArrayList<String>();\n                for (ValueHolder value : resolvedValues.getIndexedArgumentValues().values()) {\n                    String argType = (value.getType() != null ? ClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName());\n                    argTypes.add(argType);\n                }\n                argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n            }\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() != null ? \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") + \"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" + \"Check that a method with the specified name \" + (hasArgs ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method '\" + mbd.getFactoryMethodName() + \"': needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods != null && !mbd.isLenientConstructorResolution()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean '\" + beanName + \"' \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs == null && argsHolderToUse != null) {\n            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() != null) {\n            final Object fb = factoryBean;\n            final Method factoryMethod = factoryMethodToUse;\n            final Object[] args = argsToUse;\n            beanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n\n                public Object run() {\n                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                }\n            }, beanFactory.getAccessControlContext());\n        } else {\n            beanInstance = beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance == null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}"
    },
    {
      "commit": "a9da12325995ab03cef56e8f51870081e36a3c9e",
      "startLine": 2,
      "endLine": 25,
      "methodCode": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n    BeanWrapperImpl bw = new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class factoryClass;\n    boolean isStatic;\n    String factoryBeanName = mbd.getFactoryBeanName();\n    if (factoryBeanName != null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean = this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean == null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean '\" + factoryBeanName + \"' returned null\");\n        }\n        factoryClass = factoryBean.getClass();\n        isStatic = false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean = null;\n        factoryClass = mbd.getBeanClass();\n        isStatic = true;\n    }\n    Method factoryMethodToUse = null;\n    ArgumentsHolder argsHolderToUse = null;\n    Object[] argsToUse = null;\n    if (explicitArgs != null) {\n        argsToUse = explicitArgs;\n    } else {\n        Object[] argsToResolve = null;\n        synchronized (mbd.constructorArgumentLock) {\n            factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n            if (factoryMethodToUse != null && mbd.constructorArgumentsResolved) {\n                argsToUse = mbd.resolvedConstructorArguments;\n                if (argsToUse == null) {\n                    argsToResolve = mbd.preparedConstructorArguments;\n                }\n            }\n        }\n        if (argsToResolve != null) {\n            argsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n        }\n    }\n    if (factoryMethodToUse == null || argsToUse == null) {\n        factoryClass = ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates;\n        final Class factoryClazz = factoryClass;\n        if (System.getSecurityManager() != null) {\n            rawCandidates = AccessController.doPrivileged(new PrivilegedAction<Method[]>() {\n\n                public Method[] run() {\n                    return (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n                }\n            });\n        } else {\n            rawCandidates = (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n        }\n        List<Method> candidateSet = new ArrayList<Method>();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) == isStatic && candidate.getName().equals(mbd.getFactoryMethodName()) && mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues = null;\n        boolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight = Integer.MAX_VALUE;\n        Set<Method> ambiguousFactoryMethods = null;\n        int minNrOfArgs;\n        if (explicitArgs != null) {\n            minNrOfArgs = explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n            resolvedValues = new ConstructorArgumentValues();\n            minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List<Exception> causes = null;\n        for (int i = 0; i < candidates.length; i++) {\n            Method candidate = candidates[i];\n            Class[] paramTypes = candidate.getParameterTypes();\n            if (paramTypes.length >= minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (resolvedValues != null) {\n                    try {\n                        String[] paramNames = null;\n                        ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd != null) {\n                            paramNames = pnd.getParameterNames(candidate);\n                        }\n                        argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean '\" + beanName + \"': \" + ex);\n                        }\n                        if (i == candidates.length - 1 && factoryMethodToUse == null) {\n                            if (causes != null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes == null) {\n                                causes = new LinkedList<Exception>();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length != explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder = new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight = (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight < minTypeDiffWeight) {\n                    factoryMethodToUse = candidate;\n                    argsHolderToUse = argsHolder;\n                    argsToUse = argsHolder.arguments;\n                    minTypeDiffWeight = typeDiffWeight;\n                    ambiguousFactoryMethods = null;\n                } else if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight) {\n                    if (ambiguousFactoryMethods == null) {\n                        ambiguousFactoryMethods = new LinkedHashSet<Method>();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse == null) {\n            boolean hasArgs = (resolvedValues.getArgumentCount() > 0);\n            String argDesc = \"\";\n            if (hasArgs) {\n                List<String> argTypes = new ArrayList<String>();\n                for (ValueHolder value : resolvedValues.getIndexedArgumentValues().values()) {\n                    String argType = (value.getType() != null ? ClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName());\n                    argTypes.add(argType);\n                }\n                argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n            }\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() != null ? \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") + \"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" + \"Check that a method with the specified name \" + (hasArgs ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method '\" + mbd.getFactoryMethodName() + \"': needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods != null && !mbd.isLenientConstructorResolution()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean '\" + beanName + \"' \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs == null) {\n            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() != null) {\n            final Object fb = factoryBean;\n            final Method factoryMethod = factoryMethodToUse;\n            final Object[] args = argsToUse;\n            beanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n\n                public Object run() {\n                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                }\n            }, beanFactory.getAccessControlContext());\n        } else {\n            beanInstance = beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance == null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}"
    },
    {
      "commit": "9857ba077b16312e78ca6dcf2a219326955daae5",
      "startLine": 2,
      "endLine": 25,
      "methodCode": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n    BeanWrapperImpl bw = new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class factoryClass;\n    boolean isStatic;\n    String factoryBeanName = mbd.getFactoryBeanName();\n    if (factoryBeanName != null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean = this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean == null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean '\" + factoryBeanName + \"' returned null\");\n        }\n        factoryClass = factoryBean.getClass();\n        isStatic = false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean = null;\n        factoryClass = mbd.getBeanClass();\n        isStatic = true;\n    }\n    Method factoryMethodToUse = null;\n    ArgumentsHolder argsHolderToUse = null;\n    Object[] argsToUse = null;\n    if (explicitArgs != null) {\n        argsToUse = explicitArgs;\n    } else {\n        Object[] argsToResolve = null;\n        synchronized (mbd.constructorArgumentLock) {\n            factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n            if (factoryMethodToUse != null && mbd.constructorArgumentsResolved) {\n                argsToUse = mbd.resolvedConstructorArguments;\n                if (argsToUse == null) {\n                    argsToResolve = mbd.preparedConstructorArguments;\n                }\n            }\n        }\n        if (argsToResolve != null) {\n            argsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n        }\n    }\n    if (factoryMethodToUse == null || argsToUse == null) {\n        factoryClass = ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates;\n        final Class factoryClazz = factoryClass;\n        if (System.getSecurityManager() != null) {\n            rawCandidates = AccessController.doPrivileged(new PrivilegedAction<Method[]>() {\n\n                public Method[] run() {\n                    return (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n                }\n            });\n        } else {\n            rawCandidates = (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n        }\n        List<Method> candidateSet = new ArrayList<Method>();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) == isStatic && candidate.getName().equals(mbd.getFactoryMethodName()) && mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues = null;\n        boolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight = Integer.MAX_VALUE;\n        Set<Method> ambiguousFactoryMethods = null;\n        int minNrOfArgs;\n        if (explicitArgs != null) {\n            minNrOfArgs = explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n            resolvedValues = new ConstructorArgumentValues();\n            minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List<Exception> causes = null;\n        for (int i = 0; i < candidates.length; i++) {\n            Method candidate = candidates[i];\n            Class[] paramTypes = candidate.getParameterTypes();\n            if (paramTypes.length >= minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (resolvedValues != null) {\n                    try {\n                        String[] paramNames = null;\n                        ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd != null) {\n                            paramNames = pnd.getParameterNames(candidate);\n                        }\n                        argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean '\" + beanName + \"': \" + ex);\n                        }\n                        if (i == candidates.length - 1 && factoryMethodToUse == null) {\n                            if (causes != null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes == null) {\n                                causes = new LinkedList<Exception>();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length != explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder = new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight = (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight < minTypeDiffWeight) {\n                    factoryMethodToUse = candidate;\n                    argsHolderToUse = argsHolder;\n                    argsToUse = argsHolder.arguments;\n                    minTypeDiffWeight = typeDiffWeight;\n                    ambiguousFactoryMethods = null;\n                } else if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight) {\n                    if (ambiguousFactoryMethods == null) {\n                        ambiguousFactoryMethods = new LinkedHashSet<Method>();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse == null) {\n            boolean hasArgs = resolvedValues.getArgumentCount() > 0;\n            String argDesc = \"\";\n            if (hasArgs) {\n                List<String> argTypes = new ArrayList<String>();\n                for (ValueHolder value : resolvedValues.getIndexedArgumentValues().values()) {\n                    String argType = value.getType() != null ? ClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName();\n                    argTypes.add(argType);\n                }\n                argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n            }\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() != null ? \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") + \"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" + \"Check that a method with the specified name \" + (hasArgs ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method '\" + mbd.getFactoryMethodName() + \"': needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods != null && !mbd.isLenientConstructorResolution()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean '\" + beanName + \"' \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs == null) {\n            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() != null) {\n            final Object fb = factoryBean;\n            final Method factoryMethod = factoryMethodToUse;\n            final Object[] args = argsToUse;\n            beanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n\n                public Object run() {\n                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                }\n            }, beanFactory.getAccessControlContext());\n        } else {\n            beanInstance = beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance == null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}"
    },
    {
      "commit": "12ce250c6ce911774a7983905fd6e006b5a1eac1",
      "startLine": 2,
      "endLine": 25,
      "methodCode": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n    BeanWrapperImpl bw = new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class factoryClass;\n    boolean isStatic;\n    String factoryBeanName = mbd.getFactoryBeanName();\n    if (factoryBeanName != null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean = this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean == null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean '\" + factoryBeanName + \"' returned null\");\n        }\n        factoryClass = factoryBean.getClass();\n        isStatic = false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean = null;\n        factoryClass = mbd.getBeanClass();\n        isStatic = true;\n    }\n    Method factoryMethodToUse = null;\n    ArgumentsHolder argsHolderToUse = null;\n    Object[] argsToUse = null;\n    if (explicitArgs != null) {\n        argsToUse = explicitArgs;\n    } else {\n        factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n        if (factoryMethodToUse != null) {\n            argsToUse = mbd.resolvedConstructorArguments;\n            if (argsToUse == null && mbd.preparedConstructorArguments != null) {\n                argsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n            }\n        }\n    }\n    if (factoryMethodToUse == null || argsToUse == null) {\n        factoryClass = ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates;\n        final Class factoryClazz = factoryClass;\n        if (System.getSecurityManager() != null) {\n            rawCandidates = AccessController.doPrivileged(new PrivilegedAction<Method[]>() {\n\n                public Method[] run() {\n                    return (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n                }\n            });\n        } else {\n            rawCandidates = (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n        }\n        List<Method> candidateSet = new ArrayList<Method>();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) == isStatic && candidate.getName().equals(mbd.getFactoryMethodName()) && mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues = null;\n        boolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight = Integer.MAX_VALUE;\n        Set<Method> ambiguousFactoryMethods = null;\n        int minNrOfArgs;\n        if (explicitArgs != null) {\n            minNrOfArgs = explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n            resolvedValues = new ConstructorArgumentValues();\n            minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List<Exception> causes = null;\n        for (int i = 0; i < candidates.length; i++) {\n            Method candidate = candidates[i];\n            Class[] paramTypes = candidate.getParameterTypes();\n            if (paramTypes.length >= minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (resolvedValues != null) {\n                    try {\n                        String[] paramNames = null;\n                        ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd != null) {\n                            paramNames = pnd.getParameterNames(candidate);\n                        }\n                        argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean '\" + beanName + \"': \" + ex);\n                        }\n                        if (i == candidates.length - 1 && factoryMethodToUse == null) {\n                            if (causes != null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes == null) {\n                                causes = new LinkedList<Exception>();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length != explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder = new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight = (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight < minTypeDiffWeight) {\n                    factoryMethodToUse = candidate;\n                    argsHolderToUse = argsHolder;\n                    argsToUse = argsHolder.arguments;\n                    minTypeDiffWeight = typeDiffWeight;\n                    ambiguousFactoryMethods = null;\n                } else if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight) {\n                    if (ambiguousFactoryMethods == null) {\n                        ambiguousFactoryMethods = new LinkedHashSet<Method>();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse == null) {\n            boolean hasArgs = resolvedValues.getArgumentCount() > 0;\n            String argDesc = \"\";\n            if (hasArgs) {\n                List<String> argTypes = new ArrayList<String>();\n                for (ValueHolder value : resolvedValues.getIndexedArgumentValues().values()) {\n                    String argType = value.getType() != null ? ClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName();\n                    argTypes.add(argType);\n                }\n                argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n            }\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() != null ? \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") + \"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" + \"Check that a method with the specified name \" + (hasArgs ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method '\" + mbd.getFactoryMethodName() + \"': needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods != null && !mbd.isLenientConstructorResolution()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean '\" + beanName + \"' \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs == null) {\n            mbd.resolvedConstructorOrFactoryMethod = factoryMethodToUse;\n            argsHolderToUse.storeCache(mbd);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() != null) {\n            final Object fb = factoryBean;\n            final Method factoryMethod = factoryMethodToUse;\n            final Object[] args = argsToUse;\n            beanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n\n                public Object run() {\n                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                }\n            }, beanFactory.getAccessControlContext());\n        } else {\n            beanInstance = beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance == null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}"
    },
    {
      "commit": "351e72b6e258bd030fb21be253f6348319f81d0e",
      "startLine": 2,
      "endLine": 25,
      "methodCode": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n    BeanWrapperImpl bw = new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class factoryClass;\n    boolean isStatic;\n    String factoryBeanName = mbd.getFactoryBeanName();\n    if (factoryBeanName != null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean = this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean == null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean '\" + factoryBeanName + \"' returned null\");\n        }\n        factoryClass = factoryBean.getClass();\n        isStatic = false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean = null;\n        factoryClass = mbd.getBeanClass();\n        isStatic = true;\n    }\n    Method factoryMethodToUse = null;\n    Object[] argsToUse = null;\n    if (explicitArgs != null) {\n        argsToUse = explicitArgs;\n    } else {\n        factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n        if (factoryMethodToUse != null) {\n            argsToUse = mbd.resolvedConstructorArguments;\n            if (argsToUse == null && mbd.preparedConstructorArguments != null) {\n                argsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n            }\n        }\n    }\n    if (factoryMethodToUse == null || argsToUse == null) {\n        factoryClass = ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates;\n        final Class factoryClazz = factoryClass;\n        if (System.getSecurityManager() != null) {\n            rawCandidates = AccessController.doPrivileged(new PrivilegedAction<Method[]>() {\n\n                public Method[] run() {\n                    return (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n                }\n            });\n        } else {\n            rawCandidates = (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n        }\n        List<Method> candidateSet = new ArrayList<Method>();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) == isStatic && candidate.getName().equals(mbd.getFactoryMethodName()) && mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues = null;\n        boolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight = Integer.MAX_VALUE;\n        Set<Method> ambiguousFactoryMethods = null;\n        int minNrOfArgs;\n        if (explicitArgs != null) {\n            minNrOfArgs = explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n            resolvedValues = new ConstructorArgumentValues();\n            minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List<Exception> causes = null;\n        for (int i = 0; i < candidates.length; i++) {\n            Method candidate = candidates[i];\n            Class[] paramTypes = candidate.getParameterTypes();\n            if (paramTypes.length >= minNrOfArgs) {\n                ArgumentsHolder args;\n                if (resolvedValues != null) {\n                    try {\n                        String[] paramNames = null;\n                        ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd != null) {\n                            paramNames = pnd.getParameterNames(candidate);\n                        }\n                        args = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean '\" + beanName + \"': \" + ex);\n                        }\n                        if (i == candidates.length - 1 && factoryMethodToUse == null) {\n                            if (causes != null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes == null) {\n                                causes = new LinkedList<Exception>();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length != explicitArgs.length) {\n                        continue;\n                    }\n                    args = new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight = (mbd.isLenientConstructorResolution() ? args.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight < minTypeDiffWeight) {\n                    factoryMethodToUse = candidate;\n                    argsToUse = args.arguments;\n                    minTypeDiffWeight = typeDiffWeight;\n                    ambiguousFactoryMethods = null;\n                } else if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight) {\n                    if (ambiguousFactoryMethods == null) {\n                        ambiguousFactoryMethods = new LinkedHashSet<Method>();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse == null) {\n            boolean hasArgs = resolvedValues.getArgumentCount() > 0;\n            String argDesc = \"\";\n            if (hasArgs) {\n                List<String> argTypes = new ArrayList<String>();\n                for (ValueHolder value : resolvedValues.getIndexedArgumentValues().values()) {\n                    String argType = value.getType() != null ? ClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName();\n                    argTypes.add(argType);\n                }\n                argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n            }\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() != null ? \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") + \"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" + \"Check that a method with the specified name \" + (hasArgs ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method '\" + mbd.getFactoryMethodName() + \"': needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods != null && !mbd.isLenientConstructorResolution()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean '\" + beanName + \"' \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs == null) {\n            mbd.resolvedConstructorOrFactoryMethod = factoryMethodToUse;\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() != null) {\n            final Object fb = factoryBean;\n            final Method factoryMethod = factoryMethodToUse;\n            final Object[] args = argsToUse;\n            beanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n\n                public Object run() {\n                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                }\n            }, beanFactory.getAccessControlContext());\n        } else {\n            beanInstance = beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance == null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}"
    },
    {
      "commit": "18bd4a83375a1815dbf83aca384cf7f5c27e93f5",
      "startLine": 2,
      "endLine": 25,
      "methodCode": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n    BeanWrapperImpl bw = new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class factoryClass;\n    boolean isStatic;\n    String factoryBeanName = mbd.getFactoryBeanName();\n    if (factoryBeanName != null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean = this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean == null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean '\" + factoryBeanName + \"' returned null\");\n        }\n        factoryClass = factoryBean.getClass();\n        isStatic = false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean = null;\n        factoryClass = mbd.getBeanClass();\n        isStatic = true;\n    }\n    Method factoryMethodToUse = null;\n    Object[] argsToUse = null;\n    if (explicitArgs != null) {\n        argsToUse = explicitArgs;\n    } else {\n        factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n        if (factoryMethodToUse != null) {\n            argsToUse = mbd.resolvedConstructorArguments;\n            if (argsToUse == null && mbd.preparedConstructorArguments != null) {\n                argsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n            }\n        }\n    }\n    if (factoryMethodToUse == null || argsToUse == null) {\n        factoryClass = ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates;\n        final Class factoryClazz = factoryClass;\n        if (System.getSecurityManager() != null) {\n            rawCandidates = AccessController.doPrivileged(new PrivilegedAction<Method[]>() {\n\n                public Method[] run() {\n                    return (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n                }\n            });\n        } else {\n            rawCandidates = (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n        }\n        List<Method> candidateSet = new ArrayList<Method>();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) == isStatic && candidate.getName().equals(mbd.getFactoryMethodName()) && mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues = null;\n        boolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight = Integer.MAX_VALUE;\n        Set<Method> ambiguousFactoryMethods = null;\n        int minNrOfArgs;\n        if (explicitArgs != null) {\n            minNrOfArgs = explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n            resolvedValues = new ConstructorArgumentValues();\n            minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List<Exception> causes = null;\n        for (int i = 0; i < candidates.length; i++) {\n            Method candidate = candidates[i];\n            Class[] paramTypes = candidate.getParameterTypes();\n            if (paramTypes.length >= minNrOfArgs) {\n                ArgumentsHolder args;\n                if (resolvedValues != null) {\n                    try {\n                        String[] paramNames = null;\n                        ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd != null) {\n                            paramNames = pnd.getParameterNames(candidate);\n                        }\n                        args = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean '\" + beanName + \"': \" + ex);\n                        }\n                        if (i == candidates.length - 1 && factoryMethodToUse == null) {\n                            if (causes != null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes == null) {\n                                causes = new LinkedList<Exception>();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length != explicitArgs.length) {\n                        continue;\n                    }\n                    args = new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight = (mbd.isLenientConstructorResolution() ? args.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight < minTypeDiffWeight) {\n                    factoryMethodToUse = candidate;\n                    argsToUse = args.arguments;\n                    minTypeDiffWeight = typeDiffWeight;\n                    ambiguousFactoryMethods = null;\n                } else if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight) {\n                    if (ambiguousFactoryMethods == null) {\n                        ambiguousFactoryMethods = new LinkedHashSet<Method>();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse == null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() != null ? \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") + \"factory method '\" + mbd.getFactoryMethodName() + \"'. \" + \"Check that a method of the specified name exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method '\" + mbd.getFactoryMethodName() + \"': needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods != null && !mbd.isLenientConstructorResolution()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean '\" + beanName + \"' \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs == null) {\n            mbd.resolvedConstructorOrFactoryMethod = factoryMethodToUse;\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() != null) {\n            final Object fb = factoryBean;\n            final Method factoryMethod = factoryMethodToUse;\n            final Object[] args = argsToUse;\n            beanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n\n                public Object run() {\n                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                }\n            }, beanFactory.getAccessControlContext());\n        } else {\n            beanInstance = beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance == null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}"
    },
    {
      "commit": "45448463b87629bdd85cb375d3faa391bfaf147f",
      "startLine": 2,
      "endLine": 25,
      "methodCode": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n    BeanWrapperImpl bw = new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class factoryClass;\n    boolean isStatic;\n    String factoryBeanName = mbd.getFactoryBeanName();\n    if (factoryBeanName != null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean = this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean == null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean '\" + factoryBeanName + \"' returned null\");\n        }\n        factoryClass = factoryBean.getClass();\n        isStatic = false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean = null;\n        factoryClass = mbd.getBeanClass();\n        isStatic = true;\n    }\n    Method factoryMethodToUse = null;\n    Object[] argsToUse = null;\n    if (explicitArgs != null) {\n        argsToUse = explicitArgs;\n    } else {\n        factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n        if (factoryMethodToUse != null) {\n            argsToUse = mbd.resolvedConstructorArguments;\n            if (argsToUse == null && mbd.preparedConstructorArguments != null) {\n                argsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n            }\n        }\n    }\n    if (factoryMethodToUse == null || argsToUse == null) {\n        factoryClass = ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates;\n        final Class factoryClazz = factoryClass;\n        if (System.getSecurityManager() != null) {\n            rawCandidates = AccessController.doPrivileged(new PrivilegedAction<Method[]>() {\n\n                public Method[] run() {\n                    return (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n                }\n            });\n        } else {\n            rawCandidates = (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n        }\n        List<Method> candidateSet = new ArrayList<Method>();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) == isStatic && candidate.getName().equals(mbd.getFactoryMethodName()) && mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues = null;\n        boolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight = Integer.MAX_VALUE;\n        Set<Method> ambiguousFactoryMethods = null;\n        int minNrOfArgs;\n        if (explicitArgs != null) {\n            minNrOfArgs = explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n            resolvedValues = new ConstructorArgumentValues();\n            minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List<Exception> causes = null;\n        for (int i = 0; i < candidates.length; i++) {\n            Method candidate = candidates[i];\n            Class[] paramTypes = candidate.getParameterTypes();\n            if (paramTypes.length >= minNrOfArgs) {\n                ArgumentsHolder args;\n                if (resolvedValues != null) {\n                    try {\n                        String[] paramNames = null;\n                        ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd != null) {\n                            paramNames = pnd.getParameterNames(candidate);\n                        }\n                        args = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean '\" + beanName + \"': \" + ex);\n                        }\n                        if (i == candidates.length - 1 && factoryMethodToUse == null) {\n                            if (causes != null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes == null) {\n                                causes = new LinkedList<Exception>();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length != explicitArgs.length) {\n                        continue;\n                    }\n                    args = new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight = (mbd.isLenientConstructorResolution() ? args.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight < minTypeDiffWeight) {\n                    factoryMethodToUse = candidate;\n                    argsToUse = args.arguments;\n                    minTypeDiffWeight = typeDiffWeight;\n                    ambiguousFactoryMethods = null;\n                } else if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight) {\n                    if (ambiguousFactoryMethods == null) {\n                        ambiguousFactoryMethods = new LinkedHashSet<Method>();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse == null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() != null ? \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") + \"factory method '\" + mbd.getFactoryMethodName() + \"'\");\n        } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method '\" + mbd.getFactoryMethodName() + \"': needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods != null && !mbd.isLenientConstructorResolution()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean '\" + beanName + \"' \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs == null) {\n            mbd.resolvedConstructorOrFactoryMethod = factoryMethodToUse;\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() != null) {\n            final Object fb = factoryBean;\n            final Method factoryMethod = factoryMethodToUse;\n            final Object[] args = argsToUse;\n            beanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n\n                public Object run() {\n                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                }\n            }, beanFactory.getAccessControlContext());\n        } else {\n            beanInstance = beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance == null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}"
    },
    {
      "commit": "904c2358cdfd9cd8337da0950b8c8d6fc7099839",
      "startLine": 2,
      "endLine": 25,
      "methodCode": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n    BeanWrapperImpl bw = new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class factoryClass;\n    boolean isStatic;\n    String factoryBeanName = mbd.getFactoryBeanName();\n    if (factoryBeanName != null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean = this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean == null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean '\" + factoryBeanName + \"' returned null\");\n        }\n        factoryClass = factoryBean.getClass();\n        isStatic = false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean = null;\n        factoryClass = mbd.getBeanClass();\n        isStatic = true;\n    }\n    Method factoryMethodToUse = null;\n    Object[] argsToUse = null;\n    if (explicitArgs != null) {\n        argsToUse = explicitArgs;\n    } else {\n        factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n        if (factoryMethodToUse != null) {\n            argsToUse = mbd.resolvedConstructorArguments;\n            if (argsToUse == null && mbd.preparedConstructorArguments != null) {\n                argsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n            }\n        }\n    }\n    if (factoryMethodToUse == null || argsToUse == null) {\n        factoryClass = ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates = null;\n        final Class factoryClazz = factoryClass;\n        if (System.getSecurityManager() != null) {\n            rawCandidates = AccessController.doPrivileged(new PrivilegedAction<Method[]>() {\n\n                public Method[] run() {\n                    return (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n                }\n            });\n        } else {\n            rawCandidates = (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n        }\n        List<Method> candidateSet = new ArrayList<Method>();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) == isStatic && candidate.getName().equals(mbd.getFactoryMethodName()) && mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues = null;\n        boolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight = Integer.MAX_VALUE;\n        Set<Method> ambiguousFactoryMethods = null;\n        int minNrOfArgs;\n        if (explicitArgs != null) {\n            minNrOfArgs = explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n            resolvedValues = new ConstructorArgumentValues();\n            minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List<Exception> causes = null;\n        for (int i = 0; i < candidates.length; i++) {\n            Method candidate = candidates[i];\n            Class[] paramTypes = candidate.getParameterTypes();\n            if (paramTypes.length >= minNrOfArgs) {\n                ArgumentsHolder args;\n                if (resolvedValues != null) {\n                    try {\n                        String[] paramNames = null;\n                        ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd != null) {\n                            paramNames = pnd.getParameterNames(candidate);\n                        }\n                        args = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean '\" + beanName + \"': \" + ex);\n                        }\n                        if (i == candidates.length - 1 && factoryMethodToUse == null) {\n                            if (causes != null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes == null) {\n                                causes = new LinkedList<Exception>();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length != explicitArgs.length) {\n                        continue;\n                    }\n                    args = new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight = (mbd.isLenientConstructorResolution() ? args.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight < minTypeDiffWeight) {\n                    factoryMethodToUse = candidate;\n                    argsToUse = args.arguments;\n                    minTypeDiffWeight = typeDiffWeight;\n                    ambiguousFactoryMethods = null;\n                } else if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight) {\n                    if (ambiguousFactoryMethods == null) {\n                        ambiguousFactoryMethods = new LinkedHashSet<Method>();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse == null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() != null ? \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") + \"factory method '\" + mbd.getFactoryMethodName() + \"'\");\n        } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method '\" + mbd.getFactoryMethodName() + \"': needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods != null && !mbd.isLenientConstructorResolution()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean '\" + beanName + \"' \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs == null) {\n            mbd.resolvedConstructorOrFactoryMethod = factoryMethodToUse;\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() != null) {\n            final Object fb = factoryBean;\n            final Method factoryMethod = factoryMethodToUse;\n            final Object[] args = argsToUse;\n            beanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n\n                public Object run() {\n                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                }\n            }, beanFactory.getAccessControlContext());\n        } else {\n            beanInstance = beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance == null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}"
    },
    {
      "commit": "af8af8c633ba016eca671bc9468eba006e8834b1",
      "startLine": 2,
      "endLine": 25,
      "methodCode": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n    BeanWrapperImpl bw = new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class factoryClass;\n    boolean isStatic;\n    String factoryBeanName = mbd.getFactoryBeanName();\n    if (factoryBeanName != null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean = this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean == null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean '\" + factoryBeanName + \"' returned null\");\n        }\n        factoryClass = factoryBean.getClass();\n        isStatic = false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean = null;\n        factoryClass = mbd.getBeanClass();\n        isStatic = true;\n    }\n    Method factoryMethodToUse = null;\n    Object[] argsToUse = null;\n    if (explicitArgs != null) {\n        argsToUse = explicitArgs;\n    } else {\n        factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n        if (factoryMethodToUse != null) {\n            argsToUse = mbd.resolvedConstructorArguments;\n            if (argsToUse == null && mbd.preparedConstructorArguments != null) {\n                argsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n            }\n        }\n    }\n    if (factoryMethodToUse == null || argsToUse == null) {\n        factoryClass = ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates = null;\n        final Class factoryClazz = factoryClass;\n        if (System.getSecurityManager() != null) {\n            rawCandidates = AccessController.doPrivileged(new PrivilegedAction<Method[]>() {\n\n                public Method[] run() {\n                    return (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n                }\n            });\n        } else {\n            rawCandidates = (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n        }\n        List<Method> candidateSet = new ArrayList<Method>();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) == isStatic && candidate.getName().equals(mbd.getFactoryMethodName()) && mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues = null;\n        boolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight = Integer.MAX_VALUE;\n        Set<Method> ambiguousFactoryMethods = null;\n        int minNrOfArgs;\n        if (explicitArgs != null) {\n            minNrOfArgs = explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n            resolvedValues = new ConstructorArgumentValues();\n            minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List<Exception> causes = null;\n        for (int i = 0; i < candidates.length; i++) {\n            Method candidate = candidates[i];\n            Class[] paramTypes = candidate.getParameterTypes();\n            if (paramTypes.length >= minNrOfArgs) {\n                ArgumentsHolder args;\n                if (resolvedValues != null) {\n                    try {\n                        String[] paramNames = null;\n                        ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd != null) {\n                            paramNames = pnd.getParameterNames(candidate);\n                        }\n                        args = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean '\" + beanName + \"': \" + ex);\n                        }\n                        if (i == candidates.length - 1 && factoryMethodToUse == null) {\n                            if (causes != null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes == null) {\n                                causes = new LinkedList<Exception>();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length != explicitArgs.length) {\n                        continue;\n                    }\n                    args = new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight = (mbd.isLenientConstructorResolution() ? args.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight < minTypeDiffWeight) {\n                    factoryMethodToUse = candidate;\n                    argsToUse = args.arguments;\n                    minTypeDiffWeight = typeDiffWeight;\n                    ambiguousFactoryMethods = null;\n                } else if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight) {\n                    if (ambiguousFactoryMethods == null) {\n                        ambiguousFactoryMethods = new LinkedHashSet<Method>();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse == null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() != null ? \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") + \"factory method '\" + mbd.getFactoryMethodName() + \"'\");\n        } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method '\" + mbd.getFactoryMethodName() + \"': needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods != null && !mbd.isLenientConstructorResolution()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean '\" + beanName + \"' \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs == null) {\n            mbd.resolvedConstructorOrFactoryMethod = factoryMethodToUse;\n        }\n    }\n    try {\n        Object beanInstance = null;\n        if (System.getSecurityManager() != null) {\n            final Object fb = factoryBean;\n            final Method factoryMethod = factoryMethodToUse;\n            final Object[] args = argsToUse;\n            beanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n\n                public Object run() {\n                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                }\n            }, beanFactory.getAccessControlContext());\n        } else {\n            beanInstance = beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance == null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}"
    },
    {
      "commit": "d5d3104b7b13ce249bf9c877f7160cd2137ec209",
      "startLine": 2,
      "endLine": 25,
      "methodCode": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n    BeanWrapperImpl bw = new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class factoryClass;\n    boolean isStatic;\n    String factoryBeanName = mbd.getFactoryBeanName();\n    if (factoryBeanName != null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean = this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean == null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean '\" + factoryBeanName + \"' returned null\");\n        }\n        factoryClass = factoryBean.getClass();\n        isStatic = false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean = null;\n        factoryClass = mbd.getBeanClass();\n        isStatic = true;\n    }\n    Method factoryMethodToUse = null;\n    Object[] argsToUse = null;\n    if (explicitArgs != null) {\n        argsToUse = explicitArgs;\n    } else {\n        factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n        if (factoryMethodToUse != null) {\n            argsToUse = mbd.resolvedConstructorArguments;\n            if (argsToUse == null && mbd.preparedConstructorArguments != null) {\n                argsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n            }\n        }\n    }\n    if (factoryMethodToUse == null || argsToUse == null) {\n        factoryClass = ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates = (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClass) : factoryClass.getMethods());\n        List<Method> candidateSet = new ArrayList<Method>();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) == isStatic && candidate.getName().equals(mbd.getFactoryMethodName()) && mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues = null;\n        boolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight = Integer.MAX_VALUE;\n        Set<Method> ambiguousFactoryMethods = null;\n        int minNrOfArgs;\n        if (explicitArgs != null) {\n            minNrOfArgs = explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n            resolvedValues = new ConstructorArgumentValues();\n            minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List<Exception> causes = null;\n        for (int i = 0; i < candidates.length; i++) {\n            Method candidate = candidates[i];\n            Class[] paramTypes = candidate.getParameterTypes();\n            if (paramTypes.length >= minNrOfArgs) {\n                ArgumentsHolder args;\n                if (resolvedValues != null) {\n                    try {\n                        String[] paramNames = null;\n                        ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd != null) {\n                            paramNames = pnd.getParameterNames(candidate);\n                        }\n                        args = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean '\" + beanName + \"': \" + ex);\n                        }\n                        if (i == candidates.length - 1 && factoryMethodToUse == null) {\n                            if (causes != null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes == null) {\n                                causes = new LinkedList<Exception>();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length != explicitArgs.length) {\n                        continue;\n                    }\n                    args = new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight = (mbd.isLenientConstructorResolution() ? args.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight < minTypeDiffWeight) {\n                    factoryMethodToUse = candidate;\n                    argsToUse = args.arguments;\n                    minTypeDiffWeight = typeDiffWeight;\n                    ambiguousFactoryMethods = null;\n                } else if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight) {\n                    if (ambiguousFactoryMethods == null) {\n                        ambiguousFactoryMethods = new LinkedHashSet<Method>();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse == null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() != null ? \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") + \"factory method '\" + mbd.getFactoryMethodName() + \"'\");\n        } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method '\" + mbd.getFactoryMethodName() + \"': needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods != null && !mbd.isLenientConstructorResolution()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean '\" + beanName + \"' \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs == null) {\n            mbd.resolvedConstructorOrFactoryMethod = factoryMethodToUse;\n        }\n    }\n    try {\n        Object beanInstance = null;\n        if (System.getSecurityManager() != null) {\n            final Object fb = factoryBean;\n            final Method factoryMethod = factoryMethodToUse;\n            final Object[] args = argsToUse;\n            beanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n\n                public Object run() {\n                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                }\n            }, beanFactory.getAccessControlContext());\n        } else {\n            beanInstance = beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance == null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}"
    },
    {
      "commit": "17dfc8b0fcf3e2a02ab0db48af1d309981bbe6c2",
      "startLine": 2,
      "endLine": 25,
      "methodCode": "public BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n    BeanWrapperImpl bw = new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class factoryClass;\n    boolean isStatic;\n    String factoryBeanName = mbd.getFactoryBeanName();\n    if (factoryBeanName != null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean = this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean == null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean '\" + factoryBeanName + \"' returned null\");\n        }\n        factoryClass = factoryBean.getClass();\n        isStatic = false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean = null;\n        factoryClass = mbd.getBeanClass();\n        isStatic = true;\n    }\n    Method factoryMethodToUse = null;\n    Object[] argsToUse = null;\n    if (explicitArgs != null) {\n        argsToUse = explicitArgs;\n    } else {\n        factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n        if (factoryMethodToUse != null) {\n            argsToUse = mbd.resolvedConstructorArguments;\n            if (argsToUse == null && mbd.preparedConstructorArguments != null) {\n                argsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n            }\n        }\n    }\n    if (factoryMethodToUse == null || argsToUse == null) {\n        factoryClass = ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates = (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClass) : factoryClass.getMethods());\n        List<Method> candidateSet = new ArrayList<Method>();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) == isStatic && candidate.getName().equals(mbd.getFactoryMethodName()) && mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues = null;\n        boolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight = Integer.MAX_VALUE;\n        Set<Method> ambiguousFactoryMethods = null;\n        int minNrOfArgs;\n        if (explicitArgs != null) {\n            minNrOfArgs = explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n            resolvedValues = new ConstructorArgumentValues();\n            minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List<Exception> causes = null;\n        for (int i = 0; i < candidates.length; i++) {\n            Method candidate = candidates[i];\n            Class[] paramTypes = candidate.getParameterTypes();\n            if (paramTypes.length >= minNrOfArgs) {\n                ArgumentsHolder args;\n                if (resolvedValues != null) {\n                    try {\n                        String[] paramNames = null;\n                        ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd != null) {\n                            paramNames = pnd.getParameterNames(candidate);\n                        }\n                        args = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean '\" + beanName + \"': \" + ex);\n                        }\n                        if (i == candidates.length - 1 && factoryMethodToUse == null) {\n                            if (causes != null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes == null) {\n                                causes = new LinkedList<Exception>();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length != explicitArgs.length) {\n                        continue;\n                    }\n                    args = new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight = (mbd.isLenientConstructorResolution() ? args.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight < minTypeDiffWeight) {\n                    factoryMethodToUse = candidate;\n                    argsToUse = args.arguments;\n                    minTypeDiffWeight = typeDiffWeight;\n                    ambiguousFactoryMethods = null;\n                } else if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight) {\n                    if (ambiguousFactoryMethods == null) {\n                        ambiguousFactoryMethods = new LinkedHashSet<Method>();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse == null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() != null ? \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") + \"factory method '\" + mbd.getFactoryMethodName() + \"'\");\n        } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method '\" + mbd.getFactoryMethodName() + \"': needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods != null && !mbd.isLenientConstructorResolution()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean '\" + beanName + \"' \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs == null) {\n            mbd.resolvedConstructorOrFactoryMethod = factoryMethodToUse;\n        }\n    }\n    try {\n        Object beanInstance = this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        if (beanInstance == null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}"
    },
    {
      "commit": "3cb073abce659c130abc9adc0662b75380fcc7f3",
      "startLine": 2,
      "endLine": 25,
      "methodCode": "public BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n    BeanWrapperImpl bw = new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class factoryClass;\n    boolean isStatic;\n    String factoryBeanName = mbd.getFactoryBeanName();\n    if (factoryBeanName != null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean = this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean == null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean '\" + factoryBeanName + \"' returned null\");\n        }\n        factoryClass = factoryBean.getClass();\n        isStatic = false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean = null;\n        factoryClass = mbd.getBeanClass();\n        isStatic = true;\n    }\n    Method factoryMethodToUse = null;\n    Object[] argsToUse = null;\n    if (explicitArgs != null) {\n        argsToUse = explicitArgs;\n    } else {\n        factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n        if (factoryMethodToUse != null) {\n            argsToUse = mbd.resolvedConstructorArguments;\n            if (argsToUse == null && mbd.preparedConstructorArguments != null) {\n                argsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n            }\n        }\n    }\n    if (factoryMethodToUse == null || argsToUse == null) {\n        factoryClass = ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates = (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClass) : factoryClass.getMethods());\n        List<Method> candidateSet = new ArrayList<Method>();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) == isStatic && candidate.getName().equals(mbd.getFactoryMethodName()) && mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        boolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight = Integer.MAX_VALUE;\n        ConstructorArgumentValues resolvedValues = null;\n        int minNrOfArgs;\n        if (explicitArgs != null) {\n            minNrOfArgs = explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n            resolvedValues = new ConstructorArgumentValues();\n            minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List<Exception> causes = null;\n        for (int i = 0; i < candidates.length; i++) {\n            Method candidate = candidates[i];\n            Class[] paramTypes = candidate.getParameterTypes();\n            if (paramTypes.length >= minNrOfArgs) {\n                ArgumentsHolder args;\n                if (resolvedValues != null) {\n                    try {\n                        String[] paramNames = null;\n                        ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd != null) {\n                            paramNames = pnd.getParameterNames(candidate);\n                        }\n                        args = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean '\" + beanName + \"': \" + ex);\n                        }\n                        if (i == candidates.length - 1 && factoryMethodToUse == null) {\n                            if (causes != null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes == null) {\n                                causes = new LinkedList<Exception>();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length != explicitArgs.length) {\n                        continue;\n                    }\n                    args = new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight = (mbd.isLenientConstructorResolution() ? args.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight < minTypeDiffWeight) {\n                    factoryMethodToUse = candidate;\n                    argsToUse = args.arguments;\n                    minTypeDiffWeight = typeDiffWeight;\n                } else if (typeDiffWeight < Integer.MAX_VALUE && typeDiffWeight == minTypeDiffWeight && !mbd.isLenientConstructorResolution()) {\n                    throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean '\" + beanName + \"' \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities)\");\n                }\n            }\n        }\n        if (factoryMethodToUse == null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() != null ? \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") + \"factory method '\" + mbd.getFactoryMethodName() + \"'\");\n        }\n        if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method '\" + mbd.getFactoryMethodName() + \"': needs to have a non-void return type!\");\n        }\n        if (explicitArgs == null) {\n            mbd.resolvedConstructorOrFactoryMethod = factoryMethodToUse;\n        }\n    }\n    try {\n        Object beanInstance = this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        if (beanInstance == null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}"
    },
    {
      "commit": "1eabe2b4416ee7619bd863fcdc1e6f6ada766400",
      "startLine": 2,
      "endLine": 25,
      "methodCode": "public BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n    BeanWrapperImpl bw = new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class factoryClass;\n    boolean isStatic;\n    String factoryBeanName = mbd.getFactoryBeanName();\n    if (factoryBeanName != null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean = this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean == null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean '\" + factoryBeanName + \"' returned null\");\n        }\n        factoryClass = factoryBean.getClass();\n        isStatic = false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean = null;\n        factoryClass = mbd.getBeanClass();\n        isStatic = true;\n    }\n    Method factoryMethodToUse = null;\n    Object[] argsToUse = null;\n    if (explicitArgs != null) {\n        argsToUse = explicitArgs;\n    } else {\n        factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n        if (factoryMethodToUse != null) {\n            argsToUse = mbd.resolvedConstructorArguments;\n            if (argsToUse == null && mbd.preparedConstructorArguments != null) {\n                argsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n            }\n        }\n    }\n    if (factoryMethodToUse == null || argsToUse == null) {\n        factoryClass = ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates = (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClass) : factoryClass.getMethods());\n        List<Method> candidateSet = new ArrayList<Method>();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) == isStatic && candidate.getName().equals(mbd.getFactoryMethodName()) && mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        boolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight = Integer.MAX_VALUE;\n        ConstructorArgumentValues resolvedValues = null;\n        int minNrOfArgs;\n        if (explicitArgs != null) {\n            minNrOfArgs = explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n            resolvedValues = new ConstructorArgumentValues();\n            minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List<Exception> causes = null;\n        for (int i = 0; i < candidates.length; i++) {\n            Method candidate = candidates[i];\n            Class[] paramTypes = candidate.getParameterTypes();\n            if (paramTypes.length >= minNrOfArgs) {\n                ArgumentsHolder args;\n                if (resolvedValues != null) {\n                    try {\n                        String[] paramNames = null;\n                        ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd != null) {\n                            paramNames = pnd.getParameterNames(candidate);\n                        }\n                        args = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean '\" + beanName + \"': \" + ex);\n                        }\n                        if (i == candidates.length - 1 && factoryMethodToUse == null) {\n                            if (causes != null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes == null) {\n                                causes = new LinkedList<Exception>();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length != explicitArgs.length) {\n                        continue;\n                    }\n                    args = new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight = args.getTypeDifferenceWeight(paramTypes);\n                if (typeDiffWeight < minTypeDiffWeight) {\n                    factoryMethodToUse = candidate;\n                    argsToUse = args.arguments;\n                    minTypeDiffWeight = typeDiffWeight;\n                } else if (typeDiffWeight < Integer.MAX_VALUE && typeDiffWeight == minTypeDiffWeight && !mbd.isLenientConstructorResolution()) {\n                    throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean '\" + beanName + \"' \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities)\");\n                }\n            }\n        }\n        if (factoryMethodToUse == null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() != null ? \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") + \"factory method '\" + mbd.getFactoryMethodName() + \"'\");\n        }\n        if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method '\" + mbd.getFactoryMethodName() + \"': needs to have a non-void return type!\");\n        }\n        if (explicitArgs == null) {\n            mbd.resolvedConstructorOrFactoryMethod = factoryMethodToUse;\n        }\n    }\n    try {\n        Object beanInstance = this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        if (beanInstance == null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}"
    },
    {
      "commit": "7eabd2da563a4e95928e89f72f7a207804eef0ab",
      "startLine": 2,
      "endLine": 25,
      "methodCode": "public BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n    BeanWrapperImpl bw = new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class factoryClass;\n    boolean isStatic;\n    String factoryBeanName = mbd.getFactoryBeanName();\n    if (factoryBeanName != null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean = this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean == null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean '\" + factoryBeanName + \"' returned null\");\n        }\n        factoryClass = factoryBean.getClass();\n        isStatic = false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean = null;\n        factoryClass = mbd.getBeanClass();\n        isStatic = true;\n    }\n    Method factoryMethodToUse = null;\n    Object[] argsToUse = null;\n    if (explicitArgs != null) {\n        argsToUse = explicitArgs;\n    } else {\n        factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n        if (factoryMethodToUse != null) {\n            argsToUse = mbd.resolvedConstructorArguments;\n            if (argsToUse == null && mbd.preparedConstructorArguments != null) {\n                argsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n            }\n        }\n    }\n    if (factoryMethodToUse == null || argsToUse == null) {\n        factoryClass = ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates = (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClass) : factoryClass.getMethods());\n        List<Method> candidateSet = new ArrayList<Method>();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) == isStatic && candidate.getName().equals(mbd.getFactoryMethodName()) && mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        boolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight = Integer.MAX_VALUE;\n        ConstructorArgumentValues resolvedValues = null;\n        int minNrOfArgs;\n        if (explicitArgs != null) {\n            minNrOfArgs = explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n            resolvedValues = new ConstructorArgumentValues();\n            minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List<Exception> causes = null;\n        for (int i = 0; i < candidates.length; i++) {\n            Method candidate = candidates[i];\n            Class[] paramTypes = candidate.getParameterTypes();\n            if (paramTypes.length >= minNrOfArgs) {\n                ArgumentsHolder args;\n                if (resolvedValues != null) {\n                    try {\n                        String[] paramNames = null;\n                        ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd != null) {\n                            paramNames = pnd.getParameterNames(candidate);\n                        }\n                        args = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean '\" + beanName + \"': \" + ex);\n                        }\n                        if (i == candidates.length - 1 && factoryMethodToUse == null) {\n                            if (causes != null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes == null) {\n                                causes = new LinkedList<Exception>();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length != explicitArgs.length) {\n                        continue;\n                    }\n                    args = new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight = args.getTypeDifferenceWeight(paramTypes);\n                if (typeDiffWeight < minTypeDiffWeight) {\n                    factoryMethodToUse = candidate;\n                    argsToUse = args.arguments;\n                    minTypeDiffWeight = typeDiffWeight;\n                }\n            }\n        }\n        if (factoryMethodToUse == null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() != null ? \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") + \"factory method '\" + mbd.getFactoryMethodName() + \"'\");\n        }\n        if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method '\" + mbd.getFactoryMethodName() + \"': needs to have a non-void return type!\");\n        }\n        if (explicitArgs == null) {\n            mbd.resolvedConstructorOrFactoryMethod = factoryMethodToUse;\n        }\n    }\n    try {\n        Object beanInstance = this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        if (beanInstance == null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}"
    },
    {
      "commit": "53333c3ed06e465a55592a0f351ffab40110e5b3",
      "startLine": 2,
      "endLine": 25,
      "methodCode": "public BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n    BeanWrapperImpl bw = new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class factoryClass;\n    boolean isStatic;\n    String factoryBeanName = mbd.getFactoryBeanName();\n    if (factoryBeanName != null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean = this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean == null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean '\" + factoryBeanName + \"' returned null\");\n        }\n        factoryClass = factoryBean.getClass();\n        isStatic = false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean = null;\n        factoryClass = mbd.getBeanClass();\n        isStatic = true;\n    }\n    Method factoryMethodToUse = null;\n    Object[] argsToUse = null;\n    if (explicitArgs != null) {\n        argsToUse = explicitArgs;\n    } else {\n        factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n        if (factoryMethodToUse != null) {\n            argsToUse = mbd.resolvedConstructorArguments;\n            if (argsToUse == null && mbd.preparedConstructorArguments != null) {\n                argsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n            }\n        }\n    }\n    if (factoryMethodToUse == null || argsToUse == null) {\n        factoryClass = ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates = ReflectionUtils.getAllDeclaredMethods(factoryClass);\n        List<Method> candidateSet = new ArrayList<Method>();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) == isStatic && candidate.getName().equals(mbd.getFactoryMethodName()) && mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        boolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight = Integer.MAX_VALUE;\n        ConstructorArgumentValues resolvedValues = null;\n        int minNrOfArgs;\n        if (explicitArgs != null) {\n            minNrOfArgs = explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n            resolvedValues = new ConstructorArgumentValues();\n            minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List<Exception> causes = null;\n        for (int i = 0; i < candidates.length; i++) {\n            Method candidate = candidates[i];\n            Class[] paramTypes = candidate.getParameterTypes();\n            if (paramTypes.length >= minNrOfArgs) {\n                ArgumentsHolder args;\n                if (resolvedValues != null) {\n                    try {\n                        String[] paramNames = null;\n                        ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd != null) {\n                            paramNames = pnd.getParameterNames(candidate);\n                        }\n                        args = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean '\" + beanName + \"': \" + ex);\n                        }\n                        if (i == candidates.length - 1 && factoryMethodToUse == null) {\n                            if (causes != null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes == null) {\n                                causes = new LinkedList<Exception>();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length != explicitArgs.length) {\n                        continue;\n                    }\n                    args = new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight = args.getTypeDifferenceWeight(paramTypes);\n                if (typeDiffWeight < minTypeDiffWeight) {\n                    factoryMethodToUse = candidate;\n                    argsToUse = args.arguments;\n                    minTypeDiffWeight = typeDiffWeight;\n                }\n            }\n        }\n        if (factoryMethodToUse == null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() != null ? \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") + \"factory method '\" + mbd.getFactoryMethodName() + \"'\");\n        }\n        if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method '\" + mbd.getFactoryMethodName() + \"': needs to have a non-void return type!\");\n        }\n        if (explicitArgs == null) {\n            mbd.resolvedConstructorOrFactoryMethod = factoryMethodToUse;\n        }\n    }\n    try {\n        Object beanInstance = this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        if (beanInstance == null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}"
    },
    {
      "commit": "ea9d8925a27e80d31d924826cf54f70b2bbcc638",
      "startLine": 2,
      "endLine": 25,
      "methodCode": "public BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n    BeanWrapperImpl bw = new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class factoryClass;\n    boolean isStatic;\n    String factoryBeanName = mbd.getFactoryBeanName();\n    if (factoryBeanName != null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean = this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean == null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean '\" + factoryBeanName + \"' returned null\");\n        }\n        factoryClass = factoryBean.getClass();\n        isStatic = false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean = null;\n        factoryClass = mbd.getBeanClass();\n        isStatic = true;\n    }\n    Method factoryMethodToUse = null;\n    Object[] argsToUse = null;\n    if (explicitArgs != null) {\n        argsToUse = explicitArgs;\n    } else {\n        factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n        if (factoryMethodToUse != null) {\n            argsToUse = mbd.resolvedConstructorArguments;\n            if (argsToUse == null && mbd.preparedConstructorArguments != null) {\n                argsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n            }\n        }\n    }\n    if (factoryMethodToUse == null || argsToUse == null) {\n        factoryClass = ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates = ReflectionUtils.getAllDeclaredMethods(factoryClass);\n        List<Method> candidateSet = new ArrayList<Method>();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) == isStatic && candidate.getName().equals(mbd.getFactoryMethodName()) && mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        boolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight = Integer.MAX_VALUE;\n        ConstructorArgumentValues resolvedValues = null;\n        int minNrOfArgs;\n        if (explicitArgs != null) {\n            minNrOfArgs = explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n            resolvedValues = new ConstructorArgumentValues();\n            minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List<Exception> causes = null;\n        for (int i = 0; i < candidates.length; i++) {\n            Method candidate = candidates[i];\n            Class[] paramTypes = candidate.getParameterTypes();\n            if (paramTypes.length >= minNrOfArgs) {\n                ArgumentsHolder args;\n                if (resolvedValues != null) {\n                    try {\n                        args = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean '\" + beanName + \"': \" + ex);\n                        }\n                        if (i == candidates.length - 1 && factoryMethodToUse == null) {\n                            if (causes != null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes == null) {\n                                causes = new LinkedList<Exception>();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length != explicitArgs.length) {\n                        continue;\n                    }\n                    args = new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight = args.getTypeDifferenceWeight(paramTypes);\n                if (typeDiffWeight < minTypeDiffWeight) {\n                    factoryMethodToUse = candidate;\n                    argsToUse = args.arguments;\n                    minTypeDiffWeight = typeDiffWeight;\n                }\n            }\n        }\n        if (factoryMethodToUse == null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() != null ? \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") + \"factory method '\" + mbd.getFactoryMethodName() + \"'\");\n        }\n        if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method '\" + mbd.getFactoryMethodName() + \"': needs to have a non-void return type!\");\n        }\n        if (explicitArgs == null) {\n            mbd.resolvedConstructorOrFactoryMethod = factoryMethodToUse;\n        }\n    }\n    try {\n        Object beanInstance = this.instantiationStrategy.instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        if (beanInstance == null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}"
    },
    {
      "commit": "14bd47551900ced88eeacf2a5f63c187ff72028c",
      "startLine": 2,
      "endLine": 25,
      "methodCode": "public BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n    BeanWrapperImpl bw = new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class factoryClass;\n    boolean isStatic;\n    String factoryBeanName = mbd.getFactoryBeanName();\n    if (factoryBeanName != null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean = this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean == null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean '\" + factoryBeanName + \"' returned null\");\n        }\n        factoryClass = factoryBean.getClass();\n        isStatic = false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean = null;\n        factoryClass = mbd.getBeanClass();\n        isStatic = true;\n    }\n    Method factoryMethodToUse = null;\n    Object[] argsToUse = null;\n    if (explicitArgs != null) {\n        argsToUse = explicitArgs;\n    } else {\n        factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n        if (factoryMethodToUse != null) {\n            argsToUse = mbd.resolvedConstructorArguments;\n            if (argsToUse == null) {\n                argsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n            }\n        }\n    }\n    if (factoryMethodToUse == null) {\n        factoryClass = ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates = ReflectionUtils.getAllDeclaredMethods(factoryClass);\n        List<Method> candidateSet = new ArrayList<Method>();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) == isStatic && candidate.getName().equals(mbd.getFactoryMethodName())) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        boolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight = Integer.MAX_VALUE;\n        ConstructorArgumentValues resolvedValues = null;\n        int minNrOfArgs;\n        if (explicitArgs != null) {\n            minNrOfArgs = explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n            resolvedValues = new ConstructorArgumentValues();\n            minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List<Exception> causes = null;\n        for (int i = 0; i < candidates.length; i++) {\n            Method candidate = candidates[i];\n            Class[] paramTypes = candidate.getParameterTypes();\n            if (paramTypes.length >= minNrOfArgs) {\n                ArgumentsHolder args;\n                if (resolvedValues != null) {\n                    try {\n                        args = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean '\" + beanName + \"': \" + ex);\n                        }\n                        if (i == candidates.length - 1 && factoryMethodToUse == null) {\n                            if (causes != null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes == null) {\n                                causes = new LinkedList<Exception>();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length != explicitArgs.length) {\n                        continue;\n                    }\n                    args = new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight = args.getTypeDifferenceWeight(paramTypes);\n                if (typeDiffWeight < minTypeDiffWeight) {\n                    factoryMethodToUse = candidate;\n                    argsToUse = args.arguments;\n                    minTypeDiffWeight = typeDiffWeight;\n                }\n            }\n        }\n        if (factoryMethodToUse == null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() != null ? \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") + \"factory method '\" + mbd.getFactoryMethodName() + \"'\");\n        }\n        if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method '\" + mbd.getFactoryMethodName() + \"': needs to have a non-void return type!\");\n        }\n        if (explicitArgs == null) {\n            mbd.resolvedConstructorOrFactoryMethod = factoryMethodToUse;\n        }\n    }\n    try {\n        Object beanInstance = this.instantiationStrategy.instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        if (beanInstance == null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}"
    },
    {
      "commit": "4344832a479831e7e67de1a9e81d52d023cd59ac",
      "startLine": 2,
      "endLine": 22,
      "methodCode": "public BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n    BeanWrapperImpl bw = new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class factoryClass;\n    boolean isStatic;\n    String factoryBeanName = mbd.getFactoryBeanName();\n    if (factoryBeanName != null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean = this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean == null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean '\" + factoryBeanName + \"' returned null\");\n        }\n        factoryClass = factoryBean.getClass();\n        isStatic = false;\n    } else {\n        factoryBean = null;\n        factoryClass = mbd.getBeanClass();\n        isStatic = true;\n    }\n    Method factoryMethodToUse = null;\n    Object[] argsToUse = null;\n    if (explicitArgs != null) {\n        argsToUse = explicitArgs;\n    } else {\n        factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n        if (factoryMethodToUse != null) {\n            argsToUse = mbd.resolvedConstructorArguments;\n            if (argsToUse == null) {\n                argsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n            }\n        }\n    }\n    if (factoryMethodToUse == null) {\n        Method[] candidates = ReflectionUtils.getAllDeclaredMethods(factoryClass);\n        boolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight = Integer.MAX_VALUE;\n        ConstructorArgumentValues resolvedValues = null;\n        int minNrOfArgs;\n        if (explicitArgs != null) {\n            minNrOfArgs = explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n            resolvedValues = new ConstructorArgumentValues();\n            minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List<Exception> causes = null;\n        for (int i = 0; i < candidates.length; i++) {\n            Method candidate = candidates[i];\n            Class[] paramTypes = candidate.getParameterTypes();\n            if (Modifier.isStatic(candidate.getModifiers()) == isStatic && candidate.getName().equals(mbd.getFactoryMethodName()) && paramTypes.length >= minNrOfArgs) {\n                ArgumentsHolder args;\n                if (resolvedValues != null) {\n                    try {\n                        args = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean '\" + beanName + \"': \" + ex);\n                        }\n                        if (i == candidates.length - 1 && factoryMethodToUse == null) {\n                            if (causes != null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes == null) {\n                                causes = new LinkedList<Exception>();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length != explicitArgs.length) {\n                        continue;\n                    }\n                    args = new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight = args.getTypeDifferenceWeight(paramTypes);\n                if (typeDiffWeight < minTypeDiffWeight) {\n                    factoryMethodToUse = candidate;\n                    argsToUse = args.arguments;\n                    minTypeDiffWeight = typeDiffWeight;\n                }\n            }\n        }\n        if (factoryMethodToUse == null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() != null ? \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") + \"factory method '\" + mbd.getFactoryMethodName() + \"'\");\n        }\n        if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method '\" + mbd.getFactoryMethodName() + \"': needs to have a non-void return type!\");\n        }\n        if (explicitArgs == null) {\n            mbd.resolvedConstructorOrFactoryMethod = factoryMethodToUse;\n        }\n    }\n    try {\n        Object beanInstance = this.instantiationStrategy.instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        if (beanInstance == null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}"
    },
    {
      "commit": "092de0107cd876d7f8207da7a9fc9ba163cfadfe",
      "startLine": 2,
      "endLine": 22,
      "methodCode": "public BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n    BeanWrapperImpl bw = new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class factoryClass;\n    boolean isStatic;\n    String factoryBeanName = mbd.getFactoryBeanName();\n    if (factoryBeanName != null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean = this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean == null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean '\" + factoryBeanName + \"' returned null\");\n        }\n        factoryClass = factoryBean.getClass();\n        isStatic = false;\n    } else {\n        factoryBean = null;\n        factoryClass = mbd.getBeanClass();\n        isStatic = true;\n    }\n    Method factoryMethodToUse = null;\n    Object[] argsToUse = null;\n    if (explicitArgs != null) {\n        argsToUse = explicitArgs;\n    } else {\n        factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n        if (factoryMethodToUse != null) {\n            argsToUse = mbd.resolvedConstructorArguments;\n            if (argsToUse == null) {\n                Class[] paramTypes = factoryMethodToUse.getParameterTypes();\n                Object[] argsToResolve = mbd.preparedConstructorArguments;\n                TypeConverter converter = (this.typeConverter != null ? this.typeConverter : bw);\n                BeanDefinitionValueResolver valueResolver = new BeanDefinitionValueResolver(this.beanFactory, beanName, mbd, converter);\n                argsToUse = new Object[argsToResolve.length];\n                for (int i = 0; i < argsToResolve.length; i++) {\n                    Object argValue = argsToResolve[i];\n                    MethodParameter methodParam = new MethodParameter(factoryMethodToUse, i);\n                    GenericTypeResolver.resolveParameterType(methodParam, factoryClass);\n                    if (argValue instanceof AutowiredArgumentMarker) {\n                        argValue = resolveAutowiredArgument(methodParam, beanName, null, converter);\n                    } else if (argValue instanceof BeanMetadataElement) {\n                        argValue = valueResolver.resolveValueIfNecessary(\"factory method argument\", argValue);\n                    }\n                    argsToUse[i] = converter.convertIfNecessary(argValue, paramTypes[i], methodParam);\n                }\n            }\n        }\n    }\n    if (factoryMethodToUse == null) {\n        Method[] candidates = ReflectionUtils.getAllDeclaredMethods(factoryClass);\n        boolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight = Integer.MAX_VALUE;\n        ConstructorArgumentValues resolvedValues = null;\n        int minNrOfArgs;\n        if (explicitArgs != null) {\n            minNrOfArgs = explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n            resolvedValues = new ConstructorArgumentValues();\n            minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List<Exception> causes = null;\n        for (int i = 0; i < candidates.length; i++) {\n            Method candidate = candidates[i];\n            Class[] paramTypes = candidate.getParameterTypes();\n            if (Modifier.isStatic(candidate.getModifiers()) == isStatic && candidate.getName().equals(mbd.getFactoryMethodName()) && paramTypes.length >= minNrOfArgs) {\n                ArgumentsHolder args;\n                if (resolvedValues != null) {\n                    try {\n                        args = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean '\" + beanName + \"': \" + ex);\n                        }\n                        if (i == candidates.length - 1 && factoryMethodToUse == null) {\n                            if (causes != null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes == null) {\n                                causes = new LinkedList<Exception>();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length != explicitArgs.length) {\n                        continue;\n                    }\n                    args = new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight = args.getTypeDifferenceWeight(paramTypes);\n                if (typeDiffWeight < minTypeDiffWeight) {\n                    factoryMethodToUse = candidate;\n                    argsToUse = args.arguments;\n                    minTypeDiffWeight = typeDiffWeight;\n                }\n            }\n        }\n        if (factoryMethodToUse == null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() != null ? \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") + \"factory method '\" + mbd.getFactoryMethodName() + \"'\");\n        }\n        if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method '\" + mbd.getFactoryMethodName() + \"': needs to have a non-void return type!\");\n        }\n        if (explicitArgs == null) {\n            mbd.resolvedConstructorOrFactoryMethod = factoryMethodToUse;\n        }\n    }\n    try {\n        Object beanInstance = this.instantiationStrategy.instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        if (beanInstance == null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}"
    },
    {
      "commit": "05bebb0c056714d97b479cf6c5552ba3c5b06d9c",
      "startLine": 2,
      "endLine": 20,
      "methodCode": "public BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n    BeanWrapperImpl bw = new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Class factoryClass = null;\n    Object factoryBean = null;\n    boolean isStatic = true;\n    String factoryBeanName = mbd.getFactoryBeanName();\n    if (factoryBeanName != null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean = this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean == null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean '\" + factoryBeanName + \"' returned null\");\n        }\n        factoryClass = factoryBean.getClass();\n        isStatic = false;\n    } else {\n        factoryClass = mbd.getBeanClass();\n    }\n    Method factoryMethodToUse = null;\n    Object[] argsToUse = null;\n    if (explicitArgs != null) {\n        argsToUse = explicitArgs;\n    } else {\n        factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n        if (factoryMethodToUse != null) {\n            argsToUse = mbd.resolvedConstructorArguments;\n            if (argsToUse == null) {\n                Class[] paramTypes = factoryMethodToUse.getParameterTypes();\n                Object[] argsToResolve = mbd.preparedConstructorArguments;\n                TypeConverter converter = (this.typeConverter != null ? this.typeConverter : bw);\n                BeanDefinitionValueResolver valueResolver = new BeanDefinitionValueResolver(this.beanFactory, beanName, mbd, converter);\n                argsToUse = new Object[argsToResolve.length];\n                for (int i = 0; i < argsToResolve.length; i++) {\n                    Object argValue = argsToResolve[i];\n                    MethodParameter methodParam = new MethodParameter(factoryMethodToUse, i);\n                    GenericTypeResolver.resolveParameterType(methodParam, factoryClass);\n                    if (argValue instanceof AutowiredArgumentMarker) {\n                        argValue = resolveAutowiredArgument(methodParam, beanName, null, converter);\n                    } else if (argValue instanceof BeanMetadataElement) {\n                        argValue = valueResolver.resolveValueIfNecessary(\"factory method argument\", argValue);\n                    }\n                    argsToUse[i] = converter.convertIfNecessary(argValue, paramTypes[i], methodParam);\n                }\n            }\n        }\n    }\n    if (factoryMethodToUse == null) {\n        Method[] candidates = ReflectionUtils.getAllDeclaredMethods(factoryClass);\n        boolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight = Integer.MAX_VALUE;\n        ConstructorArgumentValues resolvedValues = null;\n        int minNrOfArgs = 0;\n        if (explicitArgs != null) {\n            minNrOfArgs = explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n            resolvedValues = new ConstructorArgumentValues();\n            minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List<Exception> causes = null;\n        for (int i = 0; i < candidates.length; i++) {\n            Method candidate = candidates[i];\n            Class[] paramTypes = candidate.getParameterTypes();\n            if (Modifier.isStatic(candidate.getModifiers()) == isStatic && candidate.getName().equals(mbd.getFactoryMethodName()) && paramTypes.length >= minNrOfArgs) {\n                ArgumentsHolder args = null;\n                if (resolvedValues != null) {\n                    try {\n                        args = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean '\" + beanName + \"': \" + ex);\n                        }\n                        if (i == candidates.length - 1 && factoryMethodToUse == null) {\n                            if (causes != null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes == null) {\n                                causes = new LinkedList<Exception>();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length != explicitArgs.length) {\n                        continue;\n                    }\n                    args = new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight = args.getTypeDifferenceWeight(paramTypes);\n                if (typeDiffWeight < minTypeDiffWeight) {\n                    factoryMethodToUse = candidate;\n                    argsToUse = args.arguments;\n                    minTypeDiffWeight = typeDiffWeight;\n                }\n            }\n        }\n        if (factoryMethodToUse == null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() != null ? \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") + \"factory method '\" + mbd.getFactoryMethodName() + \"'\");\n        }\n        if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method '\" + mbd.getFactoryMethodName() + \"': needs to have a non-void return type!\");\n        }\n        if (explicitArgs == null) {\n            mbd.resolvedConstructorOrFactoryMethod = factoryMethodToUse;\n        }\n    }\n    try {\n        Object beanInstance = this.instantiationStrategy.instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        if (beanInstance == null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}"
    },
    {
      "commit": "347f34c68a7a5bab46cf869e762fb3cee9a1fedc",
      "startLine": 2,
      "endLine": 20,
      "methodCode": "public BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n    BeanWrapperImpl bw = new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Class factoryClass = null;\n    Object factoryBean = null;\n    boolean isStatic = true;\n    String factoryBeanName = mbd.getFactoryBeanName();\n    if (factoryBeanName != null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean = this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean == null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean '\" + factoryBeanName + \"' returned null\");\n        }\n        factoryClass = factoryBean.getClass();\n        isStatic = false;\n    } else {\n        factoryClass = mbd.getBeanClass();\n    }\n    Method factoryMethodToUse = null;\n    Object[] argsToUse = null;\n    if (explicitArgs != null) {\n        argsToUse = explicitArgs;\n    } else {\n        factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n        if (factoryMethodToUse != null) {\n            argsToUse = mbd.resolvedConstructorArguments;\n            if (argsToUse == null) {\n                Class[] paramTypes = factoryMethodToUse.getParameterTypes();\n                Object[] argsToResolve = mbd.preparedConstructorArguments;\n                TypeConverter converter = (this.typeConverter != null ? this.typeConverter : bw);\n                BeanDefinitionValueResolver valueResolver = new BeanDefinitionValueResolver(this.beanFactory, beanName, mbd, converter);\n                argsToUse = new Object[argsToResolve.length];\n                for (int i = 0; i < argsToResolve.length; i++) {\n                    Object argValue = argsToResolve[i];\n                    MethodParameter methodParam = new MethodParameter(factoryMethodToUse, i);\n                    GenericTypeResolver.resolveParameterType(methodParam, factoryClass);\n                    if (argValue instanceof AutowiredArgumentMarker) {\n                        argValue = resolveAutowiredArgument(methodParam, beanName, null, converter);\n                    } else if (argValue instanceof BeanMetadataElement) {\n                        argValue = valueResolver.resolveValueIfNecessary(\"factory method argument\", argValue);\n                    }\n                    argsToUse[i] = converter.convertIfNecessary(argValue, paramTypes[i], methodParam);\n                }\n            }\n        }\n    }\n    if (factoryMethodToUse == null) {\n        Method[] candidates = ReflectionUtils.getAllDeclaredMethods(factoryClass);\n        boolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight = Integer.MAX_VALUE;\n        ConstructorArgumentValues resolvedValues = null;\n        int minNrOfArgs = 0;\n        if (explicitArgs != null) {\n            minNrOfArgs = explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n            resolvedValues = new ConstructorArgumentValues();\n            minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List causes = null;\n        for (int i = 0; i < candidates.length; i++) {\n            Method candidate = candidates[i];\n            Class[] paramTypes = candidate.getParameterTypes();\n            if (Modifier.isStatic(candidate.getModifiers()) == isStatic && candidate.getName().equals(mbd.getFactoryMethodName()) && paramTypes.length >= minNrOfArgs) {\n                ArgumentsHolder args = null;\n                if (resolvedValues != null) {\n                    try {\n                        args = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean '\" + beanName + \"': \" + ex);\n                        }\n                        if (i == candidates.length - 1 && factoryMethodToUse == null) {\n                            if (causes != null) {\n                                for (Iterator it = causes.iterator(); it.hasNext(); ) {\n                                    this.beanFactory.onSuppressedException((Exception) it.next());\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes == null) {\n                                causes = new LinkedList();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length != explicitArgs.length) {\n                        continue;\n                    }\n                    args = new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight = args.getTypeDifferenceWeight(paramTypes);\n                if (typeDiffWeight < minTypeDiffWeight) {\n                    factoryMethodToUse = candidate;\n                    argsToUse = args.arguments;\n                    minTypeDiffWeight = typeDiffWeight;\n                }\n            }\n        }\n        if (factoryMethodToUse == null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() != null ? \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") + \"factory method '\" + mbd.getFactoryMethodName() + \"'\");\n        }\n        if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method '\" + mbd.getFactoryMethodName() + \"': needs to have a non-void return type!\");\n        }\n        if (explicitArgs == null) {\n            mbd.resolvedConstructorOrFactoryMethod = factoryMethodToUse;\n        }\n    }\n    try {\n        Object beanInstance = this.instantiationStrategy.instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        if (beanInstance == null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}"
    },
    {
      "commit": "f11d3436ed21d3908b9e0b569f2d783df161c0a3",
      "startLine": 2,
      "endLine": 20,
      "methodCode": "public BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n    BeanWrapperImpl bw = new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Class factoryClass = null;\n    Object factoryBean = null;\n    boolean isStatic = true;\n    String factoryBeanName = mbd.getFactoryBeanName();\n    if (factoryBeanName != null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean = this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean == null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean '\" + factoryBeanName + \"' returned null\");\n        }\n        factoryClass = factoryBean.getClass();\n        isStatic = false;\n    } else {\n        factoryClass = mbd.getBeanClass();\n    }\n    Method factoryMethodToUse = null;\n    Object[] argsToUse = null;\n    if (explicitArgs != null) {\n        argsToUse = explicitArgs;\n    } else {\n        factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n        if (factoryMethodToUse != null) {\n            argsToUse = mbd.resolvedConstructorArguments;\n            if (argsToUse == null) {\n                Class[] paramTypes = factoryMethodToUse.getParameterTypes();\n                Object[] argsToResolve = mbd.preparedConstructorArguments;\n                TypeConverter converter = (this.typeConverter != null ? this.typeConverter : bw);\n                BeanDefinitionValueResolver valueResolver = new BeanDefinitionValueResolver(this.beanFactory, beanName, mbd, converter);\n                argsToUse = new Object[argsToResolve.length];\n                for (int i = 0; i < argsToResolve.length; i++) {\n                    Object argValue = argsToResolve[i];\n                    MethodParameter methodParam = new MethodParameter(factoryMethodToUse, i);\n                    if (JdkVersion.isAtLeastJava15()) {\n                        GenericTypeResolver.resolveParameterType(methodParam, factoryClass);\n                    }\n                    if (argValue instanceof AutowiredArgumentMarker) {\n                        argValue = resolveAutowiredArgument(methodParam, beanName, null, converter);\n                    } else if (argValue instanceof BeanMetadataElement) {\n                        argValue = valueResolver.resolveValueIfNecessary(\"factory method argument\", argValue);\n                    }\n                    argsToUse[i] = converter.convertIfNecessary(argValue, paramTypes[i], methodParam);\n                }\n            }\n        }\n    }\n    if (factoryMethodToUse == null) {\n        Method[] candidates = ReflectionUtils.getAllDeclaredMethods(factoryClass);\n        boolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight = Integer.MAX_VALUE;\n        ConstructorArgumentValues resolvedValues = null;\n        int minNrOfArgs = 0;\n        if (explicitArgs != null) {\n            minNrOfArgs = explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n            resolvedValues = new ConstructorArgumentValues();\n            minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List causes = null;\n        for (int i = 0; i < candidates.length; i++) {\n            Method candidate = candidates[i];\n            Class[] paramTypes = candidate.getParameterTypes();\n            if (Modifier.isStatic(candidate.getModifiers()) == isStatic && candidate.getName().equals(mbd.getFactoryMethodName()) && paramTypes.length >= minNrOfArgs) {\n                ArgumentsHolder args = null;\n                if (resolvedValues != null) {\n                    try {\n                        args = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean '\" + beanName + \"': \" + ex);\n                        }\n                        if (i == candidates.length - 1 && factoryMethodToUse == null) {\n                            if (causes != null) {\n                                for (Iterator it = causes.iterator(); it.hasNext(); ) {\n                                    this.beanFactory.onSuppressedException((Exception) it.next());\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes == null) {\n                                causes = new LinkedList();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length != explicitArgs.length) {\n                        continue;\n                    }\n                    args = new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight = args.getTypeDifferenceWeight(paramTypes);\n                if (typeDiffWeight < minTypeDiffWeight) {\n                    factoryMethodToUse = candidate;\n                    argsToUse = args.arguments;\n                    minTypeDiffWeight = typeDiffWeight;\n                }\n            }\n        }\n        if (factoryMethodToUse == null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() != null ? \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") + \"factory method '\" + mbd.getFactoryMethodName() + \"'\");\n        }\n        if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method '\" + mbd.getFactoryMethodName() + \"': needs to have a non-void return type!\");\n        }\n        if (explicitArgs == null) {\n            mbd.resolvedConstructorOrFactoryMethod = factoryMethodToUse;\n        }\n    }\n    try {\n        Object beanInstance = this.instantiationStrategy.instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        if (beanInstance == null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}"
    }
  ]
}