{
  "statementVersions": [
    {
      "commit": "38af23796971193fa529c3d08ffde8fcd6e607b6",
      "startLine": 3,
      "endLine": 13,
      "methodCode": "@Override\npublic Allocation allocate(ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask, List<SchedulingRequest> schedulingRequests, List<ContainerId> release, List<String> blacklistAdditions, List<String> blacklistRemovals, ContainerUpdates updateRequests) {\n    FifoAppAttempt application = getApplicationAttempt(applicationAttemptId);\n    if (application == null) {\n        LOG.error(\"Calling allocate on removed or non existent application \" + applicationAttemptId.getApplicationId());\n        return EMPTY_ALLOCATION;\n    }\n    if (!application.getApplicationAttemptId().equals(applicationAttemptId)) {\n        LOG.error(\"Calling allocate on previous or removed \" + \"or non existent application attempt \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n    }\n    normalizeResourceRequests(ask);\n    releaseContainers(release, application);\n    synchronized (application) {\n        if (application.isStopped()) {\n            LOG.info(\"Calling allocate on a stopped \" + \"application \" + applicationAttemptId);\n            return EMPTY_ALLOCATION;\n        }\n        if (!ask.isEmpty()) {\n            LOG.debug(\"allocate: pre-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n            application.showRequests();\n            application.updateResourceRequests(ask);\n            LOG.debug(\"allocate: post-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n            application.showRequests();\n            LOG.debug(\"allocate:\" + \" applicationId=\" + applicationAttemptId + \" #ask=\" + ask.size());\n        }\n        application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n        Resource headroom = application.getHeadroom();\n        application.setApplicationHeadroomForMetrics(headroom);\n        return new Allocation(application.pullNewlyAllocatedContainers(), headroom, null, null, null, application.pullUpdatedNMTokens());\n    }\n}"
    },
    {
      "commit": "e2f6299f6f580d7a03f2377d19ac85f55fd4e73b",
      "startLine": 3,
      "endLine": 13,
      "methodCode": "@Override\npublic Allocation allocate(ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask, List<ContainerId> release, List<String> blacklistAdditions, List<String> blacklistRemovals, ContainerUpdates updateRequests) {\n    FifoAppAttempt application = getApplicationAttempt(applicationAttemptId);\n    if (application == null) {\n        LOG.error(\"Calling allocate on removed or non existent application \" + applicationAttemptId.getApplicationId());\n        return EMPTY_ALLOCATION;\n    }\n    if (!application.getApplicationAttemptId().equals(applicationAttemptId)) {\n        LOG.error(\"Calling allocate on previous or removed \" + \"or non existent application attempt \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n    }\n    normalizeRequests(ask);\n    releaseContainers(release, application);\n    synchronized (application) {\n        if (application.isStopped()) {\n            LOG.info(\"Calling allocate on a stopped \" + \"application \" + applicationAttemptId);\n            return EMPTY_ALLOCATION;\n        }\n        if (!ask.isEmpty()) {\n            LOG.debug(\"allocate: pre-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n            application.showRequests();\n            application.updateResourceRequests(ask);\n            LOG.debug(\"allocate: post-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n            application.showRequests();\n            LOG.debug(\"allocate:\" + \" applicationId=\" + applicationAttemptId + \" #ask=\" + ask.size());\n        }\n        application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n        Resource headroom = application.getHeadroom();\n        application.setApplicationHeadroomForMetrics(headroom);\n        return new Allocation(application.pullNewlyAllocatedContainers(), headroom, null, null, null, application.pullUpdatedNMTokens());\n    }\n}"
    },
    {
      "commit": "0a55bd841ec0f2eb89a0383f4c589526e8b138d4",
      "startLine": 3,
      "endLine": 9,
      "methodCode": "@Override\npublic Allocation allocate(ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask, List<ContainerId> release, List<String> blacklistAdditions, List<String> blacklistRemovals, ContainerUpdates updateRequests) {\n    FifoAppAttempt application = getApplicationAttempt(applicationAttemptId);\n    if (application == null) {\n        LOG.error(\"Calling allocate on removed \" + \"or non-existent application \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n    }\n    normalizeRequests(ask);\n    releaseContainers(release, application);\n    synchronized (application) {\n        if (application.isStopped()) {\n            LOG.info(\"Calling allocate on a stopped \" + \"application \" + applicationAttemptId);\n            return EMPTY_ALLOCATION;\n        }\n        if (!ask.isEmpty()) {\n            LOG.debug(\"allocate: pre-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n            application.showRequests();\n            application.updateResourceRequests(ask);\n            LOG.debug(\"allocate: post-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n            application.showRequests();\n            LOG.debug(\"allocate:\" + \" applicationId=\" + applicationAttemptId + \" #ask=\" + ask.size());\n        }\n        application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n        Resource headroom = application.getHeadroom();\n        application.setApplicationHeadroomForMetrics(headroom);\n        return new Allocation(application.pullNewlyAllocatedContainers(), headroom, null, null, null, application.pullUpdatedNMTokens());\n    }\n}"
    },
    {
      "commit": "1bbd023275db535ab80fcb60e022151e9679d468",
      "startLine": 3,
      "endLine": 9,
      "methodCode": "@Override\npublic Allocation allocate(ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask, List<ContainerId> release, List<String> blacklistAdditions, List<String> blacklistRemovals, List<UpdateContainerRequest> increaseRequests, List<UpdateContainerRequest> decreaseRequests) {\n    FifoAppAttempt application = getApplicationAttempt(applicationAttemptId);\n    if (application == null) {\n        LOG.error(\"Calling allocate on removed \" + \"or non-existent application \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n    }\n    normalizeRequests(ask);\n    releaseContainers(release, application);\n    synchronized (application) {\n        if (application.isStopped()) {\n            LOG.info(\"Calling allocate on a stopped \" + \"application \" + applicationAttemptId);\n            return EMPTY_ALLOCATION;\n        }\n        if (!ask.isEmpty()) {\n            LOG.debug(\"allocate: pre-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n            application.showRequests();\n            application.updateResourceRequests(ask);\n            LOG.debug(\"allocate: post-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n            application.showRequests();\n            LOG.debug(\"allocate:\" + \" applicationId=\" + applicationAttemptId + \" #ask=\" + ask.size());\n        }\n        application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n        Resource headroom = application.getHeadroom();\n        application.setApplicationHeadroomForMetrics(headroom);\n        return new Allocation(application.pullNewlyAllocatedContainers(), headroom, null, null, null, application.pullUpdatedNMTokens());\n    }\n}"
    },
    {
      "commit": "25f9872be63423ada6a18481eaad2888e731fdac",
      "startLine": 3,
      "endLine": 9,
      "methodCode": "@Override\npublic Allocation allocate(ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask, List<ContainerId> release, List<String> blacklistAdditions, List<String> blacklistRemovals, List<UpdateContainerRequest> increaseRequests, List<UpdateContainerRequest> decreaseRequests) {\n    FifoAppAttempt application = getApplicationAttempt(applicationAttemptId);\n    if (application == null) {\n        LOG.error(\"Calling allocate on removed \" + \"or non existant application \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n    }\n    normalizeRequests(ask);\n    releaseContainers(release, application);\n    synchronized (application) {\n        if (application.isStopped()) {\n            LOG.info(\"Calling allocate on a stopped \" + \"application \" + applicationAttemptId);\n            return EMPTY_ALLOCATION;\n        }\n        if (!ask.isEmpty()) {\n            LOG.debug(\"allocate: pre-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n            application.showRequests();\n            application.updateResourceRequests(ask);\n            LOG.debug(\"allocate: post-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n            application.showRequests();\n            LOG.debug(\"allocate:\" + \" applicationId=\" + applicationAttemptId + \" #ask=\" + ask.size());\n        }\n        application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n        Resource headroom = application.getHeadroom();\n        application.setApplicationHeadroomForMetrics(headroom);\n        return new Allocation(application.pullNewlyAllocatedContainers(), headroom, null, null, null, application.pullUpdatedNMTokens());\n    }\n}"
    },
    {
      "commit": "de3b4aac561258ad242a3c5ed1c919428893fd4c",
      "startLine": 3,
      "endLine": 9,
      "methodCode": "@Override\npublic Allocation allocate(ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask, List<ContainerId> release, List<String> blacklistAdditions, List<String> blacklistRemovals, List<UpdateContainerRequest> increaseRequests, List<UpdateContainerRequest> decreaseRequests) {\n    FifoAppAttempt application = getApplicationAttempt(applicationAttemptId);\n    if (application == null) {\n        LOG.error(\"Calling allocate on removed \" + \"or non existant application \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n    }\n    SchedulerUtils.normalizeRequests(ask, resourceCalculator, getClusterResource(), minimumAllocation, getMaximumResourceCapability());\n    releaseContainers(release, application);\n    synchronized (application) {\n        if (application.isStopped()) {\n            LOG.info(\"Calling allocate on a stopped \" + \"application \" + applicationAttemptId);\n            return EMPTY_ALLOCATION;\n        }\n        if (!ask.isEmpty()) {\n            LOG.debug(\"allocate: pre-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n            application.showRequests();\n            application.updateResourceRequests(ask);\n            LOG.debug(\"allocate: post-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n            application.showRequests();\n            LOG.debug(\"allocate:\" + \" applicationId=\" + applicationAttemptId + \" #ask=\" + ask.size());\n        }\n        application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n        Resource headroom = application.getHeadroom();\n        application.setApplicationHeadroomForMetrics(headroom);\n        return new Allocation(application.pullNewlyAllocatedContainers(), headroom, null, null, null, application.pullUpdatedNMTokens());\n    }\n}"
    },
    {
      "commit": "d6d9cff21b7b6141ed88359652cf22e8973c0661",
      "startLine": 3,
      "endLine": 9,
      "methodCode": "@Override\npublic Allocation allocate(ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask, List<ContainerId> release, List<String> blacklistAdditions, List<String> blacklistRemovals, List<UpdateContainerRequest> increaseRequests, List<UpdateContainerRequest> decreaseRequests) {\n    FiCaSchedulerApp application = getApplicationAttempt(applicationAttemptId);\n    if (application == null) {\n        LOG.error(\"Calling allocate on removed \" + \"or non existant application \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n    }\n    SchedulerUtils.normalizeRequests(ask, resourceCalculator, getClusterResource(), minimumAllocation, getMaximumResourceCapability());\n    releaseContainers(release, application);\n    synchronized (application) {\n        if (application.isStopped()) {\n            LOG.info(\"Calling allocate on a stopped \" + \"application \" + applicationAttemptId);\n            return EMPTY_ALLOCATION;\n        }\n        if (!ask.isEmpty()) {\n            LOG.debug(\"allocate: pre-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n            application.showRequests();\n            application.updateResourceRequests(ask);\n            LOG.debug(\"allocate: post-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n            application.showRequests();\n            LOG.debug(\"allocate:\" + \" applicationId=\" + applicationAttemptId + \" #ask=\" + ask.size());\n        }\n        application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n        Resource headroom = application.getHeadroom();\n        application.setApplicationHeadroomForMetrics(headroom);\n        return new Allocation(application.pullNewlyAllocatedContainers(), headroom, null, null, null, application.pullUpdatedNMTokens());\n    }\n}"
    },
    {
      "commit": "620325e81696fca140195b74929ed9eda2d5eb16",
      "startLine": 3,
      "endLine": 9,
      "methodCode": "@Override\npublic Allocation allocate(ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask, List<ContainerId> release, List<String> blacklistAdditions, List<String> blacklistRemovals, List<ContainerResourceChangeRequest> increaseRequests, List<ContainerResourceChangeRequest> decreaseRequests) {\n    FiCaSchedulerApp application = getApplicationAttempt(applicationAttemptId);\n    if (application == null) {\n        LOG.error(\"Calling allocate on removed \" + \"or non existant application \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n    }\n    SchedulerUtils.normalizeRequests(ask, resourceCalculator, getClusterResource(), minimumAllocation, getMaximumResourceCapability());\n    releaseContainers(release, application);\n    synchronized (application) {\n        if (application.isStopped()) {\n            LOG.info(\"Calling allocate on a stopped \" + \"application \" + applicationAttemptId);\n            return EMPTY_ALLOCATION;\n        }\n        if (!ask.isEmpty()) {\n            LOG.debug(\"allocate: pre-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n            application.showRequests();\n            application.updateResourceRequests(ask);\n            LOG.debug(\"allocate: post-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n            application.showRequests();\n            LOG.debug(\"allocate:\" + \" applicationId=\" + applicationAttemptId + \" #ask=\" + ask.size());\n        }\n        application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n        Resource headroom = application.getHeadroom();\n        application.setApplicationHeadroomForMetrics(headroom);\n        return new Allocation(application.pullNewlyAllocatedContainers(), headroom, null, null, null, application.pullUpdatedNMTokens());\n    }\n}"
    },
    {
      "commit": "20d389ce61eaacb5ddfb329015f50e96ad894f8d",
      "startLine": 3,
      "endLine": 9,
      "methodCode": "@Override\npublic Allocation allocate(ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask, List<ContainerId> release, List<String> blacklistAdditions, List<String> blacklistRemovals, List<ContainerResourceChangeRequest> increaseRequests, List<ContainerResourceChangeRequest> decreaseRequests) {\n    FiCaSchedulerApp application = getApplicationAttempt(applicationAttemptId);\n    if (application == null) {\n        LOG.error(\"Calling allocate on removed \" + \"or non existant application \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n    }\n    SchedulerUtils.normalizeRequests(ask, resourceCalculator, getClusterResource(), minimumAllocation, getMaximumResourceCapability());\n    releaseContainers(release, application);\n    synchronized (application) {\n        if (application.isStopped()) {\n            LOG.info(\"Calling allocate on a stopped \" + \"application \" + applicationAttemptId);\n            return EMPTY_ALLOCATION;\n        }\n        if (!ask.isEmpty()) {\n            LOG.debug(\"allocate: pre-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n            application.showRequests();\n            application.updateResourceRequests(ask);\n            LOG.debug(\"allocate: post-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n            application.showRequests();\n            LOG.debug(\"allocate:\" + \" applicationId=\" + applicationAttemptId + \" #ask=\" + ask.size());\n        }\n        if (application.isWaitingForAMContainer()) {\n            application.updateAMBlacklist(blacklistAdditions, blacklistRemovals);\n        } else {\n            application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n        }\n        Resource headroom = application.getHeadroom();\n        application.setApplicationHeadroomForMetrics(headroom);\n        return new Allocation(application.pullNewlyAllocatedContainers(), headroom, null, null, null, application.pullUpdatedNMTokens());\n    }\n}"
    },
    {
      "commit": "6cb0af3c39a5d49cb2f7911ee21363a9542ca2d7",
      "startLine": 3,
      "endLine": 9,
      "methodCode": "@Override\npublic Allocation allocate(ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask, List<ContainerId> release, List<String> blacklistAdditions, List<String> blacklistRemovals, List<ContainerResourceChangeRequest> increaseRequests, List<ContainerResourceChangeRequest> decreaseRequests) {\n    FiCaSchedulerApp application = getApplicationAttempt(applicationAttemptId);\n    if (application == null) {\n        LOG.error(\"Calling allocate on removed \" + \"or non existant application \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n    }\n    SchedulerUtils.normalizeRequests(ask, resourceCalculator, clusterResource, minimumAllocation, getMaximumResourceCapability());\n    releaseContainers(release, application);\n    synchronized (application) {\n        if (application.isStopped()) {\n            LOG.info(\"Calling allocate on a stopped \" + \"application \" + applicationAttemptId);\n            return EMPTY_ALLOCATION;\n        }\n        if (!ask.isEmpty()) {\n            LOG.debug(\"allocate: pre-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n            application.showRequests();\n            application.updateResourceRequests(ask);\n            LOG.debug(\"allocate: post-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n            application.showRequests();\n            LOG.debug(\"allocate:\" + \" applicationId=\" + applicationAttemptId + \" #ask=\" + ask.size());\n        }\n        if (application.isWaitingForAMContainer()) {\n            application.updateAMBlacklist(blacklistAdditions, blacklistRemovals);\n        } else {\n            application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n        }\n        Resource headroom = application.getHeadroom();\n        application.setApplicationHeadroomForMetrics(headroom);\n        return new Allocation(application.pullNewlyAllocatedContainers(), headroom, null, null, null, application.pullUpdatedNMTokens());\n    }\n}"
    },
    {
      "commit": "89cab1ba5f0671f8ef30dbe7432079c18362b434",
      "startLine": 3,
      "endLine": 9,
      "methodCode": "@Override\npublic Allocation allocate(ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask, List<ContainerId> release, List<String> blacklistAdditions, List<String> blacklistRemovals, List<ContainerResourceChangeRequest> increaseRequests, List<ContainerResourceChangeRequest> decreaseRequests) {\n    FiCaSchedulerApp application = getApplicationAttempt(applicationAttemptId);\n    if (application == null) {\n        LOG.error(\"Calling allocate on removed \" + \"or non existant application \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n    }\n    SchedulerUtils.normalizeRequests(ask, resourceCalculator, clusterResource, minimumAllocation, getMaximumResourceCapability());\n    releaseContainers(release, application);\n    synchronized (application) {\n        if (application.isStopped()) {\n            LOG.info(\"Calling allocate on a stopped \" + \"application \" + applicationAttemptId);\n            return EMPTY_ALLOCATION;\n        }\n        if (!ask.isEmpty()) {\n            LOG.debug(\"allocate: pre-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n            application.showRequests();\n            application.updateResourceRequests(ask);\n            LOG.debug(\"allocate: post-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n            application.showRequests();\n            LOG.debug(\"allocate:\" + \" applicationId=\" + applicationAttemptId + \" #ask=\" + ask.size());\n        }\n        if (application.isWaitingForAMContainer(application.getApplicationId())) {\n            application.updateAMBlacklist(blacklistAdditions, blacklistRemovals);\n        } else {\n            application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n        }\n        Resource headroom = application.getHeadroom();\n        application.setApplicationHeadroomForMetrics(headroom);\n        return new Allocation(application.pullNewlyAllocatedContainers(), headroom, null, null, null, application.pullUpdatedNMTokens());\n    }\n}"
    },
    {
      "commit": "81df7b586a16f8226c7b01c139c1c70c060399c3",
      "startLine": 3,
      "endLine": 9,
      "methodCode": "@Override\npublic Allocation allocate(ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask, List<ContainerId> release, List<String> blacklistAdditions, List<String> blacklistRemovals) {\n    FiCaSchedulerApp application = getApplicationAttempt(applicationAttemptId);\n    if (application == null) {\n        LOG.error(\"Calling allocate on removed \" + \"or non existant application \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n    }\n    SchedulerUtils.normalizeRequests(ask, resourceCalculator, clusterResource, minimumAllocation, getMaximumResourceCapability());\n    releaseContainers(release, application);\n    synchronized (application) {\n        if (application.isStopped()) {\n            LOG.info(\"Calling allocate on a stopped \" + \"application \" + applicationAttemptId);\n            return EMPTY_ALLOCATION;\n        }\n        if (!ask.isEmpty()) {\n            LOG.debug(\"allocate: pre-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n            application.showRequests();\n            application.updateResourceRequests(ask);\n            LOG.debug(\"allocate: post-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n            application.showRequests();\n            LOG.debug(\"allocate:\" + \" applicationId=\" + applicationAttemptId + \" #ask=\" + ask.size());\n        }\n        if (application.isWaitingForAMContainer(application.getApplicationId())) {\n            application.updateAMBlacklist(blacklistAdditions, blacklistRemovals);\n        } else {\n            application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n        }\n        ContainersAndNMTokensAllocation allocation = application.pullNewlyAllocatedContainersAndNMTokens();\n        Resource headroom = application.getHeadroom();\n        application.setApplicationHeadroomForMetrics(headroom);\n        return new Allocation(allocation.getContainerList(), headroom, null, null, null, allocation.getNMTokenList());\n    }\n}"
    },
    {
      "commit": "658097d6da1b1aac8e01db459f0c3b456e99652f",
      "startLine": 3,
      "endLine": 9,
      "methodCode": "@Override\npublic Allocation allocate(ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask, List<ContainerId> release, List<String> blacklistAdditions, List<String> blacklistRemovals) {\n    FiCaSchedulerApp application = getApplicationAttempt(applicationAttemptId);\n    if (application == null) {\n        LOG.error(\"Calling allocate on removed \" + \"or non existant application \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n    }\n    SchedulerUtils.normalizeRequests(ask, resourceCalculator, clusterResource, minimumAllocation, getMaximumResourceCapability());\n    releaseContainers(release, application);\n    synchronized (application) {\n        if (application.isStopped()) {\n            LOG.info(\"Calling allocate on a stopped \" + \"application \" + applicationAttemptId);\n            return EMPTY_ALLOCATION;\n        }\n        if (!ask.isEmpty()) {\n            LOG.debug(\"allocate: pre-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n            application.showRequests();\n            application.updateResourceRequests(ask);\n            LOG.debug(\"allocate: post-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n            application.showRequests();\n            LOG.debug(\"allocate:\" + \" applicationId=\" + applicationAttemptId + \" #ask=\" + ask.size());\n        }\n        application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n        ContainersAndNMTokensAllocation allocation = application.pullNewlyAllocatedContainersAndNMTokens();\n        Resource headroom = application.getHeadroom();\n        application.setApplicationHeadroomForMetrics(headroom);\n        return new Allocation(allocation.getContainerList(), headroom, null, null, null, allocation.getNMTokenList());\n    }\n}"
    },
    {
      "commit": "3114d4731dcca7cb6c16aaa7c7a6550b7dd7dccb",
      "startLine": 3,
      "endLine": 9,
      "methodCode": "@Override\npublic Allocation allocate(ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask, List<ContainerId> release, List<String> blacklistAdditions, List<String> blacklistRemovals) {\n    FiCaSchedulerApp application = getApplicationAttempt(applicationAttemptId);\n    if (application == null) {\n        LOG.error(\"Calling allocate on removed \" + \"or non existant application \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n    }\n    SchedulerUtils.normalizeRequests(ask, resourceCalculator, clusterResource, minimumAllocation, getMaximumResourceCapability());\n    releaseContainers(release, application);\n    synchronized (application) {\n        if (application.isStopped()) {\n            LOG.info(\"Calling allocate on a stopped \" + \"application \" + applicationAttemptId);\n            return EMPTY_ALLOCATION;\n        }\n        if (!ask.isEmpty()) {\n            LOG.debug(\"allocate: pre-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n            application.showRequests();\n            application.updateResourceRequests(ask);\n            LOG.debug(\"allocate: post-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n            application.showRequests();\n            LOG.debug(\"allocate:\" + \" applicationId=\" + applicationAttemptId + \" #ask=\" + ask.size());\n        }\n        application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n        ContainersAndNMTokensAllocation allocation = application.pullNewlyAllocatedContainersAndNMTokens();\n        return new Allocation(allocation.getContainerList(), application.getHeadroom(), null, null, null, allocation.getNMTokenList());\n    }\n}"
    },
    {
      "commit": "f6a778c3725bcdaba1e1de43786af17dd44deb78",
      "startLine": 3,
      "endLine": 9,
      "methodCode": "@Override\npublic Allocation allocate(ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask, List<ContainerId> release, List<String> blacklistAdditions, List<String> blacklistRemovals) {\n    FiCaSchedulerApp application = getApplicationAttempt(applicationAttemptId);\n    if (application == null) {\n        LOG.error(\"Calling allocate on removed \" + \"or non existant application \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n    }\n    SchedulerUtils.normalizeRequests(ask, resourceCalculator, clusterResource, minimumAllocation, maximumAllocation);\n    releaseContainers(release, application);\n    synchronized (application) {\n        if (application.isStopped()) {\n            LOG.info(\"Calling allocate on a stopped \" + \"application \" + applicationAttemptId);\n            return EMPTY_ALLOCATION;\n        }\n        if (!ask.isEmpty()) {\n            LOG.debug(\"allocate: pre-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n            application.showRequests();\n            application.updateResourceRequests(ask);\n            LOG.debug(\"allocate: post-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n            application.showRequests();\n            LOG.debug(\"allocate:\" + \" applicationId=\" + applicationAttemptId + \" #ask=\" + ask.size());\n        }\n        application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n        ContainersAndNMTokensAllocation allocation = application.pullNewlyAllocatedContainersAndNMTokens();\n        return new Allocation(allocation.getContainerList(), application.getHeadroom(), null, null, null, allocation.getNMTokenList());\n    }\n}"
    },
    {
      "commit": "5fd5c9900cfd299428acbc8dff767273e44647c0",
      "startLine": 3,
      "endLine": 15,
      "methodCode": "@Override\npublic Allocation allocate(ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask, List<ContainerId> release, List<String> blacklistAdditions, List<String> blacklistRemovals) {\n    FiCaSchedulerApp application = getApplicationAttempt(applicationAttemptId);\n    if (application == null) {\n        LOG.error(\"Calling allocate on removed \" + \"or non existant application \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n    }\n    SchedulerUtils.normalizeRequests(ask, resourceCalculator, clusterResource, minimumAllocation, maximumAllocation);\n    for (ContainerId releasedContainer : release) {\n        RMContainer rmContainer = getRMContainer(releasedContainer);\n        if (rmContainer == null) {\n            RMAuditLogger.logFailure(application.getUser(), AuditConstants.RELEASE_CONTAINER, \"Unauthorized access or invalid container\", \"FifoScheduler\", \"Trying to release container not owned by app or with invalid id\", application.getApplicationId(), releasedContainer);\n        }\n        containerCompleted(rmContainer, SchedulerUtils.createAbnormalContainerStatus(releasedContainer, SchedulerUtils.RELEASED_CONTAINER), RMContainerEventType.RELEASED);\n    }\n    synchronized (application) {\n        if (application.isStopped()) {\n            LOG.info(\"Calling allocate on a stopped \" + \"application \" + applicationAttemptId);\n            return EMPTY_ALLOCATION;\n        }\n        if (!ask.isEmpty()) {\n            LOG.debug(\"allocate: pre-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n            application.showRequests();\n            application.updateResourceRequests(ask);\n            LOG.debug(\"allocate: post-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n            application.showRequests();\n            LOG.debug(\"allocate:\" + \" applicationId=\" + applicationAttemptId + \" #ask=\" + ask.size());\n        }\n        application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n        ContainersAndNMTokensAllocation allocation = application.pullNewlyAllocatedContainersAndNMTokens();\n        return new Allocation(allocation.getContainerList(), application.getHeadroom(), null, null, null, allocation.getNMTokenList());\n    }\n}"
    },
    {
      "commit": "1393581bceda234c88cafec00dbfc0ef2a402e83",
      "startLine": 3,
      "endLine": 15,
      "methodCode": "@Override\npublic Allocation allocate(ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask, List<ContainerId> release, List<String> blacklistAdditions, List<String> blacklistRemovals) {\n    FiCaSchedulerApp application = getApplicationAttempt(applicationAttemptId);\n    if (application == null) {\n        LOG.error(\"Calling allocate on removed \" + \"or non existant application \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n    }\n    SchedulerUtils.normalizeRequests(ask, resourceCalculator, clusterResource, minimumAllocation, maximumAllocation);\n    for (ContainerId releasedContainer : release) {\n        RMContainer rmContainer = getRMContainer(releasedContainer);\n        if (rmContainer == null) {\n            RMAuditLogger.logFailure(application.getUser(), AuditConstants.RELEASE_CONTAINER, \"Unauthorized access or invalid container\", \"FifoScheduler\", \"Trying to release container not owned by app or with invalid id\", application.getApplicationId(), releasedContainer);\n        }\n        containerCompleted(rmContainer, SchedulerUtils.createAbnormalContainerStatus(releasedContainer, SchedulerUtils.RELEASED_CONTAINER), RMContainerEventType.RELEASED);\n    }\n    synchronized (application) {\n        if (application.isStopped()) {\n            LOG.info(\"Calling allocate on a stopped \" + \"application \" + applicationAttemptId);\n            return EMPTY_ALLOCATION;\n        }\n        if (!ask.isEmpty()) {\n            LOG.debug(\"allocate: pre-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n            application.showRequests();\n            application.updateResourceRequests(ask);\n            LOG.debug(\"allocate: post-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n            application.showRequests();\n            LOG.debug(\"allocate:\" + \" applicationId=\" + applicationAttemptId + \" #ask=\" + ask.size());\n        }\n        application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n        return new Allocation(application.pullNewlyAllocatedContainers(), application.getHeadroom());\n    }\n}"
    },
    {
      "commit": "0a6e275ee3360719290ad666629624450d4f0a6f",
      "startLine": 3,
      "endLine": 15,
      "methodCode": "@Override\npublic Allocation allocate(ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask, List<ContainerId> release, List<String> blacklistAdditions, List<String> blacklistRemovals) {\n    FiCaSchedulerApp application = getApplication(applicationAttemptId);\n    if (application == null) {\n        LOG.error(\"Calling allocate on removed \" + \"or non existant application \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n    }\n    SchedulerUtils.normalizeRequests(ask, resourceCalculator, clusterResource, minimumAllocation, maximumAllocation);\n    for (ContainerId releasedContainer : release) {\n        RMContainer rmContainer = getRMContainer(releasedContainer);\n        if (rmContainer == null) {\n            RMAuditLogger.logFailure(application.getUser(), AuditConstants.RELEASE_CONTAINER, \"Unauthorized access or invalid container\", \"FifoScheduler\", \"Trying to release container not owned by app or with invalid id\", application.getApplicationId(), releasedContainer);\n        }\n        containerCompleted(rmContainer, SchedulerUtils.createAbnormalContainerStatus(releasedContainer, SchedulerUtils.RELEASED_CONTAINER), RMContainerEventType.RELEASED);\n    }\n    synchronized (application) {\n        if (application.isStopped()) {\n            LOG.info(\"Calling allocate on a stopped \" + \"application \" + applicationAttemptId);\n            return EMPTY_ALLOCATION;\n        }\n        if (!ask.isEmpty()) {\n            LOG.debug(\"allocate: pre-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n            application.showRequests();\n            application.updateResourceRequests(ask);\n            LOG.debug(\"allocate: post-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n            application.showRequests();\n            LOG.debug(\"allocate:\" + \" applicationId=\" + applicationAttemptId + \" #ask=\" + ask.size());\n        }\n        application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n        return new Allocation(application.pullNewlyAllocatedContainers(), application.getHeadroom());\n    }\n}"
    },
    {
      "commit": "8eb3be63f598daae01f0a0c09eab5086881f153d",
      "startLine": 3,
      "endLine": 15,
      "methodCode": "@Override\npublic Allocation allocate(ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask, List<ContainerId> release, List<String> blacklistAdditions, List<String> blacklistRemovals) {\n    FiCaSchedulerApp application = getApplication(applicationAttemptId);\n    if (application == null) {\n        LOG.error(\"Calling allocate on removed \" + \"or non existant application \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n    }\n    SchedulerUtils.normalizeRequests(ask, resourceCalculator, clusterResource, minimumAllocation, maximumAllocation);\n    for (ContainerId releasedContainer : release) {\n        RMContainer rmContainer = getRMContainer(releasedContainer);\n        if (rmContainer == null) {\n            RMAuditLogger.logFailure(application.getUser(), AuditConstants.RELEASE_CONTAINER, \"Unauthorized access or invalid container\", \"FifoScheduler\", \"Trying to release container not owned by app or with invalid id\", application.getApplicationId(), releasedContainer);\n        }\n        containerCompleted(rmContainer, SchedulerUtils.createAbnormalContainerStatus(releasedContainer, SchedulerUtils.RELEASED_CONTAINER), RMContainerEventType.RELEASED);\n    }\n    synchronized (application) {\n        if (application.isStopped()) {\n            LOG.info(\"Calling allocate on a stopped \" + \"application \" + applicationAttemptId);\n            return EMPTY_ALLOCATION;\n        }\n        if (!ask.isEmpty()) {\n            LOG.debug(\"allocate: pre-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n            application.showRequests();\n            application.updateResourceRequests(ask, blacklistAdditions, blacklistRemovals);\n            LOG.debug(\"allocate: post-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n            application.showRequests();\n            LOG.debug(\"allocate:\" + \" applicationId=\" + applicationAttemptId + \" #ask=\" + ask.size());\n        }\n        return new Allocation(application.pullNewlyAllocatedContainers(), application.getHeadroom());\n    }\n}"
    },
    {
      "commit": "2051fd5ee29e99df6fe79c70b0c7c8c0c1cc131f",
      "startLine": 3,
      "endLine": 15,
      "methodCode": "@Override\npublic Allocation allocate(ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask, List<ContainerId> release, List<String> blacklistAdditions, List<String> blacklistRemovals) {\n    FiCaSchedulerApp application = getApplication(applicationAttemptId);\n    if (application == null) {\n        LOG.error(\"Calling allocate on removed \" + \"or non existant application \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n    }\n    SchedulerUtils.normalizeRequests(ask, resourceCalculator, clusterResource, minimumAllocation, maximumAllocation);\n    for (ContainerId releasedContainer : release) {\n        RMContainer rmContainer = getRMContainer(releasedContainer);\n        if (rmContainer == null) {\n            RMAuditLogger.logFailure(application.getUser(), AuditConstants.RELEASE_CONTAINER, \"Unauthorized access or invalid container\", \"FifoScheduler\", \"Trying to release container not owned by app or with invalid id\", application.getApplicationId(), releasedContainer);\n        }\n        containerCompleted(rmContainer, SchedulerUtils.createAbnormalContainerStatus(releasedContainer, SchedulerUtils.RELEASED_CONTAINER), RMContainerEventType.RELEASED);\n    }\n    synchronized (application) {\n        if (application.isStopped()) {\n            LOG.info(\"Calling allocate on a stopped \" + \"application \" + applicationAttemptId);\n            return EMPTY_ALLOCATION;\n        }\n        if (!ask.isEmpty()) {\n            LOG.debug(\"allocate: pre-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n            application.showRequests();\n            application.updateResourceRequests(ask, null, null);\n            LOG.debug(\"allocate: post-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n            application.showRequests();\n            LOG.debug(\"allocate:\" + \" applicationId=\" + applicationAttemptId + \" #ask=\" + ask.size());\n        }\n        return new Allocation(application.pullNewlyAllocatedContainers(), application.getHeadroom());\n    }\n}"
    },
    {
      "commit": "bc6777dd5bdcbaef09897b506bc6511ae456033d",
      "startLine": 3,
      "endLine": 15,
      "methodCode": "@Override\npublic Allocation allocate(ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask, List<ContainerId> release) {\n    FiCaSchedulerApp application = getApplication(applicationAttemptId);\n    if (application == null) {\n        LOG.error(\"Calling allocate on removed \" + \"or non existant application \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n    }\n    SchedulerUtils.normalizeRequests(ask, resourceCalculator, clusterResource, minimumAllocation, maximumAllocation);\n    for (ContainerId releasedContainer : release) {\n        RMContainer rmContainer = getRMContainer(releasedContainer);\n        if (rmContainer == null) {\n            RMAuditLogger.logFailure(application.getUser(), AuditConstants.RELEASE_CONTAINER, \"Unauthorized access or invalid container\", \"FifoScheduler\", \"Trying to release container not owned by app or with invalid id\", application.getApplicationId(), releasedContainer);\n        }\n        containerCompleted(rmContainer, SchedulerUtils.createAbnormalContainerStatus(releasedContainer, SchedulerUtils.RELEASED_CONTAINER), RMContainerEventType.RELEASED);\n    }\n    synchronized (application) {\n        if (application.isStopped()) {\n            LOG.info(\"Calling allocate on a stopped \" + \"application \" + applicationAttemptId);\n            return EMPTY_ALLOCATION;\n        }\n        if (!ask.isEmpty()) {\n            LOG.debug(\"allocate: pre-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n            application.showRequests();\n            application.updateResourceRequests(ask);\n            LOG.debug(\"allocate: post-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n            application.showRequests();\n            LOG.debug(\"allocate:\" + \" applicationId=\" + applicationAttemptId + \" #ask=\" + ask.size());\n        }\n        return new Allocation(application.pullNewlyAllocatedContainers(), application.getHeadroom());\n    }\n}"
    },
    {
      "commit": "01aabf73639785a29d1651f2e268cec04a8b9b94",
      "startLine": 3,
      "endLine": 15,
      "methodCode": "@Override\npublic Allocation allocate(ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask, List<ContainerId> release) {\n    FiCaSchedulerApp application = getApplication(applicationAttemptId);\n    if (application == null) {\n        LOG.error(\"Calling allocate on removed \" + \"or non existant application \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n    }\n    SchedulerUtils.normalizeRequests(ask, resourceCalculator, clusterResource, minimumAllocation);\n    for (ContainerId releasedContainer : release) {\n        RMContainer rmContainer = getRMContainer(releasedContainer);\n        if (rmContainer == null) {\n            RMAuditLogger.logFailure(application.getUser(), AuditConstants.RELEASE_CONTAINER, \"Unauthorized access or invalid container\", \"FifoScheduler\", \"Trying to release container not owned by app or with invalid id\", application.getApplicationId(), releasedContainer);\n        }\n        containerCompleted(rmContainer, SchedulerUtils.createAbnormalContainerStatus(releasedContainer, SchedulerUtils.RELEASED_CONTAINER), RMContainerEventType.RELEASED);\n    }\n    synchronized (application) {\n        if (application.isStopped()) {\n            LOG.info(\"Calling allocate on a stopped \" + \"application \" + applicationAttemptId);\n            return EMPTY_ALLOCATION;\n        }\n        if (!ask.isEmpty()) {\n            LOG.debug(\"allocate: pre-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n            application.showRequests();\n            application.updateResourceRequests(ask);\n            LOG.debug(\"allocate: post-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n            application.showRequests();\n            LOG.debug(\"allocate:\" + \" applicationId=\" + applicationAttemptId + \" #ask=\" + ask.size());\n        }\n        return new Allocation(application.pullNewlyAllocatedContainers(), application.getHeadroom());\n    }\n}"
    },
    {
      "commit": "453926397182078c65a4428eb5de5a90d6af6448",
      "startLine": 3,
      "endLine": 15,
      "methodCode": "@Override\npublic Allocation allocate(ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask, List<ContainerId> release) {\n    FiCaSchedulerApp application = getApplication(applicationAttemptId);\n    if (application == null) {\n        LOG.error(\"Calling allocate on removed \" + \"or non existant application \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n    }\n    SchedulerUtils.normalizeRequests(ask, resourceCalculator, clusterResource, minimumAllocation);\n    for (ContainerId releasedContainer : release) {\n        RMContainer rmContainer = getRMContainer(releasedContainer);\n        if (rmContainer == null) {\n            RMAuditLogger.logFailure(application.getUser(), AuditConstants.RELEASE_CONTAINER, \"Unauthorized access or invalid container\", \"FifoScheduler\", \"Trying to release container not owned by app or with invalid id\", application.getApplicationId(), releasedContainer);\n        }\n        containerCompleted(rmContainer, SchedulerUtils.createAbnormalContainerStatus(releasedContainer, SchedulerUtils.RELEASED_CONTAINER), RMContainerEventType.RELEASED);\n    }\n    synchronized (application) {\n        if (!ask.isEmpty()) {\n            LOG.debug(\"allocate: pre-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n            application.showRequests();\n            application.updateResourceRequests(ask);\n            LOG.debug(\"allocate: post-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n            application.showRequests();\n            LOG.debug(\"allocate:\" + \" applicationId=\" + applicationAttemptId + \" #ask=\" + ask.size());\n        }\n        return new Allocation(application.pullNewlyAllocatedContainers(), application.getHeadroom());\n    }\n}"
    },
    {
      "commit": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "startLine": 3,
      "endLine": 15,
      "methodCode": "@Override\npublic Allocation allocate(ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask, List<ContainerId> release) {\n    FiCaSchedulerApp application = getApplication(applicationAttemptId);\n    if (application == null) {\n        LOG.error(\"Calling allocate on removed \" + \"or non existant application \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n    }\n    SchedulerUtils.normalizeRequests(ask, minimumAllocation.getMemory());\n    for (ContainerId releasedContainer : release) {\n        RMContainer rmContainer = getRMContainer(releasedContainer);\n        if (rmContainer == null) {\n            RMAuditLogger.logFailure(application.getUser(), AuditConstants.RELEASE_CONTAINER, \"Unauthorized access or invalid container\", \"FifoScheduler\", \"Trying to release container not owned by app or with invalid id\", application.getApplicationId(), releasedContainer);\n        }\n        containerCompleted(rmContainer, SchedulerUtils.createAbnormalContainerStatus(releasedContainer, SchedulerUtils.RELEASED_CONTAINER), RMContainerEventType.RELEASED);\n    }\n    synchronized (application) {\n        if (!ask.isEmpty()) {\n            LOG.debug(\"allocate: pre-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n            application.showRequests();\n            application.updateResourceRequests(ask);\n            LOG.debug(\"allocate: post-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n            application.showRequests();\n            LOG.debug(\"allocate:\" + \" applicationId=\" + applicationAttemptId + \" #ask=\" + ask.size());\n        }\n        return new Allocation(application.pullNewlyAllocatedContainers(), application.getHeadroom());\n    }\n}"
    },
    {
      "commit": "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76",
      "startLine": 3,
      "endLine": 15,
      "methodCode": "@Override\npublic Allocation allocate(ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask, List<ContainerId> release) {\n    FiCaSchedulerApp application = getApplication(applicationAttemptId);\n    if (application == null) {\n        LOG.error(\"Calling allocate on removed \" + \"or non existant application \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n    }\n    SchedulerUtils.normalizeRequests(ask, minimumAllocation.getMemory());\n    for (ContainerId releasedContainer : release) {\n        RMContainer rmContainer = getRMContainer(releasedContainer);\n        if (rmContainer == null) {\n            RMAuditLogger.logFailure(application.getUser(), AuditConstants.RELEASE_CONTAINER, \"Unauthorized access or invalid container\", \"FifoScheduler\", \"Trying to release container not owned by app or with invalid id\", application.getApplicationId(), releasedContainer);\n        }\n        containerCompleted(rmContainer, SchedulerUtils.createAbnormalContainerStatus(releasedContainer, SchedulerUtils.RELEASED_CONTAINER), RMContainerEventType.RELEASED);\n    }\n    synchronized (application) {\n        if (!ask.isEmpty()) {\n            LOG.debug(\"allocate: pre-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n            application.showRequests();\n            application.updateResourceRequests(ask);\n            LOG.debug(\"allocate: post-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n            application.showRequests();\n            LOG.debug(\"allocate:\" + \" applicationId=\" + applicationAttemptId + \" #ask=\" + ask.size());\n        }\n        return new Allocation(application.pullNewlyAllocatedContainers(), application.getHeadroom());\n    }\n}"
    },
    {
      "commit": "23e336a0ed314ac7f1b47649d1a688e8de6b6e94",
      "startLine": 3,
      "endLine": 15,
      "methodCode": "@Override\npublic Allocation allocate(ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask, List<ContainerId> release) {\n    SchedulerApp application = getApplication(applicationAttemptId);\n    if (application == null) {\n        LOG.error(\"Calling allocate on removed \" + \"or non existant application \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n    }\n    SchedulerUtils.normalizeRequests(ask, minimumAllocation.getMemory());\n    for (ContainerId releasedContainer : release) {\n        RMContainer rmContainer = getRMContainer(releasedContainer);\n        if (rmContainer == null) {\n            RMAuditLogger.logFailure(application.getUser(), AuditConstants.RELEASE_CONTAINER, \"Unauthorized access or invalid container\", \"FifoScheduler\", \"Trying to release container not owned by app or with invalid id\", application.getApplicationId(), releasedContainer);\n        }\n        containerCompleted(rmContainer, SchedulerUtils.createAbnormalContainerStatus(releasedContainer, SchedulerUtils.RELEASED_CONTAINER), RMContainerEventType.RELEASED);\n    }\n    synchronized (application) {\n        if (!ask.isEmpty()) {\n            LOG.debug(\"allocate: pre-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n            application.showRequests();\n            application.updateResourceRequests(ask);\n            LOG.debug(\"allocate: post-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n            application.showRequests();\n            LOG.debug(\"allocate:\" + \" applicationId=\" + applicationAttemptId + \" #ask=\" + ask.size());\n        }\n        return new Allocation(application.pullNewlyAllocatedContainers(), application.getHeadroom());\n    }\n}"
    },
    {
      "commit": "80cc8e94861e2b0fc423b77fa8ce0f174c3a91fd",
      "startLine": 3,
      "endLine": 15,
      "methodCode": "@Override\npublic Allocation allocate(ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask, List<ContainerId> release) {\n    SchedulerApp application = getApplication(applicationAttemptId);\n    if (application == null) {\n        LOG.error(\"Calling allocate on removed \" + \"or non existant application \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n    }\n    SchedulerUtils.normalizeRequests(ask, MINIMUM_MEMORY);\n    for (ContainerId releasedContainer : release) {\n        RMContainer rmContainer = getRMContainer(releasedContainer);\n        if (rmContainer == null) {\n            RMAuditLogger.logFailure(application.getUser(), AuditConstants.RELEASE_CONTAINER, \"Unauthorized access or invalid container\", \"FifoScheduler\", \"Trying to release container not owned by app or with invalid id\", application.getApplicationId(), releasedContainer);\n        }\n        containerCompleted(rmContainer, SchedulerUtils.createAbnormalContainerStatus(releasedContainer, SchedulerUtils.RELEASED_CONTAINER), RMContainerEventType.RELEASED);\n    }\n    synchronized (application) {\n        if (!ask.isEmpty()) {\n            LOG.debug(\"allocate: pre-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n            application.showRequests();\n            application.updateResourceRequests(ask);\n            LOG.debug(\"allocate: post-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n            application.showRequests();\n            LOG.debug(\"allocate:\" + \" applicationId=\" + applicationAttemptId + \" #ask=\" + ask.size());\n        }\n        return new Allocation(application.pullNewlyAllocatedContainers(), application.getHeadroom());\n    }\n}"
    },
    {
      "commit": "e549ac93694f768f2e26706a54a1b45dea6d2844",
      "startLine": 3,
      "endLine": 15,
      "methodCode": "@Override\npublic Allocation allocate(ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask, List<ContainerId> release) {\n    SchedulerApp application = getApplication(applicationAttemptId);\n    if (application == null) {\n        LOG.error(\"Calling allocate on removed \" + \"or non existant application \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n    }\n    SchedulerUtils.normalizeRequests(ask, MINIMUM_MEMORY);\n    for (ContainerId releasedContainer : release) {\n        RMContainer rmContainer = getRMContainer(releasedContainer);\n        if (rmContainer == null) {\n            RMAuditLogger.logFailure(application.getUser(), AuditConstants.RELEASE_CONTAINER, \"Unauthorized access or invalid container\", \"FifoScheduler\", \"Trying to release container not owned by app or with invalid id\", application.getApplicationId(), releasedContainer);\n        }\n        containerCompleted(rmContainer, SchedulerUtils.createAbnormalContainerStatus(releasedContainer, SchedulerUtils.RELEASED_CONTAINER), RMContainerEventType.RELEASED);\n    }\n    if (!ask.isEmpty()) {\n        LOG.debug(\"allocate: pre-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n        application.showRequests();\n        application.updateResourceRequests(ask);\n        LOG.debug(\"allocate: post-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n        application.showRequests();\n        LOG.debug(\"allocate:\" + \" applicationId=\" + applicationAttemptId + \" #ask=\" + ask.size());\n    }\n    return new Allocation(application.pullNewlyAllocatedContainers(), application.getHeadroom());\n}"
    },
    {
      "commit": "817ead65b99f465fc2dfa18072cf23cadf5f05d0",
      "startLine": 3,
      "endLine": 15,
      "methodCode": "@Override\npublic Allocation allocate(ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask, List<ContainerId> release) {\n    SchedulerApp application = getApplication(applicationAttemptId);\n    if (application == null) {\n        LOG.error(\"Calling allocate on removed \" + \"or non existant application \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n    }\n    normalizeRequests(ask);\n    for (ContainerId releasedContainer : release) {\n        RMContainer rmContainer = getRMContainer(releasedContainer);\n        if (rmContainer == null) {\n            RMAuditLogger.logFailure(application.getUser(), AuditConstants.RELEASE_CONTAINER, \"Unauthorized access or invalid container\", \"FifoScheduler\", \"Trying to release container not owned by app or with invalid id\", application.getApplicationId(), releasedContainer);\n        }\n        containerCompleted(rmContainer, SchedulerUtils.createAbnormalContainerStatus(releasedContainer, SchedulerUtils.RELEASED_CONTAINER), RMContainerEventType.RELEASED);\n    }\n    if (!ask.isEmpty()) {\n        LOG.debug(\"allocate: pre-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n        application.showRequests();\n        application.updateResourceRequests(ask);\n        LOG.debug(\"allocate: post-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n        application.showRequests();\n        LOG.debug(\"allocate:\" + \" applicationId=\" + applicationAttemptId + \" #ask=\" + ask.size());\n    }\n    return new Allocation(application.pullNewlyAllocatedContainers(), application.getHeadroom());\n}"
    },
    {
      "commit": "cdfabf5ae289836968b3d296668593b9500b6f26",
      "startLine": 3,
      "endLine": 15,
      "methodCode": "@Override\npublic Allocation allocate(ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask, List<ContainerId> release) {\n    SchedulerApp application = getApplication(applicationAttemptId);\n    if (application == null) {\n        LOG.error(\"Calling allocate on removed \" + \"or non existant application \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n    }\n    normalizeRequests(ask);\n    for (ContainerId releasedContainer : release) {\n        RMContainer rmContainer = getRMContainer(releasedContainer);\n        if (rmContainer == null) {\n            RMAuditLogger.logFailure(application.getUser(), AuditConstants.RELEASE_CONTAINER, \"Unauthorized access or invalid container\", \"FifoScheduler\", \"Trying to release container not owned by app or with invalid id\", application.getApplicationId(), releasedContainer);\n        }\n        containerCompleted(rmContainer, RMContainerEventType.RELEASED);\n    }\n    if (!ask.isEmpty()) {\n        LOG.debug(\"allocate: pre-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n        application.showRequests();\n        application.updateResourceRequests(ask);\n        LOG.debug(\"allocate: post-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n        application.showRequests();\n        LOG.debug(\"allocate:\" + \" applicationId=\" + applicationAttemptId + \" #ask=\" + ask.size());\n    }\n    return new Allocation(application.pullNewlyAllocatedContainers(), application.getHeadroom());\n}"
    },
    {
      "commit": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "startLine": 3,
      "endLine": 11,
      "methodCode": "@Override\npublic Allocation allocate(ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask, List<ContainerId> release) {\n    SchedulerApp application = getApplication(applicationAttemptId);\n    if (application == null) {\n        LOG.error(\"Calling allocate on removed \" + \"or non existant application \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n    }\n    normalizeRequests(ask);\n    for (ContainerId releasedContainer : release) {\n        containerCompleted(getRMContainer(releasedContainer), RMContainerEventType.RELEASED);\n    }\n    if (!ask.isEmpty()) {\n        LOG.debug(\"allocate: pre-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n        application.showRequests();\n        application.updateResourceRequests(ask);\n        LOG.debug(\"allocate: post-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n        application.showRequests();\n        LOG.debug(\"allocate:\" + \" applicationId=\" + applicationAttemptId + \" #ask=\" + ask.size());\n    }\n    return new Allocation(application.pullNewlyAllocatedContainers(), application.getHeadroom());\n}"
    },
    {
      "commit": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "startLine": 3,
      "endLine": 11,
      "methodCode": "@Override\npublic Allocation allocate(ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask, List<ContainerId> release) {\n    SchedulerApp application = getApplication(applicationAttemptId);\n    if (application == null) {\n        LOG.error(\"Calling allocate on removed \" + \"or non existant application \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n    }\n    normalizeRequests(ask);\n    for (ContainerId releasedContainer : release) {\n        containerCompleted(getRMContainer(releasedContainer), RMContainerEventType.RELEASED);\n    }\n    if (!ask.isEmpty()) {\n        LOG.debug(\"allocate: pre-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n        application.showRequests();\n        application.updateResourceRequests(ask);\n        LOG.debug(\"allocate: post-update\" + \" applicationId=\" + applicationAttemptId + \" application=\" + application);\n        application.showRequests();\n        LOG.debug(\"allocate:\" + \" applicationId=\" + applicationAttemptId + \" #ask=\" + ask.size());\n    }\n    return new Allocation(application.pullNewlyAllocatedContainers(), application.getHeadroom());\n}"
    }
  ]
}