{
  "statementVersions": [
    {
      "commit": "aa21f853ab0380ec1f68ae1d0b7c8d9268da4533",
      "startLine": 38,
      "endLine": 45,
      "methodCode": "public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {\n    if (shutdown || message == null) {\n        return false;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received wrong AcknowledgeCheckpoint message for job {}: {}\", job, message);\n        return false;\n    }\n    final long checkpointId = message.getCheckpointId();\n    synchronized (lock) {\n        if (shutdown) {\n            return false;\n        }\n        final PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId);\n        if (checkpoint != null && !checkpoint.isDiscarded()) {\n            switch(checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {\n                case SUCCESS:\n                    LOG.debug(\"Received acknowledge message for checkpoint {} from task {} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n                    if (checkpoint.isFullyAcknowledged()) {\n                        completePendingCheckpoint(checkpoint);\n                    }\n                    break;\n                case DUPLICATE:\n                    LOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    break;\n                case UNKNOWN:\n                    LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the task's execution attempt id was unknown. Discarding \" + \"the state handle to avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n                    break;\n                case DISCARDED:\n                    LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the pending checkpoint had been discarded. Discarding the \" + \"state handle tp avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n            }\n            return true;\n        } else if (checkpoint != null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            boolean wasPendingCheckpoint;\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                wasPendingCheckpoint = true;\n                LOG.warn(\"Received late message for now expired checkpoint attempt {} from \" + \"{} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n            } else {\n                LOG.debug(\"Received message for an unknown checkpoint {} from {} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n                wasPendingCheckpoint = false;\n            }\n            discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n            return wasPendingCheckpoint;\n        }\n    }\n}"
    },
    {
      "commit": "2edc97185700a5bdb3e181a71493d681c0f693e3",
      "startLine": 38,
      "endLine": 45,
      "methodCode": "public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {\n    if (shutdown || message == null) {\n        return false;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received wrong AcknowledgeCheckpoint message for job {}: {}\", job, message);\n        return false;\n    }\n    final long checkpointId = message.getCheckpointId();\n    synchronized (lock) {\n        if (shutdown) {\n            return false;\n        }\n        final PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId);\n        if (checkpoint != null && !checkpoint.isDiscarded()) {\n            switch(checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {\n                case SUCCESS:\n                    LOG.debug(\"Received acknowledge message for checkpoint {} from task {} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n                    if (checkpoint.isFullyAcknowledged()) {\n                        completePendingCheckpoint(checkpoint);\n                    }\n                    break;\n                case DUPLICATE:\n                    LOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    break;\n                case UNKNOWN:\n                    LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the task's execution attempt id was unknown. Discarding \" + \"the state handle to avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n                    break;\n                case DISCARDED:\n                    LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the pending checkpoint had been discarded. Discarding the \" + \"state handle tp avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n            }\n            return true;\n        } else if (checkpoint != null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            boolean wasPendingCheckpoint;\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                wasPendingCheckpoint = true;\n                LOG.warn(\"Received late message for now expired checkpoint attempt {} from \" + \"{} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n            } else {\n                LOG.debug(\"Received message for an unknown checkpoint {} from {} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n                wasPendingCheckpoint = false;\n            }\n            discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n            return wasPendingCheckpoint;\n        }\n    }\n}"
    },
    {
      "commit": "f63426b0322e05fd0986ae5f224a69b1320724f6",
      "startLine": 38,
      "endLine": 45,
      "methodCode": "public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {\n    if (shutdown || message == null) {\n        return false;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received wrong AcknowledgeCheckpoint message for job {}: {}\", job, message);\n        return false;\n    }\n    final long checkpointId = message.getCheckpointId();\n    synchronized (lock) {\n        if (shutdown) {\n            return false;\n        }\n        final PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId);\n        if (checkpoint != null && !checkpoint.isDiscarded()) {\n            switch(checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetaData())) {\n                case SUCCESS:\n                    LOG.debug(\"Received acknowledge message for checkpoint {} from task {} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n                    if (checkpoint.isFullyAcknowledged()) {\n                        completePendingCheckpoint(checkpoint);\n                    }\n                    break;\n                case DUPLICATE:\n                    LOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    break;\n                case UNKNOWN:\n                    LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the task's execution attempt id was unknown. Discarding \" + \"the state handle to avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n                    break;\n                case DISCARDED:\n                    LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the pending checkpoint had been discarded. Discarding the \" + \"state handle tp avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n            }\n            return true;\n        } else if (checkpoint != null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            boolean wasPendingCheckpoint;\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                wasPendingCheckpoint = true;\n                LOG.warn(\"Received late message for now expired checkpoint attempt {} from \" + \"{} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n            } else {\n                LOG.debug(\"Received message for an unknown checkpoint {} from {} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n                wasPendingCheckpoint = false;\n            }\n            discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n            return wasPendingCheckpoint;\n        }\n    }\n}"
    },
    {
      "commit": "579bc96446d598a2cfe8237b4ebd62d8c9df3483",
      "startLine": 38,
      "endLine": 45,
      "methodCode": "public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {\n    if (shutdown || message == null) {\n        return false;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received wrong AcknowledgeCheckpoint message for job {}: {}\", job, message);\n        return false;\n    }\n    final long checkpointId = message.getCheckpointId();\n    synchronized (lock) {\n        if (shutdown) {\n            return false;\n        }\n        final PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId);\n        if (checkpoint != null && !checkpoint.isDiscarded()) {\n            switch(checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetaData())) {\n                case SUCCESS:\n                    LOG.debug(\"Received acknowledge message for checkpoint {} from task {} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n                    if (checkpoint.isFullyAcknowledged()) {\n                        completePendingCheckpoint(checkpoint);\n                    }\n                    break;\n                case DUPLICATE:\n                    LOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    break;\n                case UNKNOWN:\n                    LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the task's execution attempt id was unknown. Discarding \" + \"the state handle to avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n                    break;\n                case DISCARDED:\n                    LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the pending checkpoint had been discarded. Discarding the \" + \"state handle tp avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n            }\n            return true;\n        } else if (checkpoint != null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            boolean wasPendingCheckpoint;\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                wasPendingCheckpoint = true;\n                LOG.warn(\"Received late message for now expired checkpoint attempt {} from \" + \"{} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n            } else {\n                LOG.debug(\"Received message for an unknown checkpoint {} from {} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n                wasPendingCheckpoint = false;\n            }\n            discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n            return wasPendingCheckpoint;\n        }\n    }\n}"
    },
    {
      "commit": "0c42d258e9d9d30eeeee7d0f1487ef0ac8b90fa4",
      "startLine": 38,
      "endLine": 45,
      "methodCode": "public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {\n    if (shutdown || message == null) {\n        return false;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received wrong AcknowledgeCheckpoint message for job {}: {}\", job, message);\n        return false;\n    }\n    final long checkpointId = message.getCheckpointId();\n    synchronized (lock) {\n        if (shutdown) {\n            return false;\n        }\n        final PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId);\n        if (checkpoint != null && !checkpoint.isDiscarded()) {\n            switch(checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n                case SUCCESS:\n                    LOG.debug(\"Received acknowledge message for checkpoint {} from task {} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n                    if (checkpoint.isFullyAcknowledged()) {\n                        completePendingCheckpoint(checkpoint);\n                    }\n                    break;\n                case DUPLICATE:\n                    LOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    break;\n                case UNKNOWN:\n                    LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the task's execution attempt id was unknown. Discarding \" + \"the state handle to avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n                    break;\n                case DISCARDED:\n                    LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the pending checkpoint had been discarded. Discarding the \" + \"state handle tp avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n            }\n            return true;\n        } else if (checkpoint != null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            boolean wasPendingCheckpoint;\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                wasPendingCheckpoint = true;\n                LOG.warn(\"Received late message for now expired checkpoint attempt {} from \" + \"{} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n            } else {\n                LOG.debug(\"Received message for an unknown checkpoint {} from {} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n                wasPendingCheckpoint = false;\n            }\n            discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n            return wasPendingCheckpoint;\n        }\n    }\n}"
    },
    {
      "commit": "ea7080712f2dcbdf125b806007c80aa3d120f30a",
      "startLine": 58,
      "endLine": 64,
      "methodCode": "public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n    if (shutdown || message == null) {\n        return false;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n        return false;\n    }\n    final long checkpointId = message.getCheckpointId();\n    CompletedCheckpoint completed = null;\n    PendingCheckpoint checkpoint;\n    boolean isPendingCheckpoint;\n    synchronized (lock) {\n        if (shutdown) {\n            return false;\n        }\n        checkpoint = pendingCheckpoints.get(checkpointId);\n        if (checkpoint != null && !checkpoint.isDiscarded()) {\n            isPendingCheckpoint = true;\n            switch(checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n                case SUCCESS:\n                    LOG.debug(\"Received acknowledge message for checkpoint {} from task {} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n                    if (checkpoint.isFullyAcknowledged()) {\n                        lastCheckpointCompletionNanos = System.nanoTime();\n                        completed = checkpoint.finalizeCheckpoint();\n                        completedCheckpointStore.addCheckpoint(completed);\n                        LOG.info(\"Completed checkpoint {} ({} bytes in {} ms).\", checkpointId, completed.getStateSize(), completed.getDuration());\n                        if (LOG.isDebugEnabled()) {\n                            StringBuilder builder = new StringBuilder();\n                            builder.append(\"Checkpoint state: \");\n                            for (TaskState state : completed.getTaskStates().values()) {\n                                builder.append(state);\n                                builder.append(\", \");\n                            }\n                            builder.delete(builder.length() - 2, builder.length());\n                            LOG.debug(builder.toString());\n                        }\n                        pendingCheckpoints.remove(checkpointId);\n                        rememberRecentCheckpointId(checkpointId);\n                        dropSubsumedCheckpoints(completed.getCheckpointID());\n                        triggerQueuedRequests();\n                    }\n                    break;\n                case DUPLICATE:\n                    LOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    break;\n                case UNKNOWN:\n                    LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the task's execution attempt id was unknown. Discarding \" + \"the state handle to avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n                    break;\n                case DISCARDED:\n                    LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the pending checkpoint had been discarded. Discarding the \" + \"state handle tp avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n            }\n        } else if (checkpoint != null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                isPendingCheckpoint = true;\n                LOG.warn(\"Received late message for now expired checkpoint attempt {} from \" + \"{} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n            } else {\n                LOG.debug(\"Received message for an unknown checkpoint {} from {} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n                isPendingCheckpoint = false;\n            }\n            discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n        }\n    }\n    if (completed != null) {\n        final long timestamp = completed.getTimestamp();\n        for (ExecutionVertex ev : tasksToCommitTo) {\n            Execution ee = ev.getCurrentExecutionAttempt();\n            if (ee != null) {\n                ee.notifyCheckpointComplete(checkpointId, timestamp);\n            }\n        }\n        statsTracker.onCompletedCheckpoint(completed);\n    }\n    return isPendingCheckpoint;\n}"
    },
    {
      "commit": "b181662be378652d6c4405841ccda6145968d145",
      "startLine": 57,
      "endLine": 63,
      "methodCode": "public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n    if (shutdown || message == null) {\n        return false;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n        return false;\n    }\n    final long checkpointId = message.getCheckpointId();\n    CompletedCheckpoint completed = null;\n    PendingCheckpoint checkpoint;\n    boolean isPendingCheckpoint;\n    synchronized (lock) {\n        if (shutdown) {\n            return false;\n        }\n        checkpoint = pendingCheckpoints.get(checkpointId);\n        if (checkpoint != null && !checkpoint.isDiscarded()) {\n            isPendingCheckpoint = true;\n            switch(checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n                case SUCCESS:\n                    if (checkpoint.isFullyAcknowledged()) {\n                        lastCheckpointCompletionNanos = System.nanoTime();\n                        completed = checkpoint.finalizeCheckpoint();\n                        completedCheckpointStore.addCheckpoint(completed);\n                        LOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" + completed.getDuration() + \" ms)\");\n                        if (LOG.isDebugEnabled()) {\n                            StringBuilder builder = new StringBuilder();\n                            builder.append(\"Checkpoint state: \");\n                            for (TaskState state : completed.getTaskStates().values()) {\n                                builder.append(state);\n                                builder.append(\", \");\n                            }\n                            builder.delete(builder.length() - 2, builder.length());\n                            LOG.debug(builder.toString());\n                        }\n                        pendingCheckpoints.remove(checkpointId);\n                        rememberRecentCheckpointId(checkpointId);\n                        dropSubsumedCheckpoints(completed.getCheckpointID());\n                        triggerQueuedRequests();\n                    }\n                    break;\n                case DUPLICATE:\n                    LOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    break;\n                case UNKNOWN:\n                    LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the task's execution attempt id was unknown. Discarding \" + \"the state handle to avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    discardState(message.getSubtaskState());\n                    break;\n                case DISCARDED:\n                    LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the pending checkpoint had been discarded. Discarding the \" + \"state handle tp avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    discardState(message.getSubtaskState());\n            }\n        } else if (checkpoint != null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                isPendingCheckpoint = true;\n                LOG.warn(\"Received late message for now expired checkpoint attempt {}.\", checkpointId);\n            } else {\n                LOG.debug(\"Received message for an unknown checkpoint {}.\", checkpointId);\n                isPendingCheckpoint = false;\n            }\n            discardState(message.getSubtaskState());\n        }\n    }\n    if (completed != null) {\n        final long timestamp = completed.getTimestamp();\n        for (ExecutionVertex ev : tasksToCommitTo) {\n            Execution ee = ev.getCurrentExecutionAttempt();\n            if (ee != null) {\n                ee.notifyCheckpointComplete(checkpointId, timestamp);\n            }\n        }\n        statsTracker.onCompletedCheckpoint(completed);\n    }\n    return isPendingCheckpoint;\n}"
    },
    {
      "commit": "dc7d8ec2c4d03c42e3d582947a3fe39a274d7f4b",
      "startLine": 56,
      "endLine": 62,
      "methodCode": "public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n    if (shutdown || message == null) {\n        return false;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n        return false;\n    }\n    final long checkpointId = message.getCheckpointId();\n    CompletedCheckpoint completed = null;\n    PendingCheckpoint checkpoint;\n    boolean isPendingCheckpoint;\n    synchronized (lock) {\n        if (shutdown) {\n            return false;\n        }\n        checkpoint = pendingCheckpoints.get(checkpointId);\n        if (checkpoint != null && !checkpoint.isDiscarded()) {\n            isPendingCheckpoint = true;\n            switch(checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n                case SUCCESS:\n                    if (checkpoint.isFullyAcknowledged()) {\n                        completed = checkpoint.finalizeCheckpoint();\n                        completedCheckpointStore.addCheckpoint(completed);\n                        LOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" + completed.getDuration() + \" ms)\");\n                        if (LOG.isDebugEnabled()) {\n                            StringBuilder builder = new StringBuilder();\n                            builder.append(\"Checkpoint state: \");\n                            for (TaskState state : completed.getTaskStates().values()) {\n                                builder.append(state);\n                                builder.append(\", \");\n                            }\n                            builder.delete(builder.length() - 2, builder.length());\n                            LOG.debug(builder.toString());\n                        }\n                        pendingCheckpoints.remove(checkpointId);\n                        rememberRecentCheckpointId(checkpointId);\n                        dropSubsumedCheckpoints(completed.getCheckpointID());\n                        triggerQueuedRequests();\n                    }\n                    break;\n                case DUPLICATE:\n                    LOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    break;\n                case UNKNOWN:\n                    LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the task's execution attempt id was unknown. Discarding \" + \"the state handle to avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    discardState(message.getSubtaskState());\n                    break;\n                case DISCARDED:\n                    LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the pending checkpoint had been discarded. Discarding the \" + \"state handle tp avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    discardState(message.getSubtaskState());\n            }\n        } else if (checkpoint != null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                isPendingCheckpoint = true;\n                LOG.warn(\"Received late message for now expired checkpoint attempt {}.\", checkpointId);\n            } else {\n                LOG.debug(\"Received message for an unknown checkpoint {}.\", checkpointId);\n                isPendingCheckpoint = false;\n            }\n            discardState(message.getSubtaskState());\n        }\n    }\n    if (completed != null) {\n        final long timestamp = completed.getTimestamp();\n        for (ExecutionVertex ev : tasksToCommitTo) {\n            Execution ee = ev.getCurrentExecutionAttempt();\n            if (ee != null) {\n                ee.notifyCheckpointComplete(checkpointId, timestamp);\n            }\n        }\n        statsTracker.onCompletedCheckpoint(completed);\n    }\n    return isPendingCheckpoint;\n}"
    },
    {
      "commit": "c590912c93a4059b40452dfa6cffbdd4d58cac13",
      "startLine": 53,
      "endLine": 59,
      "methodCode": "public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n    if (shutdown || message == null) {\n        return false;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n        return false;\n    }\n    final long checkpointId = message.getCheckpointId();\n    CompletedCheckpoint completed = null;\n    PendingCheckpoint checkpoint;\n    boolean isPendingCheckpoint;\n    synchronized (lock) {\n        if (shutdown) {\n            return false;\n        }\n        checkpoint = pendingCheckpoints.get(checkpointId);\n        if (checkpoint != null && !checkpoint.isDiscarded()) {\n            isPendingCheckpoint = true;\n            switch(checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n                case SUCCESS:\n                    if (checkpoint.isFullyAcknowledged()) {\n                        completed = checkpoint.finalizeCheckpoint();\n                        completedCheckpointStore.addCheckpoint(completed);\n                        LOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" + completed.getDuration() + \" ms)\");\n                        if (LOG.isDebugEnabled()) {\n                            StringBuilder builder = new StringBuilder();\n                            for (Map.Entry<JobVertexID, TaskState> entry : completed.getTaskStates().entrySet()) {\n                                builder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n                            }\n                            LOG.debug(builder.toString());\n                        }\n                        pendingCheckpoints.remove(checkpointId);\n                        rememberRecentCheckpointId(checkpointId);\n                        dropSubsumedCheckpoints(completed.getCheckpointID());\n                        triggerQueuedRequests();\n                    }\n                    break;\n                case DUPLICATE:\n                    LOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    break;\n                case UNKNOWN:\n                    LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the task's execution attempt id was unknown. Discarding \" + \"the state handle to avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    discardState(message.getSubtaskState());\n                    break;\n                case DISCARDED:\n                    LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the pending checkpoint had been discarded. Discarding the \" + \"state handle tp avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    discardState(message.getSubtaskState());\n            }\n        } else if (checkpoint != null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                isPendingCheckpoint = true;\n                LOG.warn(\"Received late message for now expired checkpoint attempt {}.\", checkpointId);\n            } else {\n                LOG.debug(\"Received message for an unknown checkpoint {}.\", checkpointId);\n                isPendingCheckpoint = false;\n            }\n            discardState(message.getSubtaskState());\n        }\n    }\n    if (completed != null) {\n        final long timestamp = completed.getTimestamp();\n        for (ExecutionVertex ev : tasksToCommitTo) {\n            Execution ee = ev.getCurrentExecutionAttempt();\n            if (ee != null) {\n                ee.notifyCheckpointComplete(checkpointId, timestamp);\n            }\n        }\n        statsTracker.onCompletedCheckpoint(completed);\n    }\n    return isPendingCheckpoint;\n}"
    },
    {
      "commit": "72b295b3b52dff2d0bc5b78881826e8936c370ff",
      "startLine": 61,
      "endLine": 67,
      "methodCode": "public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n    if (shutdown || message == null) {\n        return false;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n        return false;\n    }\n    final long checkpointId = message.getCheckpointId();\n    CompletedCheckpoint completed = null;\n    PendingCheckpoint checkpoint;\n    boolean isPendingCheckpoint;\n    synchronized (lock) {\n        if (shutdown) {\n            return false;\n        }\n        checkpoint = pendingCheckpoints.get(checkpointId);\n        if (checkpoint != null && !checkpoint.isDiscarded()) {\n            isPendingCheckpoint = true;\n            switch(checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n                case SUCCESS:\n                    if (checkpoint.isFullyAcknowledged()) {\n                        completed = checkpoint.finalizeCheckpoint();\n                        completedCheckpointStore.addCheckpoint(completed);\n                        LOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" + completed.getDuration() + \" ms)\");\n                        if (LOG.isDebugEnabled()) {\n                            StringBuilder builder = new StringBuilder();\n                            for (Map.Entry<JobVertexID, TaskState> entry : completed.getTaskStates().entrySet()) {\n                                builder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n                            }\n                            LOG.debug(builder.toString());\n                        }\n                        pendingCheckpoints.remove(checkpointId);\n                        rememberRecentCheckpointId(checkpointId);\n                        dropSubsumedCheckpoints(completed.getCheckpointID());\n                        triggerQueuedRequests();\n                    }\n                    break;\n                case DUPLICATE:\n                    LOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    break;\n                case UNKNOWN:\n                    LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the task's execution attempt id was unknown. Discarding \" + \"the state handle to avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    try {\n                        message.getSubtaskState().discardState();\n                    } catch (Exception e) {\n                        LOG.warn(\"Could not properly discard state for checkpoint {} of task {} of job {}.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob(), e);\n                    }\n                    break;\n                case DISCARDED:\n                    LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the pending checkpoint had been discarded. Discarding the \" + \"state handle tp avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    try {\n                        message.getSubtaskState().discardState();\n                    } catch (Exception e) {\n                        LOG.warn(\"Could not properly discard state for checkpoint {} of task {} of job {}.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob(), e);\n                    }\n            }\n        } else if (checkpoint != null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                isPendingCheckpoint = true;\n                LOG.warn(\"Received late message for now expired checkpoint attempt {}.\", checkpointId);\n            } else {\n                LOG.debug(\"Received message for an unknown checkpoint {}.\", checkpointId);\n                isPendingCheckpoint = false;\n            }\n            try {\n                message.getSubtaskState().discardState();\n            } catch (Exception e) {\n                LOG.warn(\"Could not properly discard state for checkpoint {} of task {} of job {}.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob(), e);\n            }\n        }\n    }\n    if (completed != null) {\n        final long timestamp = completed.getTimestamp();\n        for (ExecutionVertex ev : tasksToCommitTo) {\n            Execution ee = ev.getCurrentExecutionAttempt();\n            if (ee != null) {\n                ee.notifyCheckpointComplete(checkpointId, timestamp);\n            }\n        }\n        statsTracker.onCompletedCheckpoint(completed);\n    }\n    return isPendingCheckpoint;\n}"
    },
    {
      "commit": "48a48139172e86f548f3b2f1564bdc948c3fe76a",
      "startLine": 43,
      "endLine": 48,
      "methodCode": "public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n    if (shutdown || message == null) {\n        return false;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n        return false;\n    }\n    final long checkpointId = message.getCheckpointId();\n    CompletedCheckpoint completed = null;\n    PendingCheckpoint checkpoint;\n    boolean isPendingCheckpoint;\n    synchronized (lock) {\n        if (shutdown) {\n            return false;\n        }\n        checkpoint = pendingCheckpoints.get(checkpointId);\n        if (checkpoint != null && !checkpoint.isDiscarded()) {\n            isPendingCheckpoint = true;\n            if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n                if (checkpoint.isFullyAcknowledged()) {\n                    completed = checkpoint.finalizeCheckpoint();\n                    completedCheckpointStore.addCheckpoint(completed);\n                    LOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" + completed.getDuration() + \" ms)\");\n                    if (LOG.isDebugEnabled()) {\n                        StringBuilder builder = new StringBuilder();\n                        for (Map.Entry<JobVertexID, TaskState> entry : completed.getTaskStates().entrySet()) {\n                            builder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n                        }\n                        LOG.debug(builder.toString());\n                    }\n                    pendingCheckpoints.remove(checkpointId);\n                    rememberRecentCheckpointId(checkpointId);\n                    dropSubsumedCheckpoints(completed.getCheckpointID());\n                    triggerQueuedRequests();\n                }\n            } else {\n                LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint {} , task {}\", checkpointId, message.getTaskExecutionId());\n            }\n        } else if (checkpoint != null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                isPendingCheckpoint = true;\n                LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n            } else {\n                isPendingCheckpoint = false;\n            }\n        }\n    }\n    if (completed != null) {\n        final long timestamp = completed.getTimestamp();\n        for (ExecutionVertex ev : tasksToCommitTo) {\n            Execution ee = ev.getCurrentExecutionAttempt();\n            if (ee != null) {\n                ee.notifyCheckpointComplete(checkpointId, timestamp);\n            }\n        }\n        statsTracker.onCompletedCheckpoint(completed);\n    }\n    return isPendingCheckpoint;\n}"
    },
    {
      "commit": "cfb3790fb6feb6c771bccbd05d3b12c69f53657d",
      "startLine": 43,
      "endLine": 48,
      "methodCode": "public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n    if (shutdown || message == null) {\n        return false;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n        return false;\n    }\n    final long checkpointId = message.getCheckpointId();\n    CompletedCheckpoint completed = null;\n    PendingCheckpoint checkpoint;\n    boolean isPendingCheckpoint;\n    synchronized (lock) {\n        if (shutdown) {\n            return false;\n        }\n        checkpoint = pendingCheckpoints.get(checkpointId);\n        if (checkpoint != null && !checkpoint.isDiscarded()) {\n            isPendingCheckpoint = true;\n            if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n                if (checkpoint.isFullyAcknowledged()) {\n                    completed = checkpoint.finalizeCheckpoint();\n                    completedCheckpointStore.addCheckpoint(completed);\n                    LOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" + completed.getDuration() + \" ms)\");\n                    if (LOG.isDebugEnabled()) {\n                        StringBuilder builder = new StringBuilder();\n                        for (Map.Entry<JobVertexID, TaskState> entry : completed.getTaskStates().entrySet()) {\n                            builder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n                        }\n                        LOG.debug(builder.toString());\n                    }\n                    pendingCheckpoints.remove(checkpointId);\n                    rememberRecentCheckpointId(checkpointId);\n                    dropSubsumedCheckpoints(completed.getCheckpointID());\n                    triggerQueuedRequests();\n                }\n            } else {\n                LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n            }\n        } else if (checkpoint != null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                isPendingCheckpoint = true;\n                LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n            } else {\n                isPendingCheckpoint = false;\n            }\n        }\n    }\n    if (completed != null) {\n        final long timestamp = completed.getTimestamp();\n        for (ExecutionVertex ev : tasksToCommitTo) {\n            Execution ee = ev.getCurrentExecutionAttempt();\n            if (ee != null) {\n                ee.notifyCheckpointComplete(checkpointId, timestamp);\n            }\n        }\n        statsTracker.onCompletedCheckpoint(completed);\n    }\n    return isPendingCheckpoint;\n}"
    },
    {
      "commit": "cab9cd44eca83ef8cbcd2a2d070d8c79cb037977",
      "startLine": 43,
      "endLine": 48,
      "methodCode": "public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n    if (shutdown || message == null) {\n        return false;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n        return false;\n    }\n    final long checkpointId = message.getCheckpointId();\n    CompletedCheckpoint completed = null;\n    PendingCheckpoint checkpoint;\n    boolean isPendingCheckpoint;\n    synchronized (lock) {\n        if (shutdown) {\n            return false;\n        }\n        checkpoint = pendingCheckpoints.get(checkpointId);\n        if (checkpoint != null && !checkpoint.isDiscarded()) {\n            isPendingCheckpoint = true;\n            if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n                if (checkpoint.isFullyAcknowledged()) {\n                    completed = checkpoint.finalizeCheckpoint();\n                    completedCheckpointStore.addCheckpoint(completed);\n                    LOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" + completed.getDuration() + \" ms)\");\n                    if (LOG.isDebugEnabled()) {\n                        StringBuilder builder = new StringBuilder();\n                        for (Map.Entry<JobVertexID, TaskState> entry : completed.getTaskStates().entrySet()) {\n                            builder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n                        }\n                        LOG.debug(builder.toString());\n                    }\n                    pendingCheckpoints.remove(checkpointId);\n                    rememberRecentCheckpointId(checkpointId);\n                    dropSubsumedCheckpoints(completed.getCheckpointID());\n                    triggerQueuedRequests();\n                }\n            } else {\n                LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n            }\n        } else if (checkpoint != null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                isPendingCheckpoint = true;\n                LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n            } else {\n                isPendingCheckpoint = false;\n            }\n        }\n    }\n    if (completed != null) {\n        final long timestamp = completed.getTimestamp();\n        for (ExecutionVertex ev : tasksToCommitTo) {\n            Execution ee = ev.getCurrentExecutionAttempt();\n            if (ee != null) {\n                ExecutionAttemptID attemptId = ee.getAttemptId();\n                NotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n                ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n            }\n        }\n        statsTracker.onCompletedCheckpoint(completed);\n    }\n    return isPendingCheckpoint;\n}"
    },
    {
      "commit": "53ed6adac8cbe6b5dcb692dc9b94970f3ec5887c",
      "startLine": 43,
      "endLine": 48,
      "methodCode": "public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n    if (shutdown || message == null) {\n        return false;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n        return false;\n    }\n    final long checkpointId = message.getCheckpointId();\n    CompletedCheckpoint completed = null;\n    PendingCheckpoint checkpoint;\n    boolean isPendingCheckpoint;\n    synchronized (lock) {\n        if (shutdown) {\n            return false;\n        }\n        checkpoint = pendingCheckpoints.get(checkpointId);\n        if (checkpoint != null && !checkpoint.isDiscarded()) {\n            isPendingCheckpoint = true;\n            if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getCheckpointStateHandles())) {\n                if (checkpoint.isFullyAcknowledged()) {\n                    completed = checkpoint.finalizeCheckpoint();\n                    completedCheckpointStore.addCheckpoint(completed);\n                    LOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" + completed.getDuration() + \" ms)\");\n                    if (LOG.isDebugEnabled()) {\n                        StringBuilder builder = new StringBuilder();\n                        for (Map.Entry<JobVertexID, TaskState> entry : completed.getTaskStates().entrySet()) {\n                            builder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n                        }\n                        LOG.debug(builder.toString());\n                    }\n                    pendingCheckpoints.remove(checkpointId);\n                    rememberRecentCheckpointId(checkpointId);\n                    dropSubsumedCheckpoints(completed.getCheckpointID());\n                    triggerQueuedRequests();\n                }\n            } else {\n                LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n            }\n        } else if (checkpoint != null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                isPendingCheckpoint = true;\n                LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n            } else {\n                isPendingCheckpoint = false;\n            }\n        }\n    }\n    if (completed != null) {\n        final long timestamp = completed.getTimestamp();\n        for (ExecutionVertex ev : tasksToCommitTo) {\n            Execution ee = ev.getCurrentExecutionAttempt();\n            if (ee != null) {\n                ExecutionAttemptID attemptId = ee.getAttemptId();\n                NotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n                ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n            }\n        }\n        statsTracker.onCompletedCheckpoint(completed);\n    }\n    return isPendingCheckpoint;\n}"
    },
    {
      "commit": "847ead01f2f0aaf318b2b1ba8501bc697d245900",
      "startLine": 43,
      "endLine": 48,
      "methodCode": "public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n    if (shutdown || message == null) {\n        return false;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n        return false;\n    }\n    final long checkpointId = message.getCheckpointId();\n    CompletedCheckpoint completed = null;\n    PendingCheckpoint checkpoint;\n    boolean isPendingCheckpoint;\n    synchronized (lock) {\n        if (shutdown) {\n            return false;\n        }\n        checkpoint = pendingCheckpoints.get(checkpointId);\n        if (checkpoint != null && !checkpoint.isDiscarded()) {\n            isPendingCheckpoint = true;\n            if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getStateHandle(), message.getKeyGroupsStateHandle())) {\n                if (checkpoint.isFullyAcknowledged()) {\n                    completed = checkpoint.finalizeCheckpoint();\n                    completedCheckpointStore.addCheckpoint(completed);\n                    LOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" + completed.getDuration() + \" ms)\");\n                    if (LOG.isDebugEnabled()) {\n                        StringBuilder builder = new StringBuilder();\n                        for (Map.Entry<JobVertexID, TaskState> entry : completed.getTaskStates().entrySet()) {\n                            builder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n                        }\n                        LOG.debug(builder.toString());\n                    }\n                    pendingCheckpoints.remove(checkpointId);\n                    rememberRecentCheckpointId(checkpointId);\n                    dropSubsumedCheckpoints(completed.getCheckpointID());\n                    triggerQueuedRequests();\n                }\n            } else {\n                LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n            }\n        } else if (checkpoint != null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                isPendingCheckpoint = true;\n                LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n            } else {\n                isPendingCheckpoint = false;\n            }\n        }\n    }\n    if (completed != null) {\n        final long timestamp = completed.getTimestamp();\n        for (ExecutionVertex ev : tasksToCommitTo) {\n            Execution ee = ev.getCurrentExecutionAttempt();\n            if (ee != null) {\n                ExecutionAttemptID attemptId = ee.getAttemptId();\n                NotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n                ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n            }\n        }\n        statsTracker.onCompletedCheckpoint(completed);\n    }\n    return isPendingCheckpoint;\n}"
    },
    {
      "commit": "4e9d1775b5514c87981c78d55323cc2b17361867",
      "startLine": 43,
      "endLine": 48,
      "methodCode": "public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n    if (shutdown || message == null) {\n        return false;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n        return false;\n    }\n    final long checkpointId = message.getCheckpointId();\n    CompletedCheckpoint completed = null;\n    PendingCheckpoint checkpoint;\n    boolean isPendingCheckpoint;\n    synchronized (lock) {\n        if (shutdown) {\n            return false;\n        }\n        checkpoint = pendingCheckpoints.get(checkpointId);\n        if (checkpoint != null && !checkpoint.isDiscarded()) {\n            isPendingCheckpoint = true;\n            if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState(), message.getStateSize(), null)) {\n                if (checkpoint.isFullyAcknowledged()) {\n                    completed = checkpoint.finalizeCheckpoint();\n                    completedCheckpointStore.addCheckpoint(completed);\n                    LOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" + completed.getDuration() + \" ms)\");\n                    if (LOG.isDebugEnabled()) {\n                        StringBuilder builder = new StringBuilder();\n                        for (Map.Entry<JobVertexID, TaskState> entry : completed.getTaskStates().entrySet()) {\n                            builder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n                        }\n                        LOG.debug(builder.toString());\n                    }\n                    pendingCheckpoints.remove(checkpointId);\n                    rememberRecentCheckpointId(checkpointId);\n                    dropSubsumedCheckpoints(completed.getCheckpointID());\n                    triggerQueuedRequests();\n                }\n            } else {\n                LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n            }\n        } else if (checkpoint != null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                isPendingCheckpoint = true;\n                LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n            } else {\n                isPendingCheckpoint = false;\n            }\n        }\n    }\n    if (completed != null) {\n        final long timestamp = completed.getTimestamp();\n        for (ExecutionVertex ev : tasksToCommitTo) {\n            Execution ee = ev.getCurrentExecutionAttempt();\n            if (ee != null) {\n                ExecutionAttemptID attemptId = ee.getAttemptId();\n                NotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n                ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n            }\n        }\n        statsTracker.onCompletedCheckpoint(completed);\n    }\n    return isPendingCheckpoint;\n}"
    },
    {
      "commit": "76ca1a7955fedd8583a0af12289a14d0f1bcf868",
      "startLine": 43,
      "endLine": 48,
      "methodCode": "public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n    if (shutdown || message == null) {\n        return false;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n        return false;\n    }\n    final long checkpointId = message.getCheckpointId();\n    CompletedCheckpoint completed = null;\n    PendingCheckpoint checkpoint;\n    boolean isPendingCheckpoint;\n    synchronized (lock) {\n        if (shutdown) {\n            return false;\n        }\n        checkpoint = pendingCheckpoints.get(checkpointId);\n        if (checkpoint != null && !checkpoint.isDiscarded()) {\n            isPendingCheckpoint = true;\n            if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState(), message.getStateSize(), null)) {\n                if (checkpoint.isFullyAcknowledged()) {\n                    completed = checkpoint.finalizeCheckpoint();\n                    completedCheckpointStore.addCheckpoint(completed);\n                    LOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" + completed.getDuration() + \" ms)\");\n                    if (LOG.isDebugEnabled()) {\n                        StringBuilder builder = new StringBuilder();\n                        for (Map.Entry<JobVertexID, TaskState> entry : completed.getTaskStates().entrySet()) {\n                            builder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n                        }\n                        LOG.debug(builder.toString());\n                    }\n                    pendingCheckpoints.remove(checkpointId);\n                    rememberRecentCheckpointId(checkpointId);\n                    dropSubsumedCheckpoints(completed.getTimestamp());\n                    triggerQueuedRequests();\n                }\n            } else {\n                LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n            }\n        } else if (checkpoint != null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                isPendingCheckpoint = true;\n                LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n            } else {\n                isPendingCheckpoint = false;\n            }\n        }\n    }\n    if (completed != null) {\n        final long timestamp = completed.getTimestamp();\n        for (ExecutionVertex ev : tasksToCommitTo) {\n            Execution ee = ev.getCurrentExecutionAttempt();\n            if (ee != null) {\n                ExecutionAttemptID attemptId = ee.getAttemptId();\n                NotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n                ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n            }\n        }\n        statsTracker.onCompletedCheckpoint(completed);\n    }\n    return isPendingCheckpoint;\n}"
    },
    {
      "commit": "f0ac261add2eb184358d5b89bc90b13aef7b267d",
      "startLine": 44,
      "endLine": 49,
      "methodCode": "public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n    if (shutdown || message == null) {\n        return false;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n        return false;\n    }\n    final long checkpointId = message.getCheckpointId();\n    CompletedCheckpoint completed = null;\n    PendingCheckpoint checkpoint;\n    boolean isPendingCheckpoint;\n    synchronized (lock) {\n        if (shutdown) {\n            return false;\n        }\n        checkpoint = pendingCheckpoints.get(checkpointId);\n        if (checkpoint != null && !checkpoint.isDiscarded()) {\n            isPendingCheckpoint = true;\n            if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState(), message.getStateSize(), null)) {\n                if (checkpoint.isFullyAcknowledged()) {\n                    completed = checkpoint.finalizeCheckpoint();\n                    completedCheckpointStore.addCheckpoint(completed);\n                    LOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" + completed.getDuration() + \" ms)\");\n                    if (LOG.isDebugEnabled()) {\n                        StringBuilder builder = new StringBuilder();\n                        for (Map.Entry<JobVertexID, TaskState> entry : completed.getTaskStates().entrySet()) {\n                            builder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n                        }\n                        LOG.debug(builder.toString());\n                    }\n                    pendingCheckpoints.remove(checkpointId);\n                    rememberRecentCheckpointId(checkpointId);\n                    dropSubsumedCheckpoints(completed.getTimestamp());\n                    onFullyAcknowledgedCheckpoint(completed);\n                    triggerQueuedRequests();\n                }\n            } else {\n                LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n            }\n        } else if (checkpoint != null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                isPendingCheckpoint = true;\n                LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n            } else {\n                isPendingCheckpoint = false;\n            }\n        }\n    }\n    if (completed != null) {\n        final long timestamp = completed.getTimestamp();\n        for (ExecutionVertex ev : tasksToCommitTo) {\n            Execution ee = ev.getCurrentExecutionAttempt();\n            if (ee != null) {\n                ExecutionAttemptID attemptId = ee.getAttemptId();\n                NotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n                ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n            }\n        }\n        statsTracker.onCompletedCheckpoint(completed);\n    }\n    return isPendingCheckpoint;\n}"
    },
    {
      "commit": "0cf04108f70375d41ebb7c39629db3a081bd2876",
      "startLine": 44,
      "endLine": 49,
      "methodCode": "public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n    if (shutdown || message == null) {\n        return false;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n        return false;\n    }\n    final long checkpointId = message.getCheckpointId();\n    CompletedCheckpoint completed = null;\n    PendingCheckpoint checkpoint;\n    boolean isPendingCheckpoint;\n    synchronized (lock) {\n        if (shutdown) {\n            return false;\n        }\n        checkpoint = pendingCheckpoints.get(checkpointId);\n        if (checkpoint != null && !checkpoint.isDiscarded()) {\n            isPendingCheckpoint = true;\n            if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState(), message.getStateSize(), null)) {\n                if (checkpoint.isFullyAcknowledged()) {\n                    completed = checkpoint.toCompletedCheckpoint();\n                    completedCheckpointStore.addCheckpoint(completed);\n                    LOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" + completed.getDuration() + \" ms)\");\n                    if (LOG.isDebugEnabled()) {\n                        StringBuilder builder = new StringBuilder();\n                        for (Map.Entry<JobVertexID, TaskState> entry : completed.getTaskStates().entrySet()) {\n                            builder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n                        }\n                        LOG.debug(builder.toString());\n                    }\n                    pendingCheckpoints.remove(checkpointId);\n                    rememberRecentCheckpointId(checkpointId);\n                    dropSubsumedCheckpoints(completed.getTimestamp());\n                    onFullyAcknowledgedCheckpoint(completed);\n                    triggerQueuedRequests();\n                }\n            } else {\n                LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n            }\n        } else if (checkpoint != null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                isPendingCheckpoint = true;\n                LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n            } else {\n                isPendingCheckpoint = false;\n            }\n        }\n    }\n    if (completed != null) {\n        final long timestamp = completed.getTimestamp();\n        for (ExecutionVertex ev : tasksToCommitTo) {\n            Execution ee = ev.getCurrentExecutionAttempt();\n            if (ee != null) {\n                ExecutionAttemptID attemptId = ee.getAttemptId();\n                NotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n                ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n            }\n        }\n        statsTracker.onCompletedCheckpoint(completed);\n    }\n    return isPendingCheckpoint;\n}"
    },
    {
      "commit": "d739ee2532e0fd49ef37508b1c2e4a355473aaa5",
      "startLine": 38,
      "endLine": 43,
      "methodCode": "public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n    if (shutdown || message == null) {\n        return false;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n        return false;\n    }\n    final long checkpointId = message.getCheckpointId();\n    CompletedCheckpoint completed = null;\n    PendingCheckpoint checkpoint;\n    boolean isPendingCheckpoint;\n    synchronized (lock) {\n        if (shutdown) {\n            return false;\n        }\n        checkpoint = pendingCheckpoints.get(checkpointId);\n        if (checkpoint != null && !checkpoint.isDiscarded()) {\n            isPendingCheckpoint = true;\n            if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState(), message.getStateSize())) {\n                if (checkpoint.isFullyAcknowledged()) {\n                    completed = checkpoint.toCompletedCheckpoint();\n                    completedCheckpointStore.addCheckpoint(completed);\n                    LOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" + completed.getDuration() + \" ms)\");\n                    LOG.debug(completed.getStates().toString());\n                    pendingCheckpoints.remove(checkpointId);\n                    rememberRecentCheckpointId(checkpointId);\n                    dropSubsumedCheckpoints(completed.getTimestamp());\n                    onFullyAcknowledgedCheckpoint(completed);\n                    triggerQueuedRequests();\n                }\n            } else {\n                LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n            }\n        } else if (checkpoint != null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                isPendingCheckpoint = true;\n                LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n            } else {\n                isPendingCheckpoint = false;\n            }\n        }\n    }\n    if (completed != null) {\n        final long timestamp = completed.getTimestamp();\n        for (ExecutionVertex ev : tasksToCommitTo) {\n            Execution ee = ev.getCurrentExecutionAttempt();\n            if (ee != null) {\n                ExecutionAttemptID attemptId = ee.getAttemptId();\n                NotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n                ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n            }\n        }\n        statsTracker.onCompletedCheckpoint(completed);\n    }\n    return isPendingCheckpoint;\n}"
    },
    {
      "commit": "2c7e63ae9ecc38c33f0b45df21bd324c2e597ef2",
      "startLine": 35,
      "endLine": 39,
      "methodCode": "public void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n    if (shutdown || message == null) {\n        return;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n        return;\n    }\n    final long checkpointId = message.getCheckpointId();\n    CompletedCheckpoint completed = null;\n    PendingCheckpoint checkpoint;\n    synchronized (lock) {\n        if (shutdown) {\n            return;\n        }\n        checkpoint = pendingCheckpoints.get(checkpointId);\n        if (checkpoint != null && !checkpoint.isDiscarded()) {\n            if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState(), message.getStateSize())) {\n                if (checkpoint.isFullyAcknowledged()) {\n                    completed = checkpoint.toCompletedCheckpoint();\n                    completedCheckpointStore.addCheckpoint(completed);\n                    LOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" + completed.getDuration() + \" ms)\");\n                    LOG.debug(completed.getStates().toString());\n                    pendingCheckpoints.remove(checkpointId);\n                    rememberRecentCheckpointId(checkpointId);\n                    dropSubsumedCheckpoints(completed.getTimestamp());\n                    triggerQueuedRequests();\n                }\n            } else {\n                LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n            }\n        } else if (checkpoint != null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n            } else {\n                LOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n            }\n        }\n    }\n    if (completed != null) {\n        final long timestamp = completed.getTimestamp();\n        for (ExecutionVertex ev : tasksToCommitTo) {\n            Execution ee = ev.getCurrentExecutionAttempt();\n            if (ee != null) {\n                ExecutionAttemptID attemptId = ee.getAttemptId();\n                NotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n                ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n            }\n        }\n        statsTracker.onCompletedCheckpoint(completed);\n    }\n}"
    },
    {
      "commit": "55fd5f32d7ef0292a01192ab08456fae49b91791",
      "startLine": 35,
      "endLine": 39,
      "methodCode": "public void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n    if (shutdown || message == null) {\n        return;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n        return;\n    }\n    final long checkpointId = message.getCheckpointId();\n    CompletedCheckpoint completed = null;\n    PendingCheckpoint checkpoint;\n    synchronized (lock) {\n        if (shutdown) {\n            return;\n        }\n        checkpoint = pendingCheckpoints.get(checkpointId);\n        if (checkpoint != null && !checkpoint.isDiscarded()) {\n            if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n                if (checkpoint.isFullyAcknowledged()) {\n                    completed = checkpoint.toCompletedCheckpoint();\n                    completedCheckpointStore.addCheckpoint(completed);\n                    LOG.info(\"Completed checkpoint \" + checkpointId);\n                    LOG.debug(completed.getStates().toString());\n                    pendingCheckpoints.remove(checkpointId);\n                    rememberRecentCheckpointId(checkpointId);\n                    dropSubsumedCheckpoints(completed.getTimestamp());\n                    triggerQueuedRequests();\n                }\n            } else {\n                LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n            }\n        } else if (checkpoint != null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n            } else {\n                LOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n            }\n        }\n    }\n    if (completed != null) {\n        final long timestamp = completed.getTimestamp();\n        for (ExecutionVertex ev : tasksToCommitTo) {\n            Execution ee = ev.getCurrentExecutionAttempt();\n            if (ee != null) {\n                ExecutionAttemptID attemptId = ee.getAttemptId();\n                NotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n                ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n            }\n        }\n    }\n}"
    },
    {
      "commit": "73c73e92750ab8fb068d0a3cb37afcb642084fc0",
      "startLine": 34,
      "endLine": 38,
      "methodCode": "public void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n    if (shutdown || message == null) {\n        return;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n        return;\n    }\n    final long checkpointId = message.getCheckpointId();\n    CompletedCheckpoint completed = null;\n    PendingCheckpoint checkpoint;\n    synchronized (lock) {\n        if (shutdown) {\n            return;\n        }\n        checkpoint = pendingCheckpoints.get(checkpointId);\n        if (checkpoint != null && !checkpoint.isDiscarded()) {\n            if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n                if (checkpoint.isFullyAcknowledged()) {\n                    completed = checkpoint.toCompletedCheckpoint();\n                    completedCheckpointStore.addCheckpoint(completed);\n                    LOG.info(\"Completed checkpoint \" + checkpointId);\n                    LOG.debug(completed.getStates().toString());\n                    pendingCheckpoints.remove(checkpointId);\n                    rememberRecentCheckpointId(checkpointId);\n                    dropSubsumedCheckpoints(completed.getTimestamp());\n                }\n            } else {\n                LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n            }\n        } else if (checkpoint != null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n            } else {\n                LOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n            }\n        }\n    }\n    if (completed != null) {\n        final long timestamp = completed.getTimestamp();\n        for (ExecutionVertex ev : tasksToCommitTo) {\n            Execution ee = ev.getCurrentExecutionAttempt();\n            if (ee != null) {\n                ExecutionAttemptID attemptId = ee.getAttemptId();\n                NotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n                ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n            }\n        }\n    }\n}"
    },
    {
      "commit": "aa5e5b3087a68f2aac792c0b0fc64b4f9c707e9b",
      "startLine": 36,
      "endLine": 40,
      "methodCode": "public void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) {\n    if (shutdown || message == null) {\n        return;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n        return;\n    }\n    final long checkpointId = message.getCheckpointId();\n    SuccessfulCheckpoint completed = null;\n    PendingCheckpoint checkpoint;\n    synchronized (lock) {\n        if (shutdown) {\n            return;\n        }\n        checkpoint = pendingCheckpoints.get(checkpointId);\n        if (checkpoint != null && !checkpoint.isDiscarded()) {\n            if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n                if (checkpoint.isFullyAcknowledged()) {\n                    LOG.info(\"Completed checkpoint \" + checkpointId);\n                    completed = checkpoint.toCompletedCheckpoint();\n                    completedCheckpoints.addLast(completed);\n                    if (completedCheckpoints.size() > numSuccessfulCheckpointsToRetain) {\n                        completedCheckpoints.removeFirst().discard(userClassLoader);\n                    }\n                    pendingCheckpoints.remove(checkpointId);\n                    rememberRecentCheckpointId(checkpointId);\n                    dropSubsumedCheckpoints(completed.getTimestamp());\n                }\n            } else {\n                LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n            }\n        } else if (checkpoint != null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n            } else {\n                LOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n            }\n        }\n    }\n    if (completed != null) {\n        final long timestamp = completed.getTimestamp();\n        for (ExecutionVertex ev : tasksToCommitTo) {\n            Execution ee = ev.getCurrentExecutionAttempt();\n            if (ee != null) {\n                ExecutionAttemptID attemptId = ee.getAttemptId();\n                NotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n                ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n            }\n        }\n    }\n}"
    },
    {
      "commit": "0ecab82add0946503a000162813bb820f6f3b4d4",
      "startLine": 36,
      "endLine": 40,
      "methodCode": "public void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) {\n    if (shutdown || message == null) {\n        return;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n        return;\n    }\n    final long checkpointId = message.getCheckpointId();\n    SuccessfulCheckpoint completed = null;\n    PendingCheckpoint checkpoint;\n    synchronized (lock) {\n        if (shutdown) {\n            return;\n        }\n        checkpoint = pendingCheckpoints.get(checkpointId);\n        if (checkpoint != null && !checkpoint.isDiscarded()) {\n            if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n                if (checkpoint.isFullyAcknowledged()) {\n                    LOG.info(\"Completed checkpoint \" + checkpointId);\n                    completed = checkpoint.toCompletedCheckpoint();\n                    completedCheckpoints.addLast(completed);\n                    if (completedCheckpoints.size() > numSuccessfulCheckpointsToRetain) {\n                        completedCheckpoints.removeFirst().discard(userClassLoader);\n                    }\n                    pendingCheckpoints.remove(checkpointId);\n                    rememberRecentCheckpointId(checkpointId);\n                    dropSubsumedCheckpoints(completed.getTimestamp());\n                }\n            } else {\n                LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n            }\n        } else if (checkpoint != null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n            } else {\n                LOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n            }\n        }\n    }\n    if (completed != null) {\n        final long timestamp = completed.getTimestamp();\n        for (ExecutionVertex ev : tasksToCommitTo) {\n            Execution ee = ev.getCurrentExecutionAttempt();\n            if (ee != null) {\n                ExecutionAttemptID attemptId = ee.getAttemptId();\n                StateForTask stateForTask = completed.getState(ev.getJobvertexId());\n                SerializedValue<StateHandle<?>> taskState = (stateForTask != null) ? stateForTask.getState() : null;\n                ConfirmCheckpoint confirmMessage = new ConfirmCheckpoint(job, attemptId, checkpointId, timestamp, taskState);\n                ev.sendMessageToCurrentExecution(confirmMessage, ee.getAttemptId());\n            }\n        }\n    }\n}"
    },
    {
      "commit": "f27c3f1d1cbff7433a23227e75f2f8e30058397a",
      "startLine": 36,
      "endLine": 40,
      "methodCode": "public void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) {\n    if (shutdown || message == null) {\n        return;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n        return;\n    }\n    final long checkpointId = message.getCheckpointId();\n    SuccessfulCheckpoint completed = null;\n    PendingCheckpoint checkpoint;\n    synchronized (lock) {\n        if (shutdown) {\n            return;\n        }\n        checkpoint = pendingCheckpoints.get(checkpointId);\n        if (checkpoint != null && !checkpoint.isDiscarded()) {\n            if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n                if (checkpoint.isFullyAcknowledged()) {\n                    LOG.info(\"Completed checkpoint \" + checkpointId);\n                    completed = checkpoint.toCompletedCheckpoint();\n                    completedCheckpoints.addLast(completed);\n                    if (completedCheckpoints.size() > numSuccessfulCheckpointsToRetain) {\n                        completedCheckpoints.removeFirst().discard(userClassLoader);\n                    }\n                    pendingCheckpoints.remove(checkpointId);\n                    rememberRecentCheckpointId(checkpointId);\n                    dropSubsumedCheckpoints(completed.getTimestamp());\n                }\n            } else {\n                LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n            }\n        } else if (checkpoint != null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n            } else {\n                LOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n            }\n        }\n    }\n    if (completed != null) {\n        final long timestamp = completed.getTimestamp();\n        for (ExecutionVertex ev : tasksToCommitTo) {\n            Execution ee = ev.getCurrentExecutionAttempt();\n            if (ee != null) {\n                ExecutionAttemptID attemptId = ee.getAttemptId();\n                ConfirmCheckpoint confirmMessage = new ConfirmCheckpoint(job, attemptId, checkpointId, timestamp, completed.getState(ev.getJobvertexId()).getState());\n                ev.sendMessageToCurrentExecution(confirmMessage, ee.getAttemptId());\n            }\n        }\n    }\n}"
    },
    {
      "commit": "197cd6cf0fb10efc6badd5fc8584f4b36b09e705",
      "startLine": 35,
      "endLine": 39,
      "methodCode": "public void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) {\n    if (shutdown || message == null) {\n        return;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n        return;\n    }\n    final long checkpointId = message.getCheckpointId();\n    SuccessfulCheckpoint completed = null;\n    synchronized (lock) {\n        if (shutdown) {\n            return;\n        }\n        PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId);\n        if (checkpoint != null && !checkpoint.isDiscarded()) {\n            if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n                if (checkpoint.isFullyAcknowledged()) {\n                    LOG.info(\"Completed checkpoint \" + checkpointId);\n                    completed = checkpoint.toCompletedCheckpoint();\n                    completedCheckpoints.addLast(completed);\n                    if (completedCheckpoints.size() > numSuccessfulCheckpointsToRetain) {\n                        completedCheckpoints.removeFirst().discard(userClassLoader);\n                    }\n                    pendingCheckpoints.remove(checkpointId);\n                    rememberRecentCheckpointId(checkpointId);\n                    dropSubsumedCheckpoints(completed.getTimestamp());\n                }\n            } else {\n                LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n            }\n        } else if (checkpoint != null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n            } else {\n                LOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n            }\n        }\n    }\n    if (completed != null) {\n        final long timestamp = completed.getTimestamp();\n        for (ExecutionVertex ev : tasksToCommitTo) {\n            Execution ee = ev.getCurrentExecutionAttempt();\n            if (ee != null) {\n                ExecutionAttemptID attemptId = ee.getAttemptId();\n                ConfirmCheckpoint confirmMessage = new ConfirmCheckpoint(job, attemptId, checkpointId, timestamp);\n                ev.sendMessageToCurrentExecution(confirmMessage, ee.getAttemptId());\n            }\n        }\n    }\n}"
    },
    {
      "commit": "59bee4ad825d7252c791e0376ea2504602134fe7",
      "startLine": 36,
      "endLine": 40,
      "methodCode": "public void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) {\n    if (shutdown || message == null) {\n        return;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n        return;\n    }\n    final long checkpointId = message.getCheckpointId();\n    SuccessfulCheckpoint completed = null;\n    synchronized (lock) {\n        if (shutdown) {\n            return;\n        }\n        PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId);\n        if (checkpoint != null && !checkpoint.isDiscarded()) {\n            if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n                if (checkpoint.isFullyAcknowledged()) {\n                    LOG.info(\"Completed checkpoint \" + checkpointId);\n                    completed = checkpoint.toCompletedCheckpoint();\n                    completedCheckpoints.addLast(completed);\n                    if (completedCheckpoints.size() > numSuccessfulCheckpointsToRetain) {\n                        completedCheckpoints.removeFirst().dispose(userClassLoader);\n                        ;\n                    }\n                    pendingCheckpoints.remove(checkpointId);\n                    rememberRecentCheckpointId(checkpointId);\n                    dropSubsumedCheckpoints(completed.getTimestamp());\n                }\n            } else {\n                LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n            }\n        } else if (checkpoint != null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n            } else {\n                LOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n            }\n        }\n    }\n    if (completed != null) {\n        final long timestamp = completed.getTimestamp();\n        for (ExecutionVertex ev : tasksToCommitTo) {\n            Execution ee = ev.getCurrentExecutionAttempt();\n            if (ee != null) {\n                ExecutionAttemptID attemptId = ee.getAttemptId();\n                ConfirmCheckpoint confirmMessage = new ConfirmCheckpoint(job, attemptId, checkpointId, timestamp);\n                ev.sendMessageToCurrentExecution(confirmMessage, ee.getAttemptId());\n            }\n        }\n    }\n}"
    },
    {
      "commit": "9b7f8aa121e4a231632296d0809029aca9ebde6a",
      "startLine": 35,
      "endLine": 39,
      "methodCode": "public void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) {\n    if (shutdown || message == null) {\n        return;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n        return;\n    }\n    final long checkpointId = message.getCheckpointId();\n    SuccessfulCheckpoint completed = null;\n    synchronized (lock) {\n        if (shutdown) {\n            return;\n        }\n        PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId);\n        if (checkpoint != null && !checkpoint.isDiscarded()) {\n            if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n                if (checkpoint.isFullyAcknowledged()) {\n                    LOG.info(\"Completed checkpoint \" + checkpointId);\n                    completed = checkpoint.toCompletedCheckpoint();\n                    completedCheckpoints.addLast(completed);\n                    if (completedCheckpoints.size() > numSuccessfulCheckpointsToRetain) {\n                        completedCheckpoints.removeFirst();\n                    }\n                    pendingCheckpoints.remove(checkpointId);\n                    rememberRecentCheckpointId(checkpointId);\n                    dropSubsumedCheckpoints(completed.getTimestamp());\n                }\n            } else {\n                LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n            }\n        } else if (checkpoint != null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n            } else {\n                LOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n            }\n        }\n    }\n    if (completed != null) {\n        final long timestamp = completed.getTimestamp();\n        for (ExecutionVertex ev : tasksToCommitTo) {\n            Execution ee = ev.getCurrentExecutionAttempt();\n            if (ee != null) {\n                ExecutionAttemptID attemptId = ee.getAttemptId();\n                ConfirmCheckpoint confirmMessage = new ConfirmCheckpoint(job, attemptId, checkpointId, timestamp);\n                ev.sendMessageToCurrentExecution(confirmMessage, ee.getAttemptId());\n            }\n        }\n    }\n}"
    },
    {
      "commit": "7f0ce1428bc32181d6d79ca6f1226b9e2e3d93be",
      "startLine": 36,
      "endLine": 40,
      "methodCode": "public void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) {\n    if (shutdown || message == null) {\n        return;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n        return;\n    }\n    final long checkpointId = message.getCheckpointId();\n    boolean checkpointCompleted = false;\n    synchronized (lock) {\n        if (shutdown) {\n            return;\n        }\n        PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId);\n        if (checkpoint != null && !checkpoint.isDiscarded()) {\n            if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n                if (checkpoint.isFullyAcknowledged()) {\n                    LOG.info(\"Completed checkpoint \" + checkpointId);\n                    SuccessfulCheckpoint completed = checkpoint.toCompletedCheckpoint();\n                    completedCheckpoints.addLast(completed);\n                    if (completedCheckpoints.size() > numSuccessfulCheckpointsToRetain) {\n                        completedCheckpoints.removeFirst();\n                    }\n                    pendingCheckpoints.remove(checkpointId);\n                    rememberRecentCheckpointId(checkpointId);\n                    dropSubsumedCheckpoints(completed.getTimestamp());\n                    checkpointCompleted = true;\n                }\n            } else {\n                LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n            }\n        } else if (checkpoint != null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n            } else {\n                LOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n            }\n        }\n    }\n    if (checkpointCompleted) {\n        for (ExecutionVertex ev : tasksToCommitTo) {\n            Execution ee = ev.getCurrentExecutionAttempt();\n            if (ee != null) {\n                ExecutionAttemptID attemptId = ee.getAttemptId();\n                ConfirmCheckpoint confirmMessage = new ConfirmCheckpoint(job, attemptId, checkpointId);\n                ev.sendMessageToCurrentExecution(confirmMessage, ee.getAttemptId());\n            }\n        }\n    }\n}"
    }
  ]
}