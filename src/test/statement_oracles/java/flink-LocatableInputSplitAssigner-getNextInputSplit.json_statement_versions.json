{
  "statementVersions": [
    {
      "commit": "7452802bc25c0915b7347d4faf2d60adcfc27644",
      "startLine": 56,
      "endLine": 57,
      "methodCode": "@Override\npublic LocatableInputSplit getNextInputSplit(String host, int taskId) {\n    if (host == null) {\n        synchronized (this.remoteSplitChooser) {\n            synchronized (this.unassigned) {\n                LocatableInputSplitWithCount split = this.remoteSplitChooser.getNextUnassignedMinLocalCountSplit(this.unassigned);\n                if (split != null) {\n                    if (this.unassigned.remove(split)) {\n                        if (LOG.isInfoEnabled()) {\n                            LOG.info(\"Assigning split to null host (random assignment).\");\n                        }\n                        remoteAssignments++;\n                        return split.getSplit();\n                    } else {\n                        throw new IllegalStateException(\"Chosen InputSplit has already been assigned. This should not happen!\");\n                    }\n                } else {\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"No more unassigned input splits remaining.\");\n                    }\n                    return null;\n                }\n            }\n        }\n    }\n    host = host.toLowerCase(Locale.US);\n    LocatableInputSplitChooser localSplits = this.localPerHost.get(host);\n    if (localSplits == null) {\n        localSplits = new LocatableInputSplitChooser();\n        synchronized (localSplits) {\n            LocatableInputSplitChooser prior = this.localPerHost.putIfAbsent(host, localSplits);\n            if (prior == null) {\n                LocatableInputSplitWithCount[] remaining;\n                synchronized (this.unassigned) {\n                    remaining = this.unassigned.toArray(new LocatableInputSplitWithCount[this.unassigned.size()]);\n                }\n                for (LocatableInputSplitWithCount isw : remaining) {\n                    if (isLocal(host, isw.getSplit().getHostnames())) {\n                        isw.incrementLocalCount();\n                        localSplits.addInputSplit(isw);\n                    }\n                }\n            } else {\n                localSplits = prior;\n            }\n        }\n    }\n    synchronized (localSplits) {\n        synchronized (this.unassigned) {\n            LocatableInputSplitWithCount split = localSplits.getNextUnassignedMinLocalCountSplit(this.unassigned);\n            if (split != null) {\n                if (this.unassigned.remove(split)) {\n                    if (LOG.isInfoEnabled()) {\n                        LOG.info(\"Assigning local split to host \" + host);\n                    }\n                    localAssignments++;\n                    return split.getSplit();\n                } else {\n                    throw new IllegalStateException(\"Chosen InputSplit has already been assigned. This should not happen!\");\n                }\n            }\n        }\n    }\n    synchronized (this.remoteSplitChooser) {\n        synchronized (this.unassigned) {\n            LocatableInputSplitWithCount split = this.remoteSplitChooser.getNextUnassignedMinLocalCountSplit(this.unassigned);\n            if (split != null) {\n                if (this.unassigned.remove(split)) {\n                    if (LOG.isInfoEnabled()) {\n                        LOG.info(\"Assigning remote split to host \" + host);\n                    }\n                    remoteAssignments++;\n                    return split.getSplit();\n                } else {\n                    throw new IllegalStateException(\"Chosen InputSplit has already been assigned. This should not happen!\");\n                }\n            } else {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"No more input splits remaining.\");\n                }\n                return null;\n            }\n        }\n    }\n}"
    },
    {
      "commit": "e0a4ee07084bc6ab56a20fbc4a18863462da93eb",
      "startLine": 56,
      "endLine": 57,
      "methodCode": "@Override\npublic LocatableInputSplit getNextInputSplit(String host) {\n    if (host == null) {\n        synchronized (this.remoteSplitChooser) {\n            synchronized (this.unassigned) {\n                LocatableInputSplitWithCount split = this.remoteSplitChooser.getNextUnassignedMinLocalCountSplit(this.unassigned);\n                if (split != null) {\n                    if (this.unassigned.remove(split)) {\n                        if (LOG.isInfoEnabled()) {\n                            LOG.info(\"Assigning split to null host (random assignment).\");\n                        }\n                        remoteAssignments++;\n                        return split.getSplit();\n                    } else {\n                        throw new IllegalStateException(\"Chosen InputSplit has already been assigned. This should not happen!\");\n                    }\n                } else {\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"No more unassigned input splits remaining.\");\n                    }\n                    return null;\n                }\n            }\n        }\n    }\n    host = host.toLowerCase(Locale.US);\n    LocatableInputSplitChooser localSplits = this.localPerHost.get(host);\n    if (localSplits == null) {\n        localSplits = new LocatableInputSplitChooser();\n        synchronized (localSplits) {\n            LocatableInputSplitChooser prior = this.localPerHost.putIfAbsent(host, localSplits);\n            if (prior == null) {\n                LocatableInputSplitWithCount[] remaining;\n                synchronized (this.unassigned) {\n                    remaining = this.unassigned.toArray(new LocatableInputSplitWithCount[this.unassigned.size()]);\n                }\n                for (LocatableInputSplitWithCount isw : remaining) {\n                    if (isLocal(host, isw.getSplit().getHostnames())) {\n                        isw.incrementLocalCount();\n                        localSplits.addInputSplit(isw);\n                    }\n                }\n            } else {\n                localSplits = prior;\n            }\n        }\n    }\n    synchronized (localSplits) {\n        synchronized (this.unassigned) {\n            LocatableInputSplitWithCount split = localSplits.getNextUnassignedMinLocalCountSplit(this.unassigned);\n            if (split != null) {\n                if (this.unassigned.remove(split)) {\n                    if (LOG.isInfoEnabled()) {\n                        LOG.info(\"Assigning local split to host \" + host);\n                    }\n                    localAssignments++;\n                    return split.getSplit();\n                } else {\n                    throw new IllegalStateException(\"Chosen InputSplit has already been assigned. This should not happen!\");\n                }\n            }\n        }\n    }\n    synchronized (this.remoteSplitChooser) {\n        synchronized (this.unassigned) {\n            LocatableInputSplitWithCount split = this.remoteSplitChooser.getNextUnassignedMinLocalCountSplit(this.unassigned);\n            if (split != null) {\n                if (this.unassigned.remove(split)) {\n                    if (LOG.isInfoEnabled()) {\n                        LOG.info(\"Assigning remote split to host \" + host);\n                    }\n                    remoteAssignments++;\n                    return split.getSplit();\n                } else {\n                    throw new IllegalStateException(\"Chosen InputSplit has already been assigned. This should not happen!\");\n                }\n            } else {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"No more input splits remaining.\");\n                }\n                return null;\n            }\n        }\n    }\n}"
    },
    {
      "commit": "a959dd5034127161aafcf9c56222c7d08aa80e54",
      "startLine": 54,
      "endLine": 55,
      "methodCode": "@Override\npublic LocatableInputSplit getNextInputSplit(String host) {\n    if (host == null) {\n        synchronized (this.unassigned) {\n            Iterator<LocatableInputSplit> iter = this.unassigned.iterator();\n            if (iter.hasNext()) {\n                LocatableInputSplit next = iter.next();\n                iter.remove();\n                if (LOG.isInfoEnabled()) {\n                    LOG.info(\"Assigning split to null host (random assignment).\");\n                }\n                remoteAssignments++;\n                return next;\n            } else {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"No more unassigned input splits remaining.\");\n                }\n                return null;\n            }\n        }\n    }\n    host = host.toLowerCase(Locale.US);\n    List<LocatableInputSplit> localSplits = this.localPerHost.get(host);\n    if (localSplits == null) {\n        localSplits = new ArrayList<LocatableInputSplit>(16);\n        synchronized (localSplits) {\n            List<LocatableInputSplit> prior = this.localPerHost.putIfAbsent(host, localSplits);\n            if (prior == null) {\n                LocatableInputSplit[] remaining;\n                synchronized (this.unassigned) {\n                    remaining = (LocatableInputSplit[]) this.unassigned.toArray(new LocatableInputSplit[this.unassigned.size()]);\n                }\n                for (LocatableInputSplit is : remaining) {\n                    if (isLocal(host, is.getHostnames())) {\n                        localSplits.add(is);\n                    }\n                }\n            } else {\n                localSplits = prior;\n            }\n        }\n    }\n    synchronized (localSplits) {\n        int size = localSplits.size();\n        if (size > 0) {\n            synchronized (this.unassigned) {\n                do {\n                    --size;\n                    LocatableInputSplit split = localSplits.remove(size);\n                    if (this.unassigned.remove(split)) {\n                        if (LOG.isInfoEnabled()) {\n                            LOG.info(\"Assigning local split to host \" + host);\n                        }\n                        localAssignments++;\n                        return split;\n                    }\n                } while (size > 0);\n            }\n        }\n    }\n    synchronized (this.unassigned) {\n        Iterator<LocatableInputSplit> iter = this.unassigned.iterator();\n        if (iter.hasNext()) {\n            LocatableInputSplit next = iter.next();\n            iter.remove();\n            if (LOG.isInfoEnabled()) {\n                LOG.info(\"Assigning remote split to host \" + host);\n            }\n            remoteAssignments++;\n            return next;\n        } else {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"No more input splits remaining.\");\n            }\n            return null;\n        }\n    }\n}"
    },
    {
      "commit": "b6f599f1ed27a28ee0f8be7176f06a5fa43fa310",
      "startLine": 54,
      "endLine": 55,
      "methodCode": "@Override\npublic LocatableInputSplit getNextInputSplit(String host) {\n    if (host == null) {\n        synchronized (this.unassigned) {\n            Iterator<LocatableInputSplit> iter = this.unassigned.iterator();\n            if (iter.hasNext()) {\n                LocatableInputSplit next = iter.next();\n                iter.remove();\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Assigning arbitrary split to null host.\");\n                }\n                remoteAssignments++;\n                return next;\n            } else {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"No more unassigned input splits remaining.\");\n                }\n                return null;\n            }\n        }\n    }\n    host = host.toLowerCase(Locale.US);\n    List<LocatableInputSplit> localSplits = this.localPerHost.get(host);\n    if (localSplits == null) {\n        localSplits = new ArrayList<LocatableInputSplit>(16);\n        synchronized (localSplits) {\n            List<LocatableInputSplit> prior = this.localPerHost.putIfAbsent(host, localSplits);\n            if (prior == null) {\n                LocatableInputSplit[] remaining;\n                synchronized (this.unassigned) {\n                    remaining = (LocatableInputSplit[]) this.unassigned.toArray(new LocatableInputSplit[this.unassigned.size()]);\n                }\n                for (LocatableInputSplit is : remaining) {\n                    if (isLocal(host, is.getHostnames())) {\n                        localSplits.add(is);\n                    }\n                }\n            } else {\n                localSplits = prior;\n            }\n        }\n    }\n    synchronized (localSplits) {\n        int size = localSplits.size();\n        if (size > 0) {\n            synchronized (this.unassigned) {\n                do {\n                    --size;\n                    LocatableInputSplit split = localSplits.remove(size);\n                    if (this.unassigned.remove(split)) {\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"Assigning local split to host \" + host);\n                        }\n                        localAssignments++;\n                        return split;\n                    }\n                } while (size > 0);\n            }\n        }\n    }\n    synchronized (this.unassigned) {\n        Iterator<LocatableInputSplit> iter = this.unassigned.iterator();\n        if (iter.hasNext()) {\n            LocatableInputSplit next = iter.next();\n            iter.remove();\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Assigning remote split to host \" + host);\n            }\n            remoteAssignments++;\n            return next;\n        } else {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"No more input splits remaining.\");\n            }\n            return null;\n        }\n    }\n}"
    },
    {
      "commit": "b32e77a2d8be76aeafa28b94fd7cfbb8de80f4cb",
      "startLine": 54,
      "endLine": 55,
      "methodCode": "@Override\npublic LocatableInputSplit getNextInputSplit(String host) {\n    if (host == null) {\n        synchronized (this.unassigned) {\n            Iterator<LocatableInputSplit> iter = this.unassigned.iterator();\n            if (iter.hasNext()) {\n                LocatableInputSplit next = iter.next();\n                iter.remove();\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Assigning arbitrary split to null host.\");\n                }\n                remoteAssignments++;\n                return next;\n            } else {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"No more input splits remaining.\");\n                }\n                return null;\n            }\n        }\n    }\n    host = host.toLowerCase(Locale.US);\n    List<LocatableInputSplit> localSplits = this.localPerHost.get(host);\n    if (localSplits == null) {\n        localSplits = new ArrayList<LocatableInputSplit>(16);\n        synchronized (localSplits) {\n            List<LocatableInputSplit> prior = this.localPerHost.putIfAbsent(host, localSplits);\n            if (prior == null) {\n                LocatableInputSplit[] remaining;\n                synchronized (this.unassigned) {\n                    remaining = (LocatableInputSplit[]) this.unassigned.toArray(new LocatableInputSplit[this.unassigned.size()]);\n                }\n                for (LocatableInputSplit is : remaining) {\n                    if (isLocal(host, is.getHostnames())) {\n                        localSplits.add(is);\n                    }\n                }\n            } else {\n                localSplits = prior;\n            }\n        }\n    }\n    synchronized (localSplits) {\n        int size = localSplits.size();\n        if (size > 0) {\n            synchronized (this.unassigned) {\n                do {\n                    --size;\n                    LocatableInputSplit split = localSplits.remove(size);\n                    if (this.unassigned.remove(split)) {\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"Assigning local split to host \" + host);\n                        }\n                        localAssignments++;\n                        return split;\n                    }\n                } while (size > 0);\n            }\n        }\n    }\n    synchronized (this.unassigned) {\n        Iterator<LocatableInputSplit> iter = this.unassigned.iterator();\n        if (iter.hasNext()) {\n            LocatableInputSplit next = iter.next();\n            iter.remove();\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Assigning remote split to host \" + host);\n            }\n            remoteAssignments++;\n            return next;\n        } else {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"No more input splits remaining.\");\n            }\n            return null;\n        }\n    }\n}"
    },
    {
      "commit": "c32569aed12ffa968e2c2289c2d56db262c0eba4",
      "startLine": 54,
      "endLine": 55,
      "methodCode": "@Override\npublic LocatableInputSplit getNextInputSplit(String host) {\n    if (host == null) {\n        synchronized (this.unassigned) {\n            Iterator<LocatableInputSplit> iter = this.unassigned.iterator();\n            if (iter.hasNext()) {\n                LocatableInputSplit next = iter.next();\n                iter.remove();\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Assigning arbitrary split to null host.\");\n                }\n                remoteAssignments++;\n                return next;\n            } else {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"No more input splits remaining.\");\n                }\n                return null;\n            }\n        }\n    }\n    host = host.toLowerCase(Locale.US);\n    List<LocatableInputSplit> localSplits = this.localPerHost.get(host);\n    if (localSplits == null) {\n        localSplits = new ArrayList<LocatableInputSplit>(16);\n        synchronized (localSplits) {\n            List<LocatableInputSplit> prior = this.localPerHost.putIfAbsent(host, localSplits);\n            if (prior == null) {\n                LocatableInputSplit[] remaining;\n                synchronized (this.unassigned) {\n                    remaining = (LocatableInputSplit[]) this.unassigned.toArray(new LocatableInputSplit[this.unassigned.size()]);\n                }\n                for (LocatableInputSplit is : remaining) {\n                    if (isLocal(host, is.getHostnames())) {\n                        localSplits.add(is);\n                    }\n                }\n            } else {\n                localSplits = prior;\n            }\n        }\n    }\n    synchronized (localSplits) {\n        int size = localSplits.size();\n        if (size > 0) {\n            synchronized (this.unassigned) {\n                do {\n                    --size;\n                    LocatableInputSplit split = localSplits.remove(size);\n                    if (this.unassigned.remove(split)) {\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"Assigning local split to host \" + host);\n                        }\n                        localAssignments++;\n                        return split;\n                    }\n                } while (size > 0);\n            }\n        }\n    }\n    synchronized (this.unassigned) {\n        Iterator<LocatableInputSplit> iter = this.unassigned.iterator();\n        if (iter.hasNext()) {\n            LocatableInputSplit next = iter.next();\n            iter.remove();\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Assigning remote split to host \" + host);\n            }\n            remoteAssignments++;\n            return next;\n        } else {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"No more input splits remaining.\");\n            }\n            return null;\n        }\n    }\n}"
    }
  ]
}