{
  "statementVersions": [
    {
      "commit": "09232ff6b0ea19e850482f3a87ac6ef1c063c759",
      "startLine": 4,
      "endLine": 10,
      "methodCode": "@Override\npublic SymbolReference<ResolvedMethodDeclaration> solveMethod(String name, List<ResolvedType> argumentsTypes, boolean staticOnly, TypeSolver typeSolver) {\n    Collection<ResolvedReferenceTypeDeclaration> rrtds = findTypeDeclarations(wrappedNode.getScope(), typeSolver);\n    for (ResolvedReferenceTypeDeclaration rrtd : rrtds) {\n        SymbolReference<ResolvedMethodDeclaration> res = MethodResolutionLogic.solveMethodInType(rrtd, name, argumentsTypes, false, typeSolver);\n        if (res.isSolved()) {\n            return res;\n        }\n    }\n    return SymbolReference.unsolved(ResolvedMethodDeclaration.class);\n}"
    },
    {
      "commit": "1db4cd7914d4f36224a4a8944e546650d5fc5a4d",
      "startLine": 4,
      "endLine": 10,
      "methodCode": "@Override\npublic SymbolReference<ResolvedMethodDeclaration> solveMethod(String name, List<ResolvedType> argumentsTypes, boolean staticOnly, TypeSolver typeSolver) {\n    Collection<ResolvedReferenceTypeDeclaration> rrtds = findTypeDeclarations(wrappedNode.getScope(), typeSolver);\n    for (ResolvedReferenceTypeDeclaration rrtd : rrtds) {\n        SymbolReference<ResolvedMethodDeclaration> res = MethodResolutionLogic.solveMethodInType(rrtd, name, argumentsTypes, false, typeSolver);\n        if (res.isSolved()) {\n            return res;\n        }\n    }\n    return SymbolReference.unsolved(ResolvedMethodDeclaration.class);\n}"
    },
    {
      "commit": "5d8d0cb7947efcf2282f7d056302dd905f348532",
      "startLine": 28,
      "endLine": 34,
      "methodCode": "@Override\npublic SymbolReference<ResolvedMethodDeclaration> solveMethod(String name, List<ResolvedType> argumentsTypes, boolean staticOnly, TypeSolver typeSolver) {\n    if (wrappedNode.getScope().isPresent()) {\n        Expression scope = wrappedNode.getScope().get();\n        if (scope instanceof NameExpr) {\n            NameExpr scopeAsName = (NameExpr) scope;\n            SymbolReference<ResolvedTypeDeclaration> symbolReference = this.solveType(scopeAsName.getName().getId(), typeSolver);\n            if (symbolReference.isSolved() && symbolReference.getCorrespondingDeclaration().isType()) {\n                ResolvedTypeDeclaration typeDeclaration = symbolReference.getCorrespondingDeclaration().asType();\n                return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, false, typeSolver);\n            }\n        }\n        ResolvedType typeOfScope = null;\n        try {\n            typeOfScope = JavaParserFacade.get(typeSolver).getType(scope);\n        } catch (Exception e) {\n            throw new RuntimeException(String.format(\"Issue calculating the type of the scope of \" + this), e);\n        }\n        if (typeOfScope.isWildcard()) {\n            if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n            } else {\n                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, false, typeSolver);\n            }\n        } else if (typeOfScope.isArray()) {\n            return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, false, typeSolver);\n        } else if (typeOfScope.isTypeVariable()) {\n            for (ResolvedTypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds()) {\n                SymbolReference<ResolvedMethodDeclaration> res = MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n                if (res.isSolved()) {\n                    return res;\n                }\n            }\n            return SymbolReference.unsolved(ResolvedMethodDeclaration.class);\n        } else if (typeOfScope.isConstraint()) {\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asConstraintType().getBound().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n        } else {\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n        }\n    } else {\n        ResolvedType typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n    }\n}"
    },
    {
      "commit": "acdac6790f4424f8097b3aa6c888e825cac485f9",
      "startLine": 28,
      "endLine": 34,
      "methodCode": "@Override\npublic SymbolReference<MethodDeclaration> solveMethod(String name, List<Type> argumentsTypes, boolean staticOnly, TypeSolver typeSolver) {\n    if (wrappedNode.getScope().isPresent()) {\n        Expression scope = wrappedNode.getScope().get();\n        if (scope instanceof NameExpr) {\n            NameExpr scopeAsName = (NameExpr) scope;\n            SymbolReference<TypeDeclaration> symbolReference = this.solveType(scopeAsName.getName().getId(), typeSolver);\n            if (symbolReference.isSolved() && symbolReference.getCorrespondingDeclaration().isType()) {\n                TypeDeclaration typeDeclaration = symbolReference.getCorrespondingDeclaration().asType();\n                return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, false, typeSolver);\n            }\n        }\n        Type typeOfScope = null;\n        try {\n            typeOfScope = JavaParserFacade.get(typeSolver).getType(scope);\n        } catch (Exception e) {\n            throw new RuntimeException(String.format(\"Issue calculating the type of the scope of \" + this), e);\n        }\n        if (typeOfScope.isWildcard()) {\n            if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n            } else {\n                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, false, typeSolver);\n            }\n        } else if (typeOfScope.isArray()) {\n            return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, false, typeSolver);\n        } else if (typeOfScope.isTypeVariable()) {\n            for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                SymbolReference<MethodDeclaration> res = MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n                if (res.isSolved()) {\n                    return res;\n                }\n            }\n            return SymbolReference.unsolved(MethodDeclaration.class);\n        } else if (typeOfScope.isConstraint()) {\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asConstraintType().getBound().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n        } else {\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n        }\n    } else {\n        Type typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n    }\n}"
    },
    {
      "commit": "17ac5ada0476c72aa79a2e0c39311e90bfa0fe60",
      "startLine": 28,
      "endLine": 34,
      "methodCode": "@Override\npublic SymbolReference<MethodDeclaration> solveMethod(String name, List<Type> argumentsTypes, boolean staticOnly, TypeSolver typeSolver) {\n    if (wrappedNode.getScope().isPresent()) {\n        Expression scope = wrappedNode.getScope().get();\n        if (scope instanceof NameExpr) {\n            NameExpr scopeAsName = (NameExpr) scope;\n            SymbolReference<TypeDeclaration> symbolReference = this.solveType(scopeAsName.getName().getId(), typeSolver);\n            if (symbolReference.isSolved() && symbolReference.getCorrespondingDeclaration().isType()) {\n                TypeDeclaration typeDeclaration = symbolReference.getCorrespondingDeclaration().asType();\n                return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver, false);\n            }\n        }\n        Type typeOfScope = null;\n        try {\n            typeOfScope = JavaParserFacade.get(typeSolver).getType(scope);\n        } catch (Exception e) {\n            throw new RuntimeException(String.format(\"Issue calculating the type of the scope of \" + this), e);\n        }\n        if (typeOfScope.isWildcard()) {\n            if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver, false);\n            } else {\n                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver, false);\n            }\n        } else if (typeOfScope.isArray()) {\n            return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver, false);\n        } else if (typeOfScope.isTypeVariable()) {\n            for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                SymbolReference<MethodDeclaration> res = MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver, false);\n                if (res.isSolved()) {\n                    return res;\n                }\n            }\n            return SymbolReference.unsolved(MethodDeclaration.class);\n        } else {\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver, false);\n        }\n    } else {\n        Type typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver, false);\n    }\n}"
    },
    {
      "commit": "e5fe2b597be66d230f8824277c1d4167fa2bb609",
      "startLine": 28,
      "endLine": 34,
      "methodCode": "@Override\npublic SymbolReference<MethodDeclaration> solveMethod(String name, List<Type> argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope().isPresent()) {\n        Expression scope = wrappedNode.getScope().get();\n        if (scope instanceof NameExpr) {\n            NameExpr scopeAsName = (NameExpr) scope;\n            SymbolReference<TypeDeclaration> symbolReference = this.solveType(scopeAsName.getName().getId(), typeSolver);\n            if (symbolReference.isSolved() && symbolReference.getCorrespondingDeclaration().isType()) {\n                TypeDeclaration typeDeclaration = symbolReference.getCorrespondingDeclaration().asType();\n                return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n            }\n        }\n        Type typeOfScope = null;\n        try {\n            typeOfScope = JavaParserFacade.get(typeSolver).getType(scope);\n        } catch (Exception e) {\n            throw new RuntimeException(String.format(\"Issue calculating the type of the scope of \" + this), e);\n        }\n        if (typeOfScope.isWildcard()) {\n            if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n            } else {\n                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n            }\n        } else if (typeOfScope.isArray()) {\n            return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n        } else if (typeOfScope.isTypeVariable()) {\n            for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                SymbolReference<MethodDeclaration> res = MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                if (res.isSolved()) {\n                    return res;\n                }\n            }\n            return SymbolReference.unsolved(MethodDeclaration.class);\n        } else {\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n        }\n    } else {\n        Type typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n    }\n}"
    },
    {
      "commit": "065875981b4d1ffa4bf3535d7c89319a4a3345f1",
      "startLine": 28,
      "endLine": 34,
      "methodCode": "@Override\npublic SymbolReference<MethodDeclaration> solveMethod(String name, List<Type> argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope().isPresent()) {\n        Expression scope = wrappedNode.getScope().get();\n        if (scope instanceof NameExpr) {\n            NameExpr scopeAsName = (NameExpr) scope;\n            SymbolReference<TypeDeclaration> symbolReference = this.solveType(scopeAsName.getName().getId(), typeSolver);\n            if (symbolReference.isSolved() && symbolReference.getCorrespondingDeclaration().isType()) {\n                TypeDeclaration typeDeclaration = symbolReference.getCorrespondingDeclaration().asType();\n                return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n            }\n        }\n        Type typeOfScope = null;\n        try {\n            typeOfScope = JavaParserFacade.get(typeSolver).getType(scope);\n        } catch (Exception e) {\n            throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n        }\n        if (typeOfScope.isWildcard()) {\n            if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n            } else {\n                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n            }\n        } else if (typeOfScope.isArray()) {\n            return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n        } else if (typeOfScope.isTypeVariable()) {\n            for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                SymbolReference<MethodDeclaration> res = MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                if (res.isSolved()) {\n                    return res;\n                }\n            }\n            return SymbolReference.unsolved(MethodDeclaration.class);\n        } else {\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n        }\n    } else {\n        Type typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n    }\n}"
    },
    {
      "commit": "e47162df70ac5344d1a7b8c08220474224e64536",
      "startLine": 27,
      "endLine": 33,
      "methodCode": "@Override\npublic SymbolReference<MethodDeclaration> solveMethod(String name, List<Type> argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() != null) {\n        if (wrappedNode.getScope() instanceof NameExpr) {\n            NameExpr scopeAsName = (NameExpr) wrappedNode.getScope();\n            SymbolReference<TypeDeclaration> symbolReference = this.solveType(scopeAsName.getName().getId(), typeSolver);\n            if (symbolReference.isSolved() && symbolReference.getCorrespondingDeclaration().isType()) {\n                TypeDeclaration typeDeclaration = symbolReference.getCorrespondingDeclaration().asType();\n                return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n            }\n        }\n        Type typeOfScope = null;\n        try {\n            typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n        } catch (Exception e) {\n            throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n        }\n        if (typeOfScope.isWildcard()) {\n            if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n            } else {\n                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n            }\n        } else if (typeOfScope.isArray()) {\n            return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n        } else if (typeOfScope.isTypeVariable()) {\n            for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                SymbolReference<MethodDeclaration> res = MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                if (res.isSolved()) {\n                    return res;\n                }\n            }\n            return SymbolReference.unsolved(MethodDeclaration.class);\n        } else {\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n        }\n    } else {\n        Type typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n    }\n}"
    },
    {
      "commit": "c990d23490f5c4ac4322119b03d5951b63eef055",
      "startLine": 27,
      "endLine": 33,
      "methodCode": "@Override\npublic SymbolReference<MethodDeclaration> solveMethod(String name, List<Type> argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() != null) {\n        if (wrappedNode.getScope() instanceof NameExpr) {\n            NameExpr scopeAsName = (NameExpr) wrappedNode.getScope();\n            SymbolReference<TypeDeclaration> symbolReference = this.solveType(scopeAsName.getName().getId(), typeSolver);\n            if (symbolReference.isSolved() && symbolReference.getCorrespondingDeclaration().isType()) {\n                TypeDeclaration typeDeclaration = symbolReference.getCorrespondingDeclaration().asType();\n                return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n            }\n        }\n        Type typeOfScope = null;\n        try {\n            typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n        } catch (Exception e) {\n            throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n        }\n        if (typeOfScope.isWildcard()) {\n            if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n            } else {\n                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n            }\n        } else if (typeOfScope.isArray()) {\n            return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n        } else if (typeOfScope.isTypeVariable()) {\n            for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                SymbolReference<MethodDeclaration> res = MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                if (res.isSolved()) {\n                    return res;\n                }\n            }\n            return SymbolReference.unsolved(MethodDeclaration.class);\n        } else {\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n        }\n    } else {\n        Type typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n    }\n}"
    },
    {
      "commit": "6e1380f412d334f1c887d15edf0b4610c3cf0da2",
      "startLine": 27,
      "endLine": 33,
      "methodCode": "@Override\npublic SymbolReference<MethodDeclaration> solveMethod(String name, List<Type> argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() != null) {\n        if (wrappedNode.getScope() instanceof NameExpr) {\n            NameExpr scopeAsName = (NameExpr) wrappedNode.getScope();\n            SymbolReference symbolReference = this.solveType(scopeAsName.getName().getId(), typeSolver);\n            if (symbolReference.isSolved() && symbolReference.getCorrespondingDeclaration().isType()) {\n                TypeDeclaration typeDeclaration = symbolReference.getCorrespondingDeclaration().asType();\n                return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n            }\n        }\n        Type typeOfScope = null;\n        try {\n            typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n        } catch (Exception e) {\n            throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n        }\n        if (typeOfScope.isWildcard()) {\n            if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n            } else {\n                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n            }\n        } else if (typeOfScope.isArray() && typeOfScope.asArrayType().getComponentType().isReferenceType()) {\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n        } else if (typeOfScope.isTypeVariable()) {\n            for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                SymbolReference<MethodDeclaration> res = MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                if (res.isSolved()) {\n                    return res;\n                }\n            }\n            return SymbolReference.unsolved(MethodDeclaration.class);\n        } else {\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n        }\n    } else {\n        Type typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n    }\n}"
    },
    {
      "commit": "ca3e3a946698cf3a4f93e6fb7b4d2b16ee2e3ed5",
      "startLine": 27,
      "endLine": 33,
      "methodCode": "@Override\npublic SymbolReference<MethodDeclaration> solveMethod(String name, List<Type> argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() != null) {\n        if (wrappedNode.getScope() instanceof NameExpr) {\n            NameExpr scopeAsName = (NameExpr) wrappedNode.getScope();\n            SymbolReference symbolReference = this.solveType(scopeAsName.getName(), typeSolver);\n            if (symbolReference.isSolved() && symbolReference.getCorrespondingDeclaration().isType()) {\n                TypeDeclaration typeDeclaration = symbolReference.getCorrespondingDeclaration().asType();\n                return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n            }\n        }\n        Type typeOfScope = null;\n        try {\n            typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n        } catch (Exception e) {\n            throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n        }\n        if (typeOfScope.isWildcard()) {\n            if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n            } else {\n                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n            }\n        } else if (typeOfScope.isArray() && typeOfScope.asArrayType().getComponentType().isReferenceType()) {\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n        } else if (typeOfScope.isTypeVariable()) {\n            for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                SymbolReference<MethodDeclaration> res = MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                if (res.isSolved()) {\n                    return res;\n                }\n            }\n            return SymbolReference.unsolved(MethodDeclaration.class);\n        } else {\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n        }\n    } else {\n        Type typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n    }\n}"
    },
    {
      "commit": "9c53c2cbc607ea694438ade8630be0c155a33162",
      "startLine": 27,
      "endLine": 33,
      "methodCode": "@Override\npublic SymbolReference<MethodDeclaration> solveMethod(String name, List<Type> argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope().isPresent()) {\n        if (wrappedNode.getScope().get() instanceof NameExpr) {\n            NameExpr scopeAsName = (NameExpr) wrappedNode.getScope().get();\n            SymbolReference symbolReference = this.solveType(scopeAsName.getName(), typeSolver);\n            if (symbolReference.isSolved() && symbolReference.getCorrespondingDeclaration().isType()) {\n                TypeDeclaration typeDeclaration = symbolReference.getCorrespondingDeclaration().asType();\n                return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n            }\n        }\n        Type typeOfScope = null;\n        try {\n            typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n        } catch (Exception e) {\n            throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n        }\n        if (typeOfScope.isWildcard()) {\n            if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n            } else {\n                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n            }\n        } else if (typeOfScope.isArray() && typeOfScope.asArrayType().getComponentType().isReferenceType()) {\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n        } else if (typeOfScope.isTypeVariable()) {\n            for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                SymbolReference<MethodDeclaration> res = MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                if (res.isSolved()) {\n                    return res;\n                }\n            }\n            return SymbolReference.unsolved(MethodDeclaration.class);\n        } else {\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n        }\n    } else {\n        Type typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n    }\n}"
    },
    {
      "commit": "0d14741fef3a17451db153cfe379e398da4b4b79",
      "startLine": 27,
      "endLine": 33,
      "methodCode": "@Override\npublic SymbolReference<MethodDeclaration> solveMethod(String name, List<Type> argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope().isPresent()) {\n        if (wrappedNode.getScope().get() instanceof NameExpr) {\n            NameExpr scopeAsName = (NameExpr) wrappedNode.getScope().get();\n            SymbolReference symbolReference = this.solveType(scopeAsName.getName(), typeSolver);\n            if (symbolReference.isSolved() && symbolReference.getCorrespondingDeclaration().isType()) {\n                TypeDeclaration typeDeclaration = symbolReference.getCorrespondingDeclaration().asType();\n                return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n            }\n        }\n        Type typeOfScope = null;\n        try {\n            typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n        } catch (Exception e) {\n            throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n        }\n        if (typeOfScope.isWildcard()) {\n            if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n            } else {\n                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n            }\n        } else if (typeOfScope.isArray() && typeOfScope.asArrayType().getComponentType().isReferenceType()) {\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n        } else if (typeOfScope.isTypeVariable()) {\n            for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                SymbolReference<MethodDeclaration> res = MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                if (res.isSolved()) {\n                    return res;\n                }\n            }\n            return SymbolReference.unsolved(MethodDeclaration.class);\n        } else {\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n        }\n    } else {\n        Type typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n    }\n}"
    },
    {
      "commit": "341e081a5f8909a3a467671befcca2941b786d3d",
      "startLine": 27,
      "endLine": 33,
      "methodCode": "@Override\npublic SymbolReference<MethodDeclaration> solveMethod(String name, List<Type> argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() != null) {\n        if (wrappedNode.getScope().get() instanceof NameExpr) {\n            NameExpr scopeAsName = (NameExpr) wrappedNode.getScope().get();\n            SymbolReference symbolReference = this.solveType(scopeAsName.getName(), typeSolver);\n            if (symbolReference.isSolved() && symbolReference.getCorrespondingDeclaration().isType()) {\n                TypeDeclaration typeDeclaration = symbolReference.getCorrespondingDeclaration().asType();\n                return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n            }\n        }\n        Type typeOfScope = null;\n        try {\n            typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n        } catch (Exception e) {\n            throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n        }\n        if (typeOfScope.isWildcard()) {\n            if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n            } else {\n                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n            }\n        } else if (typeOfScope.isArray() && typeOfScope.asArrayType().getComponentType().isReferenceType()) {\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n        } else if (typeOfScope.isTypeVariable()) {\n            for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                SymbolReference<MethodDeclaration> res = MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                if (res.isSolved()) {\n                    return res;\n                }\n            }\n            return SymbolReference.unsolved(MethodDeclaration.class);\n        } else {\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n        }\n    } else {\n        Type typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n    }\n}"
    },
    {
      "commit": "88db8b2a8b93bcc692cb8fd5085ba68b8bcf1968",
      "startLine": 27,
      "endLine": 33,
      "methodCode": "@Override\npublic SymbolReference<MethodDeclaration> solveMethod(String name, List<Type> argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() != null) {\n        if (wrappedNode.getScope() instanceof NameExpr) {\n            NameExpr scopeAsName = (NameExpr) wrappedNode.getScope();\n            SymbolReference symbolReference = this.solveType(scopeAsName.getName(), typeSolver);\n            if (symbolReference.isSolved() && symbolReference.getCorrespondingDeclaration().isType()) {\n                TypeDeclaration typeDeclaration = symbolReference.getCorrespondingDeclaration().asType();\n                return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n            }\n        }\n        Type typeOfScope = null;\n        try {\n            typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n        } catch (Exception e) {\n            throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n        }\n        if (typeOfScope.isWildcard()) {\n            if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n            } else {\n                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n            }\n        } else if (typeOfScope.isArray() && typeOfScope.asArrayType().getComponentType().isReferenceType()) {\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n        } else if (typeOfScope.isTypeVariable()) {\n            for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                SymbolReference<MethodDeclaration> res = MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                if (res.isSolved()) {\n                    return res;\n                }\n            }\n            return SymbolReference.unsolved(MethodDeclaration.class);\n        } else {\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n        }\n    } else {\n        Type typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n    }\n}"
    },
    {
      "commit": "656bb37a1dba87d61d24e69f2346f35dbc73d81d",
      "startLine": 27,
      "endLine": 33,
      "methodCode": "@Override\npublic SymbolReference<MethodDeclaration> solveMethod(String name, List<Type> parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() != null) {\n        if (wrappedNode.getScope() instanceof NameExpr) {\n            NameExpr scopeAsName = (NameExpr) wrappedNode.getScope();\n            SymbolReference symbolReference = this.solveType(scopeAsName.getName(), typeSolver);\n            if (symbolReference.isSolved() && symbolReference.getCorrespondingDeclaration().isType()) {\n                TypeDeclaration typeDeclaration = symbolReference.getCorrespondingDeclaration().asType();\n                return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, parameterTypes, typeSolver);\n            }\n        }\n        Type typeOfScope = null;\n        try {\n            typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n        } catch (Exception e) {\n            throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n        }\n        if (typeOfScope.isWildcard()) {\n            if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n            } else {\n                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, parameterTypes, typeSolver);\n            }\n        } else if (typeOfScope.isArray() && typeOfScope.asArrayType().getComponentType().isReferenceType()) {\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n        } else if (typeOfScope.isTypeVariable()) {\n            for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                SymbolReference<MethodDeclaration> res = MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n                if (res.isSolved()) {\n                    return res;\n                }\n            }\n            return SymbolReference.unsolved(MethodDeclaration.class);\n        } else {\n            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n        }\n    } else {\n        Type typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n    }\n}"
    },
    {
      "commit": "051dbd94c17c4f142d3fe9e8fbd03c29d09ace54",
      "startLine": 27,
      "endLine": 33,
      "methodCode": "@Override\npublic SymbolReference<MethodDeclaration> solveMethod(String name, List<Type> parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() != null) {\n        if (wrappedNode.getScope() instanceof NameExpr) {\n            NameExpr scopeAsName = (NameExpr) wrappedNode.getScope();\n            SymbolReference symbolReference = this.solveType(scopeAsName.getName(), typeSolver);\n            if (symbolReference.isSolved() && symbolReference.getCorrespondingDeclaration().isType()) {\n                TypeDeclaration typeDeclaration = symbolReference.getCorrespondingDeclaration().asType();\n                return typeDeclaration.solveMethod(name, parameterTypes);\n            }\n        }\n        Type typeOfScope = null;\n        try {\n            typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n        } catch (Exception e) {\n            throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n        }\n        if (typeOfScope.isWildcard()) {\n            if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                return typeOfScope.asWildcard().getBoundedType().asReferenceType().solveMethod(name, parameterTypes);\n            } else {\n                return new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n            }\n        } else if (typeOfScope.isArray() && typeOfScope.asArrayType().getComponentType().isReferenceType()) {\n            return typeOfScope.asArrayType().getComponentType().asReferenceType().solveMethod(name, parameterTypes);\n        } else if (typeOfScope.isTypeVariable()) {\n            for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                SymbolReference<MethodDeclaration> res = bound.getType().asReferenceType().solveMethod(name, parameterTypes);\n                if (res.isSolved()) {\n                    return res;\n                }\n            }\n            return SymbolReference.unsolved(MethodDeclaration.class);\n        } else {\n            return typeOfScope.asReferenceType().solveMethod(name, parameterTypes);\n        }\n    } else {\n        Type typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return typeOfScope.asReferenceType().solveMethod(name, parameterTypes);\n    }\n}"
    },
    {
      "commit": "ecc78c8b480ceb41019f764c983aaa69c2dabfe3",
      "startLine": 27,
      "endLine": 33,
      "methodCode": "@Override\npublic SymbolReference<MethodDeclaration> solveMethod(String name, List<Type> parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() != null) {\n        if (wrappedNode.getScope() instanceof NameExpr) {\n            NameExpr scopeAsName = (NameExpr) wrappedNode.getScope();\n            SymbolReference symbolReference = this.solveType(scopeAsName.getName(), typeSolver);\n            if (symbolReference.isSolved() && symbolReference.getCorrespondingDeclaration().isType()) {\n                TypeDeclaration typeDeclaration = symbolReference.getCorrespondingDeclaration().asType();\n                return typeDeclaration.solveMethod(name, parameterTypes);\n            }\n        }\n        Type typeOfScope = null;\n        try {\n            typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n        } catch (Exception e) {\n            throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n        }\n        if (typeOfScope.isWildcard()) {\n            if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n            } else {\n                return new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n            }\n        } else if (typeOfScope.isArray() && typeOfScope.asArrayTypeUsage().getComponentType().isReferenceType()) {\n            return typeOfScope.asArrayTypeUsage().getComponentType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n        } else if (typeOfScope.isTypeVariable()) {\n            for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                SymbolReference<MethodDeclaration> res = bound.getType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n                if (res.isSolved()) {\n                    return res;\n                }\n            }\n            return SymbolReference.unsolved(MethodDeclaration.class);\n        } else {\n            return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n        }\n    } else {\n        Type typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n    }\n}"
    },
    {
      "commit": "82eb44707b620803d424188a1eb8708fcaf093cb",
      "startLine": 27,
      "endLine": 33,
      "methodCode": "@Override\npublic SymbolReference<MethodDeclaration> solveMethod(String name, List<Type> parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() != null) {\n        if (wrappedNode.getScope() instanceof NameExpr) {\n            NameExpr scopeAsName = (NameExpr) wrappedNode.getScope();\n            SymbolReference symbolReference = this.solveType(scopeAsName.getName(), typeSolver);\n            if (symbolReference.isSolved() && symbolReference.getCorrespondingDeclaration().isType()) {\n                TypeDeclaration typeDeclaration = symbolReference.getCorrespondingDeclaration().asType();\n                return typeDeclaration.solveMethod(name, parameterTypes);\n            }\n        }\n        Type typeOfScope = null;\n        try {\n            typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n        } catch (Exception e) {\n            throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n        }\n        if (typeOfScope.isWildcard()) {\n            if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n            } else {\n                return new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n            }\n        } else if (typeOfScope.isArray() && typeOfScope.asArrayTypeUsage().getComponentType().isReferenceType()) {\n            return typeOfScope.asArrayTypeUsage().getComponentType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n        } else if (typeOfScope.isTypeVariable()) {\n            for (me.tomassetti.symbolsolver.model.resolution.TypeParameter.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                SymbolReference<MethodDeclaration> res = bound.getType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n                if (res.isSolved()) {\n                    return res;\n                }\n            }\n            return SymbolReference.unsolved(MethodDeclaration.class);\n        } else {\n            return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n        }\n    } else {\n        Type typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n    }\n}"
    },
    {
      "commit": "401a56f412ca186a00a2282d9088e8cb7b67e0e5",
      "startLine": 27,
      "endLine": 33,
      "methodCode": "@Override\npublic SymbolReference<MethodDeclaration> solveMethod(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() != null) {\n        if (wrappedNode.getScope() instanceof NameExpr) {\n            NameExpr scopeAsName = (NameExpr) wrappedNode.getScope();\n            SymbolReference symbolReference = this.solveType(scopeAsName.getName(), typeSolver);\n            if (symbolReference.isSolved() && symbolReference.getCorrespondingDeclaration().isType()) {\n                TypeDeclaration typeDeclaration = symbolReference.getCorrespondingDeclaration().asType();\n                return typeDeclaration.solveMethod(name, parameterTypes);\n            }\n        }\n        TypeUsage typeOfScope = null;\n        try {\n            typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n        } catch (Exception e) {\n            throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n        }\n        if (typeOfScope.isWildcard()) {\n            if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n            } else {\n                return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n            }\n        } else if (typeOfScope.isArray() && typeOfScope.asArrayTypeUsage().getComponentType().isReferenceType()) {\n            return typeOfScope.asArrayTypeUsage().getComponentType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n        } else if (typeOfScope.isTypeVariable()) {\n            for (TypeParameter.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                SymbolReference<MethodDeclaration> res = bound.getType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n                if (res.isSolved()) {\n                    return res;\n                }\n            }\n            return SymbolReference.unsolved(MethodDeclaration.class);\n        } else {\n            return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n        }\n    } else {\n        TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n    }\n}"
    },
    {
      "commit": "a16d5b37001074f2fa6eea4d1d1ef7e0466ca51b",
      "startLine": 22,
      "endLine": 28,
      "methodCode": "@Override\npublic SymbolReference<MethodDeclaration> solveMethod(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() != null) {\n        if (wrappedNode.getScope() instanceof NameExpr) {\n            NameExpr scopeAsName = (NameExpr) wrappedNode.getScope();\n            SymbolReference symbolReference = this.solveType(scopeAsName.getName(), typeSolver);\n            if (symbolReference.isSolved() && symbolReference.getCorrespondingDeclaration().isType()) {\n                TypeDeclaration typeDeclaration = symbolReference.getCorrespondingDeclaration().asType();\n                return typeDeclaration.solveMethod(name, parameterTypes);\n            }\n        }\n        TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n        if (typeOfScope.isWildcard()) {\n            if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n            } else {\n                return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n            }\n        } else if (typeOfScope.isArray() && typeOfScope.asArrayTypeUsage().getComponentType().isReferenceType()) {\n            return typeOfScope.asArrayTypeUsage().getComponentType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n        } else if (typeOfScope.isTypeVariable()) {\n            for (TypeParameter.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                SymbolReference<MethodDeclaration> res = bound.getType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n                if (res.isSolved()) {\n                    return res;\n                }\n            }\n            return SymbolReference.unsolved(MethodDeclaration.class);\n        } else {\n            return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n        }\n    } else {\n        TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n    }\n}"
    }
  ]
}