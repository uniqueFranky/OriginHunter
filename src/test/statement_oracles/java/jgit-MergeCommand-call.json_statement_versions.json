{
  "statementVersions": [
    {
      "commit": "f6c4a492d06e0dd345679bfba3399dabbf778f41",
      "startLine": 80,
      "endLine": 98,
      "methodCode": "@Override\n@SuppressWarnings(\"boxing\")\npublic MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    fallBackToConfiguration();\n    checkParameters();\n    DirCacheCheckout dco = null;\n    try (RevWalk revWalk = new RevWalk(repo)) {\n        Ref head = repo.exactRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage = new StringBuilder(\"merge \");\n        Ref ref = commits.get(0);\n        refLogMessage.append(ref.getName());\n        ref = repo.getRefDatabase().peel(ref);\n        ObjectId objectId = ref.getPeeledObjectId();\n        if (objectId == null)\n            objectId = ref.getObjectId();\n        RevCommit srcCommit = revWalk.lookupCommit(objectId);\n        ObjectId headId = head.getObjectId();\n        if (headId == null) {\n            revWalk.parseHeaders(srcCommit);\n            dco = new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.setProgressMonitor(monitor);\n            dco.checkout();\n            RefUpdate refUpdate = repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() != Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit = revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit) && fastForwardMode != FastForwardMode.NO_FF) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setProgressMonitor(monitor);\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            String msg = null;\n            ObjectId newHead, base = null;\n            MergeStatus mergeStatus = null;\n            if (!squash) {\n                updateHead(refLogMessage, srcCommit, headId);\n                newHead = base = srcCommit;\n                mergeStatus = MergeStatus.FAST_FORWARD;\n            } else {\n                msg = JGitText.get().squashCommitNotUpdatingHEAD;\n                newHead = base = headId;\n                mergeStatus = MergeStatus.FAST_FORWARD_SQUASHED;\n                List<RevCommit> squashedCommits = RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage = new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            setCallable(false);\n            return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n        } else {\n            if (fastForwardMode == FastForwardMode.FF_ONLY) {\n                return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n            }\n            String mergeMessage = \"\";\n            if (!squash) {\n                if (message != null)\n                    mergeMessage = message;\n                else\n                    mergeMessage = new MergeMessageFormatter().format(commits, head);\n                repo.writeMergeCommitMsg(mergeMessage);\n                repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            } else {\n                List<RevCommit> squashedCommits = RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage = new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            Merger merger = mergeStrategy.newMerger(repo);\n            merger.setProgressMonitor(monitor);\n            boolean noProblems;\n            Map<String, org.eclipse.jgit.merge.MergeResult<?>> lowLevelResults = null;\n            Map<String, MergeFailureReason> failingPaths = null;\n            List<String> unmergedPaths = null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger = (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems = merger.merge(headCommit, srcCommit);\n                lowLevelResults = resolveMerger.getMergeResults();\n                failingPaths = resolveMerger.getFailingPaths();\n                unmergedPaths = resolveMerger.getUnmergedPaths();\n                if (!resolveMerger.getModifiedFiles().isEmpty()) {\n                    repo.fireEvent(new WorkingTreeModifiedEvent(resolveMerger.getModifiedFiles(), null));\n                }\n            } else\n                noProblems = merger.merge(headCommit, srcCommit);\n            refLogMessage.append(\": Merge made by \");\n            if (!revWalk.isMergedInto(headCommit, srcCommit))\n                refLogMessage.append(mergeStrategy.getName());\n            else\n                refLogMessage.append(\"recursive\");\n            refLogMessage.append('.');\n            if (noProblems) {\n                dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.setProgressMonitor(monitor);\n                dco.checkout();\n                String msg = null;\n                ObjectId newHeadId = null;\n                MergeStatus mergeStatus = null;\n                if (!commit && squash) {\n                    mergeStatus = MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n                }\n                if (!commit && !squash) {\n                    mergeStatus = MergeStatus.MERGED_NOT_COMMITTED;\n                }\n                if (commit && !squash) {\n                    try (Git git = new Git(getRepository())) {\n                        newHeadId = git.commit().setReflogComment(refLogMessage.toString()).setInsertChangeId(insertChangeId).call().getId();\n                    }\n                    mergeStatus = MergeStatus.MERGED;\n                    getRepository().autoGC(monitor);\n                }\n                if (commit && squash) {\n                    msg = JGitText.get().squashCommitNotUpdatingHEAD;\n                    newHeadId = headCommit.getId();\n                    mergeStatus = MergeStatus.MERGED_SQUASHED;\n                }\n                return new MergeResult(newHeadId, null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n            } else {\n                if (failingPaths != null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else {\n                    String mergeMessageWithConflicts = new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                    repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                }\n            }\n        }\n    } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n        List<String> conflicts = (dco == null) ? Collections.<String>emptyList() : dco.getConflicts();\n        throw new CheckoutConflictException(conflicts, e);\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    }\n}"
    },
    {
      "commit": "42e69409d796421bb1353279cfae463b19a43fe9",
      "startLine": 80,
      "endLine": 98,
      "methodCode": "@Override\n@SuppressWarnings(\"boxing\")\npublic MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    fallBackToConfiguration();\n    checkParameters();\n    DirCacheCheckout dco = null;\n    try (RevWalk revWalk = new RevWalk(repo)) {\n        Ref head = repo.exactRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage = new StringBuilder(\"merge \");\n        Ref ref = commits.get(0);\n        refLogMessage.append(ref.getName());\n        ref = repo.peel(ref);\n        ObjectId objectId = ref.getPeeledObjectId();\n        if (objectId == null)\n            objectId = ref.getObjectId();\n        RevCommit srcCommit = revWalk.lookupCommit(objectId);\n        ObjectId headId = head.getObjectId();\n        if (headId == null) {\n            revWalk.parseHeaders(srcCommit);\n            dco = new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.setProgressMonitor(monitor);\n            dco.checkout();\n            RefUpdate refUpdate = repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() != Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit = revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit) && fastForwardMode != FastForwardMode.NO_FF) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setProgressMonitor(monitor);\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            String msg = null;\n            ObjectId newHead, base = null;\n            MergeStatus mergeStatus = null;\n            if (!squash) {\n                updateHead(refLogMessage, srcCommit, headId);\n                newHead = base = srcCommit;\n                mergeStatus = MergeStatus.FAST_FORWARD;\n            } else {\n                msg = JGitText.get().squashCommitNotUpdatingHEAD;\n                newHead = base = headId;\n                mergeStatus = MergeStatus.FAST_FORWARD_SQUASHED;\n                List<RevCommit> squashedCommits = RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage = new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            setCallable(false);\n            return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n        } else {\n            if (fastForwardMode == FastForwardMode.FF_ONLY) {\n                return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n            }\n            String mergeMessage = \"\";\n            if (!squash) {\n                if (message != null)\n                    mergeMessage = message;\n                else\n                    mergeMessage = new MergeMessageFormatter().format(commits, head);\n                repo.writeMergeCommitMsg(mergeMessage);\n                repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            } else {\n                List<RevCommit> squashedCommits = RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage = new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            Merger merger = mergeStrategy.newMerger(repo);\n            merger.setProgressMonitor(monitor);\n            boolean noProblems;\n            Map<String, org.eclipse.jgit.merge.MergeResult<?>> lowLevelResults = null;\n            Map<String, MergeFailureReason> failingPaths = null;\n            List<String> unmergedPaths = null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger = (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems = merger.merge(headCommit, srcCommit);\n                lowLevelResults = resolveMerger.getMergeResults();\n                failingPaths = resolveMerger.getFailingPaths();\n                unmergedPaths = resolveMerger.getUnmergedPaths();\n                if (!resolveMerger.getModifiedFiles().isEmpty()) {\n                    repo.fireEvent(new WorkingTreeModifiedEvent(resolveMerger.getModifiedFiles(), null));\n                }\n            } else\n                noProblems = merger.merge(headCommit, srcCommit);\n            refLogMessage.append(\": Merge made by \");\n            if (!revWalk.isMergedInto(headCommit, srcCommit))\n                refLogMessage.append(mergeStrategy.getName());\n            else\n                refLogMessage.append(\"recursive\");\n            refLogMessage.append('.');\n            if (noProblems) {\n                dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.setProgressMonitor(monitor);\n                dco.checkout();\n                String msg = null;\n                ObjectId newHeadId = null;\n                MergeStatus mergeStatus = null;\n                if (!commit && squash) {\n                    mergeStatus = MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n                }\n                if (!commit && !squash) {\n                    mergeStatus = MergeStatus.MERGED_NOT_COMMITTED;\n                }\n                if (commit && !squash) {\n                    try (Git git = new Git(getRepository())) {\n                        newHeadId = git.commit().setReflogComment(refLogMessage.toString()).setInsertChangeId(insertChangeId).call().getId();\n                    }\n                    mergeStatus = MergeStatus.MERGED;\n                    getRepository().autoGC(monitor);\n                }\n                if (commit && squash) {\n                    msg = JGitText.get().squashCommitNotUpdatingHEAD;\n                    newHeadId = headCommit.getId();\n                    mergeStatus = MergeStatus.MERGED_SQUASHED;\n                }\n                return new MergeResult(newHeadId, null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n            } else {\n                if (failingPaths != null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else {\n                    String mergeMessageWithConflicts = new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                    repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                }\n            }\n        }\n    } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n        List<String> conflicts = (dco == null) ? Collections.<String>emptyList() : dco.getConflicts();\n        throw new CheckoutConflictException(conflicts, e);\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    }\n}"
    },
    {
      "commit": "2c29af786763c0c8d74741c86edbeff4e5140e35",
      "startLine": 80,
      "endLine": 98,
      "methodCode": "@Override\n@SuppressWarnings(\"boxing\")\npublic MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    fallBackToConfiguration();\n    checkParameters();\n    DirCacheCheckout dco = null;\n    try (RevWalk revWalk = new RevWalk(repo)) {\n        Ref head = repo.exactRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage = new StringBuilder(\"merge \");\n        Ref ref = commits.get(0);\n        refLogMessage.append(ref.getName());\n        ref = repo.peel(ref);\n        ObjectId objectId = ref.getPeeledObjectId();\n        if (objectId == null)\n            objectId = ref.getObjectId();\n        RevCommit srcCommit = revWalk.lookupCommit(objectId);\n        ObjectId headId = head.getObjectId();\n        if (headId == null) {\n            revWalk.parseHeaders(srcCommit);\n            dco = new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.setProgressMonitor(monitor);\n            dco.checkout();\n            RefUpdate refUpdate = repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() != Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit = revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit) && fastForwardMode != FastForwardMode.NO_FF) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setProgressMonitor(monitor);\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            String msg = null;\n            ObjectId newHead, base = null;\n            MergeStatus mergeStatus = null;\n            if (!squash) {\n                updateHead(refLogMessage, srcCommit, headId);\n                newHead = base = srcCommit;\n                mergeStatus = MergeStatus.FAST_FORWARD;\n            } else {\n                msg = JGitText.get().squashCommitNotUpdatingHEAD;\n                newHead = base = headId;\n                mergeStatus = MergeStatus.FAST_FORWARD_SQUASHED;\n                List<RevCommit> squashedCommits = RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage = new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            setCallable(false);\n            return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n        } else {\n            if (fastForwardMode == FastForwardMode.FF_ONLY) {\n                return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n            }\n            String mergeMessage = \"\";\n            if (!squash) {\n                if (message != null)\n                    mergeMessage = message;\n                else\n                    mergeMessage = new MergeMessageFormatter().format(commits, head);\n                repo.writeMergeCommitMsg(mergeMessage);\n                repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            } else {\n                List<RevCommit> squashedCommits = RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage = new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            Merger merger = mergeStrategy.newMerger(repo);\n            merger.setProgressMonitor(monitor);\n            boolean noProblems;\n            Map<String, org.eclipse.jgit.merge.MergeResult<?>> lowLevelResults = null;\n            Map<String, MergeFailureReason> failingPaths = null;\n            List<String> unmergedPaths = null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger = (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems = merger.merge(headCommit, srcCommit);\n                lowLevelResults = resolveMerger.getMergeResults();\n                failingPaths = resolveMerger.getFailingPaths();\n                unmergedPaths = resolveMerger.getUnmergedPaths();\n                if (!resolveMerger.getModifiedFiles().isEmpty()) {\n                    repo.fireEvent(new WorkingTreeModifiedEvent(resolveMerger.getModifiedFiles(), null));\n                }\n            } else\n                noProblems = merger.merge(headCommit, srcCommit);\n            refLogMessage.append(\": Merge made by \");\n            if (!revWalk.isMergedInto(headCommit, srcCommit))\n                refLogMessage.append(mergeStrategy.getName());\n            else\n                refLogMessage.append(\"recursive\");\n            refLogMessage.append('.');\n            if (noProblems) {\n                dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.setProgressMonitor(monitor);\n                dco.checkout();\n                String msg = null;\n                ObjectId newHeadId = null;\n                MergeStatus mergeStatus = null;\n                if (!commit && squash) {\n                    mergeStatus = MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n                }\n                if (!commit && !squash) {\n                    mergeStatus = MergeStatus.MERGED_NOT_COMMITTED;\n                }\n                if (commit && !squash) {\n                    try (Git git = new Git(getRepository())) {\n                        newHeadId = git.commit().setReflogComment(refLogMessage.toString()).call().getId();\n                    }\n                    mergeStatus = MergeStatus.MERGED;\n                    getRepository().autoGC(monitor);\n                }\n                if (commit && squash) {\n                    msg = JGitText.get().squashCommitNotUpdatingHEAD;\n                    newHeadId = headCommit.getId();\n                    mergeStatus = MergeStatus.MERGED_SQUASHED;\n                }\n                return new MergeResult(newHeadId, null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n            } else {\n                if (failingPaths != null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else {\n                    String mergeMessageWithConflicts = new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                    repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                }\n            }\n        }\n    } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n        List<String> conflicts = (dco == null) ? Collections.<String>emptyList() : dco.getConflicts();\n        throw new CheckoutConflictException(conflicts, e);\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    }\n}"
    },
    {
      "commit": "1c43af8b9794abcad7a4ac77c352626063aa1f05",
      "startLine": 82,
      "endLine": 100,
      "methodCode": "@Override\n@SuppressWarnings(\"boxing\")\npublic MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    fallBackToConfiguration();\n    checkParameters();\n    RevWalk revWalk = null;\n    DirCacheCheckout dco = null;\n    try {\n        Ref head = repo.exactRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage = new StringBuilder(\"merge \");\n        revWalk = new RevWalk(repo);\n        Ref ref = commits.get(0);\n        refLogMessage.append(ref.getName());\n        ref = repo.peel(ref);\n        ObjectId objectId = ref.getPeeledObjectId();\n        if (objectId == null)\n            objectId = ref.getObjectId();\n        RevCommit srcCommit = revWalk.lookupCommit(objectId);\n        ObjectId headId = head.getObjectId();\n        if (headId == null) {\n            revWalk.parseHeaders(srcCommit);\n            dco = new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.setProgressMonitor(monitor);\n            dco.checkout();\n            RefUpdate refUpdate = repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() != Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit = revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit) && fastForwardMode != FastForwardMode.NO_FF) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setProgressMonitor(monitor);\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            String msg = null;\n            ObjectId newHead, base = null;\n            MergeStatus mergeStatus = null;\n            if (!squash) {\n                updateHead(refLogMessage, srcCommit, headId);\n                newHead = base = srcCommit;\n                mergeStatus = MergeStatus.FAST_FORWARD;\n            } else {\n                msg = JGitText.get().squashCommitNotUpdatingHEAD;\n                newHead = base = headId;\n                mergeStatus = MergeStatus.FAST_FORWARD_SQUASHED;\n                List<RevCommit> squashedCommits = RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage = new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            setCallable(false);\n            return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n        } else {\n            if (fastForwardMode == FastForwardMode.FF_ONLY) {\n                return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n            }\n            String mergeMessage = \"\";\n            if (!squash) {\n                if (message != null)\n                    mergeMessage = message;\n                else\n                    mergeMessage = new MergeMessageFormatter().format(commits, head);\n                repo.writeMergeCommitMsg(mergeMessage);\n                repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            } else {\n                List<RevCommit> squashedCommits = RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage = new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            Merger merger = mergeStrategy.newMerger(repo);\n            merger.setProgressMonitor(monitor);\n            boolean noProblems;\n            Map<String, org.eclipse.jgit.merge.MergeResult<?>> lowLevelResults = null;\n            Map<String, MergeFailureReason> failingPaths = null;\n            List<String> unmergedPaths = null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger = (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems = merger.merge(headCommit, srcCommit);\n                lowLevelResults = resolveMerger.getMergeResults();\n                failingPaths = resolveMerger.getFailingPaths();\n                unmergedPaths = resolveMerger.getUnmergedPaths();\n                if (!resolveMerger.getModifiedFiles().isEmpty()) {\n                    repo.fireEvent(new WorkingTreeModifiedEvent(resolveMerger.getModifiedFiles(), null));\n                }\n            } else\n                noProblems = merger.merge(headCommit, srcCommit);\n            refLogMessage.append(\": Merge made by \");\n            if (!revWalk.isMergedInto(headCommit, srcCommit))\n                refLogMessage.append(mergeStrategy.getName());\n            else\n                refLogMessage.append(\"recursive\");\n            refLogMessage.append('.');\n            if (noProblems) {\n                dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.setProgressMonitor(monitor);\n                dco.checkout();\n                String msg = null;\n                ObjectId newHeadId = null;\n                MergeStatus mergeStatus = null;\n                if (!commit && squash) {\n                    mergeStatus = MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n                }\n                if (!commit && !squash) {\n                    mergeStatus = MergeStatus.MERGED_NOT_COMMITTED;\n                }\n                if (commit && !squash) {\n                    try (Git git = new Git(getRepository())) {\n                        newHeadId = git.commit().setReflogComment(refLogMessage.toString()).call().getId();\n                    }\n                    mergeStatus = MergeStatus.MERGED;\n                    getRepository().autoGC(monitor);\n                }\n                if (commit && squash) {\n                    msg = JGitText.get().squashCommitNotUpdatingHEAD;\n                    newHeadId = headCommit.getId();\n                    mergeStatus = MergeStatus.MERGED_SQUASHED;\n                }\n                return new MergeResult(newHeadId, null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n            } else {\n                if (failingPaths != null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else {\n                    String mergeMessageWithConflicts = new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                    repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                }\n            }\n        }\n    } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n        List<String> conflicts = (dco == null) ? Collections.<String>emptyList() : dco.getConflicts();\n        throw new CheckoutConflictException(conflicts, e);\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk != null)\n            revWalk.close();\n    }\n}"
    },
    {
      "commit": "0210e0e299bed69176e0a929d0b67f3cf9fb1e37",
      "startLine": 80,
      "endLine": 98,
      "methodCode": "@Override\n@SuppressWarnings(\"boxing\")\npublic MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    fallBackToConfiguration();\n    checkParameters();\n    RevWalk revWalk = null;\n    DirCacheCheckout dco = null;\n    try {\n        Ref head = repo.exactRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage = new StringBuilder(\"merge \");\n        revWalk = new RevWalk(repo);\n        Ref ref = commits.get(0);\n        refLogMessage.append(ref.getName());\n        ref = repo.peel(ref);\n        ObjectId objectId = ref.getPeeledObjectId();\n        if (objectId == null)\n            objectId = ref.getObjectId();\n        RevCommit srcCommit = revWalk.lookupCommit(objectId);\n        ObjectId headId = head.getObjectId();\n        if (headId == null) {\n            revWalk.parseHeaders(srcCommit);\n            dco = new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            RefUpdate refUpdate = repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() != Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit = revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit) && fastForwardMode != FastForwardMode.NO_FF) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            String msg = null;\n            ObjectId newHead, base = null;\n            MergeStatus mergeStatus = null;\n            if (!squash) {\n                updateHead(refLogMessage, srcCommit, headId);\n                newHead = base = srcCommit;\n                mergeStatus = MergeStatus.FAST_FORWARD;\n            } else {\n                msg = JGitText.get().squashCommitNotUpdatingHEAD;\n                newHead = base = headId;\n                mergeStatus = MergeStatus.FAST_FORWARD_SQUASHED;\n                List<RevCommit> squashedCommits = RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage = new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            setCallable(false);\n            return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n        } else {\n            if (fastForwardMode == FastForwardMode.FF_ONLY) {\n                return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n            }\n            String mergeMessage = \"\";\n            if (!squash) {\n                if (message != null)\n                    mergeMessage = message;\n                else\n                    mergeMessage = new MergeMessageFormatter().format(commits, head);\n                repo.writeMergeCommitMsg(mergeMessage);\n                repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            } else {\n                List<RevCommit> squashedCommits = RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage = new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            Merger merger = mergeStrategy.newMerger(repo);\n            merger.setProgressMonitor(monitor);\n            boolean noProblems;\n            Map<String, org.eclipse.jgit.merge.MergeResult<?>> lowLevelResults = null;\n            Map<String, MergeFailureReason> failingPaths = null;\n            List<String> unmergedPaths = null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger = (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems = merger.merge(headCommit, srcCommit);\n                lowLevelResults = resolveMerger.getMergeResults();\n                failingPaths = resolveMerger.getFailingPaths();\n                unmergedPaths = resolveMerger.getUnmergedPaths();\n                if (!resolveMerger.getModifiedFiles().isEmpty()) {\n                    repo.fireEvent(new WorkingTreeModifiedEvent(resolveMerger.getModifiedFiles(), null));\n                }\n            } else\n                noProblems = merger.merge(headCommit, srcCommit);\n            refLogMessage.append(\": Merge made by \");\n            if (!revWalk.isMergedInto(headCommit, srcCommit))\n                refLogMessage.append(mergeStrategy.getName());\n            else\n                refLogMessage.append(\"recursive\");\n            refLogMessage.append('.');\n            if (noProblems) {\n                dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                String msg = null;\n                ObjectId newHeadId = null;\n                MergeStatus mergeStatus = null;\n                if (!commit && squash) {\n                    mergeStatus = MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n                }\n                if (!commit && !squash) {\n                    mergeStatus = MergeStatus.MERGED_NOT_COMMITTED;\n                }\n                if (commit && !squash) {\n                    try (Git git = new Git(getRepository())) {\n                        newHeadId = git.commit().setReflogComment(refLogMessage.toString()).call().getId();\n                    }\n                    mergeStatus = MergeStatus.MERGED;\n                    getRepository().autoGC(monitor);\n                }\n                if (commit && squash) {\n                    msg = JGitText.get().squashCommitNotUpdatingHEAD;\n                    newHeadId = headCommit.getId();\n                    mergeStatus = MergeStatus.MERGED_SQUASHED;\n                }\n                return new MergeResult(newHeadId, null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n            } else {\n                if (failingPaths != null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else {\n                    String mergeMessageWithConflicts = new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                    repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                }\n            }\n        }\n    } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n        List<String> conflicts = (dco == null) ? Collections.<String>emptyList() : dco.getConflicts();\n        throw new CheckoutConflictException(conflicts, e);\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk != null)\n            revWalk.close();\n    }\n}"
    },
    {
      "commit": "b13a285098305149b34924bce2679a0cd98d9b2c",
      "startLine": 80,
      "endLine": 98,
      "methodCode": "@Override\n@SuppressWarnings(\"boxing\")\npublic MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    fallBackToConfiguration();\n    checkParameters();\n    RevWalk revWalk = null;\n    DirCacheCheckout dco = null;\n    try {\n        Ref head = repo.exactRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage = new StringBuilder(\"merge \");\n        revWalk = new RevWalk(repo);\n        Ref ref = commits.get(0);\n        refLogMessage.append(ref.getName());\n        ref = repo.peel(ref);\n        ObjectId objectId = ref.getPeeledObjectId();\n        if (objectId == null)\n            objectId = ref.getObjectId();\n        RevCommit srcCommit = revWalk.lookupCommit(objectId);\n        ObjectId headId = head.getObjectId();\n        if (headId == null) {\n            revWalk.parseHeaders(srcCommit);\n            dco = new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            RefUpdate refUpdate = repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() != Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit = revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit) && fastForwardMode != FastForwardMode.NO_FF) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            String msg = null;\n            ObjectId newHead, base = null;\n            MergeStatus mergeStatus = null;\n            if (!squash) {\n                updateHead(refLogMessage, srcCommit, headId);\n                newHead = base = srcCommit;\n                mergeStatus = MergeStatus.FAST_FORWARD;\n            } else {\n                msg = JGitText.get().squashCommitNotUpdatingHEAD;\n                newHead = base = headId;\n                mergeStatus = MergeStatus.FAST_FORWARD_SQUASHED;\n                List<RevCommit> squashedCommits = RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage = new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            setCallable(false);\n            return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n        } else {\n            if (fastForwardMode == FastForwardMode.FF_ONLY) {\n                return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n            }\n            String mergeMessage = \"\";\n            if (!squash) {\n                if (message != null)\n                    mergeMessage = message;\n                else\n                    mergeMessage = new MergeMessageFormatter().format(commits, head);\n                repo.writeMergeCommitMsg(mergeMessage);\n                repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            } else {\n                List<RevCommit> squashedCommits = RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage = new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            Merger merger = mergeStrategy.newMerger(repo);\n            merger.setProgressMonitor(monitor);\n            boolean noProblems;\n            Map<String, org.eclipse.jgit.merge.MergeResult<?>> lowLevelResults = null;\n            Map<String, MergeFailureReason> failingPaths = null;\n            List<String> unmergedPaths = null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger = (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems = merger.merge(headCommit, srcCommit);\n                lowLevelResults = resolveMerger.getMergeResults();\n                failingPaths = resolveMerger.getFailingPaths();\n                unmergedPaths = resolveMerger.getUnmergedPaths();\n                if (!resolveMerger.getModifiedFiles().isEmpty()) {\n                    repo.fireEvent(new WorkingTreeModifiedEvent(resolveMerger.getModifiedFiles(), null));\n                }\n            } else\n                noProblems = merger.merge(headCommit, srcCommit);\n            refLogMessage.append(\": Merge made by \");\n            if (!revWalk.isMergedInto(headCommit, srcCommit))\n                refLogMessage.append(mergeStrategy.getName());\n            else\n                refLogMessage.append(\"recursive\");\n            refLogMessage.append('.');\n            if (noProblems) {\n                dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                String msg = null;\n                ObjectId newHeadId = null;\n                MergeStatus mergeStatus = null;\n                if (!commit && squash) {\n                    mergeStatus = MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n                }\n                if (!commit && !squash) {\n                    mergeStatus = MergeStatus.MERGED_NOT_COMMITTED;\n                }\n                if (commit && !squash) {\n                    try (Git git = new Git(getRepository())) {\n                        newHeadId = git.commit().setReflogComment(refLogMessage.toString()).call().getId();\n                    }\n                    mergeStatus = MergeStatus.MERGED;\n                    getRepository().autoGC(monitor);\n                }\n                if (commit && squash) {\n                    msg = JGitText.get().squashCommitNotUpdatingHEAD;\n                    newHeadId = headCommit.getId();\n                    mergeStatus = MergeStatus.MERGED_SQUASHED;\n                }\n                return new MergeResult(newHeadId, null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n            } else {\n                if (failingPaths != null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else {\n                    String mergeMessageWithConflicts = new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                    repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                }\n            }\n        }\n    } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n        List<String> conflicts = (dco == null) ? Collections.<String>emptyList() : dco.getConflicts();\n        throw new CheckoutConflictException(conflicts, e);\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk != null)\n            revWalk.close();\n    }\n}"
    },
    {
      "commit": "7ac182f4e427e0d5a986b8ca67a56fc22828b1a0",
      "startLine": 80,
      "endLine": 95,
      "methodCode": "@Override\n@SuppressWarnings(\"boxing\")\npublic MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    fallBackToConfiguration();\n    checkParameters();\n    RevWalk revWalk = null;\n    DirCacheCheckout dco = null;\n    try {\n        Ref head = repo.exactRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage = new StringBuilder(\"merge \");\n        revWalk = new RevWalk(repo);\n        Ref ref = commits.get(0);\n        refLogMessage.append(ref.getName());\n        ref = repo.peel(ref);\n        ObjectId objectId = ref.getPeeledObjectId();\n        if (objectId == null)\n            objectId = ref.getObjectId();\n        RevCommit srcCommit = revWalk.lookupCommit(objectId);\n        ObjectId headId = head.getObjectId();\n        if (headId == null) {\n            revWalk.parseHeaders(srcCommit);\n            dco = new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            RefUpdate refUpdate = repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() != Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit = revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit) && fastForwardMode != FastForwardMode.NO_FF) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            String msg = null;\n            ObjectId newHead, base = null;\n            MergeStatus mergeStatus = null;\n            if (!squash) {\n                updateHead(refLogMessage, srcCommit, headId);\n                newHead = base = srcCommit;\n                mergeStatus = MergeStatus.FAST_FORWARD;\n            } else {\n                msg = JGitText.get().squashCommitNotUpdatingHEAD;\n                newHead = base = headId;\n                mergeStatus = MergeStatus.FAST_FORWARD_SQUASHED;\n                List<RevCommit> squashedCommits = RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage = new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            setCallable(false);\n            return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n        } else {\n            if (fastForwardMode == FastForwardMode.FF_ONLY) {\n                return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n            }\n            String mergeMessage = \"\";\n            if (!squash) {\n                if (message != null)\n                    mergeMessage = message;\n                else\n                    mergeMessage = new MergeMessageFormatter().format(commits, head);\n                repo.writeMergeCommitMsg(mergeMessage);\n                repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            } else {\n                List<RevCommit> squashedCommits = RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage = new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            Merger merger = mergeStrategy.newMerger(repo);\n            merger.setProgressMonitor(monitor);\n            boolean noProblems;\n            Map<String, org.eclipse.jgit.merge.MergeResult<?>> lowLevelResults = null;\n            Map<String, MergeFailureReason> failingPaths = null;\n            List<String> unmergedPaths = null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger = (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems = merger.merge(headCommit, srcCommit);\n                lowLevelResults = resolveMerger.getMergeResults();\n                failingPaths = resolveMerger.getFailingPaths();\n                unmergedPaths = resolveMerger.getUnmergedPaths();\n            } else\n                noProblems = merger.merge(headCommit, srcCommit);\n            refLogMessage.append(\": Merge made by \");\n            if (!revWalk.isMergedInto(headCommit, srcCommit))\n                refLogMessage.append(mergeStrategy.getName());\n            else\n                refLogMessage.append(\"recursive\");\n            refLogMessage.append('.');\n            if (noProblems) {\n                dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                String msg = null;\n                ObjectId newHeadId = null;\n                MergeStatus mergeStatus = null;\n                if (!commit && squash) {\n                    mergeStatus = MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n                }\n                if (!commit && !squash) {\n                    mergeStatus = MergeStatus.MERGED_NOT_COMMITTED;\n                }\n                if (commit && !squash) {\n                    try (Git git = new Git(getRepository())) {\n                        newHeadId = git.commit().setReflogComment(refLogMessage.toString()).call().getId();\n                    }\n                    mergeStatus = MergeStatus.MERGED;\n                    getRepository().autoGC(monitor);\n                }\n                if (commit && squash) {\n                    msg = JGitText.get().squashCommitNotUpdatingHEAD;\n                    newHeadId = headCommit.getId();\n                    mergeStatus = MergeStatus.MERGED_SQUASHED;\n                }\n                return new MergeResult(newHeadId, null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n            } else {\n                if (failingPaths != null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else {\n                    String mergeMessageWithConflicts = new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                    repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                }\n            }\n        }\n    } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n        List<String> conflicts = (dco == null) ? Collections.<String>emptyList() : dco.getConflicts();\n        throw new CheckoutConflictException(conflicts, e);\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk != null)\n            revWalk.close();\n    }\n}"
    },
    {
      "commit": "64a404803eaccc88d7d57567c5cd86b88c342bec",
      "startLine": 79,
      "endLine": 94,
      "methodCode": "@SuppressWarnings(\"boxing\")\npublic MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    fallBackToConfiguration();\n    checkParameters();\n    RevWalk revWalk = null;\n    DirCacheCheckout dco = null;\n    try {\n        Ref head = repo.exactRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage = new StringBuilder(\"merge \");\n        revWalk = new RevWalk(repo);\n        Ref ref = commits.get(0);\n        refLogMessage.append(ref.getName());\n        ref = repo.peel(ref);\n        ObjectId objectId = ref.getPeeledObjectId();\n        if (objectId == null)\n            objectId = ref.getObjectId();\n        RevCommit srcCommit = revWalk.lookupCommit(objectId);\n        ObjectId headId = head.getObjectId();\n        if (headId == null) {\n            revWalk.parseHeaders(srcCommit);\n            dco = new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            RefUpdate refUpdate = repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() != Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit = revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit) && fastForwardMode != FastForwardMode.NO_FF) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            String msg = null;\n            ObjectId newHead, base = null;\n            MergeStatus mergeStatus = null;\n            if (!squash) {\n                updateHead(refLogMessage, srcCommit, headId);\n                newHead = base = srcCommit;\n                mergeStatus = MergeStatus.FAST_FORWARD;\n            } else {\n                msg = JGitText.get().squashCommitNotUpdatingHEAD;\n                newHead = base = headId;\n                mergeStatus = MergeStatus.FAST_FORWARD_SQUASHED;\n                List<RevCommit> squashedCommits = RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage = new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            setCallable(false);\n            return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n        } else {\n            if (fastForwardMode == FastForwardMode.FF_ONLY) {\n                return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n            }\n            String mergeMessage = \"\";\n            if (!squash) {\n                if (message != null)\n                    mergeMessage = message;\n                else\n                    mergeMessage = new MergeMessageFormatter().format(commits, head);\n                repo.writeMergeCommitMsg(mergeMessage);\n                repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            } else {\n                List<RevCommit> squashedCommits = RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage = new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            Merger merger = mergeStrategy.newMerger(repo);\n            merger.setProgressMonitor(monitor);\n            boolean noProblems;\n            Map<String, org.eclipse.jgit.merge.MergeResult<?>> lowLevelResults = null;\n            Map<String, MergeFailureReason> failingPaths = null;\n            List<String> unmergedPaths = null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger = (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems = merger.merge(headCommit, srcCommit);\n                lowLevelResults = resolveMerger.getMergeResults();\n                failingPaths = resolveMerger.getFailingPaths();\n                unmergedPaths = resolveMerger.getUnmergedPaths();\n            } else\n                noProblems = merger.merge(headCommit, srcCommit);\n            refLogMessage.append(\": Merge made by \");\n            if (!revWalk.isMergedInto(headCommit, srcCommit))\n                refLogMessage.append(mergeStrategy.getName());\n            else\n                refLogMessage.append(\"recursive\");\n            refLogMessage.append('.');\n            if (noProblems) {\n                dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                String msg = null;\n                ObjectId newHeadId = null;\n                MergeStatus mergeStatus = null;\n                if (!commit && squash) {\n                    mergeStatus = MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n                }\n                if (!commit && !squash) {\n                    mergeStatus = MergeStatus.MERGED_NOT_COMMITTED;\n                }\n                if (commit && !squash) {\n                    try (Git git = new Git(getRepository())) {\n                        newHeadId = git.commit().setReflogComment(refLogMessage.toString()).call().getId();\n                    }\n                    mergeStatus = MergeStatus.MERGED;\n                    getRepository().autoGC(monitor);\n                }\n                if (commit && squash) {\n                    msg = JGitText.get().squashCommitNotUpdatingHEAD;\n                    newHeadId = headCommit.getId();\n                    mergeStatus = MergeStatus.MERGED_SQUASHED;\n                }\n                return new MergeResult(newHeadId, null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n            } else {\n                if (failingPaths != null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else {\n                    String mergeMessageWithConflicts = new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                    repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                }\n            }\n        }\n    } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n        List<String> conflicts = (dco == null) ? Collections.<String>emptyList() : dco.getConflicts();\n        throw new CheckoutConflictException(conflicts, e);\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk != null)\n            revWalk.close();\n    }\n}"
    },
    {
      "commit": "4c236ff4bbf664fd177a33f42517b0eef52510c8",
      "startLine": 79,
      "endLine": 94,
      "methodCode": "@SuppressWarnings(\"boxing\")\npublic MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    fallBackToConfiguration();\n    checkParameters();\n    RevWalk revWalk = null;\n    DirCacheCheckout dco = null;\n    try {\n        Ref head = repo.exactRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage = new StringBuilder(\"merge \");\n        revWalk = new RevWalk(repo);\n        Ref ref = commits.get(0);\n        refLogMessage.append(ref.getName());\n        ref = repo.peel(ref);\n        ObjectId objectId = ref.getPeeledObjectId();\n        if (objectId == null)\n            objectId = ref.getObjectId();\n        RevCommit srcCommit = revWalk.lookupCommit(objectId);\n        ObjectId headId = head.getObjectId();\n        if (headId == null) {\n            revWalk.parseHeaders(srcCommit);\n            dco = new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            RefUpdate refUpdate = repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() != Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit = revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit) && fastForwardMode != FastForwardMode.NO_FF) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            String msg = null;\n            ObjectId newHead, base = null;\n            MergeStatus mergeStatus = null;\n            if (!squash) {\n                updateHead(refLogMessage, srcCommit, headId);\n                newHead = base = srcCommit;\n                mergeStatus = MergeStatus.FAST_FORWARD;\n            } else {\n                msg = JGitText.get().squashCommitNotUpdatingHEAD;\n                newHead = base = headId;\n                mergeStatus = MergeStatus.FAST_FORWARD_SQUASHED;\n                List<RevCommit> squashedCommits = RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage = new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            setCallable(false);\n            return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n        } else {\n            if (fastForwardMode == FastForwardMode.FF_ONLY) {\n                return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n            }\n            String mergeMessage = \"\";\n            if (!squash) {\n                if (message != null)\n                    mergeMessage = message;\n                else\n                    mergeMessage = new MergeMessageFormatter().format(commits, head);\n                repo.writeMergeCommitMsg(mergeMessage);\n                repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            } else {\n                List<RevCommit> squashedCommits = RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage = new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            Merger merger = mergeStrategy.newMerger(repo);\n            merger.setProgressMonitor(monitor);\n            boolean noProblems;\n            Map<String, org.eclipse.jgit.merge.MergeResult<?>> lowLevelResults = null;\n            Map<String, MergeFailureReason> failingPaths = null;\n            List<String> unmergedPaths = null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger = (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems = merger.merge(headCommit, srcCommit);\n                lowLevelResults = resolveMerger.getMergeResults();\n                failingPaths = resolveMerger.getFailingPaths();\n                unmergedPaths = resolveMerger.getUnmergedPaths();\n            } else\n                noProblems = merger.merge(headCommit, srcCommit);\n            refLogMessage.append(\": Merge made by \");\n            if (!revWalk.isMergedInto(headCommit, srcCommit))\n                refLogMessage.append(mergeStrategy.getName());\n            else\n                refLogMessage.append(\"recursive\");\n            refLogMessage.append('.');\n            if (noProblems) {\n                dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                String msg = null;\n                ObjectId newHeadId = null;\n                MergeStatus mergeStatus = null;\n                if (!commit && squash) {\n                    mergeStatus = MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n                }\n                if (!commit && !squash) {\n                    mergeStatus = MergeStatus.MERGED_NOT_COMMITTED;\n                }\n                if (commit && !squash) {\n                    try (Git git = new Git(getRepository())) {\n                        newHeadId = git.commit().setReflogComment(refLogMessage.toString()).call().getId();\n                    }\n                    mergeStatus = MergeStatus.MERGED;\n                }\n                if (commit && squash) {\n                    msg = JGitText.get().squashCommitNotUpdatingHEAD;\n                    newHeadId = headCommit.getId();\n                    mergeStatus = MergeStatus.MERGED_SQUASHED;\n                }\n                return new MergeResult(newHeadId, null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n            } else {\n                if (failingPaths != null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else {\n                    String mergeMessageWithConflicts = new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                    repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                }\n            }\n        }\n    } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n        List<String> conflicts = (dco == null) ? Collections.<String>emptyList() : dco.getConflicts();\n        throw new CheckoutConflictException(conflicts, e);\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk != null)\n            revWalk.close();\n    }\n}"
    },
    {
      "commit": "1e1fb9fc596603a44b0fff6d19eeba2b005d659d",
      "startLine": 79,
      "endLine": 94,
      "methodCode": "@SuppressWarnings(\"boxing\")\npublic MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    fallBackToConfiguration();\n    checkParameters();\n    RevWalk revWalk = null;\n    DirCacheCheckout dco = null;\n    try {\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage = new StringBuilder(\"merge \");\n        revWalk = new RevWalk(repo);\n        Ref ref = commits.get(0);\n        refLogMessage.append(ref.getName());\n        ref = repo.peel(ref);\n        ObjectId objectId = ref.getPeeledObjectId();\n        if (objectId == null)\n            objectId = ref.getObjectId();\n        RevCommit srcCommit = revWalk.lookupCommit(objectId);\n        ObjectId headId = head.getObjectId();\n        if (headId == null) {\n            revWalk.parseHeaders(srcCommit);\n            dco = new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            RefUpdate refUpdate = repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() != Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit = revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit) && fastForwardMode != FastForwardMode.NO_FF) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            String msg = null;\n            ObjectId newHead, base = null;\n            MergeStatus mergeStatus = null;\n            if (!squash) {\n                updateHead(refLogMessage, srcCommit, headId);\n                newHead = base = srcCommit;\n                mergeStatus = MergeStatus.FAST_FORWARD;\n            } else {\n                msg = JGitText.get().squashCommitNotUpdatingHEAD;\n                newHead = base = headId;\n                mergeStatus = MergeStatus.FAST_FORWARD_SQUASHED;\n                List<RevCommit> squashedCommits = RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage = new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            setCallable(false);\n            return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n        } else {\n            if (fastForwardMode == FastForwardMode.FF_ONLY) {\n                return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n            }\n            String mergeMessage = \"\";\n            if (!squash) {\n                if (message != null)\n                    mergeMessage = message;\n                else\n                    mergeMessage = new MergeMessageFormatter().format(commits, head);\n                repo.writeMergeCommitMsg(mergeMessage);\n                repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            } else {\n                List<RevCommit> squashedCommits = RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage = new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            Merger merger = mergeStrategy.newMerger(repo);\n            merger.setProgressMonitor(monitor);\n            boolean noProblems;\n            Map<String, org.eclipse.jgit.merge.MergeResult<?>> lowLevelResults = null;\n            Map<String, MergeFailureReason> failingPaths = null;\n            List<String> unmergedPaths = null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger = (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems = merger.merge(headCommit, srcCommit);\n                lowLevelResults = resolveMerger.getMergeResults();\n                failingPaths = resolveMerger.getFailingPaths();\n                unmergedPaths = resolveMerger.getUnmergedPaths();\n            } else\n                noProblems = merger.merge(headCommit, srcCommit);\n            refLogMessage.append(\": Merge made by \");\n            if (!revWalk.isMergedInto(headCommit, srcCommit))\n                refLogMessage.append(mergeStrategy.getName());\n            else\n                refLogMessage.append(\"recursive\");\n            refLogMessage.append('.');\n            if (noProblems) {\n                dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                String msg = null;\n                ObjectId newHeadId = null;\n                MergeStatus mergeStatus = null;\n                if (!commit && squash) {\n                    mergeStatus = MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n                }\n                if (!commit && !squash) {\n                    mergeStatus = MergeStatus.MERGED_NOT_COMMITTED;\n                }\n                if (commit && !squash) {\n                    try (Git git = new Git(getRepository())) {\n                        newHeadId = git.commit().setReflogComment(refLogMessage.toString()).call().getId();\n                    }\n                    mergeStatus = MergeStatus.MERGED;\n                }\n                if (commit && squash) {\n                    msg = JGitText.get().squashCommitNotUpdatingHEAD;\n                    newHeadId = headCommit.getId();\n                    mergeStatus = MergeStatus.MERGED_SQUASHED;\n                }\n                return new MergeResult(newHeadId, null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n            } else {\n                if (failingPaths != null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else {\n                    String mergeMessageWithConflicts = new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                    repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                }\n            }\n        }\n    } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n        List<String> conflicts = (dco == null) ? Collections.<String>emptyList() : dco.getConflicts();\n        throw new CheckoutConflictException(conflicts, e);\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk != null)\n            revWalk.close();\n    }\n}"
    },
    {
      "commit": "0e73d395061d1bfee365acaa2f79c392175d13bf",
      "startLine": 79,
      "endLine": 93,
      "methodCode": "@SuppressWarnings(\"boxing\")\npublic MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    fallBackToConfiguration();\n    checkParameters();\n    RevWalk revWalk = null;\n    DirCacheCheckout dco = null;\n    try {\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage = new StringBuilder(\"merge \");\n        revWalk = new RevWalk(repo);\n        Ref ref = commits.get(0);\n        refLogMessage.append(ref.getName());\n        ref = repo.peel(ref);\n        ObjectId objectId = ref.getPeeledObjectId();\n        if (objectId == null)\n            objectId = ref.getObjectId();\n        RevCommit srcCommit = revWalk.lookupCommit(objectId);\n        ObjectId headId = head.getObjectId();\n        if (headId == null) {\n            revWalk.parseHeaders(srcCommit);\n            dco = new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            RefUpdate refUpdate = repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() != Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit = revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit) && fastForwardMode != FastForwardMode.NO_FF) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            String msg = null;\n            ObjectId newHead, base = null;\n            MergeStatus mergeStatus = null;\n            if (!squash) {\n                updateHead(refLogMessage, srcCommit, headId);\n                newHead = base = srcCommit;\n                mergeStatus = MergeStatus.FAST_FORWARD;\n            } else {\n                msg = JGitText.get().squashCommitNotUpdatingHEAD;\n                newHead = base = headId;\n                mergeStatus = MergeStatus.FAST_FORWARD_SQUASHED;\n                List<RevCommit> squashedCommits = RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage = new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            setCallable(false);\n            return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n        } else {\n            if (fastForwardMode == FastForwardMode.FF_ONLY) {\n                return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n            }\n            String mergeMessage = \"\";\n            if (!squash) {\n                if (message != null)\n                    mergeMessage = message;\n                else\n                    mergeMessage = new MergeMessageFormatter().format(commits, head);\n                repo.writeMergeCommitMsg(mergeMessage);\n                repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            } else {\n                List<RevCommit> squashedCommits = RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage = new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            Merger merger = mergeStrategy.newMerger(repo);\n            boolean noProblems;\n            Map<String, org.eclipse.jgit.merge.MergeResult<?>> lowLevelResults = null;\n            Map<String, MergeFailureReason> failingPaths = null;\n            List<String> unmergedPaths = null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger = (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems = merger.merge(headCommit, srcCommit);\n                lowLevelResults = resolveMerger.getMergeResults();\n                failingPaths = resolveMerger.getFailingPaths();\n                unmergedPaths = resolveMerger.getUnmergedPaths();\n            } else\n                noProblems = merger.merge(headCommit, srcCommit);\n            refLogMessage.append(\": Merge made by \");\n            if (!revWalk.isMergedInto(headCommit, srcCommit))\n                refLogMessage.append(mergeStrategy.getName());\n            else\n                refLogMessage.append(\"recursive\");\n            refLogMessage.append('.');\n            if (noProblems) {\n                dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                String msg = null;\n                ObjectId newHeadId = null;\n                MergeStatus mergeStatus = null;\n                if (!commit && squash) {\n                    mergeStatus = MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n                }\n                if (!commit && !squash) {\n                    mergeStatus = MergeStatus.MERGED_NOT_COMMITTED;\n                }\n                if (commit && !squash) {\n                    try (Git git = new Git(getRepository())) {\n                        newHeadId = git.commit().setReflogComment(refLogMessage.toString()).call().getId();\n                    }\n                    mergeStatus = MergeStatus.MERGED;\n                }\n                if (commit && squash) {\n                    msg = JGitText.get().squashCommitNotUpdatingHEAD;\n                    newHeadId = headCommit.getId();\n                    mergeStatus = MergeStatus.MERGED_SQUASHED;\n                }\n                return new MergeResult(newHeadId, null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n            } else {\n                if (failingPaths != null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else {\n                    String mergeMessageWithConflicts = new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                    repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                }\n            }\n        }\n    } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n        List<String> conflicts = (dco == null) ? Collections.<String>emptyList() : dco.getConflicts();\n        throw new CheckoutConflictException(conflicts, e);\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk != null)\n            revWalk.close();\n    }\n}"
    },
    {
      "commit": "46f3007b52a5d12c5a973957128ac38680b20ab8",
      "startLine": 79,
      "endLine": 93,
      "methodCode": "@SuppressWarnings(\"boxing\")\npublic MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    fallBackToConfiguration();\n    checkParameters();\n    RevWalk revWalk = null;\n    DirCacheCheckout dco = null;\n    try {\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage = new StringBuilder(\"merge \");\n        revWalk = new RevWalk(repo);\n        Ref ref = commits.get(0);\n        refLogMessage.append(ref.getName());\n        ref = repo.peel(ref);\n        ObjectId objectId = ref.getPeeledObjectId();\n        if (objectId == null)\n            objectId = ref.getObjectId();\n        RevCommit srcCommit = revWalk.lookupCommit(objectId);\n        ObjectId headId = head.getObjectId();\n        if (headId == null) {\n            revWalk.parseHeaders(srcCommit);\n            dco = new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            RefUpdate refUpdate = repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() != Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit = revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit) && fastForwardMode != FastForwardMode.NO_FF) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            String msg = null;\n            ObjectId newHead, base = null;\n            MergeStatus mergeStatus = null;\n            if (!squash) {\n                updateHead(refLogMessage, srcCommit, headId);\n                newHead = base = srcCommit;\n                mergeStatus = MergeStatus.FAST_FORWARD;\n            } else {\n                msg = JGitText.get().squashCommitNotUpdatingHEAD;\n                newHead = base = headId;\n                mergeStatus = MergeStatus.FAST_FORWARD_SQUASHED;\n                List<RevCommit> squashedCommits = RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage = new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            setCallable(false);\n            return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n        } else {\n            if (fastForwardMode == FastForwardMode.FF_ONLY) {\n                return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n            }\n            String mergeMessage = \"\";\n            if (!squash) {\n                if (message != null)\n                    mergeMessage = message;\n                else\n                    mergeMessage = new MergeMessageFormatter().format(commits, head);\n                repo.writeMergeCommitMsg(mergeMessage);\n                repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            } else {\n                List<RevCommit> squashedCommits = RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage = new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            Merger merger = mergeStrategy.newMerger(repo);\n            boolean noProblems;\n            Map<String, org.eclipse.jgit.merge.MergeResult<?>> lowLevelResults = null;\n            Map<String, MergeFailureReason> failingPaths = null;\n            List<String> unmergedPaths = null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger = (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems = merger.merge(headCommit, srcCommit);\n                lowLevelResults = resolveMerger.getMergeResults();\n                failingPaths = resolveMerger.getFailingPaths();\n                unmergedPaths = resolveMerger.getUnmergedPaths();\n            } else\n                noProblems = merger.merge(headCommit, srcCommit);\n            refLogMessage.append(\": Merge made by \");\n            if (!revWalk.isMergedInto(headCommit, srcCommit))\n                refLogMessage.append(mergeStrategy.getName());\n            else\n                refLogMessage.append(\"recursive\");\n            refLogMessage.append('.');\n            if (noProblems) {\n                dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                String msg = null;\n                ObjectId newHeadId = null;\n                MergeStatus mergeStatus = null;\n                if (!commit && squash) {\n                    mergeStatus = MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n                }\n                if (!commit && !squash) {\n                    mergeStatus = MergeStatus.MERGED_NOT_COMMITTED;\n                }\n                if (commit && !squash) {\n                    newHeadId = new Git(getRepository()).commit().setReflogComment(refLogMessage.toString()).call().getId();\n                    mergeStatus = MergeStatus.MERGED;\n                }\n                if (commit && squash) {\n                    msg = JGitText.get().squashCommitNotUpdatingHEAD;\n                    newHeadId = headCommit.getId();\n                    mergeStatus = MergeStatus.MERGED_SQUASHED;\n                }\n                return new MergeResult(newHeadId, null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n            } else {\n                if (failingPaths != null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else {\n                    String mergeMessageWithConflicts = new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                    repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                }\n            }\n        }\n    } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n        List<String> conflicts = (dco == null) ? Collections.<String>emptyList() : dco.getConflicts();\n        throw new CheckoutConflictException(conflicts, e);\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk != null)\n            revWalk.release();\n    }\n}"
    },
    {
      "commit": "48e36d8cb335382b99ec829d0dfe34be71ed49bb",
      "startLine": 76,
      "endLine": 90,
      "methodCode": "@SuppressWarnings(\"boxing\")\npublic MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    fallBackToConfiguration();\n    checkParameters();\n    RevWalk revWalk = null;\n    DirCacheCheckout dco = null;\n    try {\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage = new StringBuilder(\"merge \");\n        revWalk = new RevWalk(repo);\n        Ref ref = commits.get(0);\n        refLogMessage.append(ref.getName());\n        ref = repo.peel(ref);\n        ObjectId objectId = ref.getPeeledObjectId();\n        if (objectId == null)\n            objectId = ref.getObjectId();\n        RevCommit srcCommit = revWalk.lookupCommit(objectId);\n        ObjectId headId = head.getObjectId();\n        if (headId == null) {\n            revWalk.parseHeaders(srcCommit);\n            dco = new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            RefUpdate refUpdate = repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() != Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit = revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit) && fastForwardMode != FastForwardMode.NO_FF) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            String msg = null;\n            ObjectId newHead, base = null;\n            MergeStatus mergeStatus = null;\n            if (!squash) {\n                updateHead(refLogMessage, srcCommit, headId);\n                newHead = base = srcCommit;\n                mergeStatus = MergeStatus.FAST_FORWARD;\n            } else {\n                msg = JGitText.get().squashCommitNotUpdatingHEAD;\n                newHead = base = headId;\n                mergeStatus = MergeStatus.FAST_FORWARD_SQUASHED;\n                List<RevCommit> squashedCommits = RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage = new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            setCallable(false);\n            return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n        } else {\n            if (fastForwardMode == FastForwardMode.FF_ONLY) {\n                return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n            }\n            String mergeMessage = \"\";\n            if (!squash) {\n                mergeMessage = new MergeMessageFormatter().format(commits, head);\n                repo.writeMergeCommitMsg(mergeMessage);\n                repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            } else {\n                List<RevCommit> squashedCommits = RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage = new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            Merger merger = mergeStrategy.newMerger(repo);\n            boolean noProblems;\n            Map<String, org.eclipse.jgit.merge.MergeResult<?>> lowLevelResults = null;\n            Map<String, MergeFailureReason> failingPaths = null;\n            List<String> unmergedPaths = null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger = (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems = merger.merge(headCommit, srcCommit);\n                lowLevelResults = resolveMerger.getMergeResults();\n                failingPaths = resolveMerger.getFailingPaths();\n                unmergedPaths = resolveMerger.getUnmergedPaths();\n            } else\n                noProblems = merger.merge(headCommit, srcCommit);\n            refLogMessage.append(\": Merge made by \");\n            if (!revWalk.isMergedInto(headCommit, srcCommit))\n                refLogMessage.append(mergeStrategy.getName());\n            else\n                refLogMessage.append(\"recursive\");\n            refLogMessage.append('.');\n            if (noProblems) {\n                dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                String msg = null;\n                ObjectId newHeadId = null;\n                MergeStatus mergeStatus = null;\n                if (!commit && squash) {\n                    mergeStatus = MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n                }\n                if (!commit && !squash) {\n                    mergeStatus = MergeStatus.MERGED_NOT_COMMITTED;\n                }\n                if (commit && !squash) {\n                    newHeadId = new Git(getRepository()).commit().setReflogComment(refLogMessage.toString()).call().getId();\n                    mergeStatus = MergeStatus.MERGED;\n                }\n                if (commit && squash) {\n                    msg = JGitText.get().squashCommitNotUpdatingHEAD;\n                    newHeadId = headCommit.getId();\n                    mergeStatus = MergeStatus.MERGED_SQUASHED;\n                }\n                return new MergeResult(newHeadId, null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n            } else {\n                if (failingPaths != null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else {\n                    String mergeMessageWithConflicts = new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                    repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                }\n            }\n        }\n    } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n        List<String> conflicts = (dco == null) ? Collections.<String>emptyList() : dco.getConflicts();\n        throw new CheckoutConflictException(conflicts, e);\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk != null)\n            revWalk.release();\n    }\n}"
    },
    {
      "commit": "7dc8a4f089c1ca4762cf6fbf2e77898607a5820a",
      "startLine": 74,
      "endLine": 88,
      "methodCode": "public MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    checkParameters();\n    RevWalk revWalk = null;\n    DirCacheCheckout dco = null;\n    try {\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage = new StringBuilder(\"merge \");\n        revWalk = new RevWalk(repo);\n        Ref ref = commits.get(0);\n        refLogMessage.append(ref.getName());\n        ref = repo.peel(ref);\n        ObjectId objectId = ref.getPeeledObjectId();\n        if (objectId == null)\n            objectId = ref.getObjectId();\n        RevCommit srcCommit = revWalk.lookupCommit(objectId);\n        ObjectId headId = head.getObjectId();\n        if (headId == null) {\n            revWalk.parseHeaders(srcCommit);\n            dco = new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            RefUpdate refUpdate = repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() != Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit = revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit) && fastForwardMode != FastForwardMode.NO_FF) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            String msg = null;\n            ObjectId newHead, base = null;\n            MergeStatus mergeStatus = null;\n            if (!squash) {\n                updateHead(refLogMessage, srcCommit, headId);\n                newHead = base = srcCommit;\n                mergeStatus = MergeStatus.FAST_FORWARD;\n            } else {\n                msg = JGitText.get().squashCommitNotUpdatingHEAD;\n                newHead = base = headId;\n                mergeStatus = MergeStatus.FAST_FORWARD_SQUASHED;\n                List<RevCommit> squashedCommits = RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage = new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            setCallable(false);\n            return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n        } else {\n            if (fastForwardMode == FastForwardMode.FF_ONLY) {\n                return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n            }\n            String mergeMessage = \"\";\n            if (!squash) {\n                mergeMessage = new MergeMessageFormatter().format(commits, head);\n                repo.writeMergeCommitMsg(mergeMessage);\n                repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            } else {\n                List<RevCommit> squashedCommits = RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage = new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            Merger merger = mergeStrategy.newMerger(repo);\n            boolean noProblems;\n            Map<String, org.eclipse.jgit.merge.MergeResult<?>> lowLevelResults = null;\n            Map<String, MergeFailureReason> failingPaths = null;\n            List<String> unmergedPaths = null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger = (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems = merger.merge(headCommit, srcCommit);\n                lowLevelResults = resolveMerger.getMergeResults();\n                failingPaths = resolveMerger.getFailingPaths();\n                unmergedPaths = resolveMerger.getUnmergedPaths();\n            } else\n                noProblems = merger.merge(headCommit, srcCommit);\n            refLogMessage.append(\": Merge made by \");\n            if (!revWalk.isMergedInto(headCommit, srcCommit))\n                refLogMessage.append(mergeStrategy.getName());\n            else\n                refLogMessage.append(\"recursive\");\n            refLogMessage.append('.');\n            if (noProblems) {\n                dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                String msg = null;\n                ObjectId newHeadId = null;\n                MergeStatus mergeStatus = null;\n                if (!commit && squash) {\n                    mergeStatus = MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n                }\n                if (!commit && !squash) {\n                    mergeStatus = MergeStatus.MERGED_NOT_COMMITTED;\n                }\n                if (commit && !squash) {\n                    newHeadId = new Git(getRepository()).commit().setReflogComment(refLogMessage.toString()).call().getId();\n                    mergeStatus = MergeStatus.MERGED;\n                }\n                if (commit && squash) {\n                    msg = JGitText.get().squashCommitNotUpdatingHEAD;\n                    newHeadId = headCommit.getId();\n                    mergeStatus = MergeStatus.MERGED_SQUASHED;\n                }\n                return new MergeResult(newHeadId, null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n            } else {\n                if (failingPaths != null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else {\n                    String mergeMessageWithConflicts = new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                    repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                    return new MergeResult(null, merger.getBaseCommitId(), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                }\n            }\n        }\n    } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n        List<String> conflicts = (dco == null) ? Collections.<String>emptyList() : dco.getConflicts();\n        throw new CheckoutConflictException(conflicts, e);\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk != null)\n            revWalk.release();\n    }\n}"
    },
    {
      "commit": "545358577376bec8fc140a76ce0f72bf81cc0a94",
      "startLine": 74,
      "endLine": 88,
      "methodCode": "public MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    checkParameters();\n    RevWalk revWalk = null;\n    DirCacheCheckout dco = null;\n    try {\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage = new StringBuilder(\"merge \");\n        revWalk = new RevWalk(repo);\n        Ref ref = commits.get(0);\n        refLogMessage.append(ref.getName());\n        ref = repo.peel(ref);\n        ObjectId objectId = ref.getPeeledObjectId();\n        if (objectId == null)\n            objectId = ref.getObjectId();\n        RevCommit srcCommit = revWalk.lookupCommit(objectId);\n        ObjectId headId = head.getObjectId();\n        if (headId == null) {\n            revWalk.parseHeaders(srcCommit);\n            dco = new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            RefUpdate refUpdate = repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() != Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit = revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit) && fastForwardMode != FastForwardMode.NO_FF) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            String msg = null;\n            ObjectId newHead, base = null;\n            MergeStatus mergeStatus = null;\n            if (!squash) {\n                updateHead(refLogMessage, srcCommit, headId);\n                newHead = base = srcCommit;\n                mergeStatus = MergeStatus.FAST_FORWARD;\n            } else {\n                msg = JGitText.get().squashCommitNotUpdatingHEAD;\n                newHead = base = headId;\n                mergeStatus = MergeStatus.FAST_FORWARD_SQUASHED;\n                List<RevCommit> squashedCommits = RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage = new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            setCallable(false);\n            return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n        } else {\n            if (fastForwardMode == FastForwardMode.FF_ONLY) {\n                return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n            }\n            String mergeMessage = \"\";\n            if (!squash) {\n                mergeMessage = new MergeMessageFormatter().format(commits, head);\n                repo.writeMergeCommitMsg(mergeMessage);\n                repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            } else {\n                List<RevCommit> squashedCommits = RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage = new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            Merger merger = mergeStrategy.newMerger(repo);\n            boolean noProblems;\n            Map<String, org.eclipse.jgit.merge.MergeResult<?>> lowLevelResults = null;\n            Map<String, MergeFailureReason> failingPaths = null;\n            List<String> unmergedPaths = null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger = (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems = merger.merge(headCommit, srcCommit);\n                lowLevelResults = resolveMerger.getMergeResults();\n                failingPaths = resolveMerger.getFailingPaths();\n                unmergedPaths = resolveMerger.getUnmergedPaths();\n            } else\n                noProblems = merger.merge(headCommit, srcCommit);\n            refLogMessage.append(\": Merge made by \");\n            if (!revWalk.isMergedInto(headCommit, srcCommit))\n                refLogMessage.append(mergeStrategy.getName());\n            else\n                refLogMessage.append(\"recursive\");\n            refLogMessage.append('.');\n            if (noProblems) {\n                dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                String msg = null;\n                ObjectId newHeadId = null;\n                MergeStatus mergeStatus = null;\n                if (!commit && squash) {\n                    mergeStatus = MergeStatus.MERGED_SQUASHED_NOT_COMMITTED;\n                }\n                if (!commit && !squash) {\n                    mergeStatus = MergeStatus.MERGED_NOT_COMMITTED;\n                }\n                if (commit && !squash) {\n                    newHeadId = new Git(getRepository()).commit().setReflogComment(refLogMessage.toString()).call().getId();\n                    mergeStatus = MergeStatus.MERGED;\n                }\n                if (commit && squash) {\n                    msg = JGitText.get().squashCommitNotUpdatingHEAD;\n                    newHeadId = headCommit.getId();\n                    mergeStatus = MergeStatus.MERGED_SQUASHED;\n                }\n                return new MergeResult(newHeadId, null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n            } else {\n                if (failingPaths != null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else {\n                    String mergeMessageWithConflicts = new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                    repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                }\n            }\n        }\n    } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n        List<String> conflicts = (dco == null) ? Collections.<String>emptyList() : dco.getConflicts();\n        throw new CheckoutConflictException(conflicts, e);\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk != null)\n            revWalk.release();\n    }\n}"
    },
    {
      "commit": "3a4ebc0c24b7732a57064299153794084fbfae59",
      "startLine": 74,
      "endLine": 88,
      "methodCode": "public MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    checkParameters();\n    RevWalk revWalk = null;\n    DirCacheCheckout dco = null;\n    try {\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage = new StringBuilder(\"merge \");\n        revWalk = new RevWalk(repo);\n        Ref ref = commits.get(0);\n        refLogMessage.append(ref.getName());\n        ref = repo.peel(ref);\n        ObjectId objectId = ref.getPeeledObjectId();\n        if (objectId == null)\n            objectId = ref.getObjectId();\n        RevCommit srcCommit = revWalk.lookupCommit(objectId);\n        ObjectId headId = head.getObjectId();\n        if (headId == null) {\n            revWalk.parseHeaders(srcCommit);\n            dco = new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            RefUpdate refUpdate = repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() != Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit = revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit) && fastForwardMode != FastForwardMode.NO_FF) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            String msg = null;\n            ObjectId newHead, base = null;\n            MergeStatus mergeStatus = null;\n            if (!squash) {\n                updateHead(refLogMessage, srcCommit, headId);\n                newHead = base = srcCommit;\n                mergeStatus = MergeStatus.FAST_FORWARD;\n            } else {\n                msg = JGitText.get().squashCommitNotUpdatingHEAD;\n                newHead = base = headId;\n                mergeStatus = MergeStatus.FAST_FORWARD_SQUASHED;\n                List<RevCommit> squashedCommits = RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage = new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            setCallable(false);\n            return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n        } else {\n            if (fastForwardMode == FastForwardMode.FF_ONLY) {\n                return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n            }\n            String mergeMessage = \"\";\n            if (!squash) {\n                mergeMessage = new MergeMessageFormatter().format(commits, head);\n                repo.writeMergeCommitMsg(mergeMessage);\n                repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            } else {\n                List<RevCommit> squashedCommits = RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage = new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            Merger merger = mergeStrategy.newMerger(repo);\n            boolean noProblems;\n            Map<String, org.eclipse.jgit.merge.MergeResult<?>> lowLevelResults = null;\n            Map<String, MergeFailureReason> failingPaths = null;\n            List<String> unmergedPaths = null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger = (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems = merger.merge(headCommit, srcCommit);\n                lowLevelResults = resolveMerger.getMergeResults();\n                failingPaths = resolveMerger.getFailingPaths();\n                unmergedPaths = resolveMerger.getUnmergedPaths();\n            } else\n                noProblems = merger.merge(headCommit, srcCommit);\n            refLogMessage.append(\": Merge made by \");\n            if (!revWalk.isMergedInto(headCommit, srcCommit))\n                refLogMessage.append(mergeStrategy.getName());\n            else\n                refLogMessage.append(\"recursive\");\n            refLogMessage.append('.');\n            if (noProblems) {\n                dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                String msg = null;\n                RevCommit newHead = null;\n                MergeStatus mergeStatus = null;\n                if (!squash) {\n                    newHead = new Git(getRepository()).commit().setReflogComment(refLogMessage.toString()).call();\n                    mergeStatus = MergeStatus.MERGED;\n                } else {\n                    msg = JGitText.get().squashCommitNotUpdatingHEAD;\n                    newHead = headCommit;\n                    mergeStatus = MergeStatus.MERGED_SQUASHED;\n                }\n                return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n            } else {\n                if (failingPaths != null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else {\n                    String mergeMessageWithConflicts = new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                    repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                }\n            }\n        }\n    } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n        List<String> conflicts = (dco == null) ? Collections.<String>emptyList() : dco.getConflicts();\n        throw new CheckoutConflictException(conflicts, e);\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk != null)\n            revWalk.release();\n    }\n}"
    },
    {
      "commit": "eb6093293022e468c2aea93a11f63b366e0d3891",
      "startLine": 73,
      "endLine": 87,
      "methodCode": "public MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    checkParameters();\n    RevWalk revWalk = null;\n    DirCacheCheckout dco = null;\n    try {\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage = new StringBuilder(\"merge \");\n        revWalk = new RevWalk(repo);\n        Ref ref = commits.get(0);\n        refLogMessage.append(ref.getName());\n        ObjectId objectId = ref.getPeeledObjectId();\n        if (objectId == null)\n            objectId = ref.getObjectId();\n        RevCommit srcCommit = revWalk.lookupCommit(objectId);\n        ObjectId headId = head.getObjectId();\n        if (headId == null) {\n            revWalk.parseHeaders(srcCommit);\n            dco = new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            RefUpdate refUpdate = repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() != Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit = revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit) && fastForwardMode != FastForwardMode.NO_FF) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            String msg = null;\n            ObjectId newHead, base = null;\n            MergeStatus mergeStatus = null;\n            if (!squash) {\n                updateHead(refLogMessage, srcCommit, headId);\n                newHead = base = srcCommit;\n                mergeStatus = MergeStatus.FAST_FORWARD;\n            } else {\n                msg = JGitText.get().squashCommitNotUpdatingHEAD;\n                newHead = base = headId;\n                mergeStatus = MergeStatus.FAST_FORWARD_SQUASHED;\n                List<RevCommit> squashedCommits = RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage = new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            setCallable(false);\n            return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n        } else {\n            if (fastForwardMode == FastForwardMode.FF_ONLY) {\n                return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n            }\n            String mergeMessage = \"\";\n            if (!squash) {\n                mergeMessage = new MergeMessageFormatter().format(commits, head);\n                repo.writeMergeCommitMsg(mergeMessage);\n                repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            } else {\n                List<RevCommit> squashedCommits = RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage = new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            Merger merger = mergeStrategy.newMerger(repo);\n            boolean noProblems;\n            Map<String, org.eclipse.jgit.merge.MergeResult<?>> lowLevelResults = null;\n            Map<String, MergeFailureReason> failingPaths = null;\n            List<String> unmergedPaths = null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger = (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems = merger.merge(headCommit, srcCommit);\n                lowLevelResults = resolveMerger.getMergeResults();\n                failingPaths = resolveMerger.getFailingPaths();\n                unmergedPaths = resolveMerger.getUnmergedPaths();\n            } else\n                noProblems = merger.merge(headCommit, srcCommit);\n            refLogMessage.append(\": Merge made by \");\n            if (!revWalk.isMergedInto(headCommit, srcCommit))\n                refLogMessage.append(mergeStrategy.getName());\n            else\n                refLogMessage.append(\"recursive\");\n            refLogMessage.append('.');\n            if (noProblems) {\n                dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                String msg = null;\n                RevCommit newHead = null;\n                MergeStatus mergeStatus = null;\n                if (!squash) {\n                    newHead = new Git(getRepository()).commit().setReflogComment(refLogMessage.toString()).call();\n                    mergeStatus = MergeStatus.MERGED;\n                } else {\n                    msg = JGitText.get().squashCommitNotUpdatingHEAD;\n                    newHead = headCommit;\n                    mergeStatus = MergeStatus.MERGED_SQUASHED;\n                }\n                return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n            } else {\n                if (failingPaths != null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else {\n                    String mergeMessageWithConflicts = new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                    repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                }\n            }\n        }\n    } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n        List<String> conflicts = (dco == null) ? Collections.<String>emptyList() : dco.getConflicts();\n        throw new CheckoutConflictException(conflicts, e);\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk != null)\n            revWalk.release();\n    }\n}"
    },
    {
      "commit": "642ff2cd7dd6ae361e4993255ade89a32e20601f",
      "startLine": 73,
      "endLine": 87,
      "methodCode": "public MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    checkParameters();\n    RevWalk revWalk = null;\n    DirCacheCheckout dco = null;\n    try {\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage = new StringBuilder(\"merge \");\n        revWalk = new RevWalk(repo);\n        Ref ref = commits.get(0);\n        refLogMessage.append(ref.getName());\n        ObjectId objectId = ref.getPeeledObjectId();\n        if (objectId == null)\n            objectId = ref.getObjectId();\n        RevCommit srcCommit = revWalk.lookupCommit(objectId);\n        ObjectId headId = head.getObjectId();\n        if (headId == null) {\n            revWalk.parseHeaders(srcCommit);\n            dco = new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            RefUpdate refUpdate = repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() != Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit = revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit) && fastForwardMode != FastForwardMode.NO_FF) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            String msg = null;\n            ObjectId newHead, base = null;\n            MergeStatus mergeStatus = null;\n            if (!squash) {\n                updateHead(refLogMessage, srcCommit, headId);\n                newHead = base = srcCommit;\n                mergeStatus = MergeStatus.FAST_FORWARD;\n            } else {\n                msg = JGitText.get().squashCommitNotUpdatingHEAD;\n                newHead = base = headId;\n                mergeStatus = MergeStatus.FAST_FORWARD_SQUASHED;\n                List<RevCommit> squashedCommits = RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage = new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            setCallable(false);\n            return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n        } else {\n            if (fastForwardMode == FastForwardMode.NO_FF) {\n                return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n            }\n            String mergeMessage = \"\";\n            if (!squash) {\n                mergeMessage = new MergeMessageFormatter().format(commits, head);\n                repo.writeMergeCommitMsg(mergeMessage);\n                repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            } else {\n                List<RevCommit> squashedCommits = RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage = new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            Merger merger = mergeStrategy.newMerger(repo);\n            boolean noProblems;\n            Map<String, org.eclipse.jgit.merge.MergeResult<?>> lowLevelResults = null;\n            Map<String, MergeFailureReason> failingPaths = null;\n            List<String> unmergedPaths = null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger = (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems = merger.merge(headCommit, srcCommit);\n                lowLevelResults = resolveMerger.getMergeResults();\n                failingPaths = resolveMerger.getFailingPaths();\n                unmergedPaths = resolveMerger.getUnmergedPaths();\n            } else\n                noProblems = merger.merge(headCommit, srcCommit);\n            refLogMessage.append(\": Merge made by \");\n            if (!revWalk.isMergedInto(headCommit, srcCommit))\n                refLogMessage.append(mergeStrategy.getName());\n            else\n                refLogMessage.append(\"recursive\");\n            refLogMessage.append('.');\n            if (noProblems) {\n                dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                String msg = null;\n                RevCommit newHead = null;\n                MergeStatus mergeStatus = null;\n                if (!squash) {\n                    newHead = new Git(getRepository()).commit().setReflogComment(refLogMessage.toString()).call();\n                    mergeStatus = MergeStatus.MERGED;\n                } else {\n                    msg = JGitText.get().squashCommitNotUpdatingHEAD;\n                    newHead = headCommit;\n                    mergeStatus = MergeStatus.MERGED_SQUASHED;\n                }\n                return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n            } else {\n                if (failingPaths != null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else {\n                    String mergeMessageWithConflicts = new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                    repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                }\n            }\n        }\n    } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n        List<String> conflicts = (dco == null) ? Collections.<String>emptyList() : dco.getConflicts();\n        throw new CheckoutConflictException(conflicts, e);\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk != null)\n            revWalk.release();\n    }\n}"
    },
    {
      "commit": "c310fa0c802f40a774edb58641de3ac5bfad0e2c",
      "startLine": 73,
      "endLine": 87,
      "methodCode": "public MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    checkParameters();\n    RevWalk revWalk = null;\n    DirCacheCheckout dco = null;\n    try {\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage = new StringBuilder(\"merge \");\n        revWalk = new RevWalk(repo);\n        Ref ref = commits.get(0);\n        refLogMessage.append(ref.getName());\n        ObjectId objectId = ref.getPeeledObjectId();\n        if (objectId == null)\n            objectId = ref.getObjectId();\n        RevCommit srcCommit = revWalk.lookupCommit(objectId);\n        ObjectId headId = head.getObjectId();\n        if (headId == null) {\n            revWalk.parseHeaders(srcCommit);\n            dco = new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            RefUpdate refUpdate = repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() != Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit = revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit) && fastForwardMode == FastForwardMode.FF) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            String msg = null;\n            ObjectId newHead, base = null;\n            MergeStatus mergeStatus = null;\n            if (!squash) {\n                updateHead(refLogMessage, srcCommit, headId);\n                newHead = base = srcCommit;\n                mergeStatus = MergeStatus.FAST_FORWARD;\n            } else {\n                msg = JGitText.get().squashCommitNotUpdatingHEAD;\n                newHead = base = headId;\n                mergeStatus = MergeStatus.FAST_FORWARD_SQUASHED;\n                List<RevCommit> squashedCommits = RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage = new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            setCallable(false);\n            return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n        } else {\n            if (fastForwardMode == FastForwardMode.FF_ONLY) {\n                return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n            }\n            String mergeMessage = \"\";\n            if (!squash) {\n                mergeMessage = new MergeMessageFormatter().format(commits, head);\n                repo.writeMergeCommitMsg(mergeMessage);\n                repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            } else {\n                List<RevCommit> squashedCommits = RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage = new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            Merger merger = mergeStrategy.newMerger(repo);\n            boolean noProblems;\n            Map<String, org.eclipse.jgit.merge.MergeResult<?>> lowLevelResults = null;\n            Map<String, MergeFailureReason> failingPaths = null;\n            List<String> unmergedPaths = null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger = (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems = merger.merge(headCommit, srcCommit);\n                lowLevelResults = resolveMerger.getMergeResults();\n                failingPaths = resolveMerger.getFailingPaths();\n                unmergedPaths = resolveMerger.getUnmergedPaths();\n            } else\n                noProblems = merger.merge(headCommit, srcCommit);\n            refLogMessage.append(\": Merge made by \");\n            if (!revWalk.isMergedInto(headCommit, srcCommit))\n                refLogMessage.append(mergeStrategy.getName());\n            else\n                refLogMessage.append(\"recursive\");\n            refLogMessage.append('.');\n            if (noProblems) {\n                dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                String msg = null;\n                RevCommit newHead = null;\n                MergeStatus mergeStatus = null;\n                if (!squash) {\n                    newHead = new Git(getRepository()).commit().setReflogComment(refLogMessage.toString()).call();\n                    mergeStatus = MergeStatus.MERGED;\n                } else {\n                    msg = JGitText.get().squashCommitNotUpdatingHEAD;\n                    newHead = headCommit;\n                    mergeStatus = MergeStatus.MERGED_SQUASHED;\n                }\n                return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n            } else {\n                if (failingPaths != null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else {\n                    String mergeMessageWithConflicts = new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                    repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                }\n            }\n        }\n    } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n        List<String> conflicts = (dco == null) ? Collections.<String>emptyList() : dco.getConflicts();\n        throw new CheckoutConflictException(conflicts, e);\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk != null)\n            revWalk.release();\n    }\n}"
    },
    {
      "commit": "318f3d464307e3efd8342852310c17e71a7282fe",
      "startLine": 73,
      "endLine": 87,
      "methodCode": "public MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    checkParameters();\n    RevWalk revWalk = null;\n    DirCacheCheckout dco = null;\n    try {\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage = new StringBuilder(\"merge \");\n        revWalk = new RevWalk(repo);\n        Ref ref = commits.get(0);\n        refLogMessage.append(ref.getName());\n        ObjectId objectId = ref.getPeeledObjectId();\n        if (objectId == null)\n            objectId = ref.getObjectId();\n        RevCommit srcCommit = revWalk.lookupCommit(objectId);\n        ObjectId headId = head.getObjectId();\n        if (headId == null) {\n            revWalk.parseHeaders(srcCommit);\n            dco = new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            RefUpdate refUpdate = repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() != Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit = revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit) && fastForwardMode == FastForwardMode.FF) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            String msg = null;\n            ObjectId newHead, base = null;\n            MergeStatus mergeStatus = null;\n            if (!squash) {\n                updateHead(refLogMessage, srcCommit, headId);\n                newHead = base = srcCommit;\n                mergeStatus = MergeStatus.FAST_FORWARD;\n            } else {\n                msg = JGitText.get().squashCommitNotUpdatingHEAD;\n                newHead = base = headId;\n                mergeStatus = MergeStatus.FAST_FORWARD_SQUASHED;\n                List<RevCommit> squashedCommits = RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage = new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            setCallable(false);\n            return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n        } else {\n            if (fastForwardMode == FastForwardMode.FF_ONLY) {\n                return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ABORTED, mergeStrategy, null, null);\n            }\n            String mergeMessage = \"\";\n            if (!squash) {\n                mergeMessage = new MergeMessageFormatter().format(commits, head);\n                repo.writeMergeCommitMsg(mergeMessage);\n                repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            } else {\n                List<RevCommit> squashedCommits = RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage = new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            Merger merger = mergeStrategy.newMerger(repo);\n            boolean noProblems;\n            Map<String, org.eclipse.jgit.merge.MergeResult<?>> lowLevelResults = null;\n            Map<String, MergeFailureReason> failingPaths = null;\n            List<String> unmergedPaths = null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger = (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems = merger.merge(headCommit, srcCommit);\n                lowLevelResults = resolveMerger.getMergeResults();\n                failingPaths = resolveMerger.getFailingPaths();\n                unmergedPaths = resolveMerger.getUnmergedPaths();\n            } else\n                noProblems = merger.merge(headCommit, srcCommit);\n            refLogMessage.append(\": Merge made by \");\n            if (!revWalk.isMergedInto(headCommit, srcCommit))\n                refLogMessage.append(mergeStrategy.getName());\n            else\n                refLogMessage.append(\"recursive\");\n            refLogMessage.append('.');\n            if (noProblems) {\n                dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                String msg = null;\n                RevCommit newHead = null;\n                MergeStatus mergeStatus = null;\n                if (!squash) {\n                    newHead = new Git(getRepository()).commit().setReflogComment(refLogMessage.toString()).call();\n                    mergeStatus = MergeStatus.MERGED;\n                } else {\n                    msg = JGitText.get().squashCommitNotUpdatingHEAD;\n                    newHead = headCommit;\n                    mergeStatus = MergeStatus.MERGED_SQUASHED;\n                }\n                return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n            } else {\n                if (failingPaths != null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else {\n                    String mergeMessageWithConflicts = new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                    repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                }\n            }\n        }\n    } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n        List<String> conflicts = (dco == null) ? Collections.<String>emptyList() : dco.getConflicts();\n        throw new CheckoutConflictException(conflicts, e);\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk != null)\n            revWalk.release();\n    }\n}"
    },
    {
      "commit": "2656ac1b5acb9b73c6b47e2cf8830a0a0b2cc214",
      "startLine": 71,
      "endLine": 85,
      "methodCode": "public MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    if (commits.size() != 1)\n        throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads, mergeStrategy.getName(), Integer.valueOf(commits.size())));\n    RevWalk revWalk = null;\n    DirCacheCheckout dco = null;\n    try {\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage = new StringBuilder(\"merge \");\n        revWalk = new RevWalk(repo);\n        Ref ref = commits.get(0);\n        refLogMessage.append(ref.getName());\n        ObjectId objectId = ref.getPeeledObjectId();\n        if (objectId == null)\n            objectId = ref.getObjectId();\n        RevCommit srcCommit = revWalk.lookupCommit(objectId);\n        ObjectId headId = head.getObjectId();\n        if (headId == null) {\n            revWalk.parseHeaders(srcCommit);\n            dco = new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            RefUpdate refUpdate = repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() != Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit = revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            String msg = null;\n            ObjectId newHead, base = null;\n            MergeStatus mergeStatus = null;\n            if (!squash) {\n                updateHead(refLogMessage, srcCommit, headId);\n                newHead = base = srcCommit;\n                mergeStatus = MergeStatus.FAST_FORWARD;\n            } else {\n                msg = JGitText.get().squashCommitNotUpdatingHEAD;\n                newHead = base = headId;\n                mergeStatus = MergeStatus.FAST_FORWARD_SQUASHED;\n                List<RevCommit> squashedCommits = RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage = new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            setCallable(false);\n            return new MergeResult(newHead, base, new ObjectId[] { headCommit, srcCommit }, mergeStatus, mergeStrategy, null, msg);\n        } else {\n            String mergeMessage = \"\";\n            if (!squash) {\n                mergeMessage = new MergeMessageFormatter().format(commits, head);\n                repo.writeMergeCommitMsg(mergeMessage);\n                repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            } else {\n                List<RevCommit> squashedCommits = RevWalkUtils.find(revWalk, srcCommit, headCommit);\n                String squashMessage = new SquashMessageFormatter().format(squashedCommits, head);\n                repo.writeSquashCommitMsg(squashMessage);\n            }\n            Merger merger = mergeStrategy.newMerger(repo);\n            boolean noProblems;\n            Map<String, org.eclipse.jgit.merge.MergeResult<?>> lowLevelResults = null;\n            Map<String, MergeFailureReason> failingPaths = null;\n            List<String> unmergedPaths = null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger = (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems = merger.merge(headCommit, srcCommit);\n                lowLevelResults = resolveMerger.getMergeResults();\n                failingPaths = resolveMerger.getFailingPaths();\n                unmergedPaths = resolveMerger.getUnmergedPaths();\n            } else\n                noProblems = merger.merge(headCommit, srcCommit);\n            refLogMessage.append(\": Merge made by \");\n            refLogMessage.append(mergeStrategy.getName());\n            refLogMessage.append('.');\n            if (noProblems) {\n                dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                String msg = null;\n                RevCommit newHead = null;\n                MergeStatus mergeStatus = null;\n                if (!squash) {\n                    newHead = new Git(getRepository()).commit().setReflogComment(refLogMessage.toString()).call();\n                    mergeStatus = MergeStatus.MERGED;\n                } else {\n                    msg = JGitText.get().squashCommitNotUpdatingHEAD;\n                    newHead = headCommit;\n                    mergeStatus = MergeStatus.MERGED_SQUASHED;\n                }\n                return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, mergeStatus, mergeStrategy, null, msg);\n            } else {\n                if (failingPaths != null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else {\n                    String mergeMessageWithConflicts = new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                    repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                }\n            }\n        }\n    } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n        List<String> conflicts = (dco == null) ? Collections.<String>emptyList() : dco.getConflicts();\n        throw new CheckoutConflictException(conflicts, e);\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk != null)\n            revWalk.release();\n    }\n}"
    },
    {
      "commit": "4e1454ded6e2fcf6cb789c004756883c3ea5f77e",
      "startLine": 50,
      "endLine": 64,
      "methodCode": "public MergeResult call() throws GitAPIException, NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    if (commits.size() != 1)\n        throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads, mergeStrategy.getName(), Integer.valueOf(commits.size())));\n    RevWalk revWalk = null;\n    DirCacheCheckout dco = null;\n    try {\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage = new StringBuilder(\"merge \");\n        revWalk = new RevWalk(repo);\n        Ref ref = commits.get(0);\n        refLogMessage.append(ref.getName());\n        ObjectId objectId = ref.getPeeledObjectId();\n        if (objectId == null)\n            objectId = ref.getObjectId();\n        RevCommit srcCommit = revWalk.lookupCommit(objectId);\n        ObjectId headId = head.getObjectId();\n        if (headId == null) {\n            revWalk.parseHeaders(srcCommit);\n            dco = new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            RefUpdate refUpdate = repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() != Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit = revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            updateHead(refLogMessage, srcCommit, headId);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        } else {\n            String mergeMessage = new MergeMessageFormatter().format(commits, head);\n            repo.writeMergeCommitMsg(mergeMessage);\n            repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            Merger merger = mergeStrategy.newMerger(repo);\n            boolean noProblems;\n            Map<String, org.eclipse.jgit.merge.MergeResult<?>> lowLevelResults = null;\n            Map<String, MergeFailureReason> failingPaths = null;\n            List<String> unmergedPaths = null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger = (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems = merger.merge(headCommit, srcCommit);\n                lowLevelResults = resolveMerger.getMergeResults();\n                failingPaths = resolveMerger.getFailingPaths();\n                unmergedPaths = resolveMerger.getUnmergedPaths();\n            } else\n                noProblems = merger.merge(headCommit, srcCommit);\n            refLogMessage.append(\": Merge made by \");\n            refLogMessage.append(mergeStrategy.getName());\n            refLogMessage.append('.');\n            if (noProblems) {\n                dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                RevCommit newHead = new Git(getRepository()).commit().setReflogComment(refLogMessage.toString()).call();\n                return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.MERGED, mergeStrategy, null, null);\n            } else {\n                if (failingPaths != null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else {\n                    String mergeMessageWithConflicts = new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                    repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                }\n            }\n        }\n    } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n        List<String> conflicts = (dco == null) ? Collections.<String>emptyList() : dco.getConflicts();\n        throw new CheckoutConflictException(conflicts, e);\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk != null)\n            revWalk.release();\n    }\n}"
    },
    {
      "commit": "26b573862912b2faf3824bb18dfeb44a3b700014",
      "startLine": 50,
      "endLine": 64,
      "methodCode": "public MergeResult call() throws NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    if (commits.size() != 1)\n        throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads, mergeStrategy.getName(), Integer.valueOf(commits.size())));\n    RevWalk revWalk = null;\n    DirCacheCheckout dco = null;\n    try {\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage = new StringBuilder(\"merge \");\n        revWalk = new RevWalk(repo);\n        Ref ref = commits.get(0);\n        refLogMessage.append(ref.getName());\n        ObjectId objectId = ref.getPeeledObjectId();\n        if (objectId == null)\n            objectId = ref.getObjectId();\n        RevCommit srcCommit = revWalk.lookupCommit(objectId);\n        ObjectId headId = head.getObjectId();\n        if (headId == null) {\n            revWalk.parseHeaders(srcCommit);\n            dco = new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            RefUpdate refUpdate = repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() != Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit = revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            updateHead(refLogMessage, srcCommit, headId);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        } else {\n            String mergeMessage = new MergeMessageFormatter().format(commits, head);\n            repo.writeMergeCommitMsg(mergeMessage);\n            repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            Merger merger = mergeStrategy.newMerger(repo);\n            boolean noProblems;\n            Map<String, org.eclipse.jgit.merge.MergeResult<?>> lowLevelResults = null;\n            Map<String, MergeFailureReason> failingPaths = null;\n            List<String> unmergedPaths = null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger = (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems = merger.merge(headCommit, srcCommit);\n                lowLevelResults = resolveMerger.getMergeResults();\n                failingPaths = resolveMerger.getFailingPaths();\n                unmergedPaths = resolveMerger.getUnmergedPaths();\n            } else\n                noProblems = merger.merge(headCommit, srcCommit);\n            refLogMessage.append(\": Merge made by \");\n            refLogMessage.append(mergeStrategy.getName());\n            refLogMessage.append('.');\n            if (noProblems) {\n                dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                RevCommit newHead = new Git(getRepository()).commit().setReflogComment(refLogMessage.toString()).call();\n                return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.MERGED, mergeStrategy, null, null);\n            } else {\n                if (failingPaths != null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else {\n                    String mergeMessageWithConflicts = new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                    repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                }\n            }\n        }\n    } catch (org.eclipse.jgit.errors.CheckoutConflictException e) {\n        List<String> conflicts = (dco == null) ? Collections.<String>emptyList() : dco.getConflicts();\n        throw new CheckoutConflictException(conflicts, e);\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk != null)\n            revWalk.release();\n    }\n}"
    },
    {
      "commit": "39ad503fcb0c293e9c6d47d653a0d52456d4760b",
      "startLine": 49,
      "endLine": 63,
      "methodCode": "public MergeResult call() throws NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    if (commits.size() != 1)\n        throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads, mergeStrategy.getName(), Integer.valueOf(commits.size())));\n    RevWalk revWalk = null;\n    try {\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage = new StringBuilder(\"merge \");\n        revWalk = new RevWalk(repo);\n        Ref ref = commits.get(0);\n        refLogMessage.append(ref.getName());\n        ObjectId objectId = ref.getPeeledObjectId();\n        if (objectId == null)\n            objectId = ref.getObjectId();\n        RevCommit srcCommit = revWalk.lookupCommit(objectId);\n        ObjectId headId = head.getObjectId();\n        if (headId == null) {\n            revWalk.parseHeaders(srcCommit);\n            DirCacheCheckout dco = new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            RefUpdate refUpdate = repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() != Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit = revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            DirCacheCheckout dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            updateHead(refLogMessage, srcCommit, headId);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        } else {\n            String mergeMessage = new MergeMessageFormatter().format(commits, head);\n            repo.writeMergeCommitMsg(mergeMessage);\n            repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            Merger merger = mergeStrategy.newMerger(repo);\n            boolean noProblems;\n            Map<String, org.eclipse.jgit.merge.MergeResult<?>> lowLevelResults = null;\n            Map<String, MergeFailureReason> failingPaths = null;\n            List<String> unmergedPaths = null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger = (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems = merger.merge(headCommit, srcCommit);\n                lowLevelResults = resolveMerger.getMergeResults();\n                failingPaths = resolveMerger.getFailingPaths();\n                unmergedPaths = resolveMerger.getUnmergedPaths();\n            } else\n                noProblems = merger.merge(headCommit, srcCommit);\n            refLogMessage.append(\": Merge made by \");\n            refLogMessage.append(mergeStrategy.getName());\n            refLogMessage.append('.');\n            if (noProblems) {\n                DirCacheCheckout dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                RevCommit newHead = new Git(getRepository()).commit().setReflogComment(refLogMessage.toString()).call();\n                return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.MERGED, mergeStrategy, null, null);\n            } else {\n                if (failingPaths != null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else {\n                    String mergeMessageWithConflicts = new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                    repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                }\n            }\n        }\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk != null)\n            revWalk.release();\n    }\n}"
    },
    {
      "commit": "4f4e468f6f344ed7c106b86b850d2c9171dd1a0f",
      "startLine": 49,
      "endLine": 63,
      "methodCode": "public MergeResult call() throws NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    if (commits.size() != 1)\n        throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads, mergeStrategy.getName(), Integer.valueOf(commits.size())));\n    RevWalk revWalk = null;\n    try {\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage = new StringBuilder(\"merge \");\n        revWalk = new RevWalk(repo);\n        Ref ref = commits.get(0);\n        refLogMessage.append(ref.getName());\n        ObjectId objectId = ref.getPeeledObjectId();\n        if (objectId == null)\n            objectId = ref.getObjectId();\n        RevCommit srcCommit = revWalk.lookupCommit(objectId);\n        ObjectId headId = head.getObjectId();\n        if (headId == null) {\n            revWalk.parseHeaders(srcCommit);\n            DirCacheCheckout dco = new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            RefUpdate refUpdate = repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() != Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit = revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            DirCacheCheckout dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            updateHead(refLogMessage, srcCommit, headId);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        } else {\n            String mergeMessage = new MergeMessageFormatter().format(commits, head);\n            repo.writeMergeCommitMsg(mergeMessage);\n            repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            Merger merger = mergeStrategy.newMerger(repo);\n            boolean noProblems;\n            Map<String, org.eclipse.jgit.merge.MergeResult<?>> lowLevelResults = null;\n            Map<String, MergeFailureReason> failingPaths = null;\n            List<String> unmergedPaths = null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger = (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems = merger.merge(headCommit, srcCommit);\n                lowLevelResults = resolveMerger.getMergeResults();\n                failingPaths = resolveMerger.getFailingPaths();\n                unmergedPaths = resolveMerger.getUnmergedPaths();\n            } else\n                noProblems = merger.merge(headCommit, srcCommit);\n            if (noProblems) {\n                DirCacheCheckout dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                RevCommit newHead = new Git(getRepository()).commit().setReflogComment(refLogMessage.toString()).call();\n                return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.MERGED, mergeStrategy, null, null);\n            } else {\n                if (failingPaths != null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else {\n                    String mergeMessageWithConflicts = new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                    repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                }\n            }\n        }\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk != null)\n            revWalk.release();\n    }\n}"
    },
    {
      "commit": "c580c56c4def9639b603553b3d4cbc7117a30938",
      "startLine": 49,
      "endLine": 63,
      "methodCode": "public MergeResult call() throws NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    if (commits.size() != 1)\n        throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads, mergeStrategy.getName(), Integer.valueOf(commits.size())));\n    RevWalk revWalk = null;\n    try {\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage = new StringBuilder(\"merge \");\n        revWalk = new RevWalk(repo);\n        Ref ref = commits.get(0);\n        refLogMessage.append(ref.getName());\n        ObjectId objectId = ref.getPeeledObjectId();\n        if (objectId == null)\n            objectId = ref.getObjectId();\n        RevCommit srcCommit = revWalk.lookupCommit(objectId);\n        ObjectId headId = head.getObjectId();\n        if (headId == null) {\n            revWalk.parseHeaders(srcCommit);\n            DirCacheCheckout dco = new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            RefUpdate refUpdate = repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() != Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit = revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            DirCacheCheckout dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            updateHead(refLogMessage, srcCommit, headId);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        } else {\n            String mergeMessage = new MergeMessageFormatter().format(commits, head);\n            repo.writeMergeCommitMsg(mergeMessage);\n            repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            Merger merger = mergeStrategy.newMerger(repo);\n            boolean noProblems;\n            Map<String, org.eclipse.jgit.merge.MergeResult<?>> lowLevelResults = null;\n            Map<String, MergeFailureReason> failingPaths = null;\n            List<String> unmergedPaths = null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger = (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems = merger.merge(headCommit, srcCommit);\n                lowLevelResults = resolveMerger.getMergeResults();\n                failingPaths = resolveMerger.getFailingPaths();\n                unmergedPaths = resolveMerger.getUnmergedPaths();\n            } else\n                noProblems = merger.merge(headCommit, srcCommit);\n            if (noProblems) {\n                DirCacheCheckout dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                RevCommit newHead = new Git(getRepository()).commit().call();\n                return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.MERGED, mergeStrategy, null, null);\n            } else {\n                if (failingPaths != null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else {\n                    String mergeMessageWithConflicts = new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                    repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                }\n            }\n        }\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk != null)\n            revWalk.release();\n    }\n}"
    },
    {
      "commit": "5dbef3fa51053b37f68b44ed390cab6dc8336dcc",
      "startLine": 49,
      "endLine": 63,
      "methodCode": "public MergeResult call() throws NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    if (commits.size() != 1)\n        throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads, mergeStrategy.getName(), Integer.valueOf(commits.size())));\n    RevWalk revWalk = null;\n    try {\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage = new StringBuilder(\"merge \");\n        revWalk = new RevWalk(repo);\n        Ref ref = commits.get(0);\n        refLogMessage.append(ref.getName());\n        ObjectId objectId = ref.getPeeledObjectId();\n        if (objectId == null)\n            objectId = ref.getObjectId();\n        RevCommit srcCommit = revWalk.lookupCommit(objectId);\n        ObjectId headId = head.getObjectId();\n        if (headId == null) {\n            revWalk.parseHeaders(srcCommit);\n            DirCacheCheckout dco = new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            RefUpdate refUpdate = repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() != Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit = revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            DirCacheCheckout dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            updateHead(refLogMessage, srcCommit, headId);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        } else {\n            String mergeMessage = new MergeMessageFormatter().format(commits, head);\n            repo.writeMergeCommitMsg(mergeMessage);\n            repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            ThreeWayMerger merger = (ThreeWayMerger) mergeStrategy.newMerger(repo);\n            boolean noProblems;\n            Map<String, org.eclipse.jgit.merge.MergeResult<?>> lowLevelResults = null;\n            Map<String, MergeFailureReason> failingPaths = null;\n            List<String> unmergedPaths = null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger = (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems = merger.merge(headCommit, srcCommit);\n                lowLevelResults = resolveMerger.getMergeResults();\n                failingPaths = resolveMerger.getFailingPaths();\n                unmergedPaths = resolveMerger.getUnmergedPaths();\n            } else\n                noProblems = merger.merge(headCommit, srcCommit);\n            if (noProblems) {\n                DirCacheCheckout dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                RevCommit newHead = new Git(getRepository()).commit().call();\n                return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.MERGED, mergeStrategy, null, null);\n            } else {\n                if (failingPaths != null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else {\n                    String mergeMessageWithConflicts = new MergeMessageFormatter().formatWithConflicts(mergeMessage, unmergedPaths);\n                    repo.writeMergeCommitMsg(mergeMessageWithConflicts);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n                }\n            }\n        }\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk != null)\n            revWalk.release();\n    }\n}"
    },
    {
      "commit": "dcf7bd9a8f7acafbd1461dc0414aded2db030983",
      "startLine": 48,
      "endLine": 60,
      "methodCode": "public MergeResult call() throws NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    if (commits.size() != 1)\n        throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads, mergeStrategy.getName(), Integer.valueOf(commits.size())));\n    RevWalk revWalk = null;\n    try {\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage = new StringBuilder(\"merge \");\n        revWalk = new RevWalk(repo);\n        Ref ref = commits.get(0);\n        refLogMessage.append(ref.getName());\n        ObjectId objectId = ref.getPeeledObjectId();\n        if (objectId == null)\n            objectId = ref.getObjectId();\n        RevCommit srcCommit = revWalk.lookupCommit(objectId);\n        ObjectId headId = head.getObjectId();\n        if (headId == null) {\n            revWalk.parseHeaders(srcCommit);\n            DirCacheCheckout dco = new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            RefUpdate refUpdate = repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() != Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit = revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            DirCacheCheckout dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            updateHead(refLogMessage, srcCommit, headId);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        } else {\n            repo.writeMergeCommitMsg(new MergeMessageFormatter().format(commits, head));\n            repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            ThreeWayMerger merger = (ThreeWayMerger) mergeStrategy.newMerger(repo);\n            boolean noProblems;\n            Map<String, org.eclipse.jgit.merge.MergeResult<?>> lowLevelResults = null;\n            Map<String, MergeFailureReason> failingPaths = null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger = (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems = merger.merge(headCommit, srcCommit);\n                lowLevelResults = resolveMerger.getMergeResults();\n                failingPaths = resolveMerger.getFailingPaths();\n            } else\n                noProblems = merger.merge(headCommit, srcCommit);\n            if (noProblems) {\n                DirCacheCheckout dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                RevCommit newHead = new Git(getRepository()).commit().call();\n                return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.MERGED, mergeStrategy, null, null);\n            } else {\n                if (failingPaths != null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, failingPaths, null);\n                } else\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n            }\n        }\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk != null)\n            revWalk.release();\n    }\n}"
    },
    {
      "commit": "85f69c286b6c3225dcff05aba42910daefb28da0",
      "startLine": 48,
      "endLine": 60,
      "methodCode": "public MergeResult call() throws NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    if (commits.size() != 1)\n        throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads, mergeStrategy.getName(), Integer.valueOf(commits.size())));\n    RevWalk revWalk = null;\n    try {\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage = new StringBuilder(\"merge \");\n        revWalk = new RevWalk(repo);\n        Ref ref = commits.get(0);\n        refLogMessage.append(ref.getName());\n        ObjectId objectId = ref.getPeeledObjectId();\n        if (objectId == null)\n            objectId = ref.getObjectId();\n        RevCommit srcCommit = revWalk.lookupCommit(objectId);\n        ObjectId headId = head.getObjectId();\n        if (headId == null) {\n            revWalk.parseHeaders(srcCommit);\n            DirCacheCheckout dco = new DirCacheCheckout(repo, repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            RefUpdate refUpdate = repo.updateRef(head.getTarget().getName());\n            refUpdate.setNewObjectId(objectId);\n            refUpdate.setExpectedOldObjectId(null);\n            refUpdate.setRefLogMessage(\"initial pull\", false);\n            if (refUpdate.update() != Result.NEW)\n                throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { null, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        }\n        RevCommit headCommit = revWalk.lookupCommit(headId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            DirCacheCheckout dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            updateHead(refLogMessage, srcCommit, headId);\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        } else {\n            repo.writeMergeCommitMsg(new MergeMessageFormatter().format(commits, head));\n            repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            ThreeWayMerger merger = (ThreeWayMerger) mergeStrategy.newMerger(repo);\n            boolean noProblems;\n            Map<String, org.eclipse.jgit.merge.MergeResult<?>> lowLevelResults = null;\n            Map<String, MergeFailureReason> failingPaths = null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger = (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems = merger.merge(headCommit, srcCommit);\n                lowLevelResults = resolveMerger.getMergeResults();\n                failingPaths = resolveMerger.getFailingPaths();\n            } else\n                noProblems = merger.merge(headCommit, srcCommit);\n            if (noProblems) {\n                DirCacheCheckout dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                RevCommit newHead = new Git(getRepository()).commit().call();\n                return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.MERGED, mergeStrategy, null, null);\n            } else {\n                if (failingPaths != null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, null);\n                } else\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n            }\n        }\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk != null)\n            revWalk.release();\n    }\n}"
    },
    {
      "commit": "e43887b69e27672b80e55391e0ee255efe715ab9",
      "startLine": 33,
      "endLine": 45,
      "methodCode": "public MergeResult call() throws NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    if (commits.size() != 1)\n        throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads, mergeStrategy.getName(), Integer.valueOf(commits.size())));\n    RevWalk revWalk = null;\n    try {\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage = new StringBuilder(\"merge \");\n        revWalk = new RevWalk(repo);\n        RevCommit headCommit = revWalk.lookupCommit(head.getObjectId());\n        Ref ref = commits.get(0);\n        refLogMessage.append(ref.getName());\n        ObjectId objectId = ref.getPeeledObjectId();\n        if (objectId == null)\n            objectId = ref.getObjectId();\n        RevCommit srcCommit = revWalk.lookupCommit(objectId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            DirCacheCheckout dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            updateHead(refLogMessage, srcCommit, head.getObjectId());\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        } else {\n            repo.writeMergeCommitMsg(new MergeMessageFormatter().format(commits, head));\n            repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            ThreeWayMerger merger = (ThreeWayMerger) mergeStrategy.newMerger(repo);\n            boolean noProblems;\n            Map<String, org.eclipse.jgit.merge.MergeResult<?>> lowLevelResults = null;\n            Map<String, MergeFailureReason> failingPaths = null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger = (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems = merger.merge(headCommit, srcCommit);\n                lowLevelResults = resolveMerger.getMergeResults();\n                failingPaths = resolveMerger.getFailingPaths();\n            } else\n                noProblems = merger.merge(headCommit, srcCommit);\n            if (noProblems) {\n                DirCacheCheckout dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                RevCommit newHead = new Git(getRepository()).commit().call();\n                return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.MERGED, mergeStrategy, null, null);\n            } else {\n                if (failingPaths != null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, null);\n                } else\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n            }\n        }\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk != null)\n            revWalk.release();\n    }\n}"
    },
    {
      "commit": "6290ca3a638d1ac999da6c11628f904b31972067",
      "startLine": 33,
      "endLine": 45,
      "methodCode": "public MergeResult call() throws NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    if (commits.size() != 1)\n        throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads, mergeStrategy.getName(), Integer.valueOf(commits.size())));\n    RevWalk revWalk = null;\n    try {\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage = new StringBuilder(\"merge \");\n        revWalk = new RevWalk(repo);\n        RevCommit headCommit = revWalk.lookupCommit(head.getObjectId());\n        Ref ref = commits.get(0);\n        refLogMessage.append(ref.getName());\n        ObjectId objectId = ref.getPeeledObjectId();\n        if (objectId == null)\n            objectId = ref.getObjectId();\n        RevCommit srcCommit = revWalk.lookupCommit(objectId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            DirCacheCheckout dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            updateHead(refLogMessage, srcCommit, head.getObjectId());\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        } else {\n            repo.writeMergeCommitMsg(new MergeMessageFormatter().format(commits, head));\n            repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            ThreeWayMerger merger = (ThreeWayMerger) mergeStrategy.newMerger(repo);\n            boolean noProblems;\n            Map<String, org.eclipse.jgit.merge.MergeResult<?>> lowLevelResults = null;\n            Map<String, MergeFailureReason> failingPaths = null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger = (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems = merger.merge(headCommit, srcCommit);\n                lowLevelResults = resolveMerger.getMergeResults();\n                failingPaths = resolveMerger.getFailingPathes();\n            } else\n                noProblems = merger.merge(headCommit, srcCommit);\n            if (noProblems) {\n                DirCacheCheckout dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                RevCommit newHead = new Git(getRepository()).commit().call();\n                return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.MERGED, mergeStrategy, null, null);\n            } else {\n                if (failingPaths != null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, null);\n                } else\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n            }\n        }\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk != null)\n            revWalk.release();\n    }\n}"
    },
    {
      "commit": "fb1e500adc011dfaad1a6e68b23a9b254a77bf43",
      "startLine": 33,
      "endLine": 45,
      "methodCode": "public MergeResult call() throws NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    if (commits.size() != 1)\n        throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads, mergeStrategy.getName(), Integer.valueOf(commits.size())));\n    RevWalk revWalk = null;\n    try {\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage = new StringBuilder(\"merge \");\n        revWalk = new RevWalk(repo);\n        RevCommit headCommit = revWalk.lookupCommit(head.getObjectId());\n        Ref ref = commits.get(0);\n        refLogMessage.append(ref.getName());\n        ObjectId objectId = ref.getPeeledObjectId();\n        if (objectId == null)\n            objectId = ref.getObjectId();\n        RevCommit srcCommit = revWalk.lookupCommit(objectId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            DirCacheCheckout dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            updateHead(refLogMessage, srcCommit, head.getObjectId());\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        } else {\n            repo.writeMergeCommitMsg(\"merging \" + ref.getName() + \" into \" + head.getName());\n            repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            ThreeWayMerger merger = (ThreeWayMerger) mergeStrategy.newMerger(repo);\n            boolean noProblems;\n            Map<String, org.eclipse.jgit.merge.MergeResult<?>> lowLevelResults = null;\n            Map<String, MergeFailureReason> failingPaths = null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger = (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));\n                noProblems = merger.merge(headCommit, srcCommit);\n                lowLevelResults = resolveMerger.getMergeResults();\n                failingPaths = resolveMerger.getFailingPathes();\n            } else\n                noProblems = merger.merge(headCommit, srcCommit);\n            if (noProblems) {\n                DirCacheCheckout dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                RevCommit newHead = new Git(getRepository()).commit().call();\n                return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.MERGED, mergeStrategy, null, null);\n            } else {\n                if (failingPaths != null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, null);\n                } else\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n            }\n        }\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk != null)\n            revWalk.release();\n    }\n}"
    },
    {
      "commit": "67263e2056108e471d684c3cef9e719724b51220",
      "startLine": 33,
      "endLine": 45,
      "methodCode": "public MergeResult call() throws NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    if (commits.size() != 1)\n        throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads, mergeStrategy.getName(), Integer.valueOf(commits.size())));\n    RevWalk revWalk = null;\n    try {\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage = new StringBuilder(\"merge \");\n        revWalk = new RevWalk(repo);\n        RevCommit headCommit = revWalk.lookupCommit(head.getObjectId());\n        Ref ref = commits.get(0);\n        refLogMessage.append(ref.getName());\n        ObjectId objectId = ref.getPeeledObjectId();\n        if (objectId == null)\n            objectId = ref.getObjectId();\n        RevCommit srcCommit = revWalk.lookupCommit(objectId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            DirCacheCheckout dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            updateHead(refLogMessage, srcCommit, head.getObjectId());\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        } else {\n            repo.writeMergeCommitMsg(\"merging \" + ref.getName() + \" into \" + head.getName());\n            repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            ThreeWayMerger merger = (ThreeWayMerger) mergeStrategy.newMerger(repo);\n            boolean noProblems;\n            Map<String, org.eclipse.jgit.merge.MergeResult<?>> lowLevelResults = null;\n            Map<String, MergeFailureReason> failingPaths = null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger = (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIt(new FileTreeIterator(repo));\n                noProblems = merger.merge(headCommit, srcCommit);\n                lowLevelResults = resolveMerger.getMergeResults();\n                failingPaths = resolveMerger.getFailingPathes();\n            } else\n                noProblems = merger.merge(headCommit, srcCommit);\n            if (noProblems) {\n                DirCacheCheckout dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                RevCommit newHead = new Git(getRepository()).commit().call();\n                return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.MERGED, mergeStrategy, null, null);\n            } else {\n                if (failingPaths != null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, null);\n                } else\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n            }\n        }\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk != null)\n            revWalk.release();\n    }\n}"
    },
    {
      "commit": "45e79a526c7ffebaf8e4758a6cb6b7af05716707",
      "startLine": 33,
      "endLine": 45,
      "methodCode": "public MergeResult call() throws NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {\n    checkCallable();\n    if (commits.size() != 1)\n        throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads, mergeStrategy.getName(), Integer.valueOf(commits.size())));\n    RevWalk revWalk = null;\n    try {\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        StringBuilder refLogMessage = new StringBuilder(\"merge \");\n        revWalk = new RevWalk(repo);\n        RevCommit headCommit = revWalk.lookupCommit(head.getObjectId());\n        Ref ref = commits.get(0);\n        refLogMessage.append(ref.getName());\n        ObjectId objectId = ref.getPeeledObjectId();\n        if (objectId == null)\n            objectId = ref.getObjectId();\n        RevCommit srcCommit = revWalk.lookupCommit(objectId);\n        if (revWalk.isMergedInto(srcCommit, headCommit)) {\n            setCallable(false);\n            return new MergeResult(headCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.ALREADY_UP_TO_DATE, mergeStrategy, null, null);\n        } else if (revWalk.isMergedInto(headCommit, srcCommit)) {\n            refLogMessage.append(\": \" + MergeStatus.FAST_FORWARD);\n            DirCacheCheckout dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), srcCommit.getTree());\n            dco.setFailOnConflict(true);\n            dco.checkout();\n            updateHead(refLogMessage, srcCommit, head.getObjectId());\n            setCallable(false);\n            return new MergeResult(srcCommit, srcCommit, new ObjectId[] { headCommit, srcCommit }, MergeStatus.FAST_FORWARD, mergeStrategy, null, null);\n        } else {\n            repo.writeMergeCommitMsg(\"merging \" + ref.getName() + \" into \" + head.getName());\n            repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));\n            ThreeWayMerger merger = (ThreeWayMerger) mergeStrategy.newMerger(repo);\n            boolean noProblems;\n            Map<String, org.eclipse.jgit.merge.MergeResult> lowLevelResults = null;\n            Map<String, MergeFailureReason> failingPaths = null;\n            if (merger instanceof ResolveMerger) {\n                ResolveMerger resolveMerger = (ResolveMerger) merger;\n                resolveMerger.setCommitNames(new String[] { \"BASE\", \"HEAD\", ref.getName() });\n                resolveMerger.setWorkingTreeIt(new FileTreeIterator(repo));\n                noProblems = merger.merge(headCommit, srcCommit);\n                lowLevelResults = resolveMerger.getMergeResults();\n                failingPaths = resolveMerger.getFailingPathes();\n            } else\n                noProblems = merger.merge(headCommit, srcCommit);\n            if (noProblems) {\n                DirCacheCheckout dco = new DirCacheCheckout(repo, headCommit.getTree(), repo.lockDirCache(), merger.getResultTreeId());\n                dco.setFailOnConflict(true);\n                dco.checkout();\n                RevCommit newHead = new Git(getRepository()).commit().call();\n                return new MergeResult(newHead.getId(), null, new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.MERGED, mergeStrategy, null, null);\n            } else {\n                if (failingPaths != null) {\n                    repo.writeMergeCommitMsg(null);\n                    repo.writeMergeHeads(null);\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.FAILED, mergeStrategy, lowLevelResults, null);\n                } else\n                    return new MergeResult(null, merger.getBaseCommit(0, 1), new ObjectId[] { headCommit.getId(), srcCommit.getId() }, MergeStatus.CONFLICTING, mergeStrategy, lowLevelResults, null);\n            }\n        }\n    } catch (IOException e) {\n        throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand, e), e);\n    } finally {\n        if (revWalk != null)\n            revWalk.release();\n    }\n}"
    }
  ]
}