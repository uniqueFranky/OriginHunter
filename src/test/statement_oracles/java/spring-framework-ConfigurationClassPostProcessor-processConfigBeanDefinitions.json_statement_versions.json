{
  "statementVersions": [
    {
      "commit": "4fef1fe820627e6462413f4c4b658d24146367a2",
      "startLine": 2,
      "endLine": 21,
      "methodCode": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    List<BeanDefinitionHolder> configCandidates = new ArrayList<>();\n    String[] candidateNames = registry.getBeanDefinitionNames();\n    for (String beanName : candidateNames) {\n        BeanDefinition beanDef = registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) || ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n            }\n        } else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    configCandidates.sort((bd1, bd2) -> {\n        int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n        int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n        return Integer.compare(i1, i2);\n    });\n    SingletonBeanRegistry sbr = null;\n    if (registry instanceof SingletonBeanRegistry) {\n        sbr = (SingletonBeanRegistry) registry;\n        if (!this.localBeanNameGeneratorSet) {\n            BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n            if (generator != null) {\n                this.componentScanBeanNameGenerator = generator;\n                this.importBeanNameGenerator = generator;\n            }\n        }\n    }\n    if (this.environment == null) {\n        this.environment = new StandardEnvironment();\n    }\n    ConfigurationClassParser parser = new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n    Set<BeanDefinitionHolder> candidates = new LinkedHashSet<>(configCandidates);\n    Set<ConfigurationClass> alreadyParsed = new HashSet<>(configCandidates.size());\n    do {\n        parser.parse(candidates);\n        parser.validate();\n        Set<ConfigurationClass> configClasses = new LinkedHashSet<>(parser.getConfigurationClasses());\n        configClasses.removeAll(alreadyParsed);\n        if (this.reader == null) {\n            this.reader = new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.resourceLoader, this.environment, this.importBeanNameGenerator, parser.getImportRegistry());\n        }\n        this.reader.loadBeanDefinitions(configClasses);\n        alreadyParsed.addAll(configClasses);\n        candidates.clear();\n        if (registry.getBeanDefinitionCount() > candidateNames.length) {\n            String[] newCandidateNames = registry.getBeanDefinitionNames();\n            Set<String> oldCandidateNames = new HashSet<>(Arrays.asList(candidateNames));\n            Set<String> alreadyParsedClasses = new HashSet<>();\n            for (ConfigurationClass configurationClass : alreadyParsed) {\n                alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n            }\n            for (String candidateName : newCandidateNames) {\n                if (!oldCandidateNames.contains(candidateName)) {\n                    BeanDefinition bd = registry.getBeanDefinition(candidateName);\n                    if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) && !alreadyParsedClasses.contains(bd.getBeanClassName())) {\n                        candidates.add(new BeanDefinitionHolder(bd, candidateName));\n                    }\n                }\n            }\n            candidateNames = newCandidateNames;\n        }\n    } while (!candidates.isEmpty());\n    if (sbr != null && !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n        sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n    }\n    if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n        ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n    }\n}"
    },
    {
      "commit": "139dc1d373cc6e32ee6b516504064a2c87e0008a",
      "startLine": 2,
      "endLine": 21,
      "methodCode": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    List<BeanDefinitionHolder> configCandidates = new ArrayList<>();\n    String[] candidateNames = registry.getBeanDefinitionNames();\n    for (String beanName : candidateNames) {\n        BeanDefinition beanDef = registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) || ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n            }\n        } else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    configCandidates.sort((bd1, bd2) -> {\n        int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n        int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n        return (i1 < i2) ? -1 : (i1 > i2) ? 1 : 0;\n    });\n    SingletonBeanRegistry sbr = null;\n    if (registry instanceof SingletonBeanRegistry) {\n        sbr = (SingletonBeanRegistry) registry;\n        if (!this.localBeanNameGeneratorSet) {\n            BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n            if (generator != null) {\n                this.componentScanBeanNameGenerator = generator;\n                this.importBeanNameGenerator = generator;\n            }\n        }\n    }\n    if (this.environment == null) {\n        this.environment = new StandardEnvironment();\n    }\n    ConfigurationClassParser parser = new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n    Set<BeanDefinitionHolder> candidates = new LinkedHashSet<>(configCandidates);\n    Set<ConfigurationClass> alreadyParsed = new HashSet<>(configCandidates.size());\n    do {\n        parser.parse(candidates);\n        parser.validate();\n        Set<ConfigurationClass> configClasses = new LinkedHashSet<>(parser.getConfigurationClasses());\n        configClasses.removeAll(alreadyParsed);\n        if (this.reader == null) {\n            this.reader = new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.resourceLoader, this.environment, this.importBeanNameGenerator, parser.getImportRegistry());\n        }\n        this.reader.loadBeanDefinitions(configClasses);\n        alreadyParsed.addAll(configClasses);\n        candidates.clear();\n        if (registry.getBeanDefinitionCount() > candidateNames.length) {\n            String[] newCandidateNames = registry.getBeanDefinitionNames();\n            Set<String> oldCandidateNames = new HashSet<>(Arrays.asList(candidateNames));\n            Set<String> alreadyParsedClasses = new HashSet<>();\n            for (ConfigurationClass configurationClass : alreadyParsed) {\n                alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n            }\n            for (String candidateName : newCandidateNames) {\n                if (!oldCandidateNames.contains(candidateName)) {\n                    BeanDefinition bd = registry.getBeanDefinition(candidateName);\n                    if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) && !alreadyParsedClasses.contains(bd.getBeanClassName())) {\n                        candidates.add(new BeanDefinitionHolder(bd, candidateName));\n                    }\n                }\n            }\n            candidateNames = newCandidateNames;\n        }\n    } while (!candidates.isEmpty());\n    if (sbr != null && !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n        sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n    }\n    if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n        ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n    }\n}"
    },
    {
      "commit": "cc74a2891a4d2a4c7bcec059f20c35aa80bcf668",
      "startLine": 2,
      "endLine": 21,
      "methodCode": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    List<BeanDefinitionHolder> configCandidates = new ArrayList<>();\n    String[] candidateNames = registry.getBeanDefinitionNames();\n    for (String beanName : candidateNames) {\n        BeanDefinition beanDef = registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) || ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n            }\n        } else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    configCandidates.sort((bd1, bd2) -> {\n        int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n        int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n        return (i1 < i2) ? -1 : (i1 > i2) ? 1 : 0;\n    });\n    SingletonBeanRegistry sbr = null;\n    if (registry instanceof SingletonBeanRegistry) {\n        sbr = (SingletonBeanRegistry) registry;\n        if (!this.localBeanNameGeneratorSet) {\n            BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n            if (generator != null) {\n                this.componentScanBeanNameGenerator = generator;\n                this.importBeanNameGenerator = generator;\n            }\n        }\n    }\n    if (this.environment == null) {\n        this.environment = new StandardEnvironment();\n    }\n    ConfigurationClassParser parser = new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n    Set<BeanDefinitionHolder> candidates = new LinkedHashSet<>(configCandidates);\n    Set<ConfigurationClass> alreadyParsed = new HashSet<>(configCandidates.size());\n    do {\n        parser.parse(candidates);\n        parser.validate();\n        Set<ConfigurationClass> configClasses = new LinkedHashSet<>(parser.getConfigurationClasses());\n        configClasses.removeAll(alreadyParsed);\n        if (this.reader == null) {\n            this.reader = new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.resourceLoader, this.environment, this.importBeanNameGenerator, parser.getImportRegistry());\n        }\n        this.reader.loadBeanDefinitions(configClasses);\n        alreadyParsed.addAll(configClasses);\n        candidates.clear();\n        if (registry.getBeanDefinitionCount() > candidateNames.length) {\n            String[] newCandidateNames = registry.getBeanDefinitionNames();\n            Set<String> oldCandidateNames = new HashSet<>(Arrays.asList(candidateNames));\n            Set<String> alreadyParsedClasses = new HashSet<>();\n            for (ConfigurationClass configurationClass : alreadyParsed) {\n                alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n            }\n            for (String candidateName : newCandidateNames) {\n                if (!oldCandidateNames.contains(candidateName)) {\n                    BeanDefinition bd = registry.getBeanDefinition(candidateName);\n                    if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) && !alreadyParsedClasses.contains(bd.getBeanClassName())) {\n                        candidates.add(new BeanDefinitionHolder(bd, candidateName));\n                    }\n                }\n            }\n            candidateNames = newCandidateNames;\n        }\n    } while (!candidates.isEmpty());\n    if (sbr != null) {\n        if (!sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n            sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n        }\n    }\n    if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n        ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n    }\n}"
    },
    {
      "commit": "fc64b8040f7c76f2bc85387cf944436424ce408c",
      "startLine": 2,
      "endLine": 21,
      "methodCode": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    List<BeanDefinitionHolder> configCandidates = new ArrayList<>();\n    String[] candidateNames = registry.getBeanDefinitionNames();\n    for (String beanName : candidateNames) {\n        BeanDefinition beanDef = registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) || ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n            }\n        } else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    configCandidates.sort((bd1, bd2) -> {\n        int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n        int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n        return (i1 < i2) ? -1 : (i1 > i2) ? 1 : 0;\n    });\n    SingletonBeanRegistry sbr = null;\n    if (registry instanceof SingletonBeanRegistry) {\n        sbr = (SingletonBeanRegistry) registry;\n        if (!this.localBeanNameGeneratorSet) {\n            BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n            if (generator != null) {\n                this.componentScanBeanNameGenerator = generator;\n                this.importBeanNameGenerator = generator;\n            }\n        }\n    }\n    ConfigurationClassParser parser = new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n    Set<BeanDefinitionHolder> candidates = new LinkedHashSet<>(configCandidates);\n    Set<ConfigurationClass> alreadyParsed = new HashSet<>(configCandidates.size());\n    do {\n        parser.parse(candidates);\n        parser.validate();\n        Set<ConfigurationClass> configClasses = new LinkedHashSet<>(parser.getConfigurationClasses());\n        configClasses.removeAll(alreadyParsed);\n        if (this.reader == null) {\n            this.reader = new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.resourceLoader, this.environment, this.importBeanNameGenerator, parser.getImportRegistry());\n        }\n        this.reader.loadBeanDefinitions(configClasses);\n        alreadyParsed.addAll(configClasses);\n        candidates.clear();\n        if (registry.getBeanDefinitionCount() > candidateNames.length) {\n            String[] newCandidateNames = registry.getBeanDefinitionNames();\n            Set<String> oldCandidateNames = new HashSet<>(Arrays.asList(candidateNames));\n            Set<String> alreadyParsedClasses = new HashSet<>();\n            for (ConfigurationClass configurationClass : alreadyParsed) {\n                alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n            }\n            for (String candidateName : newCandidateNames) {\n                if (!oldCandidateNames.contains(candidateName)) {\n                    BeanDefinition bd = registry.getBeanDefinition(candidateName);\n                    if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) && !alreadyParsedClasses.contains(bd.getBeanClassName())) {\n                        candidates.add(new BeanDefinitionHolder(bd, candidateName));\n                    }\n                }\n            }\n            candidateNames = newCandidateNames;\n        }\n    } while (!candidates.isEmpty());\n    if (sbr != null) {\n        if (!sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n            sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n        }\n    }\n    if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n        ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n    }\n}"
    },
    {
      "commit": "4b1478d830f3cdbc4eb0d50d84f152d7900f30c3",
      "startLine": 2,
      "endLine": 21,
      "methodCode": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    List<BeanDefinitionHolder> configCandidates = new ArrayList<>();\n    String[] candidateNames = registry.getBeanDefinitionNames();\n    for (String beanName : candidateNames) {\n        BeanDefinition beanDef = registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) || ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n            }\n        } else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    Collections.sort(configCandidates, (bd1, bd2) -> {\n        int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n        int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n        return (i1 < i2) ? -1 : (i1 > i2) ? 1 : 0;\n    });\n    SingletonBeanRegistry sbr = null;\n    if (registry instanceof SingletonBeanRegistry) {\n        sbr = (SingletonBeanRegistry) registry;\n        if (!this.localBeanNameGeneratorSet) {\n            BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n            if (generator != null) {\n                this.componentScanBeanNameGenerator = generator;\n                this.importBeanNameGenerator = generator;\n            }\n        }\n    }\n    ConfigurationClassParser parser = new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n    Set<BeanDefinitionHolder> candidates = new LinkedHashSet<>(configCandidates);\n    Set<ConfigurationClass> alreadyParsed = new HashSet<>(configCandidates.size());\n    do {\n        parser.parse(candidates);\n        parser.validate();\n        Set<ConfigurationClass> configClasses = new LinkedHashSet<>(parser.getConfigurationClasses());\n        configClasses.removeAll(alreadyParsed);\n        if (this.reader == null) {\n            this.reader = new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.resourceLoader, this.environment, this.importBeanNameGenerator, parser.getImportRegistry());\n        }\n        this.reader.loadBeanDefinitions(configClasses);\n        alreadyParsed.addAll(configClasses);\n        candidates.clear();\n        if (registry.getBeanDefinitionCount() > candidateNames.length) {\n            String[] newCandidateNames = registry.getBeanDefinitionNames();\n            Set<String> oldCandidateNames = new HashSet<>(Arrays.asList(candidateNames));\n            Set<String> alreadyParsedClasses = new HashSet<>();\n            for (ConfigurationClass configurationClass : alreadyParsed) {\n                alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n            }\n            for (String candidateName : newCandidateNames) {\n                if (!oldCandidateNames.contains(candidateName)) {\n                    BeanDefinition bd = registry.getBeanDefinition(candidateName);\n                    if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) && !alreadyParsedClasses.contains(bd.getBeanClassName())) {\n                        candidates.add(new BeanDefinitionHolder(bd, candidateName));\n                    }\n                }\n            }\n            candidateNames = newCandidateNames;\n        }\n    } while (!candidates.isEmpty());\n    if (sbr != null) {\n        if (!sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n            sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n        }\n    }\n    if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n        ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n    }\n}"
    },
    {
      "commit": "f813712f5b413b354560cd7cc006352e9defa9a3",
      "startLine": 2,
      "endLine": 25,
      "methodCode": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    List<BeanDefinitionHolder> configCandidates = new ArrayList<>();\n    String[] candidateNames = registry.getBeanDefinitionNames();\n    for (String beanName : candidateNames) {\n        BeanDefinition beanDef = registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) || ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n            }\n        } else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    Collections.sort(configCandidates, new Comparator<BeanDefinitionHolder>() {\n\n        @Override\n        public int compare(BeanDefinitionHolder bd1, BeanDefinitionHolder bd2) {\n            int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n            int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n            return (i1 < i2) ? -1 : (i1 > i2) ? 1 : 0;\n        }\n    });\n    SingletonBeanRegistry sbr = null;\n    if (registry instanceof SingletonBeanRegistry) {\n        sbr = (SingletonBeanRegistry) registry;\n        if (!this.localBeanNameGeneratorSet) {\n            BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n            if (generator != null) {\n                this.componentScanBeanNameGenerator = generator;\n                this.importBeanNameGenerator = generator;\n            }\n        }\n    }\n    ConfigurationClassParser parser = new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n    Set<BeanDefinitionHolder> candidates = new LinkedHashSet<>(configCandidates);\n    Set<ConfigurationClass> alreadyParsed = new HashSet<>(configCandidates.size());\n    do {\n        parser.parse(candidates);\n        parser.validate();\n        Set<ConfigurationClass> configClasses = new LinkedHashSet<>(parser.getConfigurationClasses());\n        configClasses.removeAll(alreadyParsed);\n        if (this.reader == null) {\n            this.reader = new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.resourceLoader, this.environment, this.importBeanNameGenerator, parser.getImportRegistry());\n        }\n        this.reader.loadBeanDefinitions(configClasses);\n        alreadyParsed.addAll(configClasses);\n        candidates.clear();\n        if (registry.getBeanDefinitionCount() > candidateNames.length) {\n            String[] newCandidateNames = registry.getBeanDefinitionNames();\n            Set<String> oldCandidateNames = new HashSet<>(Arrays.asList(candidateNames));\n            Set<String> alreadyParsedClasses = new HashSet<>();\n            for (ConfigurationClass configurationClass : alreadyParsed) {\n                alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n            }\n            for (String candidateName : newCandidateNames) {\n                if (!oldCandidateNames.contains(candidateName)) {\n                    BeanDefinition bd = registry.getBeanDefinition(candidateName);\n                    if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) && !alreadyParsedClasses.contains(bd.getBeanClassName())) {\n                        candidates.add(new BeanDefinitionHolder(bd, candidateName));\n                    }\n                }\n            }\n            candidateNames = newCandidateNames;\n        }\n    } while (!candidates.isEmpty());\n    if (sbr != null) {\n        if (!sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n            sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n        }\n    }\n    if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n        ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n    }\n}"
    },
    {
      "commit": "91df0653fe5e22477ec2ed6dbe7e44b835c99038",
      "startLine": 2,
      "endLine": 25,
      "methodCode": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    List<BeanDefinitionHolder> configCandidates = new ArrayList<>();\n    String[] candidateNames = registry.getBeanDefinitionNames();\n    for (String beanName : candidateNames) {\n        BeanDefinition beanDef = registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) || ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n            }\n        } else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    Collections.sort(configCandidates, new Comparator<BeanDefinitionHolder>() {\n\n        @Override\n        public int compare(BeanDefinitionHolder bd1, BeanDefinitionHolder bd2) {\n            int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n            int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n            return (i1 < i2) ? -1 : (i1 > i2) ? 1 : 0;\n        }\n    });\n    SingletonBeanRegistry sbr = null;\n    if (registry instanceof SingletonBeanRegistry) {\n        sbr = (SingletonBeanRegistry) registry;\n        if (!this.localBeanNameGeneratorSet && sbr.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n            BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n            this.componentScanBeanNameGenerator = generator;\n            this.importBeanNameGenerator = generator;\n        }\n    }\n    ConfigurationClassParser parser = new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n    Set<BeanDefinitionHolder> candidates = new LinkedHashSet<>(configCandidates);\n    Set<ConfigurationClass> alreadyParsed = new HashSet<>(configCandidates.size());\n    do {\n        parser.parse(candidates);\n        parser.validate();\n        Set<ConfigurationClass> configClasses = new LinkedHashSet<>(parser.getConfigurationClasses());\n        configClasses.removeAll(alreadyParsed);\n        if (this.reader == null) {\n            this.reader = new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.resourceLoader, this.environment, this.importBeanNameGenerator, parser.getImportRegistry());\n        }\n        this.reader.loadBeanDefinitions(configClasses);\n        alreadyParsed.addAll(configClasses);\n        candidates.clear();\n        if (registry.getBeanDefinitionCount() > candidateNames.length) {\n            String[] newCandidateNames = registry.getBeanDefinitionNames();\n            Set<String> oldCandidateNames = new HashSet<>(Arrays.asList(candidateNames));\n            Set<String> alreadyParsedClasses = new HashSet<>();\n            for (ConfigurationClass configurationClass : alreadyParsed) {\n                alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n            }\n            for (String candidateName : newCandidateNames) {\n                if (!oldCandidateNames.contains(candidateName)) {\n                    BeanDefinition bd = registry.getBeanDefinition(candidateName);\n                    if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) && !alreadyParsedClasses.contains(bd.getBeanClassName())) {\n                        candidates.add(new BeanDefinitionHolder(bd, candidateName));\n                    }\n                }\n            }\n            candidateNames = newCandidateNames;\n        }\n    } while (!candidates.isEmpty());\n    if (sbr != null) {\n        if (!sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n            sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n        }\n    }\n    if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n        ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n    }\n}"
    },
    {
      "commit": "7818c650ba3ad567cff2975b408509679d03e663",
      "startLine": 2,
      "endLine": 25,
      "methodCode": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    List<BeanDefinitionHolder> configCandidates = new ArrayList<>();\n    String[] candidateNames = registry.getBeanDefinitionNames();\n    for (String beanName : candidateNames) {\n        BeanDefinition beanDef = registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) || ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n            }\n        } else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    Collections.sort(configCandidates, new Comparator<BeanDefinitionHolder>() {\n\n        @Override\n        public int compare(BeanDefinitionHolder bd1, BeanDefinitionHolder bd2) {\n            int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n            int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n            return (i1 < i2) ? -1 : (i1 > i2) ? 1 : 0;\n        }\n    });\n    SingletonBeanRegistry singletonRegistry = null;\n    if (registry instanceof SingletonBeanRegistry) {\n        singletonRegistry = (SingletonBeanRegistry) registry;\n        if (!this.localBeanNameGeneratorSet && singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n            BeanNameGenerator generator = (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n            this.componentScanBeanNameGenerator = generator;\n            this.importBeanNameGenerator = generator;\n        }\n    }\n    ConfigurationClassParser parser = new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n    Set<BeanDefinitionHolder> candidates = new LinkedHashSet<>(configCandidates);\n    Set<ConfigurationClass> alreadyParsed = new HashSet<>(configCandidates.size());\n    do {\n        parser.parse(candidates);\n        parser.validate();\n        Set<ConfigurationClass> configClasses = new LinkedHashSet<>(parser.getConfigurationClasses());\n        configClasses.removeAll(alreadyParsed);\n        if (this.reader == null) {\n            this.reader = new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.resourceLoader, this.environment, this.importBeanNameGenerator, parser.getImportRegistry());\n        }\n        this.reader.loadBeanDefinitions(configClasses);\n        alreadyParsed.addAll(configClasses);\n        candidates.clear();\n        if (registry.getBeanDefinitionCount() > candidateNames.length) {\n            String[] newCandidateNames = registry.getBeanDefinitionNames();\n            Set<String> oldCandidateNames = new HashSet<>(Arrays.asList(candidateNames));\n            Set<String> alreadyParsedClasses = new HashSet<>();\n            for (ConfigurationClass configurationClass : alreadyParsed) {\n                alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n            }\n            for (String candidateName : newCandidateNames) {\n                if (!oldCandidateNames.contains(candidateName)) {\n                    BeanDefinition beanDef = registry.getBeanDefinition(candidateName);\n                    if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory) && !alreadyParsedClasses.contains(beanDef.getBeanClassName())) {\n                        candidates.add(new BeanDefinitionHolder(beanDef, candidateName));\n                    }\n                }\n            }\n            candidateNames = newCandidateNames;\n        }\n    } while (!candidates.isEmpty());\n    if (singletonRegistry != null) {\n        if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n            singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n        }\n    }\n    if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n        ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n    }\n}"
    },
    {
      "commit": "00d2606b000f9bdafbd7f4a16b6599fb51b53fa4",
      "startLine": 2,
      "endLine": 25,
      "methodCode": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    List<BeanDefinitionHolder> configCandidates = new ArrayList<>();\n    String[] candidateNames = registry.getBeanDefinitionNames();\n    for (String beanName : candidateNames) {\n        BeanDefinition beanDef = registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) || ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n            }\n        } else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    Collections.sort(configCandidates, new Comparator<BeanDefinitionHolder>() {\n\n        @Override\n        public int compare(BeanDefinitionHolder bd1, BeanDefinitionHolder bd2) {\n            int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n            int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n            return (i1 < i2) ? -1 : (i1 > i2) ? 1 : 0;\n        }\n    });\n    SingletonBeanRegistry singletonRegistry = null;\n    if (registry instanceof SingletonBeanRegistry) {\n        singletonRegistry = (SingletonBeanRegistry) registry;\n        if (!this.localBeanNameGeneratorSet && singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n            BeanNameGenerator generator = (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n            this.componentScanBeanNameGenerator = generator;\n            this.importBeanNameGenerator = generator;\n        }\n    }\n    ConfigurationClassParser parser = new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n    Set<BeanDefinitionHolder> candidates = new LinkedHashSet<>(configCandidates);\n    Set<ConfigurationClass> alreadyParsed = new HashSet<>(configCandidates.size());\n    do {\n        parser.parse(candidates);\n        parser.validate();\n        Set<ConfigurationClass> configClasses = new LinkedHashSet<>(parser.getConfigurationClasses());\n        configClasses.removeAll(alreadyParsed);\n        if (this.reader == null) {\n            this.reader = new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.resourceLoader, this.environment, this.importBeanNameGenerator, parser.getImportRegistry());\n        }\n        this.reader.loadBeanDefinitions(configClasses);\n        alreadyParsed.addAll(configClasses);\n        candidates.clear();\n        if (registry.getBeanDefinitionCount() > candidateNames.length) {\n            String[] newCandidateNames = registry.getBeanDefinitionNames();\n            Set<String> oldCandidateNames = new HashSet<>(Arrays.asList(candidateNames));\n            Set<String> alreadyParsedClasses = new HashSet<>();\n            for (ConfigurationClass configurationClass : alreadyParsed) {\n                alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n            }\n            for (String candidateName : newCandidateNames) {\n                if (!oldCandidateNames.contains(candidateName)) {\n                    BeanDefinition beanDef = registry.getBeanDefinition(candidateName);\n                    if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory) && !alreadyParsedClasses.contains(beanDef.getBeanClassName())) {\n                        candidates.add(new BeanDefinitionHolder(beanDef, candidateName));\n                    }\n                }\n            }\n            candidateNames = newCandidateNames;\n        }\n    } while (!candidates.isEmpty());\n    if (singletonRegistry != null) {\n        if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n            singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n        }\n    }\n    if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n        ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n    }\n}"
    },
    {
      "commit": "f0ac2784a4e9602a06bc91c3368f7cf423fc52dc",
      "startLine": 2,
      "endLine": 25,
      "methodCode": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    List<BeanDefinitionHolder> configCandidates = new ArrayList<BeanDefinitionHolder>();\n    String[] candidateNames = registry.getBeanDefinitionNames();\n    for (String beanName : candidateNames) {\n        BeanDefinition beanDef = registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) || ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n            }\n        } else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    Collections.sort(configCandidates, new Comparator<BeanDefinitionHolder>() {\n\n        @Override\n        public int compare(BeanDefinitionHolder bd1, BeanDefinitionHolder bd2) {\n            int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n            int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n            return (i1 < i2) ? -1 : (i1 > i2) ? 1 : 0;\n        }\n    });\n    SingletonBeanRegistry singletonRegistry = null;\n    if (registry instanceof SingletonBeanRegistry) {\n        singletonRegistry = (SingletonBeanRegistry) registry;\n        if (!this.localBeanNameGeneratorSet && singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n            BeanNameGenerator generator = (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n            this.componentScanBeanNameGenerator = generator;\n            this.importBeanNameGenerator = generator;\n        }\n    }\n    ConfigurationClassParser parser = new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n    Set<BeanDefinitionHolder> candidates = new LinkedHashSet<BeanDefinitionHolder>(configCandidates);\n    Set<ConfigurationClass> alreadyParsed = new HashSet<ConfigurationClass>(configCandidates.size());\n    do {\n        parser.parse(candidates);\n        parser.validate();\n        Set<ConfigurationClass> configClasses = new LinkedHashSet<ConfigurationClass>(parser.getConfigurationClasses());\n        configClasses.removeAll(alreadyParsed);\n        if (this.reader == null) {\n            this.reader = new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.resourceLoader, this.environment, this.importBeanNameGenerator, parser.getImportRegistry());\n        }\n        this.reader.loadBeanDefinitions(configClasses);\n        alreadyParsed.addAll(configClasses);\n        candidates.clear();\n        if (registry.getBeanDefinitionCount() > candidateNames.length) {\n            String[] newCandidateNames = registry.getBeanDefinitionNames();\n            Set<String> oldCandidateNames = new HashSet<String>(Arrays.asList(candidateNames));\n            Set<String> alreadyParsedClasses = new HashSet<String>();\n            for (ConfigurationClass configurationClass : alreadyParsed) {\n                alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n            }\n            for (String candidateName : newCandidateNames) {\n                if (!oldCandidateNames.contains(candidateName)) {\n                    BeanDefinition beanDef = registry.getBeanDefinition(candidateName);\n                    if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory) && !alreadyParsedClasses.contains(beanDef.getBeanClassName())) {\n                        candidates.add(new BeanDefinitionHolder(beanDef, candidateName));\n                    }\n                }\n            }\n            candidateNames = newCandidateNames;\n        }\n    } while (!candidates.isEmpty());\n    if (singletonRegistry != null) {\n        if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n            singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n        }\n    }\n    if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n        ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n    }\n}"
    },
    {
      "commit": "f5b4e18209c45c948ab6bce6d166ef17b3f5b25d",
      "startLine": 2,
      "endLine": 25,
      "methodCode": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    List<BeanDefinitionHolder> configCandidates = new ArrayList<BeanDefinitionHolder>();\n    String[] candidateNames = registry.getBeanDefinitionNames();\n    for (String beanName : candidateNames) {\n        BeanDefinition beanDef = registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) || ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n            }\n        } else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    Collections.sort(configCandidates, new Comparator<BeanDefinitionHolder>() {\n\n        @Override\n        public int compare(BeanDefinitionHolder bd1, BeanDefinitionHolder bd2) {\n            int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n            int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n            return (i1 < i2) ? -1 : (i1 > i2) ? 1 : 0;\n        }\n    });\n    SingletonBeanRegistry singletonRegistry = null;\n    if (registry instanceof SingletonBeanRegistry) {\n        singletonRegistry = (SingletonBeanRegistry) registry;\n        if (!this.localBeanNameGeneratorSet && singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n            BeanNameGenerator generator = (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n            this.componentScanBeanNameGenerator = generator;\n            this.importBeanNameGenerator = generator;\n        }\n    }\n    ConfigurationClassParser parser = new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n    Set<BeanDefinitionHolder> candidates = new LinkedHashSet<BeanDefinitionHolder>(configCandidates);\n    Set<ConfigurationClass> alreadyParsed = new HashSet<ConfigurationClass>(configCandidates.size());\n    do {\n        parser.parse(candidates);\n        parser.validate();\n        Set<ConfigurationClass> configClasses = new LinkedHashSet<ConfigurationClass>(parser.getConfigurationClasses());\n        configClasses.removeAll(alreadyParsed);\n        if (this.reader == null) {\n            this.reader = new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment, this.importBeanNameGenerator, parser.getImportRegistry());\n        }\n        this.reader.loadBeanDefinitions(configClasses);\n        alreadyParsed.addAll(configClasses);\n        candidates.clear();\n        if (registry.getBeanDefinitionCount() > candidateNames.length) {\n            String[] newCandidateNames = registry.getBeanDefinitionNames();\n            Set<String> oldCandidateNames = new HashSet<String>(Arrays.asList(candidateNames));\n            Set<String> alreadyParsedClasses = new HashSet<String>();\n            for (ConfigurationClass configurationClass : alreadyParsed) {\n                alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n            }\n            for (String candidateName : newCandidateNames) {\n                if (!oldCandidateNames.contains(candidateName)) {\n                    BeanDefinition beanDef = registry.getBeanDefinition(candidateName);\n                    if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory) && !alreadyParsedClasses.contains(beanDef.getBeanClassName())) {\n                        candidates.add(new BeanDefinitionHolder(beanDef, candidateName));\n                    }\n                }\n            }\n            candidateNames = newCandidateNames;\n        }\n    } while (!candidates.isEmpty());\n    if (singletonRegistry != null) {\n        if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n            singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n        }\n    }\n    if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n        ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n    }\n}"
    },
    {
      "commit": "4c59d85f690a29c45c644f9c3f13010d5cba84ed",
      "startLine": 2,
      "endLine": 16,
      "methodCode": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    Set<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n    String[] candidateNames = registry.getBeanDefinitionNames();\n    for (String beanName : candidateNames) {\n        BeanDefinition beanDef = registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) || ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n            }\n        } else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    SingletonBeanRegistry singletonRegistry = null;\n    if (registry instanceof SingletonBeanRegistry) {\n        singletonRegistry = (SingletonBeanRegistry) registry;\n        if (!this.localBeanNameGeneratorSet && singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n            BeanNameGenerator generator = (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n            this.componentScanBeanNameGenerator = generator;\n            this.importBeanNameGenerator = generator;\n        }\n    }\n    ConfigurationClassParser parser = new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n    Set<ConfigurationClass> alreadyParsed = new HashSet<ConfigurationClass>(configCandidates.size());\n    do {\n        parser.parse(configCandidates);\n        parser.validate();\n        Set<ConfigurationClass> configClasses = new LinkedHashSet<ConfigurationClass>(parser.getConfigurationClasses());\n        configClasses.removeAll(alreadyParsed);\n        if (this.reader == null) {\n            this.reader = new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment, this.importBeanNameGenerator, parser.getImportRegistry());\n        }\n        this.reader.loadBeanDefinitions(configClasses);\n        alreadyParsed.addAll(configClasses);\n        configCandidates.clear();\n        if (registry.getBeanDefinitionCount() > candidateNames.length) {\n            String[] newCandidateNames = registry.getBeanDefinitionNames();\n            Set<String> oldCandidateNames = new HashSet<String>(Arrays.asList(candidateNames));\n            Set<String> alreadyParsedClasses = new HashSet<String>();\n            for (ConfigurationClass configurationClass : alreadyParsed) {\n                alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n            }\n            for (String candidateName : newCandidateNames) {\n                if (!oldCandidateNames.contains(candidateName)) {\n                    BeanDefinition beanDef = registry.getBeanDefinition(candidateName);\n                    if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory) && !alreadyParsedClasses.contains(beanDef.getBeanClassName())) {\n                        configCandidates.add(new BeanDefinitionHolder(beanDef, candidateName));\n                    }\n                }\n            }\n            candidateNames = newCandidateNames;\n        }\n    } while (!configCandidates.isEmpty());\n    if (singletonRegistry != null) {\n        if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n            singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n        }\n    }\n    if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n        ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n    }\n}"
    },
    {
      "commit": "abc343f4076d45172587197480c41f79c23f3aac",
      "startLine": 2,
      "endLine": 16,
      "methodCode": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    Set<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n    String[] candidateNames = registry.getBeanDefinitionNames();\n    for (String beanName : candidateNames) {\n        BeanDefinition beanDef = registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) || ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n            }\n        } else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    SingletonBeanRegistry singletonRegistry = null;\n    if (registry instanceof SingletonBeanRegistry) {\n        singletonRegistry = (SingletonBeanRegistry) registry;\n        if (!this.localBeanNameGeneratorSet && singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n            BeanNameGenerator generator = (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n            this.componentScanBeanNameGenerator = generator;\n            this.importBeanNameGenerator = generator;\n        }\n    }\n    ConfigurationClassParser parser = new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n    Set<ConfigurationClass> alreadyParsed = new HashSet<ConfigurationClass>(configCandidates.size());\n    do {\n        parser.parse(configCandidates);\n        parser.validate();\n        Set<ConfigurationClass> configClasses = new LinkedHashSet<ConfigurationClass>(parser.getConfigurationClasses());\n        configClasses.removeAll(alreadyParsed);\n        if (this.reader == null) {\n            this.reader = new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment, this.importBeanNameGenerator, parser.getImportRegistry());\n        }\n        this.reader.loadBeanDefinitions(configClasses);\n        alreadyParsed.addAll(configClasses);\n        configCandidates.clear();\n        if (registry.getBeanDefinitionCount() > candidateNames.length) {\n            String[] newCandidateNames = registry.getBeanDefinitionNames();\n            Set<String> oldCandidateNames = new HashSet<String>(Arrays.asList(candidateNames));\n            for (String candidateName : newCandidateNames) {\n                if (!oldCandidateNames.contains(candidateName)) {\n                    BeanDefinition beanDef = registry.getBeanDefinition(candidateName);\n                    if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n                        configCandidates.add(new BeanDefinitionHolder(beanDef, candidateName));\n                    }\n                }\n            }\n            candidateNames = newCandidateNames;\n        }\n    } while (!configCandidates.isEmpty());\n    if (singletonRegistry != null) {\n        if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n            singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n        }\n    }\n    if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n        ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n    }\n}"
    },
    {
      "commit": "7c6088861f9e59f4e29c7f9d47a2cf467c4e8cd6",
      "startLine": 2,
      "endLine": 16,
      "methodCode": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    Set<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n    String[] candidateNames = registry.getBeanDefinitionNames();\n    for (String beanName : candidateNames) {\n        BeanDefinition beanDef = registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) || ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n            }\n        } else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    SingletonBeanRegistry singletonRegistry = null;\n    if (registry instanceof SingletonBeanRegistry) {\n        singletonRegistry = (SingletonBeanRegistry) registry;\n        if (!this.localBeanNameGeneratorSet && singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n            BeanNameGenerator generator = (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n            this.componentScanBeanNameGenerator = generator;\n            this.importBeanNameGenerator = generator;\n        }\n    }\n    ConfigurationClassParser parser = new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n    Set<ConfigurationClass> alreadyParsed = new HashSet<ConfigurationClass>(configCandidates.size());\n    do {\n        parser.parse(configCandidates);\n        parser.validate();\n        Set<ConfigurationClass> configClasses = new LinkedHashSet<ConfigurationClass>(parser.getConfigurationClasses());\n        configClasses.removeAll(alreadyParsed);\n        if (this.reader == null) {\n            this.reader = new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment, this.importBeanNameGenerator);\n        }\n        this.reader.loadBeanDefinitions(configClasses);\n        alreadyParsed.addAll(configClasses);\n        configCandidates.clear();\n        if (registry.getBeanDefinitionCount() > candidateNames.length) {\n            String[] newCandidateNames = registry.getBeanDefinitionNames();\n            Set<String> oldCandidateNames = new HashSet<String>(Arrays.asList(candidateNames));\n            for (String candidateName : newCandidateNames) {\n                if (!oldCandidateNames.contains(candidateName)) {\n                    BeanDefinition beanDef = registry.getBeanDefinition(candidateName);\n                    if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n                        configCandidates.add(new BeanDefinitionHolder(beanDef, candidateName));\n                    }\n                }\n            }\n            candidateNames = newCandidateNames;\n        }\n    } while (!configCandidates.isEmpty());\n    if (singletonRegistry != null) {\n        if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n            singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n        }\n    }\n    if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n        ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n    }\n}"
    },
    {
      "commit": "71c6eb2bb594f29803b6ec4a50de875def98be86",
      "startLine": 2,
      "endLine": 16,
      "methodCode": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    Set<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n    String[] candidateNames = registry.getBeanDefinitionNames();\n    for (String beanName : candidateNames) {\n        BeanDefinition beanDef = registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) || ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n            }\n        } else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    SingletonBeanRegistry singletonRegistry = null;\n    if (registry instanceof SingletonBeanRegistry) {\n        singletonRegistry = (SingletonBeanRegistry) registry;\n        if (!this.localBeanNameGeneratorSet && singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n            BeanNameGenerator generator = (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n            this.componentScanBeanNameGenerator = generator;\n            this.importBeanNameGenerator = generator;\n        }\n    }\n    ConfigurationClassParser parser = new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n    Set<ConfigurationClass> alreadyParsed = new HashSet<ConfigurationClass>(configCandidates.size());\n    int propertySourceCount = 0;\n    do {\n        parser.parse(configCandidates);\n        parser.validate();\n        if (parser.getPropertySourceCount() > propertySourceCount) {\n            List<PropertySource<?>> parsedPropertySources = parser.getPropertySources();\n            if (!parsedPropertySources.isEmpty()) {\n                if (!(this.environment instanceof ConfigurableEnvironment)) {\n                    logger.warn(\"Ignoring @PropertySource annotations. \" + \"Reason: Environment must implement ConfigurableEnvironment\");\n                } else {\n                    MutablePropertySources envPropertySources = ((ConfigurableEnvironment) this.environment).getPropertySources();\n                    for (PropertySource<?> propertySource : parsedPropertySources) {\n                        envPropertySources.addLast(propertySource);\n                    }\n                }\n            }\n            propertySourceCount = parser.getPropertySourceCount();\n        }\n        Set<ConfigurationClass> configClasses = new LinkedHashSet<ConfigurationClass>(parser.getConfigurationClasses());\n        configClasses.removeAll(alreadyParsed);\n        if (this.reader == null) {\n            this.reader = new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment, this.importBeanNameGenerator);\n        }\n        this.reader.loadBeanDefinitions(configClasses);\n        alreadyParsed.addAll(configClasses);\n        configCandidates.clear();\n        if (registry.getBeanDefinitionCount() > candidateNames.length) {\n            String[] newCandidateNames = registry.getBeanDefinitionNames();\n            Set<String> oldCandidateNames = new HashSet<String>(Arrays.asList(candidateNames));\n            for (String candidateName : newCandidateNames) {\n                if (!oldCandidateNames.contains(candidateName)) {\n                    BeanDefinition beanDef = registry.getBeanDefinition(candidateName);\n                    if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n                        configCandidates.add(new BeanDefinitionHolder(beanDef, candidateName));\n                    }\n                }\n            }\n            candidateNames = newCandidateNames;\n        }\n    } while (!configCandidates.isEmpty());\n    if (singletonRegistry != null) {\n        if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n            singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n        }\n    }\n    if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n        ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n    }\n}"
    },
    {
      "commit": "b6255128bf7a32384f03e985d79b8bb03c3dd8a0",
      "startLine": 2,
      "endLine": 15,
      "methodCode": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    Set<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef = registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) || ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n            }\n        } else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    SingletonBeanRegistry singletonRegistry = null;\n    if (registry instanceof SingletonBeanRegistry) {\n        singletonRegistry = (SingletonBeanRegistry) registry;\n        if (!this.localBeanNameGeneratorSet && singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n            BeanNameGenerator generator = (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n            this.componentScanBeanNameGenerator = generator;\n            this.importBeanNameGenerator = generator;\n        }\n    }\n    ConfigurationClassParser parser = new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n    parser.parse(configCandidates);\n    parser.validate();\n    List<PropertySource<?>> parsedPropertySources = parser.getPropertySources();\n    if (!parsedPropertySources.isEmpty()) {\n        if (!(this.environment instanceof ConfigurableEnvironment)) {\n            logger.warn(\"Ignoring @PropertySource annotations. \" + \"Reason: Environment must implement ConfigurableEnvironment\");\n        } else {\n            MutablePropertySources envPropertySources = ((ConfigurableEnvironment) this.environment).getPropertySources();\n            for (PropertySource<?> propertySource : parsedPropertySources) {\n                envPropertySources.addLast(propertySource);\n            }\n        }\n    }\n    if (this.reader == null) {\n        this.reader = new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment, this.importBeanNameGenerator);\n    }\n    this.reader.loadBeanDefinitions(parser.getConfigurationClasses());\n    if (singletonRegistry != null) {\n        if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n            singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n        }\n    }\n    if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n        ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n    }\n}"
    },
    {
      "commit": "eed1a323d10de122a08db26192dc602f9fb173f8",
      "startLine": 2,
      "endLine": 11,
      "methodCode": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    Set<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef = registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    SingletonBeanRegistry singletonRegistry = null;\n    if (registry instanceof SingletonBeanRegistry) {\n        singletonRegistry = (SingletonBeanRegistry) registry;\n        if (!this.localBeanNameGeneratorSet && singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n            BeanNameGenerator generator = (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n            this.componentScanBeanNameGenerator = generator;\n            this.importBeanNameGenerator = generator;\n        }\n    }\n    ConfigurationClassParser parser = new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n    parser.parse(configCandidates);\n    parser.validate();\n    List<PropertySource<?>> parsedPropertySources = parser.getPropertySources();\n    if (!parsedPropertySources.isEmpty()) {\n        if (!(this.environment instanceof ConfigurableEnvironment)) {\n            logger.warn(\"Ignoring @PropertySource annotations. \" + \"Reason: Environment must implement ConfigurableEnvironment\");\n        } else {\n            MutablePropertySources envPropertySources = ((ConfigurableEnvironment) this.environment).getPropertySources();\n            for (PropertySource<?> propertySource : parsedPropertySources) {\n                envPropertySources.addLast(propertySource);\n            }\n        }\n    }\n    if (this.reader == null) {\n        this.reader = new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment, this.importBeanNameGenerator);\n    }\n    this.reader.loadBeanDefinitions(parser.getConfigurationClasses());\n    if (singletonRegistry != null) {\n        if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n            singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n        }\n    }\n    if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n        ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n    }\n}"
    },
    {
      "commit": "e95bd9e25086bf1dad37f8d08293c948621faf6b",
      "startLine": 2,
      "endLine": 11,
      "methodCode": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    Set<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef = registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    SingletonBeanRegistry singletonRegistry = null;\n    if (registry instanceof SingletonBeanRegistry) {\n        singletonRegistry = (SingletonBeanRegistry) registry;\n        if (!this.localBeanNameGeneratorSet && singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n            BeanNameGenerator generator = (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n            this.componentScanBeanNameGenerator = generator;\n            this.importBeanNameGenerator = generator;\n        }\n    }\n    ConfigurationClassParser parser = new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n    parser.parse(configCandidates);\n    parser.validate();\n    List<PropertySource<?>> parsedPropertySources = parser.getPropertySources();\n    if (!parsedPropertySources.isEmpty()) {\n        if (!(this.environment instanceof ConfigurableEnvironment)) {\n            logger.warn(\"Ignoring @PropertySource annotations. \" + \"Reason: Environment must implement ConfigurableEnvironment\");\n        } else {\n            MutablePropertySources envPropertySources = ((ConfigurableEnvironment) this.environment).getPropertySources();\n            for (PropertySource<?> propertySource : parsedPropertySources) {\n                envPropertySources.addLast(propertySource);\n            }\n        }\n    }\n    if (this.reader == null) {\n        this.reader = new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment, this.importBeanNameGenerator);\n    }\n    reader.loadBeanDefinitions(parser.getConfigurationClasses());\n    if (singletonRegistry != null) {\n        if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n            singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n        }\n    }\n    if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n        ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n    }\n}"
    },
    {
      "commit": "5efe894ee4969a7c3780a2fd4d2ceab695777c50",
      "startLine": 2,
      "endLine": 11,
      "methodCode": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    Set<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef = registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    SingletonBeanRegistry singletonRegistry = null;\n    if (registry instanceof SingletonBeanRegistry) {\n        singletonRegistry = (SingletonBeanRegistry) registry;\n        if (!this.localBeanNameGeneratorSet && singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n            BeanNameGenerator generator = (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n            this.componentScanBeanNameGenerator = generator;\n            this.importBeanNameGenerator = generator;\n        }\n    }\n    ConfigurationClassParser parser = new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n    parser.parse(configCandidates);\n    parser.validate();\n    Stack<PropertySource<?>> parsedPropertySources = parser.getPropertySources();\n    if (!parsedPropertySources.isEmpty()) {\n        if (!(this.environment instanceof ConfigurableEnvironment)) {\n            logger.warn(\"Ignoring @PropertySource annotations. \" + \"Reason: Environment must implement ConfigurableEnvironment\");\n        } else {\n            MutablePropertySources envPropertySources = ((ConfigurableEnvironment) this.environment).getPropertySources();\n            while (!parsedPropertySources.isEmpty()) {\n                envPropertySources.addLast(parsedPropertySources.pop());\n            }\n        }\n    }\n    if (this.reader == null) {\n        this.reader = new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment, this.importBeanNameGenerator);\n    }\n    reader.loadBeanDefinitions(parser.getConfigurationClasses());\n    if (singletonRegistry != null) {\n        if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n            singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n        }\n    }\n    if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n        ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n    }\n}"
    },
    {
      "commit": "2e2e9b8dd0ecb113c86ec3a5d0cf87d4f6f72fd6",
      "startLine": 2,
      "endLine": 11,
      "methodCode": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    Set<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef = registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    SingletonBeanRegistry singletonRegistry = null;\n    if (registry instanceof SingletonBeanRegistry) {\n        singletonRegistry = (SingletonBeanRegistry) registry;\n        if (!this.localBeanNameGeneratorSet && singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n            BeanNameGenerator generator = (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n            this.componentScanBeanNameGenerator = generator;\n            this.importBeanNameGenerator = generator;\n        }\n    }\n    ConfigurationClassParser parser = new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry, this.applicationContext);\n    parser.parse(configCandidates);\n    parser.validate();\n    Stack<PropertySource<?>> parsedPropertySources = parser.getPropertySources();\n    if (!parsedPropertySources.isEmpty()) {\n        if (!(this.environment instanceof ConfigurableEnvironment)) {\n            logger.warn(\"Ignoring @PropertySource annotations. \" + \"Reason: Environment must implement ConfigurableEnvironment\");\n        } else {\n            MutablePropertySources envPropertySources = ((ConfigurableEnvironment) this.environment).getPropertySources();\n            while (!parsedPropertySources.isEmpty()) {\n                envPropertySources.addLast(parsedPropertySources.pop());\n            }\n        }\n    }\n    if (this.reader == null) {\n        this.reader = new ConfigurationClassBeanDefinitionReader(registry, this.applicationContext, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment, this.importBeanNameGenerator);\n    }\n    reader.loadBeanDefinitions(parser.getConfigurationClasses());\n    if (singletonRegistry != null) {\n        if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n            singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n        }\n    }\n    if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n        ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n    }\n}"
    },
    {
      "commit": "239ce1466ce118294f5c7b8e842a80815fd813de",
      "startLine": 2,
      "endLine": 11,
      "methodCode": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    Set<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef = registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    SingletonBeanRegistry singletonRegistry = null;\n    if (registry instanceof SingletonBeanRegistry) {\n        singletonRegistry = (SingletonBeanRegistry) registry;\n        if (!this.localBeanNameGeneratorSet && singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n            BeanNameGenerator generator = (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n            this.componentScanBeanNameGenerator = generator;\n            this.importBeanNameGenerator = generator;\n        }\n    }\n    ConfigurationClassParser parser = new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n    parser.parse(configCandidates);\n    parser.validate();\n    Stack<PropertySource<?>> parsedPropertySources = parser.getPropertySources();\n    if (!parsedPropertySources.isEmpty()) {\n        if (!(this.environment instanceof ConfigurableEnvironment)) {\n            logger.warn(\"Ignoring @PropertySource annotations. \" + \"Reason: Environment must implement ConfigurableEnvironment\");\n        } else {\n            MutablePropertySources envPropertySources = ((ConfigurableEnvironment) this.environment).getPropertySources();\n            while (!parsedPropertySources.isEmpty()) {\n                envPropertySources.addLast(parsedPropertySources.pop());\n            }\n        }\n    }\n    if (this.reader == null) {\n        this.reader = new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment, this.importBeanNameGenerator);\n    }\n    reader.loadBeanDefinitions(parser.getConfigurationClasses());\n    if (singletonRegistry != null) {\n        if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n            singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n        }\n    }\n    if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n        ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n    }\n}"
    },
    {
      "commit": "7c7fdb07363791fb3c72f4946839f4c166196ebe",
      "startLine": 2,
      "endLine": 11,
      "methodCode": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    Set<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef = registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    SingletonBeanRegistry singletonRegistry = null;\n    if (registry instanceof SingletonBeanRegistry) {\n        singletonRegistry = (SingletonBeanRegistry) registry;\n        if (!this.localBeanNameGeneratorSet && singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n            BeanNameGenerator generator = (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n            this.componentScanBeanNameGenerator = generator;\n            this.importBeanNameGenerator = generator;\n        }\n    }\n    ConfigurationClassParser parser = new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n    parser.parse(configCandidates);\n    parser.validate();\n    Stack<PropertySource<?>> parsedPropertySources = parser.getPropertySources();\n    if (!parsedPropertySources.isEmpty()) {\n        if (!(this.environment instanceof ConfigurableEnvironment)) {\n            logger.warn(\"Ignoring @PropertySource annotations. \" + \"Reason: Environment must implement ConfigurableEnvironment\");\n        } else {\n            MutablePropertySources envPropertySources = ((ConfigurableEnvironment) this.environment).getPropertySources();\n            while (!parsedPropertySources.isEmpty()) {\n                envPropertySources.addLast(parsedPropertySources.pop());\n            }\n        }\n    }\n    if (this.reader == null) {\n        this.reader = new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment, this.importBeanNameGenerator);\n    }\n    for (ConfigurationClass configurationClass : parser.getConfigurationClasses()) {\n        if (!ConditionalAnnotationHelper.shouldSkip(configurationClass, registry, this.environment, this.importBeanNameGenerator)) {\n            reader.loadBeanDefinitionsForConfigurationClass(configurationClass);\n        }\n    }\n    if (singletonRegistry != null) {\n        if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n            singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n        }\n    }\n    if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n        ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n    }\n}"
    },
    {
      "commit": "b257253a2b6890ef532f27a662c441fc4fd21f3b",
      "startLine": 2,
      "endLine": 11,
      "methodCode": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    Set<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef = registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    SingletonBeanRegistry singletonRegistry = null;\n    if (registry instanceof SingletonBeanRegistry) {\n        singletonRegistry = (SingletonBeanRegistry) registry;\n        if (!this.localBeanNameGeneratorSet && singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n            BeanNameGenerator generator = (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n            this.componentScanBeanNameGenerator = generator;\n            this.importBeanNameGenerator = generator;\n        }\n    }\n    ConfigurationClassParser parser = new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n    for (BeanDefinitionHolder holder : configCandidates) {\n        BeanDefinition bd = holder.getBeanDefinition();\n        try {\n            if (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n            } else {\n                parser.parse(bd.getBeanClassName(), holder.getBeanName());\n            }\n        } catch (IOException ex) {\n            throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n        }\n    }\n    parser.validate();\n    Stack<PropertySource<?>> parsedPropertySources = parser.getPropertySources();\n    if (!parsedPropertySources.isEmpty()) {\n        if (!(this.environment instanceof ConfigurableEnvironment)) {\n            logger.warn(\"Ignoring @PropertySource annotations. \" + \"Reason: Environment must implement ConfigurableEnvironment\");\n        } else {\n            MutablePropertySources envPropertySources = ((ConfigurableEnvironment) this.environment).getPropertySources();\n            while (!parsedPropertySources.isEmpty()) {\n                envPropertySources.addLast(parsedPropertySources.pop());\n            }\n        }\n    }\n    if (this.reader == null) {\n        this.reader = new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment, this.importBeanNameGenerator);\n    }\n    for (ConfigurationClass configurationClass : parser.getConfigurationClasses()) {\n        if (!ConditionalAnnotationHelper.shouldSkip(configurationClass, registry, this.environment, this.importBeanNameGenerator)) {\n            reader.loadBeanDefinitionsForConfigurationClass(configurationClass);\n        }\n    }\n    if (singletonRegistry != null) {\n        if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n            singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n        }\n    }\n    if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n        ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n    }\n}"
    },
    {
      "commit": "1cb6e3dbb6e5a5f15ec06f4abc297821606ab2a6",
      "startLine": 2,
      "endLine": 11,
      "methodCode": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    Set<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef = registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    SingletonBeanRegistry singletonRegistry = null;\n    if (registry instanceof SingletonBeanRegistry) {\n        singletonRegistry = (SingletonBeanRegistry) registry;\n        if (!this.localBeanNameGeneratorSet && singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n            BeanNameGenerator generator = (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n            this.componentScanBeanNameGenerator = generator;\n            this.importBeanNameGenerator = generator;\n        }\n    }\n    ConfigurationClassParser parser = new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n    for (BeanDefinitionHolder holder : configCandidates) {\n        BeanDefinition bd = holder.getBeanDefinition();\n        try {\n            if (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n            } else {\n                parser.parse(bd.getBeanClassName(), holder.getBeanName());\n            }\n        } catch (IOException ex) {\n            throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n        }\n    }\n    parser.validate();\n    Stack<PropertySource<?>> parsedPropertySources = parser.getPropertySources();\n    if (!parsedPropertySources.isEmpty()) {\n        if (!(this.environment instanceof ConfigurableEnvironment)) {\n            logger.warn(\"Ignoring @PropertySource annotations. \" + \"Reason: Environment must implement ConfigurableEnvironment\");\n        } else {\n            MutablePropertySources envPropertySources = ((ConfigurableEnvironment) this.environment).getPropertySources();\n            while (!parsedPropertySources.isEmpty()) {\n                envPropertySources.addLast(parsedPropertySources.pop());\n            }\n        }\n    }\n    if (this.reader == null) {\n        this.reader = new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment, this.importBeanNameGenerator);\n    }\n    this.reader.loadBeanDefinitions(parser.getConfigurationClasses());\n    if (singletonRegistry != null) {\n        if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n            singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n        }\n    }\n    if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n        ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n    }\n}"
    },
    {
      "commit": "0a42c80c1151380f7f492ec75de5648cfe62d250",
      "startLine": 2,
      "endLine": 11,
      "methodCode": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    Set<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef = registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    SingletonBeanRegistry singletonRegistry = null;\n    if (registry instanceof SingletonBeanRegistry) {\n        singletonRegistry = (SingletonBeanRegistry) registry;\n        if (!this.localBeanNameGeneratorSet && singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n            BeanNameGenerator generator = (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n            this.componentScanBeanNameGenerator = generator;\n            this.importBeanNameGenerator = generator;\n        }\n    }\n    ConfigurationClassParser parser = new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n    for (BeanDefinitionHolder holder : configCandidates) {\n        BeanDefinition bd = holder.getBeanDefinition();\n        try {\n            if (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n            } else {\n                parser.parse(bd.getBeanClassName(), holder.getBeanName());\n            }\n        } catch (IOException ex) {\n            throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n        }\n    }\n    parser.validate();\n    Stack<PropertySource<?>> parsedPropertySources = parser.getPropertySources();\n    if (!parsedPropertySources.isEmpty()) {\n        if (!(this.environment instanceof ConfigurableEnvironment)) {\n            logger.warn(\"Ignoring @PropertySource annotations. \" + \"Reason: Environment must implement ConfigurableEnvironment\");\n        } else {\n            MutablePropertySources envPropertySources = ((ConfigurableEnvironment) this.environment).getPropertySources();\n            while (!parsedPropertySources.isEmpty()) {\n                envPropertySources.addLast(parsedPropertySources.pop());\n            }\n        }\n    }\n    if (this.reader == null) {\n        this.reader = new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment, this.importBeanNameGenerator);\n    }\n    this.reader.loadBeanDefinitions(parser.getConfigurationClasses());\n    if (singletonRegistry != null) {\n        if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n            singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n        }\n    }\n}"
    },
    {
      "commit": "02a4473c62d8240837bec297f0a1f3cb67ef8a7b",
      "startLine": 2,
      "endLine": 11,
      "methodCode": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    Set<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef = registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    ConfigurationClassParser parser = new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, registry);\n    for (BeanDefinitionHolder holder : configCandidates) {\n        BeanDefinition bd = holder.getBeanDefinition();\n        try {\n            if (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n            } else {\n                parser.parse(bd.getBeanClassName(), holder.getBeanName());\n            }\n        } catch (IOException ex) {\n            throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n        }\n    }\n    parser.validate();\n    Stack<PropertySource<?>> parsedPropertySources = parser.getPropertySources();\n    if (!parsedPropertySources.isEmpty()) {\n        if (!(this.environment instanceof ConfigurableEnvironment)) {\n            logger.warn(\"Ignoring @PropertySource annotations. \" + \"Reason: Environment must implement ConfigurableEnvironment\");\n        } else {\n            MutablePropertySources envPropertySources = ((ConfigurableEnvironment) this.environment).getPropertySources();\n            while (!parsedPropertySources.isEmpty()) {\n                envPropertySources.addLast(parsedPropertySources.pop());\n            }\n        }\n    }\n    this.getConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getConfigurationClasses());\n    if (registry instanceof SingletonBeanRegistry) {\n        if (!((SingletonBeanRegistry) registry).containsSingleton(\"importRegistry\")) {\n            ((SingletonBeanRegistry) registry).registerSingleton(\"importRegistry\", parser.getImportRegistry());\n        }\n    }\n}"
    },
    {
      "commit": "4520ea8690fa8769a2d45658883eac51ea2453ed",
      "startLine": 2,
      "endLine": 11,
      "methodCode": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    Set<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef = registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    ConfigurationClassParser parser = new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, registry);\n    for (BeanDefinitionHolder holder : configCandidates) {\n        BeanDefinition bd = holder.getBeanDefinition();\n        try {\n            if (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n            } else {\n                parser.parse(bd.getBeanClassName(), holder.getBeanName());\n            }\n        } catch (IOException ex) {\n            throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n        }\n    }\n    parser.validate();\n    Stack<PropertySource<?>> parsedPropertySources = parser.getPropertySources();\n    if (!parsedPropertySources.isEmpty()) {\n        if (!(this.environment instanceof ConfigurableEnvironment)) {\n            logger.warn(\"Ignoring @PropertySource annotations. \" + \"Reason: Environment must implement ConfigurableEnvironment\");\n        } else {\n            MutablePropertySources envPropertySources = ((ConfigurableEnvironment) this.environment).getPropertySources();\n            while (!parsedPropertySources.isEmpty()) {\n                envPropertySources.addLast(parsedPropertySources.pop());\n            }\n        }\n    }\n    this.getConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getConfigurationClasses());\n    if (registry instanceof SingletonBeanRegistry) {\n        if (!((SingletonBeanRegistry) registry).containsSingleton(\"importRegistry\")) {\n            ((SingletonBeanRegistry) registry).registerSingleton(\"importRegistry\", parser.getImportRegistry());\n        }\n    }\n}"
    },
    {
      "commit": "6fcea8b99da45f287149796ef2598f0d71758793",
      "startLine": 2,
      "endLine": 11,
      "methodCode": "public void processConfigBeanDefinitions(ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n    Set<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef = registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    ConfigurationClassParser parser = new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, registry);\n    for (BeanDefinitionHolder holder : configCandidates) {\n        BeanDefinition bd = holder.getBeanDefinition();\n        try {\n            if (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n            } else {\n                parser.parse(bd.getBeanClassName(), holder.getBeanName());\n            }\n        } catch (IOException ex) {\n            throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n        }\n    }\n    parser.validate();\n    Stack<PropertySource<?>> parsedPropertySources = parser.getPropertySources();\n    if (!parsedPropertySources.isEmpty()) {\n        if (!(this.environment instanceof ConfigurableEnvironment)) {\n            logger.warn(\"Ignoring @PropertySource annotations. \" + \"Reason: Environment must implement ConfigurableEnvironment\");\n        } else {\n            MutablePropertySources envPropertySources = ((ConfigurableEnvironment) this.environment).getPropertySources();\n            while (!parsedPropertySources.isEmpty()) {\n                envPropertySources.addLast(parsedPropertySources.pop());\n            }\n        }\n    }\n    reader.loadBeanDefinitions(parser.getConfigurationClasses());\n    if (registry instanceof SingletonBeanRegistry) {\n        if (!((SingletonBeanRegistry) registry).containsSingleton(\"importRegistry\")) {\n            ((SingletonBeanRegistry) registry).registerSingleton(\"importRegistry\", parser.getImportRegistry());\n        }\n    }\n}"
    },
    {
      "commit": "57206db15271f865b542264c74980e6cbb4681fd",
      "startLine": 2,
      "endLine": 11,
      "methodCode": "public void processConfigBeanDefinitions(ConfigurationClassParser parser, ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n    Set<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef = registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    for (BeanDefinitionHolder holder : configCandidates) {\n        BeanDefinition bd = holder.getBeanDefinition();\n        try {\n            if (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n            } else {\n                parser.parse(bd.getBeanClassName(), holder.getBeanName());\n            }\n        } catch (IOException ex) {\n            throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n        }\n    }\n    parser.validate();\n    Stack<PropertySource<?>> parsedPropertySources = parser.getPropertySources();\n    if (!parsedPropertySources.isEmpty()) {\n        if (!(this.environment instanceof ConfigurableEnvironment)) {\n            logger.warn(\"Ignoring @PropertySource annotations. \" + \"Reason: Environment must implement ConfigurableEnvironment\");\n        } else {\n            MutablePropertySources envPropertySources = ((ConfigurableEnvironment) this.environment).getPropertySources();\n            while (!parsedPropertySources.isEmpty()) {\n                envPropertySources.addLast(parsedPropertySources.pop());\n            }\n        }\n    }\n    reader.loadBeanDefinitions(parser.getConfigurationClasses());\n    if (registry instanceof SingletonBeanRegistry) {\n        if (!((SingletonBeanRegistry) registry).containsSingleton(\"importRegistry\")) {\n            ((SingletonBeanRegistry) registry).registerSingleton(\"importRegistry\", parser.getImportRegistry());\n        }\n    }\n}"
    },
    {
      "commit": "c8bc54e0ccad49f0785856f911349283619eb8ba",
      "startLine": 2,
      "endLine": 11,
      "methodCode": "public void processConfigBeanDefinitions(ConfigurationClassParser parser, ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n    Set<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef = registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    for (BeanDefinitionHolder holder : configCandidates) {\n        BeanDefinition bd = holder.getBeanDefinition();\n        try {\n            if (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n            } else {\n                parser.parse(bd.getBeanClassName(), holder.getBeanName());\n            }\n        } catch (IOException ex) {\n            throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n        }\n    }\n    parser.validate();\n    if (!(this.environment instanceof ConfigurableEnvironment)) {\n        logger.warn(\"Ignoring @PropertySource annotations. \" + \"Reason: Environment must implement ConfigurableEnvironment\");\n    } else {\n        MutablePropertySources envPropertySources = ((ConfigurableEnvironment) this.environment).getPropertySources();\n        Stack<PropertySource<?>> parsedPropertySources = parser.getPropertySources();\n        while (!parsedPropertySources.isEmpty()) {\n            envPropertySources.addLast(parsedPropertySources.pop());\n        }\n    }\n    reader.loadBeanDefinitions(parser.getConfigurationClasses());\n    if (registry instanceof SingletonBeanRegistry) {\n        if (!((SingletonBeanRegistry) registry).containsSingleton(\"importRegistry\")) {\n            ((SingletonBeanRegistry) registry).registerSingleton(\"importRegistry\", parser.getImportRegistry());\n        }\n    }\n}"
    },
    {
      "commit": "d0c31ad84cffd7af718a45d679483a1c51f9e552",
      "startLine": 2,
      "endLine": 11,
      "methodCode": "public void processConfigBeanDefinitions(ConfigurationClassParser parser, ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n    Set<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef = registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    for (BeanDefinitionHolder holder : configCandidates) {\n        BeanDefinition bd = holder.getBeanDefinition();\n        try {\n            if (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n            } else {\n                parser.parse(bd.getBeanClassName(), holder.getBeanName());\n            }\n        } catch (IOException ex) {\n            throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n        }\n    }\n    parser.validate();\n    reader.loadBeanDefinitions(parser.getConfigurationClasses());\n    if (registry instanceof SingletonBeanRegistry) {\n        if (!((SingletonBeanRegistry) registry).containsSingleton(\"importRegistry\")) {\n            ((SingletonBeanRegistry) registry).registerSingleton(\"importRegistry\", parser.getImportRegistry());\n        }\n    }\n}"
    },
    {
      "commit": "cdb01cbd3795f273b751d0f0a45caa22d07c62da",
      "startLine": 2,
      "endLine": 11,
      "methodCode": "public void processConfigBeanDefinitions(ConfigurationClassParser parser, ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n    Set<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef = registry.getBeanDefinition(beanName);\n        if (ConfigurationClassBeanDefinitionReader.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    for (BeanDefinitionHolder holder : configCandidates) {\n        BeanDefinition bd = holder.getBeanDefinition();\n        try {\n            if (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n            } else {\n                parser.parse(bd.getBeanClassName(), holder.getBeanName());\n            }\n        } catch (IOException ex) {\n            throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n        }\n    }\n    parser.validate();\n    reader.loadBeanDefinitions(parser.getConfigurationClasses());\n    if (registry instanceof SingletonBeanRegistry) {\n        if (!((SingletonBeanRegistry) registry).containsSingleton(\"importRegistry\")) {\n            ((SingletonBeanRegistry) registry).registerSingleton(\"importRegistry\", parser.getImportRegistry());\n        }\n    }\n}"
    },
    {
      "commit": "111fb71fe1ccb8d3a5e06e61461edd87d6d025f4",
      "startLine": 2,
      "endLine": 11,
      "methodCode": "public void processConfigBeanDefinitions(ConfigurationClassParser parser, ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n    Set<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef = registry.getBeanDefinition(beanName);\n        if (ConfigurationClassBeanDefinitionReader.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    for (BeanDefinitionHolder holder : configCandidates) {\n        BeanDefinition bd = holder.getBeanDefinition();\n        try {\n            if (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n            } else {\n                parser.parse(bd.getBeanClassName(), holder.getBeanName());\n            }\n        } catch (IOException ex) {\n            throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n        }\n    }\n    parser.validate();\n    reader.loadBeanDefinitions(parser.getConfigurationClasses());\n}"
    },
    {
      "commit": "b4fea47d5cff9f3c85e62c233c2fe86b1d616592",
      "startLine": 2,
      "endLine": 11,
      "methodCode": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry, ConfigurationClassBeanDefinitionReader reader) {\n    Set<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef = registry.getBeanDefinition(beanName);\n        if (ConfigurationClassBeanDefinitionReader.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    ConfigurationClassParser parser = new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment);\n    for (BeanDefinitionHolder holder : configCandidates) {\n        BeanDefinition bd = holder.getBeanDefinition();\n        try {\n            if (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n            } else {\n                parser.parse(bd.getBeanClassName(), holder.getBeanName());\n            }\n        } catch (IOException ex) {\n            throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n        }\n    }\n    parser.validate();\n    reader.loadBeanDefinitions(parser.getConfigurationClasses());\n}"
    },
    {
      "commit": "f480333d31d8307b8c96409e7bb4f06ec0cab0ca",
      "startLine": 2,
      "endLine": 11,
      "methodCode": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    Set<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef = registry.getBeanDefinition(beanName);\n        if (ConfigurationClassBeanDefinitionReader.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    ConfigurationClassParser parser = new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment);\n    for (BeanDefinitionHolder holder : configCandidates) {\n        BeanDefinition bd = holder.getBeanDefinition();\n        try {\n            if (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n            } else {\n                parser.parse(bd.getBeanClassName(), holder.getBeanName());\n            }\n        } catch (IOException ex) {\n            throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n        }\n    }\n    parser.validate();\n    ConfigurationClassBeanDefinitionReader reader = new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory);\n    reader.loadBeanDefinitions(parser.getConfigurationClasses());\n}"
    },
    {
      "commit": "fbd797e50b2f1c5b0dfef944ee218d826f1a0694",
      "startLine": 2,
      "endLine": 11,
      "methodCode": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    Set<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef = registry.getBeanDefinition(beanName);\n        if (ConfigurationClassBeanDefinitionReader.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    ConfigurationClassParser parser = new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter);\n    for (BeanDefinitionHolder holder : configCandidates) {\n        BeanDefinition bd = holder.getBeanDefinition();\n        try {\n            if (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n            } else {\n                parser.parse(bd.getBeanClassName(), holder.getBeanName());\n            }\n        } catch (IOException ex) {\n            throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n        }\n    }\n    parser.validate();\n    ConfigurationClassBeanDefinitionReader reader = new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory);\n    reader.loadBeanDefinitions(parser.getConfigurationClasses());\n}"
    },
    {
      "commit": "0a4463fb71e6901a943a5bafc9d1957da2229333",
      "startLine": 2,
      "endLine": 11,
      "methodCode": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    Set<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef = registry.getBeanDefinition(beanName);\n        if (checkConfigurationClassCandidate(beanDef)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    ConfigurationClassParser parser = new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter);\n    for (BeanDefinitionHolder holder : configCandidates) {\n        BeanDefinition bd = holder.getBeanDefinition();\n        try {\n            if (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n            } else {\n                parser.parse(bd.getBeanClassName(), holder.getBeanName());\n            }\n        } catch (IOException ex) {\n            throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n        }\n    }\n    parser.validate();\n    new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor).loadBeanDefinitions(parser.getConfigurationClasses());\n}"
    },
    {
      "commit": "cce6e2f4cdfed4233805a32fb82626fa5e901cc0",
      "startLine": 2,
      "endLine": 11,
      "methodCode": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    Set<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef = registry.getBeanDefinition(beanName);\n        if (checkConfigurationClassCandidate(beanDef)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    ConfigurationClassParser parser = new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter);\n    for (BeanDefinitionHolder holder : configCandidates) {\n        BeanDefinition bd = holder.getBeanDefinition();\n        try {\n            if (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n            } else {\n                parser.parse(bd.getBeanClassName(), holder.getBeanName());\n            }\n        } catch (IOException ex) {\n            throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n        }\n    }\n    parser.validate();\n    new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor).loadBeanDefinitions(parser.getModel());\n}"
    },
    {
      "commit": "a6124793fc44779b569fbbba6fd4ec8804b56558",
      "startLine": 2,
      "endLine": 11,
      "methodCode": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    Set<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef = registry.getBeanDefinition(beanName);\n        if (checkConfigurationClassCandidate(beanDef)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    ConfigurationClassParser parser = new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter);\n    for (BeanDefinitionHolder holder : configCandidates) {\n        BeanDefinition bd = holder.getBeanDefinition();\n        try {\n            if (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n            } else {\n                parser.parse(bd.getBeanClassName(), holder.getBeanName());\n            }\n        } catch (IOException ex) {\n            throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n        }\n    }\n    parser.validate();\n    new ConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getModel());\n}"
    },
    {
      "commit": "cea8f7f69e8939d4d20073862890f0b1c1824499",
      "startLine": 2,
      "endLine": 11,
      "methodCode": "protected void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    Set<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef = registry.getBeanDefinition(beanName);\n        if (checkConfigurationClassCandidate(beanDef)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    ConfigurationClassParser parser = new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter);\n    for (BeanDefinitionHolder holder : configCandidates) {\n        BeanDefinition bd = holder.getBeanDefinition();\n        try {\n            if (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n            } else {\n                parser.parse(bd.getBeanClassName(), holder.getBeanName());\n            }\n        } catch (IOException ex) {\n            throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n        }\n    }\n    parser.validate();\n    new ConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getModel());\n}"
    },
    {
      "commit": "b5d21108da24f8344be3bc708c7afdfca9a1d089",
      "startLine": 2,
      "endLine": 11,
      "methodCode": "protected final void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    Set<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef = registry.getBeanDefinition(beanName);\n        if (checkConfigurationClassCandidate(beanDef)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    ConfigurationClassParser parser = new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter);\n    for (BeanDefinitionHolder holder : configCandidates) {\n        BeanDefinition bd = holder.getBeanDefinition();\n        try {\n            if (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n            } else {\n                parser.parse(bd.getBeanClassName(), holder.getBeanName());\n            }\n        } catch (IOException ex) {\n            throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n        }\n    }\n    parser.validate();\n    new ConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getModel());\n}"
    },
    {
      "commit": "ea9d8925a27e80d31d924826cf54f70b2bbcc638",
      "startLine": 2,
      "endLine": 11,
      "methodCode": "protected final void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    Set<BeanDefinitionHolder> configBeanDefs = new LinkedHashSet<BeanDefinitionHolder>();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef = registry.getBeanDefinition(beanName);\n        if (checkConfigurationClassBeanDefinition(beanDef)) {\n            configBeanDefs.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configBeanDefs.isEmpty()) {\n        return;\n    }\n    ConfigurationClassParser parser = new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter);\n    for (BeanDefinitionHolder holder : configBeanDefs) {\n        String beanClassName = holder.getBeanDefinition().getBeanClassName();\n        try {\n            parser.parse(beanClassName, holder.getBeanName());\n        } catch (IOException ex) {\n            throw new BeanDefinitionStoreException(\"Failed to load bean class [\" + beanClassName + \"]\", ex);\n        }\n    }\n    parser.validate();\n    new ConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getModel());\n}"
    },
    {
      "commit": "14bd47551900ced88eeacf2a5f63c187ff72028c",
      "startLine": 2,
      "endLine": 11,
      "methodCode": "protected final void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    Set<BeanDefinitionHolder> configBeanDefs = new LinkedHashSet<BeanDefinitionHolder>();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef = registry.getBeanDefinition(beanName);\n        if (checkConfigurationClassBeanDefinition(beanDef)) {\n            configBeanDefs.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configBeanDefs.isEmpty()) {\n        return;\n    }\n    ConfigurationClassParser parser = new ConfigurationClassParser(this.problemReporter, this.beanClassLoader);\n    for (BeanDefinitionHolder holder : configBeanDefs) {\n        parser.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n    }\n    parser.validate();\n    new ConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getModel());\n}"
    },
    {
      "commit": "cc713ad5241a90bc66b96364b91e5439f1ae6cb6",
      "startLine": 2,
      "endLine": 10,
      "methodCode": "protected final BeanDefinitionRegistry processConfigBeanDefinitions() {\n    BeanDefinitionRegistry configBeanDefs = getConfigurationBeanDefinitions(false);\n    if (configBeanDefs.getBeanDefinitionCount() == 0)\n        return configBeanDefs;\n    ConfigurationClassParser parser = createConfigurationParser();\n    for (String beanName : configBeanDefs.getBeanDefinitionNames()) {\n        BeanDefinition beanDef = configBeanDefs.getBeanDefinition(beanName);\n        String className = beanDef.getBeanClassName();\n        parser.parse(className, beanName);\n    }\n    ConfigurationModel configModel = parser.getConfigurationModel();\n    configModel.validate(problemReporter);\n    return new ConfigurationModelBeanDefinitionReader().loadBeanDefinitions(configModel);\n}"
    },
    {
      "commit": "1697932c57af5389fe07971e91866980e966403f",
      "startLine": 2,
      "endLine": 10,
      "methodCode": "protected final BeanDefinitionRegistry processConfigBeanDefinitions() {\n    BeanDefinitionRegistry configBeanDefs = getConfigurationBeanDefinitions(false);\n    if (configBeanDefs.getBeanDefinitionCount() == 0)\n        return configBeanDefs;\n    ConfigurationParser parser = createConfigurationParser();\n    for (String beanName : configBeanDefs.getBeanDefinitionNames()) {\n        BeanDefinition beanDef = configBeanDefs.getBeanDefinition(beanName);\n        String className = beanDef.getBeanClassName();\n        parser.parse(className, beanName);\n    }\n    ConfigurationModel configModel = parser.getConfigurationModel();\n    configModel.validate(problemReporter);\n    return new ConfigurationModelBeanDefinitionReader().loadBeanDefinitions(configModel);\n}"
    },
    {
      "commit": "cd50e456457ecac48f61e2da991b6fd5dc0c6ee7",
      "startLine": 2,
      "endLine": 10,
      "methodCode": "protected final BeanDefinitionRegistry processConfigBeanDefinitions() {\n    BeanDefinitionRegistry configBeanDefs = getConfigurationBeanDefinitions(false);\n    if (configBeanDefs.getBeanDefinitionCount() == 0)\n        return configBeanDefs;\n    ConfigurationParser parser = createConfigurationParser();\n    for (String beanName : configBeanDefs.getBeanDefinitionNames()) {\n        BeanDefinition beanDef = configBeanDefs.getBeanDefinition(beanName);\n        String className = beanDef.getBeanClassName();\n        parser.parse(className, beanName);\n    }\n    ConfigurationModel configModel = parser.getConfigurationModel();\n    configModel.validate(problemReporter);\n    return new ConfigurationModelBeanDefinitionReader().loadBeanDefinitions(configModel);\n}"
    },
    {
      "commit": "ef02c61e581dcd1f3cf110608da72ed133777d62",
      "startLine": 2,
      "endLine": 10,
      "methodCode": "protected final BeanDefinitionRegistry processConfigBeanDefinitions() {\n    BeanDefinitionRegistry configBeanDefs = getConfigurationBeanDefinitions(false);\n    if (configBeanDefs.getBeanDefinitionCount() == 0)\n        return configBeanDefs;\n    ConfigurationParser parser = createConfigurationParser();\n    for (String beanName : configBeanDefs.getBeanDefinitionNames()) {\n        BeanDefinition beanDef = configBeanDefs.getBeanDefinition(beanName);\n        String className = beanDef.getBeanClassName();\n        parser.parse(className, beanName);\n    }\n    ConfigurationModel configModel = parser.getConfigurationModel();\n    configModel.validate(problemReporter);\n    return new ConfigurationModelBeanDefinitionReader().loadBeanDefinitions(configModel);\n}"
    },
    {
      "commit": "b8f712621d56b2d862338a34d52839583dc1a80a",
      "startLine": 2,
      "endLine": 10,
      "methodCode": "protected final BeanDefinitionRegistry processConfigBeanDefinitions() {\n    BeanDefinitionRegistry configBeanDefs = getConfigurationBeanDefinitions(false);\n    if (configBeanDefs.getBeanDefinitionCount() == 0)\n        return configBeanDefs;\n    ConfigurationParser parser = createConfigurationParser();\n    for (String beanName : configBeanDefs.getBeanDefinitionNames()) {\n        BeanDefinition beanDef = configBeanDefs.getBeanDefinition(beanName);\n        String className = beanDef.getBeanClassName();\n        parser.parse(className, beanName);\n    }\n    ConfigurationModel configModel = parser.getConfigurationModel();\n    configModel.validate(problemReporter);\n    return new ConfigurationModelBeanDefinitionReader().loadBeanDefinitions(configModel);\n}"
    },
    {
      "commit": "2e7e98248724f5f4fc054617765053e7d7b978cd",
      "startLine": 2,
      "endLine": 10,
      "methodCode": "protected final BeanDefinitionRegistry processConfigBeanDefinitions() {\n    BeanDefinitionRegistry configBeanDefs = getConfigurationBeanDefinitions(false);\n    if (configBeanDefs.getBeanDefinitionCount() == 0)\n        return configBeanDefs;\n    ConfigurationParser parser = createConfigurationParser();\n    for (String beanName : configBeanDefs.getBeanDefinitionNames()) {\n        BeanDefinition beanDef = configBeanDefs.getBeanDefinition(beanName);\n        String className = beanDef.getBeanClassName();\n        parser.parse(className, beanName);\n    }\n    ConfigurationModel configModel = parser.getConfigurationModel();\n    validateModel(configModel);\n    return new ConfigurationModelBeanDefinitionReader().loadBeanDefinitions(configModel);\n}"
    },
    {
      "commit": "b985011b24cb40671ad6d2b8cc34fbea763ed7a4",
      "startLine": 2,
      "endLine": 4,
      "methodCode": "protected BeanDefinitionRegistry processConfigBeanDefinitions() {\n    BeanDefinitionRegistry configBeanDefs = getConfigurationBeanDefinitions(false);\n    if (configBeanDefs.getBeanDefinitionCount() == 0)\n        return configBeanDefs;\n    ConfigurationModel configModel = createConfigurationModelFor(configBeanDefs);\n    validateModel(configModel);\n    return renderModelAsBeanDefinitions(configModel);\n}"
    },
    {
      "commit": "43b2a40343be4d4a2ad12cf4dbdc0a76ddeaedbf",
      "startLine": 2,
      "endLine": 4,
      "methodCode": "protected BeanDefinitionRegistry processConfigBeanDefinitions() {\n    BeanDefinitionRegistry configBeanDefs = getConfigurationBeanDefinitions(false);\n    if (configBeanDefs.getBeanDefinitionCount() == 0)\n        return configBeanDefs;\n    if (Package.getPackage(CGLIB_PACKAGE) == null)\n        throw new RuntimeException(\"CGLIB is required to process @Configuration classes. \" + \"Either add CGLIB v2.2.3 to the classpath or remove the following \" + \"@Configuration bean definitions: [\" + arrayToCommaDelimitedString(configBeanDefs.getBeanDefinitionNames()) + \"]\");\n    ConfigurationModel configModel = createConfigurationModelFor(configBeanDefs);\n    validateModel(configModel);\n    return renderModelAsBeanDefinitions(configModel);\n}"
    },
    {
      "commit": "eaf3a7cec49e3a6e8ed828dbb69b9a9b007b0b39",
      "startLine": 2,
      "endLine": 4,
      "methodCode": "protected BeanDefinitionRegistry processConfigBeanDefinitions() {\n    BeanDefinitionRegistry configBeanDefs = getConfigurationBeanDefinitions(false);\n    if (configBeanDefs.getBeanDefinitionCount() == 0)\n        return configBeanDefs;\n    ConfigurationModel configModel = createConfigurationModelFor(configBeanDefs);\n    validateModel(configModel);\n    return renderModelAsBeanDefinitions(configModel);\n}"
    }
  ]
}