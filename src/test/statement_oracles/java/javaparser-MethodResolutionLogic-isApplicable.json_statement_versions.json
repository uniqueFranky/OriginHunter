{
  "statementVersions": [
    {
      "commit": "09232ff6b0ea19e850482f3a87ac6ef1c063c759",
      "startLine": 41,
      "endLine": 44,
      "methodCode": "private static boolean isApplicable(ResolvedMethodDeclaration method, String name, List<ResolvedType> argumentsTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.hasVariadicParameter()) {\n        int pos = method.getNumberOfParams() - 1;\n        if (method.getNumberOfParams() == argumentsTypes.size()) {\n            ResolvedType expectedType = method.getLastParam().getType();\n            ResolvedType actualType = argumentsTypes.get(pos);\n            if (!expectedType.isAssignableBy(actualType)) {\n                for (ResolvedTypeParameterDeclaration tp : method.getTypeParameters()) {\n                    expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                }\n                if (!expectedType.isAssignableBy(actualType)) {\n                    if (actualType.isArray() && expectedType.isAssignableBy(actualType.asArrayType().getComponentType())) {\n                        argumentsTypes.set(pos, actualType.asArrayType().getComponentType());\n                    } else {\n                        argumentsTypes = groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n                    }\n                }\n            }\n        } else {\n            if (pos > argumentsTypes.size()) {\n                return false;\n            }\n            argumentsTypes = groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n        }\n    }\n    if (method.getNumberOfParams() != argumentsTypes.size()) {\n        return false;\n    }\n    Map<String, ResolvedType> matchedParameters = new HashMap<>();\n    boolean needForWildCardTolerance = false;\n    for (int i = 0; i < method.getNumberOfParams(); i++) {\n        ResolvedType expectedType = method.getParam(i).getType();\n        ResolvedType actualType = argumentsTypes.get(i);\n        if ((expectedType.isTypeVariable() && !(expectedType.isWildcard())) && expectedType.asTypeParameter().declaredOnMethod()) {\n            matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n            continue;\n        }\n        boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(actualType) || (method.getParam(i).isVariadic() && new ResolvedArrayType(expectedType).isAssignableBy(actualType));\n        if (!isAssignableWithoutSubstitution && expectedType.isReferenceType() && actualType.isReferenceType()) {\n            isAssignableWithoutSubstitution = isAssignableMatchTypeParameters(expectedType.asReferenceType(), actualType.asReferenceType(), matchedParameters);\n        }\n        if (!isAssignableWithoutSubstitution) {\n            List<ResolvedTypeParameterDeclaration> typeParameters = method.getTypeParameters();\n            typeParameters.addAll(method.declaringType().getTypeParameters());\n            for (ResolvedTypeParameterDeclaration tp : typeParameters) {\n                expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(actualType)) {\n                if (actualType.isWildcard() && withWildcardTolerance && !expectedType.isPrimitive()) {\n                    needForWildCardTolerance = true;\n                    continue;\n                }\n                if (method.hasVariadicParameter() && i == method.getNumberOfParams() - 1) {\n                    if (new ResolvedArrayType(expectedType).isAssignableBy(actualType)) {\n                        continue;\n                    }\n                }\n                return false;\n            }\n        }\n    }\n    return !withWildcardTolerance || needForWildCardTolerance;\n}"
    },
    {
      "commit": "e15d5a8aa84a34917e4ef47135dfc62e58ea7650",
      "startLine": 41,
      "endLine": 44,
      "methodCode": "private static boolean isApplicable(ResolvedMethodDeclaration method, String name, List<ResolvedType> argumentsTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.hasVariadicParameter()) {\n        int pos = method.getNumberOfParams() - 1;\n        if (method.getNumberOfParams() == argumentsTypes.size()) {\n            ResolvedType expectedType = method.getLastParam().getType();\n            ResolvedType actualType = argumentsTypes.get(pos);\n            if (!expectedType.isAssignableBy(actualType)) {\n                for (ResolvedTypeParameterDeclaration tp : method.getTypeParameters()) {\n                    expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                }\n                if (!expectedType.isAssignableBy(actualType)) {\n                    if (actualType.isArray() && expectedType.isAssignableBy(actualType.asArrayType().getComponentType())) {\n                        argumentsTypes.set(pos, actualType.asArrayType().getComponentType());\n                    } else {\n                        argumentsTypes = groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n                    }\n                }\n            }\n        } else {\n            if (pos > argumentsTypes.size()) {\n                return false;\n            }\n            argumentsTypes = groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n        }\n    }\n    if (method.getNumberOfParams() != argumentsTypes.size()) {\n        return false;\n    }\n    Map<String, ResolvedType> matchedParameters = new HashMap<>();\n    boolean needForWildCardTolerance = false;\n    for (int i = 0; i < method.getNumberOfParams(); i++) {\n        ResolvedType expectedType = method.getParam(i).getType();\n        ResolvedType actualType = argumentsTypes.get(i);\n        if ((expectedType.isTypeVariable() && !(expectedType.isWildcard())) && expectedType.asTypeParameter().declaredOnMethod()) {\n            matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n            continue;\n        }\n        boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(actualType) || (method.getParam(i).isVariadic() && new ResolvedArrayType(expectedType).isAssignableBy(actualType));\n        if (!isAssignableWithoutSubstitution && expectedType.isReferenceType() && actualType.isReferenceType()) {\n            isAssignableWithoutSubstitution = isAssignableMatchTypeParameters(expectedType.asReferenceType(), actualType.asReferenceType(), matchedParameters);\n        }\n        if (!isAssignableWithoutSubstitution) {\n            List<ResolvedTypeParameterDeclaration> typeParameters = method.getTypeParameters();\n            typeParameters.addAll(method.declaringType().getTypeParameters());\n            for (ResolvedTypeParameterDeclaration tp : typeParameters) {\n                expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(actualType)) {\n                if (actualType.isWildcard() && withWildcardTolerance && !expectedType.isPrimitive()) {\n                    needForWildCardTolerance = true;\n                    continue;\n                }\n                if (method.hasVariadicParameter() && i == method.getNumberOfParams() - 1) {\n                    if (new ResolvedArrayType(expectedType).isAssignableBy(actualType)) {\n                        continue;\n                    }\n                }\n                return false;\n            }\n        }\n    }\n    return !withWildcardTolerance || needForWildCardTolerance;\n}"
    },
    {
      "commit": "c990d23490f5c4ac4322119b03d5951b63eef055",
      "startLine": 41,
      "endLine": 44,
      "methodCode": "private static boolean isApplicable(MethodDeclaration method, String name, List<Type> argumentsTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.hasVariadicParameter()) {\n        int pos = method.getNumberOfParams() - 1;\n        if (method.getNumberOfParams() == argumentsTypes.size()) {\n            Type expectedType = method.getLastParam().getType();\n            Type actualType = argumentsTypes.get(pos);\n            if (!expectedType.isAssignableBy(actualType)) {\n                for (TypeParameterDeclaration tp : method.getTypeParameters()) {\n                    expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                }\n                if (!expectedType.isAssignableBy(actualType)) {\n                    if (actualType.isArray() && expectedType.isAssignableBy(actualType.asArrayType().getComponentType())) {\n                        argumentsTypes.set(pos, actualType.asArrayType().getComponentType());\n                    } else {\n                        argumentsTypes = groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n                    }\n                }\n            }\n        } else {\n            if (pos > argumentsTypes.size()) {\n                return false;\n            }\n            argumentsTypes = groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n        }\n    }\n    if (method.getNumberOfParams() != argumentsTypes.size()) {\n        return false;\n    }\n    Map<String, Type> matchedParameters = new HashMap<>();\n    boolean needForWildCardTolerance = false;\n    for (int i = 0; i < method.getNumberOfParams(); i++) {\n        Type expectedType = method.getParam(i).getType();\n        Type actualType = argumentsTypes.get(i);\n        if ((expectedType.isTypeVariable() && !(expectedType.isWildcard())) && expectedType.asTypeParameter().declaredOnMethod()) {\n            matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n            continue;\n        }\n        boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(actualType) || (method.getParam(i).isVariadic() && new ArrayType(expectedType).isAssignableBy(actualType));\n        if (!isAssignableWithoutSubstitution && expectedType.isReferenceType() && actualType.isReferenceType()) {\n            isAssignableWithoutSubstitution = isAssignableMatchTypeParameters(expectedType.asReferenceType(), actualType.asReferenceType(), matchedParameters);\n        }\n        if (!isAssignableWithoutSubstitution) {\n            List<TypeParameterDeclaration> typeParameters = method.getTypeParameters();\n            typeParameters.addAll(method.declaringType().getTypeParameters());\n            for (TypeParameterDeclaration tp : typeParameters) {\n                expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(actualType)) {\n                if (actualType.isWildcard() && withWildcardTolerance && !expectedType.isPrimitive()) {\n                    needForWildCardTolerance = true;\n                    continue;\n                }\n                if (method.hasVariadicParameter() && i == method.getNumberOfParams() - 1) {\n                    if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n                        continue;\n                    }\n                }\n                return false;\n            }\n        }\n    }\n    return !withWildcardTolerance || needForWildCardTolerance;\n}"
    },
    {
      "commit": "b32947e8c85bc21fe533173f50d4a0a91036fdaf",
      "startLine": 38,
      "endLine": 41,
      "methodCode": "private static boolean isApplicable(MethodDeclaration method, String name, List<Type> argumentsTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.hasVariadicParameter()) {\n        int pos = method.getNumberOfParams() - 1;\n        if (method.getNumberOfParams() == argumentsTypes.size()) {\n            Type expectedType = method.getLastParam().getType();\n            Type actualType = argumentsTypes.get(pos);\n            if (!expectedType.isAssignableBy(actualType)) {\n                for (TypeParameterDeclaration tp : method.getTypeParameters()) {\n                    expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                }\n                if (!expectedType.isAssignableBy(actualType)) {\n                    if (actualType.isArray() && expectedType.isAssignableBy(actualType.asArrayType().getComponentType())) {\n                        argumentsTypes.set(pos, actualType.asArrayType().getComponentType());\n                    } else {\n                        argumentsTypes = groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n                    }\n                }\n            }\n        } else {\n            argumentsTypes = groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n        }\n    }\n    if (method.getNumberOfParams() != argumentsTypes.size()) {\n        return false;\n    }\n    Map<String, Type> matchedParameters = new HashMap<>();\n    boolean needForWildCardTolerance = false;\n    for (int i = 0; i < method.getNumberOfParams(); i++) {\n        Type expectedType = method.getParam(i).getType();\n        Type actualType = argumentsTypes.get(i);\n        if ((expectedType.isTypeVariable() && !(expectedType.isWildcard())) && expectedType.asTypeParameter().declaredOnMethod()) {\n            matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n            continue;\n        }\n        boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(actualType) || (method.getParam(i).isVariadic() && new ArrayType(expectedType).isAssignableBy(actualType));\n        if (!isAssignableWithoutSubstitution && expectedType.isReferenceType() && actualType.isReferenceType()) {\n            isAssignableWithoutSubstitution = isAssignableMatchTypeParameters(expectedType.asReferenceType(), actualType.asReferenceType(), matchedParameters);\n        }\n        if (!isAssignableWithoutSubstitution) {\n            List<TypeParameterDeclaration> typeParameters = method.getTypeParameters();\n            typeParameters.addAll(method.declaringType().getTypeParameters());\n            for (TypeParameterDeclaration tp : typeParameters) {\n                expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(actualType)) {\n                if (actualType.isWildcard() && withWildcardTolerance && !expectedType.isPrimitive()) {\n                    needForWildCardTolerance = true;\n                    continue;\n                }\n                if (method.hasVariadicParameter() && i == method.getNumberOfParams() - 1) {\n                    if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n                        continue;\n                    }\n                }\n                return false;\n            }\n        }\n    }\n    return !withWildcardTolerance || needForWildCardTolerance;\n}"
    },
    {
      "commit": "9c53c2cbc607ea694438ade8630be0c155a33162",
      "startLine": 38,
      "endLine": 41,
      "methodCode": "private static boolean isApplicable(MethodDeclaration method, String name, List<Type> argumentsTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.hasVariadicParameter()) {\n        int pos = method.getNoParams() - 1;\n        if (method.getNoParams() == argumentsTypes.size()) {\n            Type expectedType = method.getLastParam().getType();\n            Type actualType = argumentsTypes.get(pos);\n            if (!expectedType.isAssignableBy(actualType)) {\n                for (TypeParameterDeclaration tp : method.getTypeParameters()) {\n                    expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                }\n                if (!expectedType.isAssignableBy(actualType)) {\n                    if (actualType.isArray() && expectedType.isAssignableBy(actualType.asArrayType().getComponentType())) {\n                        argumentsTypes.set(pos, actualType.asArrayType().getComponentType());\n                    } else {\n                        argumentsTypes = groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n                    }\n                }\n            }\n        } else {\n            argumentsTypes = groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n        }\n    }\n    if (method.getNoParams() != argumentsTypes.size()) {\n        return false;\n    }\n    Map<String, Type> matchedParameters = new HashMap<>();\n    boolean needForWildCardTolerance = false;\n    for (int i = 0; i < method.getNoParams(); i++) {\n        Type expectedType = method.getParam(i).getType();\n        Type actualType = argumentsTypes.get(i);\n        if ((expectedType.isTypeVariable() && !(expectedType.isWildcard())) && expectedType.asTypeParameter().declaredOnMethod()) {\n            matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n            continue;\n        }\n        boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(actualType) || (method.getParam(i).isVariadic() && new ArrayType(expectedType).isAssignableBy(actualType));\n        if (!isAssignableWithoutSubstitution && expectedType.isReferenceType() && actualType.isReferenceType()) {\n            isAssignableWithoutSubstitution = isAssignableMatchTypeParameters(expectedType.asReferenceType(), actualType.asReferenceType(), matchedParameters);\n        }\n        if (!isAssignableWithoutSubstitution) {\n            List<TypeParameterDeclaration> typeParameters = method.getTypeParameters();\n            typeParameters.addAll(method.declaringType().getTypeParameters());\n            for (TypeParameterDeclaration tp : typeParameters) {\n                expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(actualType)) {\n                if (actualType.isWildcard() && withWildcardTolerance && !expectedType.isPrimitive()) {\n                    needForWildCardTolerance = true;\n                    continue;\n                }\n                if (method.hasVariadicParameter() && i == method.getNoParams() - 1) {\n                    if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n                        continue;\n                    }\n                }\n                return false;\n            }\n        }\n    }\n    return !withWildcardTolerance || needForWildCardTolerance;\n}"
    },
    {
      "commit": "88db8b2a8b93bcc692cb8fd5085ba68b8bcf1968",
      "startLine": 38,
      "endLine": 41,
      "methodCode": "private static boolean isApplicable(MethodDeclaration method, String name, List<Type> argumentsTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.hasVariadicParameter()) {\n        int pos = method.getNoParams() - 1;\n        if (method.getNoParams() == argumentsTypes.size()) {\n            Type expectedType = method.getLastParam().getType();\n            Type actualType = argumentsTypes.get(pos);\n            if (!expectedType.isAssignableBy(actualType)) {\n                for (TypeParameterDeclaration tp : method.getTypeParameters()) {\n                    expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                }\n                if (!expectedType.isAssignableBy(actualType)) {\n                    if (actualType.isArray() && expectedType.isAssignableBy(actualType.asArrayType().getComponentType())) {\n                        argumentsTypes.set(pos, actualType.asArrayType().getComponentType());\n                    } else {\n                        argumentsTypes = groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n                    }\n                }\n            }\n        } else {\n            argumentsTypes = groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n        }\n    }\n    if (method.getNoParams() != argumentsTypes.size()) {\n        return false;\n    }\n    Map<String, Type> matchedParameters = new HashMap<>();\n    boolean needForWildCardTolerance = false;\n    for (int i = 0; i < method.getNoParams(); i++) {\n        Type expectedType = method.getParam(i).getType();\n        Type actualType = argumentsTypes.get(i);\n        if ((expectedType.isTypeVariable() && !(expectedType.isWildcard())) && expectedType.asTypeParameter().declaredOnMethod()) {\n            matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n            continue;\n        }\n        boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(actualType) || (method.getParam(i).isVariadic() && new ArrayType(expectedType).isAssignableBy(actualType));\n        if (!isAssignableWithoutSubstitution && expectedType.isReferenceType() && actualType.isReferenceType()) {\n            isAssignableWithoutSubstitution = isAssignableMatchTypeParameters(expectedType.asReferenceType(), actualType.asReferenceType(), matchedParameters);\n        }\n        if (!isAssignableWithoutSubstitution) {\n            List<TypeParameterDeclaration> typeParameters = method.getTypeParameters();\n            typeParameters.addAll(method.declaringType().getTypeParameters());\n            for (TypeParameterDeclaration tp : typeParameters) {\n                expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(actualType)) {\n                if (actualType.isWildcard() && withWildcardTolerance && !expectedType.isPrimitive()) {\n                    needForWildCardTolerance = true;\n                    continue;\n                }\n                if (method.hasVariadicParameter() && i == method.getNoParams() - 1) {\n                    if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n                        continue;\n                    }\n                }\n                return false;\n            }\n        }\n    }\n    return !withWildcardTolerance || needForWildCardTolerance;\n}"
    },
    {
      "commit": "69e724f5a168e148ea4479c872cfbf656fce8acc",
      "startLine": 38,
      "endLine": 41,
      "methodCode": "private static boolean isApplicable(MethodDeclaration method, String name, List<Type> paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.hasVariadicParameter()) {\n        int pos = method.getNoParams() - 1;\n        if (method.getNoParams() == paramTypes.size()) {\n            Type expectedType = method.getLastParam().getType();\n            Type actualType = paramTypes.get(pos);\n            if (!expectedType.isAssignableBy(actualType)) {\n                for (TypeParameterDeclaration tp : method.getTypeParameters()) {\n                    expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                }\n                if (!expectedType.isAssignableBy(actualType)) {\n                    if (actualType.isArray() && expectedType.isAssignableBy(actualType.asArrayType().getComponentType())) {\n                        paramTypes.set(pos, actualType.asArrayType().getComponentType());\n                    } else {\n                        paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                    }\n                }\n            }\n        } else {\n            paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n        }\n    }\n    if (method.getNoParams() != paramTypes.size()) {\n        return false;\n    }\n    Map<String, Type> matchedParameters = new HashMap<>();\n    boolean needForWildCardTolerance = false;\n    for (int i = 0; i < method.getNoParams(); i++) {\n        Type expectedType = method.getParam(i).getType();\n        Type actualType = paramTypes.get(i);\n        if ((expectedType.isTypeVariable() && !(expectedType.isWildcard())) && expectedType.asTypeParameter().declaredOnMethod()) {\n            matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n            continue;\n        }\n        boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(actualType) || (method.getParam(i).isVariadic() && new ArrayType(expectedType).isAssignableBy(actualType));\n        if (!isAssignableWithoutSubstitution && expectedType.isReferenceType() && actualType.isReferenceType()) {\n            isAssignableWithoutSubstitution = isAssignableMatchTypeParameters(expectedType.asReferenceType(), actualType.asReferenceType(), matchedParameters);\n        }\n        if (!isAssignableWithoutSubstitution) {\n            List<TypeParameterDeclaration> typeParameters = method.getTypeParameters();\n            typeParameters.addAll(method.declaringType().getTypeParameters());\n            for (TypeParameterDeclaration tp : typeParameters) {\n                expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(actualType)) {\n                if (actualType.isWildcard() && withWildcardTolerance && !expectedType.isPrimitive()) {\n                    needForWildCardTolerance = true;\n                    continue;\n                }\n                if (method.hasVariadicParameter() && i == method.getNoParams() - 1) {\n                    if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n                        continue;\n                    }\n                }\n                return false;\n            }\n        }\n    }\n    return !withWildcardTolerance || needForWildCardTolerance;\n}"
    },
    {
      "commit": "051dbd94c17c4f142d3fe9e8fbd03c29d09ace54",
      "startLine": 38,
      "endLine": 41,
      "methodCode": "private static boolean isApplicable(MethodDeclaration method, String name, List<Type> paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.hasVariadicParameter()) {\n        int pos = method.getNoParams() - 1;\n        if (method.getNoParams() == paramTypes.size()) {\n            Type expectedType = method.getLastParam().getType();\n            Type actualType = paramTypes.get(pos);\n            if (!expectedType.isAssignableBy(actualType)) {\n                for (TypeParameterDeclaration tp : method.getTypeParameters()) {\n                    expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                }\n                if (!expectedType.isAssignableBy(actualType)) {\n                    if (actualType.isArray() && expectedType.isAssignableBy(actualType.asArrayType().getComponentType())) {\n                        paramTypes.set(pos, actualType.asArrayType().getComponentType());\n                    } else {\n                        paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                    }\n                }\n            }\n        } else {\n            paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n        }\n    }\n    if (method.getNoParams() != paramTypes.size()) {\n        return false;\n    }\n    Map<String, Type> matchedParameters = new HashMap<>();\n    boolean needForWildCardTolerance = false;\n    for (int i = 0; i < method.getNoParams(); i++) {\n        Type expectedType = method.getParam(i).getType();\n        Type actualType = paramTypes.get(i);\n        if (expectedType.isTypeVariable() && expectedType.asTypeParameter().declaredOnMethod()) {\n            matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n            continue;\n        }\n        boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(actualType) || (method.getParam(i).isVariadic() && new ArrayType(expectedType).isAssignableBy(actualType));\n        if (!isAssignableWithoutSubstitution && expectedType.isReferenceType() && actualType.isReferenceType()) {\n            isAssignableWithoutSubstitution = isAssignableMatchTypeParameters(expectedType.asReferenceType(), actualType.asReferenceType(), matchedParameters);\n        }\n        if (!isAssignableWithoutSubstitution) {\n            List<TypeParameterDeclaration> typeParameters = method.getTypeParameters();\n            typeParameters.addAll(method.declaringType().getTypeParameters());\n            for (TypeParameterDeclaration tp : typeParameters) {\n                expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(actualType)) {\n                if (actualType.isWildcard() && withWildcardTolerance && !expectedType.isPrimitive()) {\n                    needForWildCardTolerance = true;\n                    continue;\n                }\n                if (method.hasVariadicParameter() && i == method.getNoParams() - 1) {\n                    if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n                        continue;\n                    }\n                }\n                return false;\n            }\n        }\n    }\n    return !withWildcardTolerance || needForWildCardTolerance;\n}"
    },
    {
      "commit": "ecc78c8b480ceb41019f764c983aaa69c2dabfe3",
      "startLine": 38,
      "endLine": 41,
      "methodCode": "private static boolean isApplicable(MethodDeclaration method, String name, List<Type> paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.hasVariadicParameter()) {\n        int pos = method.getNoParams() - 1;\n        if (method.getNoParams() == paramTypes.size()) {\n            Type expectedType = method.getLastParam().getType();\n            Type actualType = paramTypes.get(pos);\n            if (!expectedType.isAssignableBy(actualType)) {\n                for (TypeParameterDeclaration tp : method.getTypeParameters()) {\n                    expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                }\n                if (!expectedType.isAssignableBy(actualType)) {\n                    if (actualType.isArray() && expectedType.isAssignableBy(actualType.asArrayTypeUsage().getComponentType())) {\n                        paramTypes.set(pos, actualType.asArrayTypeUsage().getComponentType());\n                    } else {\n                        paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                    }\n                }\n            }\n        } else {\n            paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n        }\n    }\n    if (method.getNoParams() != paramTypes.size()) {\n        return false;\n    }\n    Map<String, Type> matchedParameters = new HashMap<>();\n    boolean needForWildCardTolerance = false;\n    for (int i = 0; i < method.getNoParams(); i++) {\n        Type expectedType = method.getParam(i).getType();\n        Type actualType = paramTypes.get(i);\n        if (expectedType.isTypeVariable() && expectedType.asTypeParameter().declaredOnMethod()) {\n            matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n            continue;\n        }\n        boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(actualType) || (method.getParam(i).isVariadic() && new ArrayType(expectedType).isAssignableBy(actualType));\n        if (!isAssignableWithoutSubstitution && expectedType.isReferenceType() && actualType.isReferenceType()) {\n            isAssignableWithoutSubstitution = isAssignableMatchTypeParameters(expectedType.asReferenceTypeUsage(), actualType.asReferenceTypeUsage(), matchedParameters);\n        }\n        if (!isAssignableWithoutSubstitution) {\n            List<TypeParameterDeclaration> typeParameters = method.getTypeParameters();\n            typeParameters.addAll(method.declaringType().getTypeParameters());\n            for (TypeParameterDeclaration tp : typeParameters) {\n                expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(actualType)) {\n                if (actualType.isWildcard() && withWildcardTolerance && !expectedType.isPrimitive()) {\n                    needForWildCardTolerance = true;\n                    continue;\n                }\n                if (method.hasVariadicParameter() && i == method.getNoParams() - 1) {\n                    if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n                        continue;\n                    }\n                }\n                return false;\n            }\n        }\n    }\n    return !withWildcardTolerance || needForWildCardTolerance;\n}"
    },
    {
      "commit": "82eb44707b620803d424188a1eb8708fcaf093cb",
      "startLine": 38,
      "endLine": 41,
      "methodCode": "private static boolean isApplicable(MethodDeclaration method, String name, List<Type> paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.hasVariadicParameter()) {\n        int pos = method.getNoParams() - 1;\n        if (method.getNoParams() == paramTypes.size()) {\n            Type expectedType = method.getLastParam().getType();\n            Type actualType = paramTypes.get(pos);\n            if (!expectedType.isAssignableBy(actualType)) {\n                for (TypeParameter tp : method.getTypeParameters()) {\n                    expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                }\n                if (!expectedType.isAssignableBy(actualType)) {\n                    if (actualType.isArray() && expectedType.isAssignableBy(actualType.asArrayTypeUsage().getComponentType())) {\n                        paramTypes.set(pos, actualType.asArrayTypeUsage().getComponentType());\n                    } else {\n                        paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                    }\n                }\n            }\n        } else {\n            paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n        }\n    }\n    if (method.getNoParams() != paramTypes.size()) {\n        return false;\n    }\n    Map<String, Type> matchedParameters = new HashMap<>();\n    boolean needForWildCardTolerance = false;\n    for (int i = 0; i < method.getNoParams(); i++) {\n        Type expectedType = method.getParam(i).getType();\n        Type actualType = paramTypes.get(i);\n        if (expectedType.isTypeVariable() && expectedType.asTypeParameter().declaredOnMethod()) {\n            matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n            continue;\n        }\n        boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(actualType) || (method.getParam(i).isVariadic() && new ArrayType(expectedType).isAssignableBy(actualType));\n        if (!isAssignableWithoutSubstitution && expectedType.isReferenceType() && actualType.isReferenceType()) {\n            isAssignableWithoutSubstitution = isAssignableMatchTypeParameters(expectedType.asReferenceTypeUsage(), actualType.asReferenceTypeUsage(), matchedParameters);\n        }\n        if (!isAssignableWithoutSubstitution) {\n            List<TypeParameter> typeParameters = method.getTypeParameters();\n            typeParameters.addAll(method.declaringType().getTypeParameters());\n            for (TypeParameter tp : typeParameters) {\n                expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(actualType)) {\n                if (actualType.isWildcard() && withWildcardTolerance && !expectedType.isPrimitive()) {\n                    needForWildCardTolerance = true;\n                    continue;\n                }\n                if (method.hasVariadicParameter() && i == method.getNoParams() - 1) {\n                    if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n                        continue;\n                    }\n                }\n                return false;\n            }\n        }\n    }\n    return !withWildcardTolerance || needForWildCardTolerance;\n}"
    },
    {
      "commit": "6e654694b8d141fd5503b46f9e77b8763cfa9a81",
      "startLine": 38,
      "endLine": 41,
      "methodCode": "private static boolean isApplicable(MethodDeclaration method, String name, List<TypeUsage> paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.hasVariadicParameter()) {\n        int pos = method.getNoParams() - 1;\n        if (method.getNoParams() == paramTypes.size()) {\n            TypeUsage expectedType = method.getLastParam().getType();\n            TypeUsage actualType = paramTypes.get(pos);\n            if (!expectedType.isAssignableBy(actualType)) {\n                for (TypeParameter tp : method.getTypeParameters()) {\n                    expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                }\n                if (!expectedType.isAssignableBy(actualType)) {\n                    if (actualType.isArray() && expectedType.isAssignableBy(actualType.asArrayTypeUsage().getComponentType())) {\n                        paramTypes.set(pos, actualType.asArrayTypeUsage().getComponentType());\n                    } else {\n                        paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                    }\n                }\n            }\n        } else {\n            paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n        }\n    }\n    if (method.getNoParams() != paramTypes.size()) {\n        return false;\n    }\n    Map<String, TypeUsage> matchedParameters = new HashMap<>();\n    boolean needForWildCardTolerance = false;\n    for (int i = 0; i < method.getNoParams(); i++) {\n        TypeUsage expectedType = method.getParam(i).getType();\n        TypeUsage actualType = paramTypes.get(i);\n        if (expectedType.isTypeVariable() && expectedType.asTypeParameter().declaredOnMethod()) {\n            matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n            continue;\n        }\n        boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(actualType) || (method.getParam(i).isVariadic() && new ArrayTypeUsage(expectedType).isAssignableBy(actualType));\n        if (!isAssignableWithoutSubstitution && expectedType.isReferenceType() && actualType.isReferenceType()) {\n            isAssignableWithoutSubstitution = isAssignableMatchTypeParameters(expectedType.asReferenceTypeUsage(), actualType.asReferenceTypeUsage(), matchedParameters);\n        }\n        if (!isAssignableWithoutSubstitution) {\n            List<TypeParameter> typeParameters = method.getTypeParameters();\n            typeParameters.addAll(method.declaringType().getTypeParameters());\n            for (TypeParameter tp : typeParameters) {\n                expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(actualType)) {\n                if (actualType.isWildcard() && withWildcardTolerance && !expectedType.isPrimitive()) {\n                    needForWildCardTolerance = true;\n                    continue;\n                }\n                if (method.hasVariadicParameter() && i == method.getNoParams() - 1) {\n                    if (new ArrayTypeUsage(expectedType).isAssignableBy(actualType)) {\n                        continue;\n                    }\n                }\n                return false;\n            }\n        }\n    }\n    return !withWildcardTolerance || needForWildCardTolerance;\n}"
    },
    {
      "commit": "b20f28d6034a54108c056947c631c360fa079138",
      "startLine": 34,
      "endLine": 37,
      "methodCode": "private static boolean isApplicable(MethodDeclaration method, String name, List<TypeUsage> paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.hasVariadicParameter()) {\n        int pos = method.getNoParams() - 1;\n        if (method.getNoParams() == paramTypes.size()) {\n            TypeUsage expectedType = method.getLastParam().getType();\n            TypeUsage actualType = paramTypes.get(pos);\n            if (!expectedType.isAssignableBy(actualType)) {\n                for (TypeParameter tp : method.getTypeParameters()) {\n                    expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                }\n                if (!expectedType.isAssignableBy(actualType)) {\n                    if (actualType.isArray() && expectedType.isAssignableBy(actualType.asArrayTypeUsage().getComponentType())) {\n                        paramTypes.set(pos, actualType.asArrayTypeUsage().getComponentType());\n                    } else {\n                        paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                    }\n                }\n            }\n        } else {\n            paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n        }\n    }\n    if (method.getNoParams() != paramTypes.size()) {\n        return false;\n    }\n    Map<String, TypeUsage> matchedParameters = new HashMap<>();\n    boolean needForWildCardTolerance = false;\n    for (int i = 0; i < method.getNoParams(); i++) {\n        TypeUsage expectedType = method.getParam(i).getType();\n        TypeUsage actualType = paramTypes.get(i);\n        boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(actualType) || (method.getParam(i).isVariadic() && new ArrayTypeUsage(expectedType).isAssignableBy(actualType));\n        if (!isAssignableWithoutSubstitution && expectedType.isReferenceType() && actualType.isReferenceType()) {\n            isAssignableWithoutSubstitution = isAssignableMatchTypeParameters(expectedType.asReferenceTypeUsage(), actualType.asReferenceTypeUsage(), matchedParameters);\n        }\n        if (!isAssignableWithoutSubstitution) {\n            List<TypeParameter> typeParameters = method.getTypeParameters();\n            typeParameters.addAll(method.declaringType().getTypeParameters());\n            for (TypeParameter tp : typeParameters) {\n                expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(actualType)) {\n                if (actualType.isWildcard() && withWildcardTolerance && !expectedType.isPrimitive()) {\n                    needForWildCardTolerance = true;\n                    continue;\n                }\n                if (method.hasVariadicParameter() && i == method.getNoParams() - 1) {\n                    if (new ArrayTypeUsage(expectedType).isAssignableBy(actualType)) {\n                        continue;\n                    }\n                }\n                return false;\n            }\n        }\n    }\n    return !withWildcardTolerance || needForWildCardTolerance;\n}"
    },
    {
      "commit": "c48864ccaea00039c2f6a8390d21cffd3fbde054",
      "startLine": 30,
      "endLine": 33,
      "methodCode": "private static boolean isApplicable(MethodDeclaration method, String name, List<TypeUsage> paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.hasVariadicParameter()) {\n        int pos = method.getNoParams() - 1;\n        if (method.getNoParams() == paramTypes.size()) {\n            TypeUsage expectedType = method.getLastParam().getType();\n            TypeUsage actualType = paramTypes.get(pos);\n            if (!expectedType.isAssignableBy(actualType)) {\n                for (TypeParameter tp : method.getTypeParameters()) {\n                    expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                }\n                if (!expectedType.isAssignableBy(actualType)) {\n                    paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                }\n            }\n        } else {\n            paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n        }\n    }\n    if (method.getNoParams() != paramTypes.size()) {\n        return false;\n    }\n    Map<String, TypeUsage> matchedParameters = new HashMap<>();\n    boolean needForWildCardTolerance = false;\n    for (int i = 0; i < method.getNoParams(); i++) {\n        TypeUsage expectedType = method.getParam(i).getType();\n        TypeUsage actualType = paramTypes.get(i);\n        boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(actualType) || (method.getParam(i).isVariadic() && new ArrayTypeUsage(expectedType).isAssignableBy(actualType));\n        if (!isAssignableWithoutSubstitution && expectedType.isReferenceType() && actualType.isReferenceType()) {\n            isAssignableWithoutSubstitution = isAssignableMatchTypeParameters(expectedType.asReferenceTypeUsage(), actualType.asReferenceTypeUsage(), matchedParameters);\n        }\n        if (!isAssignableWithoutSubstitution) {\n            List<TypeParameter> typeParameters = method.getTypeParameters();\n            typeParameters.addAll(method.declaringType().getTypeParameters());\n            for (TypeParameter tp : typeParameters) {\n                expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(actualType)) {\n                if (actualType.isWildcard() && withWildcardTolerance && !expectedType.isPrimitive()) {\n                    needForWildCardTolerance = true;\n                    continue;\n                }\n                return false;\n            }\n        }\n    }\n    return !withWildcardTolerance || needForWildCardTolerance;\n}"
    },
    {
      "commit": "e3e4b88ee821fdcec76aa3c940cb4b4f466bc2cd",
      "startLine": 29,
      "endLine": 32,
      "methodCode": "public static boolean isApplicable(MethodDeclaration method, String name, List<TypeUsage> paramTypes, TypeSolver typeSolver) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.hasVariadicParameter()) {\n        int pos = method.getNoParams() - 1;\n        if (method.getNoParams() == paramTypes.size()) {\n            TypeUsage expectedType = method.getLastParam().getType();\n            TypeUsage actualType = paramTypes.get(pos);\n            if (!expectedType.isAssignableBy(actualType)) {\n                for (TypeParameter tp : method.getTypeParameters()) {\n                    expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                }\n                if (!expectedType.isAssignableBy(actualType)) {\n                    paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                }\n            }\n        } else {\n            paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n        }\n    }\n    if (method.getNoParams() != paramTypes.size()) {\n        return false;\n    }\n    Map<String, TypeUsage> matchedParameters = new HashMap<>();\n    for (int i = 0; i < method.getNoParams(); i++) {\n        TypeUsage expectedType = method.getParam(i).getType();\n        TypeUsage actualType = paramTypes.get(i);\n        boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(actualType) || (method.getParam(i).isVariadic() && new ArrayTypeUsage(expectedType).isAssignableBy(actualType));\n        if (!isAssignableWithoutSubstitution && expectedType.isReferenceType() && actualType.isReferenceType()) {\n            isAssignableWithoutSubstitution = isAssignableMatchTypeParameters(expectedType.asReferenceTypeUsage(), actualType.asReferenceTypeUsage(), matchedParameters);\n        }\n        if (!isAssignableWithoutSubstitution) {\n            List<TypeParameter> typeParameters = method.getTypeParameters();\n            typeParameters.addAll(method.declaringType().getTypeParameters());\n            for (TypeParameter tp : typeParameters) {\n                expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(actualType)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
    },
    {
      "commit": "84afc7be2fabd511eccc69e29fca9c4238c9469e",
      "startLine": 29,
      "endLine": 32,
      "methodCode": "public static boolean isApplicable(MethodDeclaration method, String name, List<TypeUsage> paramTypes, TypeSolver typeSolver) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.hasVariadicParameter()) {\n        int pos = method.getNoParams() - 1;\n        if (method.getNoParams() == paramTypes.size()) {\n            TypeUsage expectedType = method.getLastParam().getType();\n            TypeUsage actualType = paramTypes.get(pos);\n            if (!expectedType.isAssignableBy(actualType)) {\n                for (TypeParameter tp : method.getTypeParameters()) {\n                    expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                }\n                if (!expectedType.isAssignableBy(actualType)) {\n                    paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                }\n            }\n        } else {\n            paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n        }\n    }\n    if (method.getNoParams() != paramTypes.size()) {\n        return false;\n    }\n    Map<String, TypeUsage> matchedParameters = new HashMap<>();\n    for (int i = 0; i < method.getNoParams(); i++) {\n        TypeUsage expectedType = method.getParam(i).getType();\n        TypeUsage actualType = paramTypes.get(i);\n        boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(actualType);\n        if (!isAssignableWithoutSubstitution && expectedType.isReferenceType() && actualType.isReferenceType()) {\n            isAssignableWithoutSubstitution = isAssignableMatchTypeParameters(expectedType.asReferenceTypeUsage(), actualType.asReferenceTypeUsage(), matchedParameters);\n        }\n        if (!isAssignableWithoutSubstitution) {\n            List<TypeParameter> typeParameters = method.getTypeParameters();\n            typeParameters.addAll(method.declaringType().getTypeParameters());\n            for (TypeParameter tp : typeParameters) {\n                expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(actualType)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
    },
    {
      "commit": "e2cc24a4f5a54a058c1d9ba971b7c8aa0a445601",
      "startLine": 30,
      "endLine": 33,
      "methodCode": "public static boolean isApplicable(MethodDeclaration method, String name, List<TypeUsage> paramTypes, TypeSolver typeSolver) {\n    List<TypeUsage> originalParamTypes = paramTypes;\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.hasVariadicParameter()) {\n        int pos = method.getNoParams() - 1;\n        if (method.getNoParams() == paramTypes.size()) {\n            TypeUsage expectedType = method.getLastParam().getType();\n            TypeUsage actualType = paramTypes.get(pos);\n            if (!expectedType.isAssignableBy(actualType)) {\n                for (TypeParameter tp : method.getTypeParameters()) {\n                    expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                }\n                if (!expectedType.isAssignableBy(actualType)) {\n                    paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                }\n            }\n        } else {\n            paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n        }\n    }\n    if (method.getNoParams() != paramTypes.size()) {\n        return false;\n    }\n    Map<String, TypeUsage> matchedParameters = new HashMap<>();\n    for (int i = 0; i < method.getNoParams(); i++) {\n        TypeUsage expectedType = method.getParam(i).getType();\n        TypeUsage actualType = paramTypes.get(i);\n        boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(actualType);\n        if (!isAssignableWithoutSubstitution && expectedType.isReferenceType() && actualType.isReferenceType()) {\n            isAssignableWithoutSubstitution = isAssignableMatchTypeParameters(expectedType.asReferenceTypeUsage(), actualType.asReferenceTypeUsage(), matchedParameters);\n        }\n        if (!isAssignableWithoutSubstitution) {\n            List<TypeParameter> typeParameters = method.getTypeParameters();\n            typeParameters.addAll(method.declaringType().getTypeParameters());\n            for (TypeParameter tp : typeParameters) {\n                expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(actualType)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
    },
    {
      "commit": "8907128c87954825abed135e781f272f67648f95",
      "startLine": 30,
      "endLine": 33,
      "methodCode": "public static boolean isApplicable(MethodDeclaration method, String name, List<TypeUsage> paramTypes, TypeSolver typeSolver) {\n    List<TypeUsage> originalParamTypes = paramTypes;\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.hasVariadicParameter()) {\n        int pos = method.getNoParams() - 1;\n        if (method.getNoParams() == paramTypes.size()) {\n            TypeUsage expectedType = method.getLastParam().getType();\n            TypeUsage actualType = paramTypes.get(pos);\n            if (!expectedType.isAssignableBy(actualType)) {\n                for (TypeParameter tp : method.getTypeParameters()) {\n                    expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                }\n                if (!expectedType.isAssignableBy(actualType)) {\n                    paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                }\n            }\n        } else {\n            paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n        }\n    }\n    if (method.getNoParams() != paramTypes.size()) {\n        return false;\n    }\n    Map<String, TypeUsage> matchedParameters = new HashMap<>();\n    for (int i = 0; i < method.getNoParams(); i++) {\n        TypeUsage expectedType = method.getParam(i).getType();\n        TypeUsage actualType = paramTypes.get(i);\n        boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(actualType);\n        if (!isAssignableWithoutSubstitution && expectedType.isReferenceType() && actualType.isReferenceType()) {\n            isAssignableWithoutSubstitution = isAssignableMatchTypeParameters(expectedType.asReferenceTypeUsage(), actualType.asReferenceTypeUsage(), matchedParameters);\n        }\n        if (!isAssignableWithoutSubstitution) {\n            for (TypeParameter tp : method.getTypeParameters()) {\n                expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(actualType)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
    },
    {
      "commit": "ead147279ca0b84d2f479a714943b20cd689e7c7",
      "startLine": 30,
      "endLine": 33,
      "methodCode": "public static boolean isApplicable(MethodDeclaration method, String name, List<TypeUsage> paramTypes, TypeSolver typeSolver) {\n    List<TypeUsage> originalParamTypes = paramTypes;\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.hasVariadicParameter()) {\n        int pos = method.getNoParams() - 1;\n        if (method.getNoParams() == paramTypes.size()) {\n            TypeUsage expectedType = method.getLastParam().getType();\n            TypeUsage actualType = paramTypes.get(pos);\n            if (!expectedType.isAssignableBy(actualType)) {\n                for (TypeParameter tp : method.getTypeParameters()) {\n                    expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                }\n                if (!expectedType.isAssignableBy(actualType)) {\n                    paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                }\n            }\n        } else {\n            paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n        }\n    }\n    if (method.getNoParams() != paramTypes.size()) {\n        return false;\n    }\n    Map<String, TypeUsage> matchedParameters = new HashMap<>();\n    for (int i = 0; i < method.getNoParams(); i++) {\n        TypeUsage expectedType = method.getParam(i).getType();\n        TypeUsage actualType = paramTypes.get(i);\n        boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(actualType);\n        if (!isAssignableWithoutSubstitution && expectedType.isReferenceType() && actualType.isReferenceType()) {\n            isAssignableWithoutSubstitution = isAssignableMatchTypeParameters(expectedType.asReferenceTypeUsage(), actualType.asReferenceTypeUsage(), matchedParameters);\n        }\n        if (!isAssignableWithoutSubstitution) {\n            for (TypeParameter tp : method.getTypeParameters()) {\n                expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(actualType)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
    },
    {
      "commit": "f4b07b1a2deac6d1b562424ac2380b92cec77a90",
      "startLine": 12,
      "endLine": 15,
      "methodCode": "public static boolean isApplicable(MethodDeclaration method, String name, List<TypeUsage> paramTypes, TypeSolver typeSolver) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.getNoParams() != paramTypes.size()) {\n        return false;\n    }\n    Map<String, TypeUsage> matchedParameters = new HashMap<>();\n    for (int i = 0; i < method.getNoParams(); i++) {\n        TypeUsage expectedType = method.getParam(i).getType();\n        TypeUsage actualType = paramTypes.get(i);\n        boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(actualType);\n        if (!isAssignableWithoutSubstitution && expectedType.isReferenceType() && actualType.isReferenceType()) {\n            isAssignableWithoutSubstitution = isAssignableMatchTypeParameters(expectedType.asReferenceTypeUsage(), actualType.asReferenceTypeUsage(), matchedParameters);\n        }\n        if (!isAssignableWithoutSubstitution) {\n            for (TypeParameter tp : method.getTypeParameters()) {\n                expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(actualType)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
    },
    {
      "commit": "9506a1844d5076b4edcc2b9a5bc375acf7e95c35",
      "startLine": 12,
      "endLine": 15,
      "methodCode": "public static boolean isApplicable(MethodDeclaration method, String name, List<TypeUsage> paramTypes, TypeSolver typeSolver) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.getNoParams() != paramTypes.size()) {\n        return false;\n    }\n    Map<String, TypeUsage> matchedParameters = new HashMap<>();\n    for (int i = 0; i < method.getNoParams(); i++) {\n        TypeUsage expectedType = method.getParam(i).getType();\n        TypeUsage actualType = paramTypes.get(i);\n        boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(actualType);\n        if (!isAssignableWithoutSubstitution && expectedType.isReferenceType() && actualType.isReferenceType()) {\n            isAssignableWithoutSubstitution = isAssignableMatchTypeParameters(expectedType.asReferenceTypeUsage(), actualType.asReferenceTypeUsage(), matchedParameters);\n        }\n        if (!isAssignableWithoutSubstitution) {\n            for (TypeParameter tp : method.getTypeParameters()) {\n                expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(actualType)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
    },
    {
      "commit": "39477e7f9375d6a539eb0ddc69eb69d986b2a8c8",
      "startLine": 12,
      "endLine": 15,
      "methodCode": "public static boolean isApplicable(MethodDeclaration method, String name, List<TypeUsage> paramTypes, TypeSolver typeSolver) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.getNoParams() != paramTypes.size()) {\n        return false;\n    }\n    Map<String, TypeUsage> matchedParameters = new HashMap<>();\n    for (int i = 0; i < method.getNoParams(); i++) {\n        TypeUsage expectedType = method.getParam(i).getType();\n        TypeUsage actualType = paramTypes.get(i);\n        boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(actualType);\n        if (!isAssignableWithoutSubstitution && expectedType.isReferenceType() && actualType.isReferenceType()) {\n            isAssignableWithoutSubstitution = isAssignableMatchTypeParameters(expectedType.asReferenceTypeUsage(), actualType.asReferenceTypeUsage(), matchedParameters);\n        }\n        if (!isAssignableWithoutSubstitution) {\n            for (TypeParameter tp : method.getTypeParameters()) {\n                expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(actualType)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
    },
    {
      "commit": "3337bf584f7ef47f4f56b81743ca0d83930763bf",
      "startLine": 12,
      "endLine": 15,
      "methodCode": "public static boolean isApplicable(MethodDeclaration method, String name, List<TypeUsage> paramTypes, TypeSolver typeSolver) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.getNoParams() != paramTypes.size()) {\n        return false;\n    }\n    Map<String, TypeUsage> matchedParameters = new HashMap<>();\n    for (int i = 0; i < method.getNoParams(); i++) {\n        TypeUsage expectedType = method.getParam(i).getType(typeSolver);\n        TypeUsage actualType = paramTypes.get(i);\n        boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(actualType);\n        if (!isAssignableWithoutSubstitution && expectedType.isReferenceType() && actualType.isReferenceType()) {\n            isAssignableWithoutSubstitution = isAssignableMatchTypeParameters(expectedType.asReferenceTypeUsage(), actualType.asReferenceTypeUsage(), matchedParameters);\n        }\n        if (!isAssignableWithoutSubstitution) {\n            for (TypeParameter tp : method.getTypeParameters()) {\n                expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(actualType)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
    },
    {
      "commit": "0b419e87200878fe13db395a415efc4d1338cef2",
      "startLine": 11,
      "endLine": 11,
      "methodCode": "public static boolean isApplicable(MethodDeclaration method, String name, List<TypeUsage> paramTypes, TypeSolver typeSolver) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.getNoParams() != paramTypes.size()) {\n        return false;\n    }\n    for (int i = 0; i < method.getNoParams(); i++) {\n        TypeUsage expectedType = method.getParam(i).getType(typeSolver);\n        TypeUsage actualType = paramTypes.get(i);\n        boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(actualType);\n        if (!isAssignableWithoutSubstitution) {\n            for (TypeParameter tp : method.getTypeParameters()) {\n                expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(actualType)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
    },
    {
      "commit": "adb02497ed443e836ae552e20bcb11ab8c1ab623",
      "startLine": 10,
      "endLine": 10,
      "methodCode": "public static boolean isApplicable(MethodDeclaration method, String name, List<TypeUsage> paramTypes, TypeSolver typeSolver) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.getNoParams() != paramTypes.size()) {\n        return false;\n    }\n    for (int i = 0; i < method.getNoParams(); i++) {\n        TypeUsage expectedType = method.getParam(i).getType(typeSolver);\n        boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(paramTypes.get(i));\n        if (!isAssignableWithoutSubstitution) {\n            for (TypeParameter tp : method.getTypeParameters()) {\n                expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(paramTypes.get(i))) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
    },
    {
      "commit": "b36f33050149a62a5b3c8c7451ae93f736715029",
      "startLine": 10,
      "endLine": 10,
      "methodCode": "public static boolean isApplicable(MethodDeclaration method, String name, List<TypeUsage> paramTypes, TypeSolver typeSolver) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.getNoParams() != paramTypes.size()) {\n        return false;\n    }\n    for (int i = 0; i < method.getNoParams(); i++) {\n        TypeUsage expectedType = method.getParam(i).getType(typeSolver);\n        boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(paramTypes.get(i), typeSolver);\n        if (!isAssignableWithoutSubstitution) {\n            for (TypeParameter tp : method.getTypeParameters()) {\n                expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(paramTypes.get(i), typeSolver)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
    },
    {
      "commit": "eec165d9e3ef0ab1d93f69a231964984a3379762",
      "startLine": 10,
      "endLine": 10,
      "methodCode": "public static boolean isApplicable(MethodDeclaration method, String name, List<TypeUsage> paramTypes, TypeSolver typeSolver) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.getNoParams() != paramTypes.size()) {\n        return false;\n    }\n    for (int i = 0; i < method.getNoParams(); i++) {\n        TypeUsage expectedType = method.getParam(i).getType(typeSolver);\n        boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(paramTypes.get(i), typeSolver);\n        if (!isAssignableWithoutSubstitution) {\n            for (TypeParameter tp : method.getTypeParameters()) {\n                expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n            }\n            if (!expectedType.isAssignableBy(paramTypes.get(i), typeSolver)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
    },
    {
      "commit": "558fc9b4f808d718b9b266071078752ba68d4203",
      "startLine": 10,
      "endLine": 10,
      "methodCode": "public static boolean isApplicable(MethodDeclaration method, String name, List<TypeUsage> paramTypes, TypeSolver typeSolver) {\n    if (!method.getName().equals(name)) {\n        return false;\n    }\n    if (method.getNoParams() != paramTypes.size()) {\n        return false;\n    }\n    for (int i = 0; i < method.getNoParams(); i++) {\n        TypeUsage expectedType = method.getParam(i).getType(typeSolver);\n        boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(paramTypes.get(i), typeSolver);\n        if (!isAssignableWithoutSubstitution) {\n            for (TypeParameter tp : method.getTypeParameters()) {\n                expectedType = replaceTypeParam(expectedType, tp);\n            }\n            if (!expectedType.isAssignableBy(paramTypes.get(i), typeSolver)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
    }
  ]
}