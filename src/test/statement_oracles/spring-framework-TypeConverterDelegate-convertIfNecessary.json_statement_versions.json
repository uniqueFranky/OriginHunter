{
  "statementVersions": [
    {
      "commit": "f813712f5b413b354560cd7cc006352e9defa9a3",
      "startLine": 95,
      "endLine": 107,
      "methodCode": "@SuppressWarnings(\"unchecked\")\n@Nullable\npublic <T> T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, @Nullable Object newValue, @Nullable Class<T> requiredType, @Nullable TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionFailedException conversionAttemptEx = null;\n    ConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n    if (editor == null && conversionService != null && newValue != null && typeDescriptor != null) {\n        TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n        if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n            try {\n                return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n            } catch (ConversionFailedException ex) {\n                conversionAttemptEx = ex;\n            }\n        }\n    }\n    Object convertedValue = newValue;\n    if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (typeDescriptor != null && requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {\n            TypeDescriptor elementTypeDesc = typeDescriptor.getElementTypeDescriptor();\n            if (elementTypeDesc != null) {\n                Class<?> elementType = elementTypeDesc.getType();\n                if (Class.class == elementType || Enum.class.isAssignableFrom(elementType)) {\n                    convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n            }\n        }\n        if (editor == null) {\n            editor = findDefaultEditor(requiredType);\n        }\n        convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    boolean standardConversion = false;\n    if (requiredType != null) {\n        if (convertedValue != null) {\n            if (Object.class == requiredType) {\n                return (T) convertedValue;\n            } else if (requiredType.isArray()) {\n                if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue = convertToTypedCollection((Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion = true;\n            } else if (convertedValue instanceof Map) {\n                convertedValue = convertToTypedMap((Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion = true;\n            }\n            if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n                convertedValue = Array.get(convertedValue, 0);\n                standardConversion = true;\n            }\n            if (String.class == requiredType && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n                if (conversionAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {\n                    try {\n                        Constructor<T> strCtor = requiredType.getConstructor(String.class);\n                        return BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue = ((String) convertedValue).trim();\n                if (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n                standardConversion = true;\n            } else if (convertedValue instanceof Number && Number.class.isAssignableFrom(requiredType)) {\n                convertedValue = NumberUtils.convertNumberToTargetClass((Number) convertedValue, (Class<Number>) requiredType);\n                standardConversion = true;\n            }\n        } else {\n            if (requiredType == Optional.class) {\n                convertedValue = Optional.empty();\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            if (conversionAttemptEx != null) {\n                throw conversionAttemptEx;\n            } else if (conversionService != null && typeDescriptor != null) {\n                TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n                if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n                    return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n                }\n            }\n            StringBuilder msg = new StringBuilder();\n            msg.append(\"Cannot convert value of type '\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"' to required type '\").append(ClassUtils.getQualifiedName(requiredType)).append(\"'\");\n            if (propertyName != null) {\n                msg.append(\" for property '\").append(propertyName).append(\"'\");\n            }\n            if (editor != null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type '\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"'\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    if (conversionAttemptEx != null) {\n        if (editor == null && !standardConversion && requiredType != null && Object.class != requiredType) {\n            throw conversionAttemptEx;\n        }\n        logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n    }\n    return (T) convertedValue;\n}"
    },
    {
      "commit": "1f28825f9da63a13aaf8940aadedcf81358dc506",
      "startLine": 94,
      "endLine": 106,
      "methodCode": "@SuppressWarnings(\"unchecked\")\npublic <T> T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, Object newValue, @Nullable Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionFailedException conversionAttemptEx = null;\n    ConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n    if (editor == null && conversionService != null && newValue != null && typeDescriptor != null) {\n        TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n        if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n            try {\n                return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n            } catch (ConversionFailedException ex) {\n                conversionAttemptEx = ex;\n            }\n        }\n    }\n    Object convertedValue = newValue;\n    if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (typeDescriptor != null && requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {\n            TypeDescriptor elementTypeDesc = typeDescriptor.getElementTypeDescriptor();\n            if (elementTypeDesc != null) {\n                Class<?> elementType = elementTypeDesc.getType();\n                if (Class.class == elementType || Enum.class.isAssignableFrom(elementType)) {\n                    convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n            }\n        }\n        if (editor == null) {\n            editor = findDefaultEditor(requiredType);\n        }\n        convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    boolean standardConversion = false;\n    if (requiredType != null) {\n        if (convertedValue != null) {\n            if (Object.class == requiredType) {\n                return (T) convertedValue;\n            } else if (requiredType.isArray()) {\n                if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue = convertToTypedCollection((Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion = true;\n            } else if (convertedValue instanceof Map) {\n                convertedValue = convertToTypedMap((Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion = true;\n            }\n            if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n                convertedValue = Array.get(convertedValue, 0);\n                standardConversion = true;\n            }\n            if (String.class == requiredType && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n                if (conversionAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {\n                    try {\n                        Constructor<T> strCtor = requiredType.getConstructor(String.class);\n                        return BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue = ((String) convertedValue).trim();\n                if (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n                standardConversion = true;\n            } else if (convertedValue instanceof Number && Number.class.isAssignableFrom(requiredType)) {\n                convertedValue = NumberUtils.convertNumberToTargetClass((Number) convertedValue, (Class<Number>) requiredType);\n                standardConversion = true;\n            }\n        } else {\n            if (requiredType == Optional.class) {\n                convertedValue = Optional.empty();\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            if (conversionAttemptEx != null) {\n                throw conversionAttemptEx;\n            } else if (conversionService != null) {\n                TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n                if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n                    return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n                }\n            }\n            StringBuilder msg = new StringBuilder();\n            msg.append(\"Cannot convert value of type '\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"' to required type '\").append(ClassUtils.getQualifiedName(requiredType)).append(\"'\");\n            if (propertyName != null) {\n                msg.append(\" for property '\").append(propertyName).append(\"'\");\n            }\n            if (editor != null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type '\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"'\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    if (conversionAttemptEx != null) {\n        if (editor == null && !standardConversion && requiredType != null && Object.class != requiredType) {\n            throw conversionAttemptEx;\n        }\n        logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n    }\n    return (T) convertedValue;\n}"
    },
    {
      "commit": "87598f48e41d483745aba56cbf4e998c6f6d680c",
      "startLine": 94,
      "endLine": 106,
      "methodCode": "@SuppressWarnings(\"unchecked\")\npublic <T> T convertIfNecessary(String propertyName, @Nullable Object oldValue, Object newValue, @Nullable Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionFailedException conversionAttemptEx = null;\n    ConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n    if (editor == null && conversionService != null && newValue != null && typeDescriptor != null) {\n        TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n        if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n            try {\n                return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n            } catch (ConversionFailedException ex) {\n                conversionAttemptEx = ex;\n            }\n        }\n    }\n    Object convertedValue = newValue;\n    if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (typeDescriptor != null && requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {\n            TypeDescriptor elementTypeDesc = typeDescriptor.getElementTypeDescriptor();\n            if (elementTypeDesc != null) {\n                Class<?> elementType = elementTypeDesc.getType();\n                if (Class.class == elementType || Enum.class.isAssignableFrom(elementType)) {\n                    convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n            }\n        }\n        if (editor == null) {\n            editor = findDefaultEditor(requiredType);\n        }\n        convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    boolean standardConversion = false;\n    if (requiredType != null) {\n        if (convertedValue != null) {\n            if (Object.class == requiredType) {\n                return (T) convertedValue;\n            } else if (requiredType.isArray()) {\n                if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue = convertToTypedCollection((Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion = true;\n            } else if (convertedValue instanceof Map) {\n                convertedValue = convertToTypedMap((Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion = true;\n            }\n            if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n                convertedValue = Array.get(convertedValue, 0);\n                standardConversion = true;\n            }\n            if (String.class == requiredType && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n                if (conversionAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {\n                    try {\n                        Constructor<T> strCtor = requiredType.getConstructor(String.class);\n                        return BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue = ((String) convertedValue).trim();\n                if (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n                standardConversion = true;\n            } else if (convertedValue instanceof Number && Number.class.isAssignableFrom(requiredType)) {\n                convertedValue = NumberUtils.convertNumberToTargetClass((Number) convertedValue, (Class<Number>) requiredType);\n                standardConversion = true;\n            }\n        } else {\n            if (requiredType == Optional.class) {\n                convertedValue = Optional.empty();\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            if (conversionAttemptEx != null) {\n                throw conversionAttemptEx;\n            } else if (conversionService != null) {\n                TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n                if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n                    return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n                }\n            }\n            StringBuilder msg = new StringBuilder();\n            msg.append(\"Cannot convert value of type '\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"' to required type '\").append(ClassUtils.getQualifiedName(requiredType)).append(\"'\");\n            if (propertyName != null) {\n                msg.append(\" for property '\").append(propertyName).append(\"'\");\n            }\n            if (editor != null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type '\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"'\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    if (conversionAttemptEx != null) {\n        if (editor == null && !standardConversion && requiredType != null && Object.class != requiredType) {\n            throw conversionAttemptEx;\n        }\n        logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n    }\n    return (T) convertedValue;\n}"
    },
    {
      "commit": "dc080cb1be4c35398d1d995c3bb8025ccfde6dea",
      "startLine": 94,
      "endLine": 106,
      "methodCode": "@SuppressWarnings(\"unchecked\")\npublic <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionFailedException conversionAttemptEx = null;\n    ConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n    if (editor == null && conversionService != null && newValue != null && typeDescriptor != null) {\n        TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n        if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n            try {\n                return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n            } catch (ConversionFailedException ex) {\n                conversionAttemptEx = ex;\n            }\n        }\n    }\n    Object convertedValue = newValue;\n    if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (typeDescriptor != null && requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {\n            TypeDescriptor elementTypeDesc = typeDescriptor.getElementTypeDescriptor();\n            if (elementTypeDesc != null) {\n                Class<?> elementType = elementTypeDesc.getType();\n                if (Class.class == elementType || Enum.class.isAssignableFrom(elementType)) {\n                    convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n            }\n        }\n        if (editor == null) {\n            editor = findDefaultEditor(requiredType);\n        }\n        convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    boolean standardConversion = false;\n    if (requiredType != null) {\n        if (convertedValue != null) {\n            if (Object.class == requiredType) {\n                return (T) convertedValue;\n            } else if (requiredType.isArray()) {\n                if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue = convertToTypedCollection((Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion = true;\n            } else if (convertedValue instanceof Map) {\n                convertedValue = convertToTypedMap((Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion = true;\n            }\n            if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n                convertedValue = Array.get(convertedValue, 0);\n                standardConversion = true;\n            }\n            if (String.class == requiredType && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n                if (conversionAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {\n                    try {\n                        Constructor<T> strCtor = requiredType.getConstructor(String.class);\n                        return BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue = ((String) convertedValue).trim();\n                if (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n                standardConversion = true;\n            } else if (convertedValue instanceof Number && Number.class.isAssignableFrom(requiredType)) {\n                convertedValue = NumberUtils.convertNumberToTargetClass((Number) convertedValue, (Class<Number>) requiredType);\n                standardConversion = true;\n            }\n        } else {\n            if (requiredType == Optional.class) {\n                convertedValue = Optional.empty();\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            if (conversionAttemptEx != null) {\n                throw conversionAttemptEx;\n            } else if (conversionService != null) {\n                TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n                if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n                    return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n                }\n            }\n            StringBuilder msg = new StringBuilder();\n            msg.append(\"Cannot convert value of type '\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"' to required type '\").append(ClassUtils.getQualifiedName(requiredType)).append(\"'\");\n            if (propertyName != null) {\n                msg.append(\" for property '\").append(propertyName).append(\"'\");\n            }\n            if (editor != null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type '\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"'\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    if (conversionAttemptEx != null) {\n        if (editor == null && !standardConversion && requiredType != null && Object.class != requiredType) {\n            throw conversionAttemptEx;\n        }\n        logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n    }\n    return (T) convertedValue;\n}"
    },
    {
      "commit": "51252ebbcaa9e65aee83311aec25ca3c7c6d7d37",
      "startLine": 94,
      "endLine": 106,
      "methodCode": "@SuppressWarnings(\"unchecked\")\npublic <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionFailedException conversionAttemptEx = null;\n    ConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n    if (editor == null && conversionService != null && newValue != null && typeDescriptor != null) {\n        TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n        if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n            try {\n                return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n            } catch (ConversionFailedException ex) {\n                conversionAttemptEx = ex;\n            }\n        }\n    }\n    Object convertedValue = newValue;\n    if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (typeDescriptor != null && requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {\n            TypeDescriptor elementTypeDesc = typeDescriptor.getElementTypeDescriptor();\n            if (elementTypeDesc != null) {\n                Class<?> elementType = elementTypeDesc.getType();\n                if (Class.class == elementType || Enum.class.isAssignableFrom(elementType)) {\n                    convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n            }\n        }\n        if (editor == null) {\n            editor = findDefaultEditor(requiredType);\n        }\n        convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    boolean standardConversion = false;\n    if (requiredType != null) {\n        if (convertedValue != null) {\n            if (Object.class == requiredType) {\n                return (T) convertedValue;\n            } else if (requiredType.isArray()) {\n                if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue = convertToTypedCollection((Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion = true;\n            } else if (convertedValue instanceof Map) {\n                convertedValue = convertToTypedMap((Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion = true;\n            }\n            if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n                convertedValue = Array.get(convertedValue, 0);\n                standardConversion = true;\n            }\n            if (String.class == requiredType && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n                if (conversionAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {\n                    try {\n                        Constructor<T> strCtor = requiredType.getConstructor(String.class);\n                        return BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue = ((String) convertedValue).trim();\n                if (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n                standardConversion = true;\n            } else if (convertedValue instanceof Number && Number.class.isAssignableFrom(requiredType)) {\n                convertedValue = NumberUtils.convertNumberToTargetClass((Number) convertedValue, (Class<Number>) requiredType);\n                standardConversion = true;\n            }\n        } else {\n            if (requiredType == Optional.class) {\n                convertedValue = Optional.empty();\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            if (conversionAttemptEx != null) {\n                throw conversionAttemptEx;\n            } else if (conversionService != null) {\n                TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n                if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n                    return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n                }\n            }\n            StringBuilder msg = new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName != null) {\n                msg.append(\" for property '\").append(propertyName).append(\"'\");\n            }\n            if (editor != null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type [\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    if (conversionAttemptEx != null) {\n        if (editor == null && !standardConversion && requiredType != null && Object.class != requiredType) {\n            throw conversionAttemptEx;\n        }\n        logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n    }\n    return (T) convertedValue;\n}"
    },
    {
      "commit": "c4c941c43fc23f58503c7b687fd1469d4a27c777",
      "startLine": 94,
      "endLine": 106,
      "methodCode": "@SuppressWarnings(\"unchecked\")\npublic <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionFailedException conversionAttemptEx = null;\n    ConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n    if (editor == null && conversionService != null && newValue != null && typeDescriptor != null) {\n        TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n        if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n            try {\n                return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n            } catch (ConversionFailedException ex) {\n                conversionAttemptEx = ex;\n            }\n        }\n    }\n    Object convertedValue = newValue;\n    if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (typeDescriptor != null && requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {\n            TypeDescriptor elementTypeDesc = typeDescriptor.getElementTypeDescriptor();\n            if (elementTypeDesc != null) {\n                Class<?> elementType = elementTypeDesc.getType();\n                if (Class.class == elementType || Enum.class.isAssignableFrom(elementType)) {\n                    convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n            }\n        }\n        if (editor == null) {\n            editor = findDefaultEditor(requiredType);\n        }\n        convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    boolean standardConversion = false;\n    if (requiredType != null) {\n        if (convertedValue != null) {\n            if (Object.class == requiredType) {\n                return (T) convertedValue;\n            } else if (requiredType.isArray()) {\n                if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue = convertToTypedCollection((Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion = true;\n            } else if (convertedValue instanceof Map) {\n                convertedValue = convertToTypedMap((Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion = true;\n            }\n            if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n                convertedValue = Array.get(convertedValue, 0);\n                standardConversion = true;\n            }\n            if (String.class == requiredType && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n                if (conversionAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {\n                    try {\n                        Constructor<T> strCtor = requiredType.getConstructor(String.class);\n                        return BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue = ((String) convertedValue).trim();\n                if (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n                standardConversion = true;\n            } else if (convertedValue instanceof Number && Number.class.isAssignableFrom(requiredType)) {\n                convertedValue = NumberUtils.convertNumberToTargetClass((Number) convertedValue, (Class<Number>) requiredType);\n                standardConversion = true;\n            }\n        } else {\n            if (javaUtilOptionalEmpty != null && requiredType.equals(javaUtilOptionalEmpty.getClass())) {\n                convertedValue = javaUtilOptionalEmpty;\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            if (conversionAttemptEx != null) {\n                throw conversionAttemptEx;\n            } else if (conversionService != null) {\n                TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n                if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n                    return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n                }\n            }\n            StringBuilder msg = new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName != null) {\n                msg.append(\" for property '\").append(propertyName).append(\"'\");\n            }\n            if (editor != null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type [\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    if (conversionAttemptEx != null) {\n        if (editor == null && !standardConversion && requiredType != null && Object.class != requiredType) {\n            throw conversionAttemptEx;\n        }\n        logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n    }\n    return (T) convertedValue;\n}"
    },
    {
      "commit": "b4095c3e1d61fc7279e6b2ca105ec60c3cd7128c",
      "startLine": 91,
      "endLine": 103,
      "methodCode": "@SuppressWarnings(\"unchecked\")\npublic <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionFailedException conversionAttemptEx = null;\n    ConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n    if (editor == null && conversionService != null && newValue != null && typeDescriptor != null) {\n        TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n        if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n            try {\n                return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n            } catch (ConversionFailedException ex) {\n                conversionAttemptEx = ex;\n            }\n        }\n    }\n    Object convertedValue = newValue;\n    if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {\n            TypeDescriptor elementType = typeDescriptor.getElementTypeDescriptor();\n            if (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {\n                convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n            }\n        }\n        if (editor == null) {\n            editor = findDefaultEditor(requiredType);\n        }\n        convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    boolean standardConversion = false;\n    if (requiredType != null) {\n        if (convertedValue != null) {\n            if (Object.class == requiredType) {\n                return (T) convertedValue;\n            } else if (requiredType.isArray()) {\n                if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue = convertToTypedCollection((Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion = true;\n            } else if (convertedValue instanceof Map) {\n                convertedValue = convertToTypedMap((Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion = true;\n            }\n            if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n                convertedValue = Array.get(convertedValue, 0);\n                standardConversion = true;\n            }\n            if (String.class == requiredType && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n                if (conversionAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {\n                    try {\n                        Constructor<T> strCtor = requiredType.getConstructor(String.class);\n                        return BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue = ((String) convertedValue).trim();\n                if (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n                standardConversion = true;\n            } else if (convertedValue instanceof Number && Number.class.isAssignableFrom(requiredType)) {\n                convertedValue = NumberUtils.convertNumberToTargetClass((Number) convertedValue, (Class<Number>) requiredType);\n                standardConversion = true;\n            }\n        } else {\n            if (javaUtilOptionalEmpty != null && requiredType.equals(javaUtilOptionalEmpty.getClass())) {\n                convertedValue = javaUtilOptionalEmpty;\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            if (conversionAttemptEx != null) {\n                throw conversionAttemptEx;\n            } else if (conversionService != null) {\n                TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n                if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n                    return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n                }\n            }\n            StringBuilder msg = new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName != null) {\n                msg.append(\" for property '\").append(propertyName).append(\"'\");\n            }\n            if (editor != null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type [\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    if (conversionAttemptEx != null) {\n        if (editor == null && !standardConversion && requiredType != null && Object.class != requiredType) {\n            throw conversionAttemptEx;\n        }\n        logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n    }\n    return (T) convertedValue;\n}"
    },
    {
      "commit": "6418b54f81a9e56242fb78fda4bf95e7b3d4c572",
      "startLine": 91,
      "endLine": 103,
      "methodCode": "@SuppressWarnings(\"unchecked\")\npublic <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionFailedException conversionAttemptEx = null;\n    ConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n    if (editor == null && conversionService != null && newValue != null && typeDescriptor != null) {\n        TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n        if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n            try {\n                return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n            } catch (ConversionFailedException ex) {\n                conversionAttemptEx = ex;\n            }\n        }\n    }\n    Object convertedValue = newValue;\n    if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {\n            TypeDescriptor elementType = typeDescriptor.getElementTypeDescriptor();\n            if (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {\n                convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n            }\n        }\n        if (editor == null) {\n            editor = findDefaultEditor(requiredType);\n        }\n        convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    boolean standardConversion = false;\n    if (requiredType != null) {\n        if (convertedValue != null) {\n            if (Object.class.equals(requiredType)) {\n                return (T) convertedValue;\n            } else if (requiredType.isArray()) {\n                if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue = convertToTypedCollection((Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion = true;\n            } else if (convertedValue instanceof Map) {\n                convertedValue = convertToTypedMap((Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion = true;\n            }\n            if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n                convertedValue = Array.get(convertedValue, 0);\n                standardConversion = true;\n            }\n            if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n                if (conversionAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {\n                    try {\n                        Constructor<T> strCtor = requiredType.getConstructor(String.class);\n                        return BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue = ((String) convertedValue).trim();\n                if (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n                standardConversion = true;\n            } else if (convertedValue instanceof Number && Number.class.isAssignableFrom(requiredType)) {\n                convertedValue = NumberUtils.convertNumberToTargetClass((Number) convertedValue, (Class<Number>) requiredType);\n                standardConversion = true;\n            }\n        } else {\n            if (javaUtilOptionalEmpty != null && requiredType.equals(javaUtilOptionalEmpty.getClass())) {\n                convertedValue = javaUtilOptionalEmpty;\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            if (conversionAttemptEx != null) {\n                throw conversionAttemptEx;\n            } else if (conversionService != null) {\n                TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n                if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n                    return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n                }\n            }\n            StringBuilder msg = new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName != null) {\n                msg.append(\" for property '\").append(propertyName).append(\"'\");\n            }\n            if (editor != null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type [\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    if (conversionAttemptEx != null) {\n        if (editor == null && !standardConversion && requiredType != null && !Object.class.equals(requiredType)) {\n            throw conversionAttemptEx;\n        }\n        logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n    }\n    return (T) convertedValue;\n}"
    },
    {
      "commit": "02da2e85ee0e58202b90d11c126e6050abe184b4",
      "startLine": 87,
      "endLine": 99,
      "methodCode": "@SuppressWarnings(\"unchecked\")\npublic <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue = newValue;\n    PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionFailedException firstAttemptEx = null;\n    ConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n    if (editor == null && conversionService != null && convertedValue != null && typeDescriptor != null) {\n        TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n        TypeDescriptor targetTypeDesc = typeDescriptor;\n        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n            try {\n                return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n            } catch (ConversionFailedException ex) {\n                firstAttemptEx = ex;\n            }\n        }\n    }\n    if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {\n            TypeDescriptor elementType = typeDescriptor.getElementTypeDescriptor();\n            if (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {\n                convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n            }\n        }\n        if (editor == null) {\n            editor = findDefaultEditor(requiredType);\n        }\n        convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    boolean standardConversion = false;\n    if (requiredType != null) {\n        if (convertedValue != null) {\n            if (Object.class.equals(requiredType)) {\n                return (T) convertedValue;\n            } else if (requiredType.isArray()) {\n                if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue = convertToTypedCollection((Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion = true;\n            } else if (convertedValue instanceof Map) {\n                convertedValue = convertToTypedMap((Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion = true;\n            }\n            if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n                convertedValue = Array.get(convertedValue, 0);\n                standardConversion = true;\n            }\n            if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n                if (firstAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {\n                    try {\n                        Constructor<T> strCtor = requiredType.getConstructor(String.class);\n                        return BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue = ((String) convertedValue).trim();\n                if (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n                standardConversion = true;\n            } else if (convertedValue instanceof Number && Number.class.isAssignableFrom(requiredType)) {\n                convertedValue = NumberUtils.convertNumberToTargetClass((Number) convertedValue, (Class<Number>) requiredType);\n                standardConversion = true;\n            }\n        } else {\n            if (javaUtilOptionalEmpty != null && requiredType.equals(javaUtilOptionalEmpty.getClass())) {\n                convertedValue = javaUtilOptionalEmpty;\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            if (firstAttemptEx != null) {\n                throw firstAttemptEx;\n            }\n            StringBuilder msg = new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName != null) {\n                msg.append(\" for property '\").append(propertyName).append(\"'\");\n            }\n            if (editor != null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type [\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    if (firstAttemptEx != null) {\n        if (editor == null && !standardConversion && requiredType != null && !Object.class.equals(requiredType)) {\n            throw firstAttemptEx;\n        }\n        logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n    }\n    return (T) convertedValue;\n}"
    },
    {
      "commit": "bc1f19ce18e9ad35d8127048737d6e6e9c276eb3",
      "startLine": 85,
      "endLine": 97,
      "methodCode": "@SuppressWarnings(\"unchecked\")\npublic <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue = newValue;\n    PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionFailedException firstAttemptEx = null;\n    ConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n    if (editor == null && conversionService != null && convertedValue != null && typeDescriptor != null) {\n        TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n        TypeDescriptor targetTypeDesc = typeDescriptor;\n        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n            try {\n                return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n            } catch (ConversionFailedException ex) {\n                firstAttemptEx = ex;\n            }\n        }\n    }\n    if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {\n            TypeDescriptor elementType = typeDescriptor.getElementTypeDescriptor();\n            if (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {\n                convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n            }\n        }\n        if (editor == null) {\n            editor = findDefaultEditor(requiredType);\n        }\n        convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    boolean standardConversion = false;\n    if (requiredType != null) {\n        if (convertedValue != null) {\n            if (Object.class.equals(requiredType)) {\n                return (T) convertedValue;\n            }\n            if (requiredType.isArray()) {\n                if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue = convertToTypedCollection((Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion = true;\n            } else if (convertedValue instanceof Map) {\n                convertedValue = convertToTypedMap((Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion = true;\n            }\n            if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n                convertedValue = Array.get(convertedValue, 0);\n                standardConversion = true;\n            }\n            if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n                if (firstAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {\n                    try {\n                        Constructor<T> strCtor = requiredType.getConstructor(String.class);\n                        return BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue = ((String) convertedValue).trim();\n                if (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n                standardConversion = true;\n            }\n        } else {\n            if (javaUtilOptionalEmpty != null && requiredType.equals(javaUtilOptionalEmpty.getClass())) {\n                convertedValue = javaUtilOptionalEmpty;\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            if (firstAttemptEx != null) {\n                throw firstAttemptEx;\n            }\n            StringBuilder msg = new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName != null) {\n                msg.append(\" for property '\").append(propertyName).append(\"'\");\n            }\n            if (editor != null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type [\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    if (firstAttemptEx != null) {\n        if (editor == null && !standardConversion && requiredType != null && !Object.class.equals(requiredType)) {\n            throw firstAttemptEx;\n        }\n        logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n    }\n    return (T) convertedValue;\n}"
    },
    {
      "commit": "0dc6082b01606c3c996b728541467ba5104b747f",
      "startLine": 83,
      "endLine": 95,
      "methodCode": "@SuppressWarnings(\"unchecked\")\npublic <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue = newValue;\n    PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionFailedException firstAttemptEx = null;\n    ConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n    if (editor == null && conversionService != null && convertedValue != null && typeDescriptor != null) {\n        TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n        TypeDescriptor targetTypeDesc = typeDescriptor;\n        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n            try {\n                return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n            } catch (ConversionFailedException ex) {\n                firstAttemptEx = ex;\n            }\n        }\n    }\n    if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {\n            TypeDescriptor elementType = typeDescriptor.getElementTypeDescriptor();\n            if (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {\n                convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n            }\n        }\n        if (editor == null) {\n            editor = findDefaultEditor(requiredType);\n        }\n        convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    boolean standardConversion = false;\n    if (requiredType != null) {\n        if (convertedValue != null) {\n            if (Object.class.equals(requiredType)) {\n                return (T) convertedValue;\n            }\n            if (requiredType.isArray()) {\n                if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue = convertToTypedCollection((Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion = true;\n            } else if (convertedValue instanceof Map) {\n                convertedValue = convertToTypedMap((Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion = true;\n            }\n            if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n                convertedValue = Array.get(convertedValue, 0);\n                standardConversion = true;\n            }\n            if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n                if (firstAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {\n                    try {\n                        Constructor<T> strCtor = requiredType.getConstructor(String.class);\n                        return BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue = ((String) convertedValue).trim();\n                if (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n                standardConversion = true;\n            }\n        } else if (requiredType.equals(javaUtilOptionalEmpty.getClass())) {\n            convertedValue = javaUtilOptionalEmpty;\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            if (firstAttemptEx != null) {\n                throw firstAttemptEx;\n            }\n            StringBuilder msg = new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName != null) {\n                msg.append(\" for property '\").append(propertyName).append(\"'\");\n            }\n            if (editor != null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type [\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    if (firstAttemptEx != null) {\n        if (editor == null && !standardConversion && requiredType != null && !Object.class.equals(requiredType)) {\n            throw firstAttemptEx;\n        }\n        logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n    }\n    return (T) convertedValue;\n}"
    },
    {
      "commit": "59002f245623d758765b72d598cd78c326c6f5fa",
      "startLine": 81,
      "endLine": 93,
      "methodCode": "@SuppressWarnings(\"unchecked\")\npublic <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue = newValue;\n    PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionFailedException firstAttemptEx = null;\n    ConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n    if (editor == null && conversionService != null && convertedValue != null && typeDescriptor != null) {\n        TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n        TypeDescriptor targetTypeDesc = typeDescriptor;\n        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n            try {\n                return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n            } catch (ConversionFailedException ex) {\n                firstAttemptEx = ex;\n            }\n        }\n    }\n    if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {\n            TypeDescriptor elementType = typeDescriptor.getElementTypeDescriptor();\n            if (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {\n                convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n            }\n        }\n        if (editor == null) {\n            editor = findDefaultEditor(requiredType);\n        }\n        convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    boolean standardConversion = false;\n    if (requiredType != null) {\n        if (convertedValue != null) {\n            if (Object.class.equals(requiredType)) {\n                return (T) convertedValue;\n            }\n            if (requiredType.isArray()) {\n                if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue = convertToTypedCollection((Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion = true;\n            } else if (convertedValue instanceof Map) {\n                convertedValue = convertToTypedMap((Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion = true;\n            }\n            if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n                convertedValue = Array.get(convertedValue, 0);\n                standardConversion = true;\n            }\n            if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n                if (firstAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {\n                    try {\n                        Constructor<T> strCtor = requiredType.getConstructor(String.class);\n                        return BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue = ((String) convertedValue).trim();\n                if (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n                standardConversion = true;\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            if (firstAttemptEx != null) {\n                throw firstAttemptEx;\n            }\n            StringBuilder msg = new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName != null) {\n                msg.append(\" for property '\").append(propertyName).append(\"'\");\n            }\n            if (editor != null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type [\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    if (firstAttemptEx != null) {\n        if (editor == null && !standardConversion && requiredType != null && !Object.class.equals(requiredType)) {\n            throw firstAttemptEx;\n        }\n        logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n    }\n    return (T) convertedValue;\n}"
    },
    {
      "commit": "c9aace4da215330c1aa552fa1dcdd79748249774",
      "startLine": 81,
      "endLine": 93,
      "methodCode": "@SuppressWarnings(\"unchecked\")\npublic <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue = newValue;\n    PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionFailedException firstAttemptEx = null;\n    ConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n    if (editor == null && conversionService != null && convertedValue != null && typeDescriptor != null) {\n        TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n        TypeDescriptor targetTypeDesc = typeDescriptor;\n        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n            try {\n                return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n            } catch (ConversionFailedException ex) {\n                firstAttemptEx = ex;\n            }\n        }\n    }\n    if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {\n            TypeDescriptor elementType = typeDescriptor.getElementTypeDescriptor();\n            if (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {\n                convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n            }\n        }\n        if (editor == null) {\n            editor = findDefaultEditor(requiredType);\n        }\n        convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    boolean standardConversion = false;\n    if (requiredType != null) {\n        if (convertedValue != null) {\n            if (Object.class.equals(requiredType)) {\n                return (T) convertedValue;\n            }\n            if (requiredType.isArray()) {\n                if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue = convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion = true;\n            } else if (convertedValue instanceof Map) {\n                convertedValue = convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion = true;\n            }\n            if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n                convertedValue = Array.get(convertedValue, 0);\n                standardConversion = true;\n            }\n            if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n                if (firstAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor = requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue = ((String) convertedValue).trim();\n                if (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n                standardConversion = true;\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            if (firstAttemptEx != null) {\n                throw firstAttemptEx;\n            }\n            StringBuilder msg = new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName != null) {\n                msg.append(\" for property '\").append(propertyName).append(\"'\");\n            }\n            if (editor != null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type [\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    if (firstAttemptEx != null) {\n        if (editor == null && !standardConversion && requiredType != null && !Object.class.equals(requiredType)) {\n            throw firstAttemptEx;\n        }\n        logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n    }\n    return (T) convertedValue;\n}"
    },
    {
      "commit": "9540d2c81b93b9062faf79d4df998525f3dedb7c",
      "startLine": 78,
      "endLine": 90,
      "methodCode": "@SuppressWarnings(\"unchecked\")\npublic <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue = newValue;\n    PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionFailedException firstAttemptEx = null;\n    ConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n    if (editor == null && conversionService != null && convertedValue != null && typeDescriptor != null) {\n        TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n        TypeDescriptor targetTypeDesc = typeDescriptor;\n        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n            try {\n                return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n            } catch (ConversionFailedException ex) {\n                firstAttemptEx = ex;\n            }\n        }\n    }\n    if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {\n            TypeDescriptor elementType = typeDescriptor.getElementTypeDescriptor();\n            if (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {\n                convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n            }\n        }\n        if (editor == null) {\n            editor = findDefaultEditor(requiredType);\n        }\n        convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    boolean standardConversion = false;\n    if (requiredType != null) {\n        if (convertedValue != null) {\n            if (requiredType.isArray()) {\n                if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue = convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion = true;\n            } else if (convertedValue instanceof Map) {\n                convertedValue = convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion = true;\n            }\n            if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n                convertedValue = Array.get(convertedValue, 0);\n                standardConversion = true;\n            }\n            if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n                if (firstAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor = requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue = ((String) convertedValue).trim();\n                if (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n                standardConversion = true;\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            if (firstAttemptEx != null) {\n                throw firstAttemptEx;\n            }\n            StringBuilder msg = new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName != null) {\n                msg.append(\" for property '\").append(propertyName).append(\"'\");\n            }\n            if (editor != null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type [\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    if (firstAttemptEx != null) {\n        if (editor == null && !standardConversion && requiredType != null && !Object.class.equals(requiredType)) {\n            throw firstAttemptEx;\n        }\n        logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n    }\n    return (T) convertedValue;\n}"
    },
    {
      "commit": "ff7dcec5f7d2b54324476bd617af74de9cbd56ec",
      "startLine": 78,
      "endLine": 90,
      "methodCode": "@SuppressWarnings(\"unchecked\")\npublic <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue = newValue;\n    PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionFailedException firstAttemptEx = null;\n    ConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n    if (editor == null && conversionService != null && convertedValue != null && typeDescriptor != null) {\n        TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n        TypeDescriptor targetTypeDesc = typeDescriptor;\n        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n            try {\n                return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n            } catch (ConversionFailedException ex) {\n                firstAttemptEx = ex;\n            }\n        }\n    }\n    if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {\n            TypeDescriptor elementType = typeDescriptor.getElementTypeDescriptor();\n            if (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {\n                convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n            }\n        }\n        if (editor == null) {\n            editor = findDefaultEditor(requiredType);\n        }\n        convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    boolean standardConversion = false;\n    if (requiredType != null) {\n        if (convertedValue != null) {\n            if (requiredType.isArray()) {\n                if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue = convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion = true;\n            } else if (convertedValue instanceof Map) {\n                convertedValue = convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion = true;\n            }\n            if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n                convertedValue = Array.get(convertedValue, 0);\n                standardConversion = true;\n            }\n            if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n                if (firstAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor = requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue = ((String) convertedValue).trim();\n                if (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n                standardConversion = true;\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            if (firstAttemptEx != null) {\n                throw firstAttemptEx;\n            }\n            StringBuilder msg = new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName != null) {\n                msg.append(\" for property '\").append(propertyName).append(\"'\");\n            }\n            if (editor != null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type [\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    if (firstAttemptEx != null) {\n        if (editor == null && !standardConversion && requiredType != null && !Object.class.equals(requiredType)) {\n            throw firstAttemptEx;\n        }\n        logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n    }\n    return (T) convertedValue;\n}"
    },
    {
      "commit": "6bce09831060430b00e6ed93785c7d40ac8529a8",
      "startLine": 78,
      "endLine": 90,
      "methodCode": "@SuppressWarnings(\"unchecked\")\npublic <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue = newValue;\n    PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionFailedException firstAttemptEx = null;\n    ConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n    if (editor == null && conversionService != null && convertedValue != null && typeDescriptor != null) {\n        TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n        TypeDescriptor targetTypeDesc = typeDescriptor;\n        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n            try {\n                return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n            } catch (ConversionFailedException ex) {\n                firstAttemptEx = ex;\n            }\n        }\n    }\n    if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {\n            TypeDescriptor elementType = typeDescriptor.getElementTypeDescriptor();\n            if (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {\n                convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n            }\n        }\n        if (editor == null) {\n            editor = findDefaultEditor(requiredType);\n        }\n        convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    boolean standardConversion = false;\n    if (requiredType != null) {\n        if (convertedValue != null) {\n            if (requiredType.isArray()) {\n                if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue = convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion = true;\n            } else if (convertedValue instanceof Map) {\n                convertedValue = convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion = true;\n            }\n            if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n                convertedValue = Array.get(convertedValue, 0);\n                standardConversion = true;\n            }\n            if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n                if (!requiredType.isInterface() && !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor = requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue = ((String) convertedValue).trim();\n                if (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n                standardConversion = true;\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            if (firstAttemptEx != null) {\n                throw firstAttemptEx;\n            }\n            StringBuilder msg = new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName != null) {\n                msg.append(\" for property '\").append(propertyName).append(\"'\");\n            }\n            if (editor != null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type [\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    if (firstAttemptEx != null) {\n        if (editor == null && !standardConversion && requiredType != null && !Object.class.equals(requiredType)) {\n            throw firstAttemptEx;\n        }\n        logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n    }\n    return (T) convertedValue;\n}"
    },
    {
      "commit": "8e754e9065b5703f93909f480933488a2b180429",
      "startLine": 73,
      "endLine": 85,
      "methodCode": "@SuppressWarnings(\"unchecked\")\npublic <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue = newValue;\n    PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionFailedException firstAttemptEx = null;\n    ConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n    if (editor == null && conversionService != null && convertedValue != null && typeDescriptor != null) {\n        TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n        TypeDescriptor targetTypeDesc = typeDescriptor;\n        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n            try {\n                return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n            } catch (ConversionFailedException ex) {\n                firstAttemptEx = ex;\n            }\n        }\n    }\n    if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {\n            TypeDescriptor elementType = typeDescriptor.getElementTypeDescriptor();\n            if (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {\n                convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n            }\n        }\n        if (editor == null) {\n            editor = findDefaultEditor(requiredType, typeDescriptor);\n        }\n        convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType != null) {\n        if (convertedValue != null) {\n            if (requiredType.isArray()) {\n                if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue = convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n            } else if (convertedValue instanceof Map) {\n                convertedValue = convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n            }\n            if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n                convertedValue = Array.get(convertedValue, 0);\n            }\n            if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n                if (!requiredType.isInterface() && !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor = requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue = ((String) convertedValue).trim();\n                if (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            if (firstAttemptEx != null) {\n                throw firstAttemptEx;\n            }\n            StringBuilder msg = new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName != null) {\n                msg.append(\" for property '\").append(propertyName).append(\"'\");\n            }\n            if (editor != null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type [\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    if (firstAttemptEx != null) {\n        if (editor == null && convertedValue == newValue && requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            throw firstAttemptEx;\n        }\n        logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n    }\n    return (T) convertedValue;\n}"
    },
    {
      "commit": "02a4473c62d8240837bec297f0a1f3cb67ef8a7b",
      "startLine": 73,
      "endLine": 85,
      "methodCode": "@SuppressWarnings(\"unchecked\")\npublic <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue = newValue;\n    PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionFailedException firstAttemptEx = null;\n    ConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n    if (editor == null && conversionService != null && convertedValue != null && typeDescriptor != null) {\n        TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n        TypeDescriptor targetTypeDesc = typeDescriptor;\n        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n            try {\n                return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n            } catch (ConversionFailedException ex) {\n                firstAttemptEx = ex;\n            }\n        }\n    }\n    if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {\n            TypeDescriptor elementType = typeDescriptor.getElementTypeDescriptor();\n            if (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {\n                convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n            }\n        }\n        if (editor == null) {\n            editor = findDefaultEditor(requiredType, typeDescriptor);\n        }\n        convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType != null) {\n        if (convertedValue != null) {\n            if (requiredType.isArray()) {\n                if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue = convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n            } else if (convertedValue instanceof Map) {\n                convertedValue = convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n            }\n            if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n                convertedValue = Array.get(convertedValue, 0);\n            }\n            if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n                if (!requiredType.isInterface() && !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor = requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue = ((String) convertedValue).trim();\n                if (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            if (firstAttemptEx != null) {\n                throw firstAttemptEx;\n            }\n            StringBuilder msg = new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName != null) {\n                msg.append(\" for property '\").append(propertyName).append(\"'\");\n            }\n            if (editor != null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type [\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    if (firstAttemptEx != null) {\n        if (editor == null && convertedValue == newValue) {\n            throw firstAttemptEx;\n        }\n        logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n    }\n    return (T) convertedValue;\n}"
    },
    {
      "commit": "d331c5d1c99a2cb6d6932c98b96433e6f9c62c79",
      "startLine": 73,
      "endLine": 85,
      "methodCode": "@SuppressWarnings(\"unchecked\")\npublic <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue = newValue;\n    PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionFailedException firstAttemptEx = null;\n    ConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n    if (editor == null && conversionService != null && convertedValue != null && typeDescriptor != null) {\n        TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n        TypeDescriptor targetTypeDesc = typeDescriptor;\n        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n            try {\n                return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n            } catch (ConversionFailedException ex) {\n                firstAttemptEx = ex;\n            }\n        }\n    }\n    if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {\n            TypeDescriptor elementType = typeDescriptor.getElementTypeDescriptor();\n            if (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {\n                convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n            }\n        }\n        if (editor == null) {\n            editor = findDefaultEditor(requiredType, typeDescriptor);\n        }\n        convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType != null) {\n        if (convertedValue != null) {\n            if (requiredType.isArray()) {\n                if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue = convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n            } else if (convertedValue instanceof Map) {\n                convertedValue = convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n            }\n            if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n                convertedValue = Array.get(convertedValue, 0);\n            }\n            if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n                if (!requiredType.isInterface() && !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor = requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue = ((String) convertedValue).trim();\n                if (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            if (firstAttemptEx != null) {\n                throw firstAttemptEx;\n            }\n            StringBuilder msg = new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName != null) {\n                msg.append(\" for property '\").append(propertyName).append(\"'\");\n            }\n            if (editor != null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type [\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    if (firstAttemptEx != null) {\n        if (editor == null && convertedValue == newValue) {\n            throw firstAttemptEx;\n        }\n        logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n    }\n    return (T) convertedValue;\n}"
    },
    {
      "commit": "86bef9030fa4e026107db74cd9eef288beb1beca",
      "startLine": 73,
      "endLine": 85,
      "methodCode": "@SuppressWarnings(\"unchecked\")\npublic <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue = newValue;\n    PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionFailedException firstAttemptEx = null;\n    ConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n    if (editor == null && conversionService != null && convertedValue != null && typeDescriptor != null) {\n        TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n        TypeDescriptor targetTypeDesc = typeDescriptor;\n        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n            try {\n                return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n            } catch (ConversionFailedException ex) {\n                firstAttemptEx = ex;\n            }\n        }\n    }\n    if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {\n            TypeDescriptor elementType = typeDescriptor.getElementTypeDescriptor();\n            if (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {\n                convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n            }\n        }\n        if (editor == null) {\n            editor = findDefaultEditor(requiredType, typeDescriptor);\n        }\n        convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType != null) {\n        if (convertedValue != null) {\n            if (requiredType.isArray()) {\n                if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue = convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n            } else if (convertedValue instanceof Map) {\n                convertedValue = convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n            }\n            if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n                convertedValue = Array.get(convertedValue, 0);\n            }\n            if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n                if (!requiredType.isInterface() && !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor = requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue = ((String) convertedValue).trim();\n                if (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            if (firstAttemptEx != null) {\n                throw firstAttemptEx;\n            }\n            StringBuilder msg = new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName != null) {\n                msg.append(\" for property '\").append(propertyName).append(\"'\");\n            }\n            if (editor != null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type [\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    if (firstAttemptEx != null) {\n        if (editor == null) {\n            throw firstAttemptEx;\n        }\n        logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n    }\n    return (T) convertedValue;\n}"
    },
    {
      "commit": "84be348cb0ac99896674170dc9f99021b43ba9ee",
      "startLine": 73,
      "endLine": 85,
      "methodCode": "@SuppressWarnings(\"unchecked\")\npublic <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue = newValue;\n    PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionFailedException firstAttemptEx = null;\n    ConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n    if (editor == null && conversionService != null && convertedValue != null && typeDescriptor != null) {\n        TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n        TypeDescriptor targetTypeDesc = typeDescriptor;\n        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n            try {\n                return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n            } catch (ConversionFailedException ex) {\n                firstAttemptEx = ex;\n            }\n        }\n    }\n    if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {\n            TypeDescriptor elementType = typeDescriptor.getElementTypeDescriptor();\n            if (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {\n                convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n            }\n        }\n        if (editor == null) {\n            editor = findDefaultEditor(requiredType, typeDescriptor);\n        }\n        convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType != null) {\n        if (convertedValue != null) {\n            if (requiredType.isArray()) {\n                if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue = convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n            } else if (convertedValue instanceof Map) {\n                convertedValue = convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n            }\n            if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n                convertedValue = Array.get(convertedValue, 0);\n            }\n            if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n                if (!requiredType.isInterface() && !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor = requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue = ((String) convertedValue).trim();\n                if (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            if (firstAttemptEx != null) {\n                throw firstAttemptEx;\n            }\n            StringBuilder msg = new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName != null) {\n                msg.append(\" for property '\").append(propertyName).append(\"'\");\n            }\n            if (editor != null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type [\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    if (firstAttemptEx != null) {\n        logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n    }\n    return (T) convertedValue;\n}"
    },
    {
      "commit": "f288060ad8f0d007f1541213130d006729b9ec40",
      "startLine": 68,
      "endLine": 80,
      "methodCode": "@SuppressWarnings(\"unchecked\")\npublic <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue = newValue;\n    PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n    if (editor == null && conversionService != null && convertedValue != null && typeDescriptor != null) {\n        TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n        TypeDescriptor targetTypeDesc = typeDescriptor;\n        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n            try {\n                return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n            } catch (ConversionFailedException e) {\n            }\n        }\n    }\n    if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {\n            TypeDescriptor elementType = typeDescriptor.getElementTypeDescriptor();\n            if (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {\n                convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n            }\n        }\n        if (editor == null) {\n            editor = findDefaultEditor(requiredType, typeDescriptor);\n        }\n        convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType != null) {\n        if (convertedValue != null) {\n            if (requiredType.isArray()) {\n                if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue = convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n            } else if (convertedValue instanceof Map) {\n                convertedValue = convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n            }\n            if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n                convertedValue = Array.get(convertedValue, 0);\n            }\n            if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n                if (!requiredType.isInterface() && !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor = requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue = ((String) convertedValue).trim();\n                if (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName != null) {\n                msg.append(\" for property '\").append(propertyName).append(\"'\");\n            }\n            if (editor != null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type [\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    return (T) convertedValue;\n}"
    },
    {
      "commit": "5e3a5202fbd17cd30607ca7bb5360c9db8197e75",
      "startLine": 68,
      "endLine": 80,
      "methodCode": "@SuppressWarnings(\"unchecked\")\npublic <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue = newValue;\n    PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n    if (editor == null && conversionService != null && convertedValue != null && typeDescriptor != null) {\n        TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n        TypeDescriptor targetTypeDesc = typeDescriptor;\n        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n            try {\n                return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n            } catch (ConversionFailedException e) {\n            }\n        }\n    }\n    if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {\n            TypeDescriptor elementType = typeDescriptor.getElementTypeDescriptor();\n            if (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {\n                convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n            }\n        }\n        if (editor == null) {\n            editor = findDefaultEditor(requiredType, typeDescriptor);\n        }\n        convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType != null) {\n        if (convertedValue != null) {\n            if (requiredType.isArray()) {\n                if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue = convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n            } else if (convertedValue instanceof Map) {\n                convertedValue = convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n            }\n            if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n                convertedValue = Array.get(convertedValue, 0);\n            }\n            if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n                if (!requiredType.isInterface() && !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor = requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue = ((String) convertedValue).trim();\n                if (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName != null) {\n                msg.append(\" for property '\").append(propertyName).append(\"'\");\n            }\n            if (editor != null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    return (T) convertedValue;\n}"
    },
    {
      "commit": "8c6890605a7080e2744be3f3994757cc72e394b0",
      "startLine": 68,
      "endLine": 80,
      "methodCode": "@SuppressWarnings(\"unchecked\")\npublic <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue = newValue;\n    PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n    if (editor == null && conversionService != null && convertedValue != null && typeDescriptor != null) {\n        TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n        TypeDescriptor targetTypeDesc = typeDescriptor;\n        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n            try {\n                return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n            } catch (ConversionFailedException e) {\n            }\n        }\n    }\n    if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {\n            TypeDescriptor elementType = typeDescriptor.getElementType();\n            if (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {\n                convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n            }\n        }\n        if (editor == null) {\n            editor = findDefaultEditor(requiredType, typeDescriptor);\n        }\n        convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType != null) {\n        if (convertedValue != null) {\n            if (requiredType.isArray()) {\n                if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue = convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n            } else if (convertedValue instanceof Map) {\n                convertedValue = convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n            }\n            if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n                convertedValue = Array.get(convertedValue, 0);\n            }\n            if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n                if (!requiredType.isInterface() && !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor = requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue = ((String) convertedValue).trim();\n                if (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName != null) {\n                msg.append(\" for property '\").append(propertyName).append(\"'\");\n            }\n            if (editor != null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    return (T) convertedValue;\n}"
    },
    {
      "commit": "2127b160512911e5f65a4e304f0b57826710a91d",
      "startLine": 68,
      "endLine": 80,
      "methodCode": "@SuppressWarnings(\"unchecked\")\npublic <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue = newValue;\n    PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n    if (editor == null && conversionService != null && convertedValue != null) {\n        TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n        TypeDescriptor targetTypeDesc = typeDescriptor;\n        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n            try {\n                return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n            } catch (ConversionFailedException e) {\n            }\n        }\n    }\n    if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {\n            TypeDescriptor elementType = typeDescriptor.getElementType();\n            if (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {\n                convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n            }\n        }\n        if (editor == null) {\n            editor = findDefaultEditor(requiredType, typeDescriptor);\n        }\n        convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType != null) {\n        if (convertedValue != null) {\n            if (requiredType.isArray()) {\n                if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue = convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n            } else if (convertedValue instanceof Map) {\n                convertedValue = convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n            }\n            if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n                convertedValue = Array.get(convertedValue, 0);\n            }\n            if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n                if (!requiredType.isInterface() && !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor = requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue = ((String) convertedValue).trim();\n                if (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName != null) {\n                msg.append(\" for property '\").append(propertyName).append(\"'\");\n            }\n            if (editor != null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    return (T) convertedValue;\n}"
    },
    {
      "commit": "c306afed63e439ee133872a49380d76064bd2638",
      "startLine": 65,
      "endLine": 77,
      "methodCode": "@SuppressWarnings(\"unchecked\")\npublic <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue = newValue;\n    PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n    if (editor == null && conversionService != null && convertedValue != null) {\n        TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n        TypeDescriptor targetTypeDesc = typeDescriptor;\n        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n            return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n        }\n    }\n    if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {\n            TypeDescriptor elementType = typeDescriptor.getElementType();\n            if (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {\n                convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n            }\n        }\n        if (editor == null) {\n            editor = findDefaultEditor(requiredType, typeDescriptor);\n        }\n        convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType != null) {\n        if (convertedValue != null) {\n            if (requiredType.isArray()) {\n                if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue = convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n            } else if (convertedValue instanceof Map) {\n                convertedValue = convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n            }\n            if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n                convertedValue = Array.get(convertedValue, 0);\n            }\n            if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n                if (!requiredType.isInterface() && !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor = requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue = ((String) convertedValue).trim();\n                if (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName != null) {\n                msg.append(\" for property '\").append(propertyName).append(\"'\");\n            }\n            if (editor != null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    return (T) convertedValue;\n}"
    },
    {
      "commit": "c84cccf06dad4e3f11cd529ab16a5655bf723820",
      "startLine": 65,
      "endLine": 77,
      "methodCode": "@SuppressWarnings(\"unchecked\")\npublic <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue = newValue;\n    PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n    if (editor == null && conversionService != null && convertedValue != null) {\n        TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(convertedValue);\n        TypeDescriptor targetTypeDesc = typeDescriptor;\n        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n            return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n        }\n    }\n    if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {\n            TypeDescriptor elementType = typeDescriptor.getElementType();\n            if (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {\n                convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n            }\n        }\n        if (editor == null) {\n            editor = findDefaultEditor(requiredType, typeDescriptor);\n        }\n        convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType != null) {\n        if (convertedValue != null) {\n            if (requiredType.isArray()) {\n                if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue = convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n            } else if (convertedValue instanceof Map) {\n                convertedValue = convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n            }\n            if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n                convertedValue = Array.get(convertedValue, 0);\n            }\n            if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n                if (!requiredType.isInterface() && !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor = requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue = ((String) convertedValue).trim();\n                if (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName != null) {\n                msg.append(\" for property '\").append(propertyName).append(\"'\");\n            }\n            if (editor != null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    return (T) convertedValue;\n}"
    },
    {
      "commit": "6f146737f475828b6d765784017773378c2c4922",
      "startLine": 65,
      "endLine": 77,
      "methodCode": "@SuppressWarnings(\"unchecked\")\npublic <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue = newValue;\n    PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n    if (editor == null && conversionService != null && convertedValue != null) {\n        TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(convertedValue);\n        TypeDescriptor targetTypeDesc = typeDescriptor;\n        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n            return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n        }\n    }\n    if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {\n            Class elemType = typeDescriptor.getElementType();\n            if (elemType != null && Enum.class.isAssignableFrom(elemType)) {\n                convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n            }\n        }\n        if (editor == null) {\n            editor = findDefaultEditor(requiredType, typeDescriptor);\n        }\n        convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType != null) {\n        if (convertedValue != null) {\n            if (requiredType.isArray()) {\n                if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue = convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n            } else if (convertedValue instanceof Map) {\n                convertedValue = convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n            }\n            if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n                convertedValue = Array.get(convertedValue, 0);\n            }\n            if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n                if (!requiredType.isInterface() && !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor = requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue = ((String) convertedValue).trim();\n                if (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName != null) {\n                msg.append(\" for property '\").append(propertyName).append(\"'\");\n            }\n            if (editor != null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    return (T) convertedValue;\n}"
    },
    {
      "commit": "39e0c29d19fa5d1f8d2a7db57b16cc5a820db5a6",
      "startLine": 65,
      "endLine": 77,
      "methodCode": "@SuppressWarnings(\"unchecked\")\npublic <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue = newValue;\n    PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n    if (editor == null && conversionService != null && convertedValue != null) {\n        TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(convertedValue);\n        TypeDescriptor targetTypeDesc = typeDescriptor;\n        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n            return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n        }\n    }\n    if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String && typeDescriptor.getMethodParameter() != null) {\n            Class elemType = GenericCollectionTypeResolver.getCollectionParameterType(typeDescriptor.getMethodParameter());\n            if (elemType != null && Enum.class.isAssignableFrom(elemType)) {\n                convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n            }\n        }\n        if (editor == null) {\n            editor = findDefaultEditor(requiredType, typeDescriptor);\n        }\n        convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType != null) {\n        if (convertedValue != null) {\n            if (requiredType.isArray()) {\n                if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue = convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n            } else if (convertedValue instanceof Map) {\n                convertedValue = convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n            }\n            if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n                convertedValue = Array.get(convertedValue, 0);\n            }\n            if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n                if (!requiredType.isInterface() && !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor = requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue = ((String) convertedValue).trim();\n                if (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName != null) {\n                msg.append(\" for property '\").append(propertyName).append(\"'\");\n            }\n            if (editor != null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    return (T) convertedValue;\n}"
    },
    {
      "commit": "2ad2022058d4a2e3d29ea793ede2cb8c09f9102e",
      "startLine": 65,
      "endLine": 77,
      "methodCode": "@SuppressWarnings(\"unchecked\")\npublic <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue = newValue;\n    PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n    if (editor == null && conversionService != null && convertedValue != null) {\n        TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(convertedValue);\n        TypeDescriptor targetTypeDesc = typeDescriptor.forElementType(requiredType);\n        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n            return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n        }\n    }\n    if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String && typeDescriptor.getMethodParameter() != null) {\n            Class elemType = GenericCollectionTypeResolver.getCollectionParameterType(typeDescriptor.getMethodParameter());\n            if (elemType != null && Enum.class.isAssignableFrom(elemType)) {\n                convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n            }\n        }\n        if (editor == null) {\n            editor = findDefaultEditor(requiredType, typeDescriptor);\n        }\n        convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType != null) {\n        if (convertedValue != null) {\n            if (requiredType.isArray()) {\n                if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue = convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n            } else if (convertedValue instanceof Map) {\n                convertedValue = convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n            }\n            if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n                convertedValue = Array.get(convertedValue, 0);\n            }\n            if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n                if (!requiredType.isInterface() && !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor = requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue = ((String) convertedValue).trim();\n                if (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName != null) {\n                msg.append(\" for property '\").append(propertyName).append(\"'\");\n            }\n            if (editor != null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    return (T) convertedValue;\n}"
    },
    {
      "commit": "cbed1c1b4b5fd74c9cd201890f619a7079804d3f",
      "startLine": 65,
      "endLine": 77,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprivate <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue = newValue;\n    PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n    if (editor == null && conversionService != null && convertedValue != null) {\n        TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(convertedValue);\n        TypeDescriptor targetTypeDesc = typeDescriptor.forElementType(requiredType);\n        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n            return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n        }\n    }\n    if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String && typeDescriptor.getMethodParameter() != null) {\n            Class elemType = GenericCollectionTypeResolver.getCollectionParameterType(typeDescriptor.getMethodParameter());\n            if (elemType != null && Enum.class.isAssignableFrom(elemType)) {\n                convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n            }\n        }\n        if (editor == null) {\n            editor = findDefaultEditor(requiredType, typeDescriptor);\n        }\n        convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType != null) {\n        if (convertedValue != null) {\n            if (requiredType.isArray()) {\n                if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue = convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n            } else if (convertedValue instanceof Map) {\n                convertedValue = convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n            }\n            if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n                convertedValue = Array.get(convertedValue, 0);\n            }\n            if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n                if (!requiredType.isInterface() && !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor = requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue = ((String) convertedValue).trim();\n                if (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName != null) {\n                msg.append(\" for property '\").append(propertyName).append(\"'\");\n            }\n            if (editor != null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    return (T) convertedValue;\n}"
    },
    {
      "commit": "dc99df297274d8c1291cdaed5d9dd508910584d3",
      "startLine": 64,
      "endLine": 76,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprivate <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue = newValue;\n    PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n    if (editor == null && conversionService != null && convertedValue != null) {\n        TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(convertedValue);\n        if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n            return (T) conversionService.convert(convertedValue, sourceTypeDesc, typeDescriptor);\n        }\n    }\n    if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String && typeDescriptor.getMethodParameter() != null) {\n            Class elementType = GenericCollectionTypeResolver.getCollectionParameterType(typeDescriptor.getMethodParameter());\n            if (elementType != null && Enum.class.isAssignableFrom(elementType)) {\n                convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n            }\n        }\n        if (editor == null) {\n            editor = findDefaultEditor(requiredType, typeDescriptor);\n        }\n        convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType != null) {\n        if (convertedValue != null) {\n            if (requiredType.isArray()) {\n                if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue = convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n            } else if (convertedValue instanceof Map) {\n                convertedValue = convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n            }\n            if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n                convertedValue = Array.get(convertedValue, 0);\n            }\n            if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n                if (!requiredType.isInterface() && !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor = requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue = ((String) convertedValue).trim();\n                if (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName != null) {\n                msg.append(\" for property '\").append(propertyName).append(\"'\");\n            }\n            if (editor != null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    return (T) convertedValue;\n}"
    },
    {
      "commit": "2153b2fbd5aa4bff9b233fddb6c1c50cc879dcde",
      "startLine": 64,
      "endLine": 76,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprivate <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue = newValue;\n    PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n    if (editor == null && conversionService != null && convertedValue != null) {\n        TypeDescriptor sourceTypeDesc = new TypeDescriptor(convertedValue);\n        if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n            return (T) conversionService.convert(convertedValue, sourceTypeDesc, typeDescriptor);\n        }\n    }\n    if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String && typeDescriptor.getMethodParameter() != null) {\n            Class elementType = GenericCollectionTypeResolver.getCollectionParameterType(typeDescriptor.getMethodParameter());\n            if (elementType != null && Enum.class.isAssignableFrom(elementType)) {\n                convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n            }\n        }\n        if (editor == null) {\n            editor = findDefaultEditor(requiredType, typeDescriptor);\n        }\n        convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType != null) {\n        if (convertedValue != null) {\n            if (requiredType.isArray()) {\n                if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue = convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n            } else if (convertedValue instanceof Map) {\n                convertedValue = convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n            }\n            if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n                convertedValue = Array.get(convertedValue, 0);\n            }\n            if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n                if (!requiredType.isInterface() && !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor = requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue = ((String) convertedValue).trim();\n                if (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName != null) {\n                msg.append(\" for property '\").append(propertyName).append(\"'\");\n            }\n            if (editor != null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    return (T) convertedValue;\n}"
    },
    {
      "commit": "5f9b4443194d3aa3948d76956897c0a1d918d546",
      "startLine": 64,
      "endLine": 76,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprivate <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue = newValue;\n    PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n    if (editor == null && conversionService != null && convertedValue != null) {\n        TypeDescriptor sourceTypeDesc = TypeDescriptor.valueOf(convertedValue.getClass());\n        if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n            return (T) conversionService.convert(convertedValue, sourceTypeDesc, typeDescriptor);\n        }\n    }\n    if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String && typeDescriptor.getMethodParameter() != null) {\n            Class elementType = GenericCollectionTypeResolver.getCollectionParameterType(typeDescriptor.getMethodParameter());\n            if (elementType != null && Enum.class.isAssignableFrom(elementType)) {\n                convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n            }\n        }\n        if (editor == null) {\n            editor = findDefaultEditor(requiredType, typeDescriptor);\n        }\n        convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType != null) {\n        if (convertedValue != null) {\n            if (requiredType.isArray()) {\n                if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue = convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n            } else if (convertedValue instanceof Map) {\n                convertedValue = convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n            }\n            if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n                convertedValue = Array.get(convertedValue, 0);\n            }\n            if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n                if (!requiredType.isInterface() && !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor = requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue = ((String) convertedValue).trim();\n                if (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName != null) {\n                msg.append(\" for property '\").append(propertyName).append(\"'\");\n            }\n            if (editor != null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    return (T) convertedValue;\n}"
    },
    {
      "commit": "ac490114aee005a66eeb0fba6c3c853552fc6a94",
      "startLine": 55,
      "endLine": 67,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprivate <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue = newValue;\n    PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n    if (editor == null && conversionService != null && convertedValue != null) {\n        TypeDescriptor sourceTypeDesc = TypeDescriptor.valueOf(convertedValue.getClass());\n        if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n            return (T) conversionService.convert(convertedValue, sourceTypeDesc, typeDescriptor);\n        }\n    }\n    if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (editor == null) {\n            editor = findDefaultEditor(requiredType, typeDescriptor);\n        }\n        convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType != null) {\n        if (convertedValue != null) {\n            if (requiredType.isArray()) {\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue = convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n            } else if (convertedValue instanceof Map) {\n                convertedValue = convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n            }\n            if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n                convertedValue = Array.get(convertedValue, 0);\n            }\n            if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n                if (!requiredType.isInterface() && !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor = requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue = ((String) convertedValue).trim();\n                if (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName != null) {\n                msg.append(\" for property '\").append(propertyName).append(\"'\");\n            }\n            if (editor != null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    return (T) convertedValue;\n}"
    },
    {
      "commit": "84447cdf9493a5f6ead3450627d8938af1b7ac5f",
      "startLine": 61,
      "endLine": 73,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprotected <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, PropertyDescriptor descriptor, MethodParameter methodParam) throws IllegalArgumentException {\n    Object convertedValue = newValue;\n    PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n    if (editor == null && conversionService != null && convertedValue != null) {\n        TypeDescriptor sourceTypeDesc = TypeDescriptor.valueOf(convertedValue.getClass());\n        TypeDescriptor targetTypeDesc;\n        if (methodParam != null) {\n            targetTypeDesc = (descriptor != null ? new BeanTypeDescriptor(methodParam, descriptor) : new TypeDescriptor(methodParam));\n        } else {\n            targetTypeDesc = TypeDescriptor.valueOf(requiredType);\n        }\n        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n            return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n        }\n    }\n    if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (editor == null) {\n            editor = findDefaultEditor(requiredType, descriptor);\n        }\n        convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType != null) {\n        if (convertedValue != null) {\n            if (requiredType.isArray()) {\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue = convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, methodParam);\n            } else if (convertedValue instanceof Map) {\n                convertedValue = convertToTypedMap((Map) convertedValue, propertyName, requiredType, methodParam);\n            }\n            if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n                convertedValue = Array.get(convertedValue, 0);\n            }\n            if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n                if (!requiredType.isInterface() && !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor = requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue = ((String) convertedValue).trim();\n                if (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName != null) {\n                msg.append(\" for property '\").append(propertyName).append(\"'\");\n            }\n            if (editor != null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    return (T) convertedValue;\n}"
    },
    {
      "commit": "45c542e51e9b01526a97a1644aebfe1e94a2342f",
      "startLine": 57,
      "endLine": 69,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprotected <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, PropertyDescriptor descriptor, MethodParameter methodParam) throws IllegalArgumentException {\n    Object convertedValue = newValue;\n    PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n    if (editor == null && conversionService != null && convertedValue != null) {\n        TypeDescriptor sourceTypeDesc = TypeDescriptor.valueOf(convertedValue.getClass());\n        TypeDescriptor targetTypeDesc;\n        if (methodParam != null) {\n            targetTypeDesc = (descriptor != null ? new BeanTypeDescriptor(methodParam, descriptor) : new TypeDescriptor(methodParam));\n        } else {\n            targetTypeDesc = TypeDescriptor.valueOf(requiredType);\n        }\n        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n            return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n        }\n    }\n    if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (editor == null) {\n            editor = findDefaultEditor(requiredType, descriptor);\n        }\n        convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType != null) {\n        if (convertedValue != null) {\n            if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (requiredType.isArray()) {\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue = convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, methodParam);\n            } else if (convertedValue instanceof Map) {\n                convertedValue = convertToTypedMap((Map) convertedValue, propertyName, requiredType, methodParam);\n            } else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n                if (!requiredType.isInterface() && !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor = requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue = ((String) convertedValue).trim();\n                if (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName != null) {\n                msg.append(\" for property '\").append(propertyName).append(\"'\");\n            }\n            if (editor != null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    return (T) convertedValue;\n}"
    },
    {
      "commit": "d3b43ebccb923c6d5825b10d4f4f305b54ee549d",
      "startLine": 56,
      "endLine": 68,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprotected <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, PropertyDescriptor descriptor, MethodParameter methodParam) throws IllegalArgumentException {\n    Object convertedValue = newValue;\n    PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n    if (editor == null && conversionService != null && convertedValue != null) {\n        TypeDescriptor typeDesc;\n        if (methodParam != null) {\n            typeDesc = (descriptor != null ? new BeanTypeDescriptor(methodParam, descriptor) : new TypeDescriptor(methodParam));\n        } else {\n            typeDesc = TypeDescriptor.valueOf(requiredType);\n        }\n        if (conversionService.matches(convertedValue.getClass(), typeDesc)) {\n            return (T) conversionService.convert(convertedValue, typeDesc);\n        }\n    }\n    if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (editor == null) {\n            editor = findDefaultEditor(requiredType, descriptor);\n        }\n        convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType != null) {\n        if (convertedValue != null) {\n            if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (requiredType.isArray()) {\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue = convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, methodParam);\n            } else if (convertedValue instanceof Map) {\n                convertedValue = convertToTypedMap((Map) convertedValue, propertyName, requiredType, methodParam);\n            } else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n                if (!requiredType.isInterface() && !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor = requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue = ((String) convertedValue).trim();\n                if (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName != null) {\n                msg.append(\" for property '\").append(propertyName).append(\"'\");\n            }\n            if (editor != null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    return (T) convertedValue;\n}"
    },
    {
      "commit": "1480202aa37d7edaf7f070a2bf45cd3a1016eea7",
      "startLine": 56,
      "endLine": 68,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprotected <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, PropertyDescriptor descriptor, MethodParameter methodParam) throws IllegalArgumentException {\n    Object convertedValue = newValue;\n    PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n    if (editor == null && conversionService != null && convertedValue != null) {\n        TypeDescriptor typeDesc;\n        if (methodParam != null) {\n            typeDesc = (descriptor != null ? new BeanTypeDescriptor(methodParam, descriptor) : new TypeDescriptor(methodParam));\n        } else {\n            typeDesc = TypeDescriptor.valueOf(requiredType);\n        }\n        if (conversionService.canConvert(convertedValue.getClass(), typeDesc)) {\n            return (T) conversionService.convert(convertedValue, typeDesc);\n        }\n    }\n    if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (editor == null) {\n            editor = findDefaultEditor(requiredType, descriptor);\n        }\n        convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType != null) {\n        if (convertedValue != null) {\n            if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (requiredType.isArray()) {\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue = convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, methodParam);\n            } else if (convertedValue instanceof Map) {\n                convertedValue = convertToTypedMap((Map) convertedValue, propertyName, requiredType, methodParam);\n            } else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n                if (!requiredType.isInterface() && !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor = requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue = ((String) convertedValue).trim();\n                if (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName != null) {\n                msg.append(\" for property '\").append(propertyName).append(\"'\");\n            }\n            if (editor != null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    return (T) convertedValue;\n}"
    },
    {
      "commit": "a86a698e5b3394c9b6721a784c8fe251611ff16b",
      "startLine": 63,
      "endLine": 75,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprotected <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, PropertyDescriptor descriptor, MethodParameter methodParam) throws IllegalArgumentException {\n    Object convertedValue = newValue;\n    PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n    if (editor == null && conversionService != null && convertedValue != null) {\n        TypeDescriptor typeDesc;\n        if (methodParam != null) {\n            typeDesc = (descriptor != null ? new BeanTypeDescriptor(methodParam, descriptor) : new TypeDescriptor(methodParam));\n        } else {\n            typeDesc = TypeDescriptor.valueOf(requiredType);\n        }\n        if (conversionService.canConvert(convertedValue.getClass(), typeDesc)) {\n            return (T) conversionService.convert(convertedValue, typeDesc);\n        }\n    }\n    if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (editor == null) {\n            editor = findDefaultEditor(requiredType, descriptor);\n        }\n        convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType != null) {\n        if (convertedValue != null) {\n            if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (requiredType.isArray()) {\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue = convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, methodParam);\n            } else if (convertedValue instanceof Map) {\n                convertedValue = convertToTypedMap((Map) convertedValue, propertyName, requiredType, methodParam);\n            } else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n                if (!requiredType.isInterface() && !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor = requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue = ((String) convertedValue).trim();\n                if (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                try {\n                    Field enumField = requiredType.getField(trimmedValue);\n                    convertedValue = enumField.get(null);\n                } catch (Throwable ex) {\n                    if (logger.isTraceEnabled()) {\n                        logger.trace(\"Field [\" + convertedValue + \"] isn't an enum value\", ex);\n                    }\n                }\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName != null) {\n                msg.append(\" for property '\").append(propertyName).append(\"'\");\n            }\n            if (editor != null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    return (T) convertedValue;\n}"
    },
    {
      "commit": "9a48f3f3a896cad821e5847a93d91c997905e325",
      "startLine": 59,
      "endLine": 71,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprotected <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, PropertyDescriptor descriptor, MethodParameter methodParam) throws IllegalArgumentException {\n    Object convertedValue = newValue;\n    PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n    if (editor == null && conversionService != null && convertedValue != null && conversionService.canConvert(convertedValue.getClass(), requiredType)) {\n        if (methodParam != null) {\n            return (T) conversionService.convert(convertedValue, new TypeDescriptor(methodParam));\n        } else {\n            return conversionService.convert(convertedValue, requiredType);\n        }\n    }\n    if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (editor == null) {\n            editor = findDefaultEditor(requiredType, descriptor);\n        }\n        convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType != null) {\n        if (convertedValue != null) {\n            if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (requiredType.isArray()) {\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue = convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, methodParam);\n            } else if (convertedValue instanceof Map) {\n                convertedValue = convertToTypedMap((Map) convertedValue, propertyName, requiredType, methodParam);\n            } else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n                if (!requiredType.isInterface() && !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor = requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue = ((String) convertedValue).trim();\n                if (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                try {\n                    Field enumField = requiredType.getField(trimmedValue);\n                    convertedValue = enumField.get(null);\n                } catch (Throwable ex) {\n                    if (logger.isTraceEnabled()) {\n                        logger.trace(\"Field [\" + convertedValue + \"] isn't an enum value\", ex);\n                    }\n                }\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName != null) {\n                msg.append(\" for property '\").append(propertyName).append(\"'\");\n            }\n            if (editor != null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    return (T) convertedValue;\n}"
    },
    {
      "commit": "04b619ebfbc1e08a9e9bdc54263b3ece21f4aa7f",
      "startLine": 57,
      "endLine": 69,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprotected <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, PropertyDescriptor descriptor, MethodParameter methodParam) throws IllegalArgumentException {\n    Object convertedValue = newValue;\n    PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n    if (editor == null && conversionService != null && convertedValue != null && conversionService.canConvert(convertedValue.getClass(), requiredType)) {\n        if (methodParam != null) {\n            return (T) conversionService.convert(convertedValue, new TypeDescriptor(methodParam));\n        } else {\n            return conversionService.convert(convertedValue, requiredType);\n        }\n    }\n    if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (editor == null) {\n            editor = findDefaultEditor(requiredType, descriptor);\n        }\n        convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType != null) {\n        if (convertedValue != null) {\n            if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (requiredType.isArray()) {\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection && CollectionFactory.isApproximableCollectionType(requiredType)) {\n                convertedValue = convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n            } else if (convertedValue instanceof Map && CollectionFactory.isApproximableMapType(requiredType)) {\n                convertedValue = convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n            } else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n                try {\n                    Constructor strCtor = requiredType.getConstructor(String.class);\n                    return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                } catch (NoSuchMethodException ex) {\n                    if (logger.isTraceEnabled()) {\n                        logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                    }\n                } catch (Exception ex) {\n                    if (logger.isTraceEnabled()) {\n                        logger.trace(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                    }\n                }\n                String trimmedValue = ((String) convertedValue).trim();\n                if (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                try {\n                    Field enumField = requiredType.getField(trimmedValue);\n                    convertedValue = enumField.get(null);\n                } catch (Throwable ex) {\n                    if (logger.isTraceEnabled()) {\n                        logger.trace(\"Field [\" + convertedValue + \"] isn't an enum value\", ex);\n                    }\n                }\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName != null) {\n                msg.append(\" for property '\").append(propertyName).append(\"'\");\n            }\n            if (editor != null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    return (T) convertedValue;\n}"
    },
    {
      "commit": "fee838a65e87f5da4b65b04ea5101681d6308104",
      "startLine": 53,
      "endLine": 65,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprotected <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, PropertyDescriptor descriptor, MethodParameter methodParam) throws IllegalArgumentException {\n    Object convertedValue = newValue;\n    PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n    if (editor == null && conversionService != null && convertedValue != null && conversionService.canConvert(convertedValue.getClass(), requiredType)) {\n        if (methodParam != null) {\n            return (T) conversionService.convert(convertedValue, new TypeDescriptor(methodParam));\n        } else {\n            return conversionService.convert(convertedValue, requiredType);\n        }\n    }\n    if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (editor == null) {\n            editor = findDefaultEditor(requiredType, descriptor);\n        }\n        convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType != null) {\n        if (convertedValue != null) {\n            if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (requiredType.isArray()) {\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection && CollectionFactory.isApproximableCollectionType(requiredType)) {\n                convertedValue = convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n            } else if (convertedValue instanceof Map && CollectionFactory.isApproximableMapType(requiredType)) {\n                convertedValue = convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n            } else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n                try {\n                    Constructor strCtor = requiredType.getConstructor(String.class);\n                    return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                } catch (NoSuchMethodException ex) {\n                    if (logger.isTraceEnabled()) {\n                        logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                    }\n                }\n                String trimmedValue = ((String) convertedValue).trim();\n                if (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                try {\n                    Field enumField = requiredType.getField(trimmedValue);\n                    convertedValue = enumField.get(null);\n                } catch (Throwable ex) {\n                    if (logger.isTraceEnabled()) {\n                        logger.trace(\"Field [\" + convertedValue + \"] isn't an enum value\", ex);\n                    }\n                }\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName != null) {\n                msg.append(\" for property '\").append(propertyName).append(\"'\");\n            }\n            if (editor != null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    return (T) convertedValue;\n}"
    },
    {
      "commit": "45a0cadf8e7fc5cc082c11ef03f77dc017af64c4",
      "startLine": 45,
      "endLine": 57,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprotected <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, PropertyDescriptor descriptor, MethodParameter methodParam) throws IllegalArgumentException {\n    Object convertedValue = newValue;\n    PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n    if (editor == null && conversionService != null && convertedValue != null && conversionService.canConvert(convertedValue.getClass(), requiredType)) {\n        if (methodParam != null) {\n            return (T) conversionService.convert(convertedValue, new TypeDescriptor(methodParam));\n        } else {\n            return conversionService.convert(convertedValue, requiredType);\n        }\n    }\n    if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (editor == null) {\n            editor = findDefaultEditor(requiredType, descriptor);\n        }\n        convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType != null) {\n        if (convertedValue != null) {\n            if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (requiredType.isArray()) {\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection && CollectionFactory.isApproximableCollectionType(requiredType)) {\n                convertedValue = convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n            } else if (convertedValue instanceof Map && CollectionFactory.isApproximableMapType(requiredType)) {\n                convertedValue = convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n            } else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n                String strValue = ((String) convertedValue).trim();\n                if (requiredType.isEnum() && \"\".equals(strValue)) {\n                    return null;\n                }\n                try {\n                    Field enumField = requiredType.getField(strValue);\n                    convertedValue = enumField.get(null);\n                } catch (Throwable ex) {\n                    if (logger.isTraceEnabled()) {\n                        logger.trace(\"Field [\" + convertedValue + \"] isn't an enum value\", ex);\n                    }\n                }\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName != null) {\n                msg.append(\" for property '\").append(propertyName).append(\"'\");\n            }\n            if (editor != null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    return (T) convertedValue;\n}"
    },
    {
      "commit": "0297116542a3ce33d19a6a81b8240097081376c5",
      "startLine": 37,
      "endLine": 49,
      "methodCode": "@SuppressWarnings(\"unchecked\")\nprotected <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, PropertyDescriptor descriptor, MethodParameter methodParam) throws IllegalArgumentException {\n    Object convertedValue = newValue;\n    PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (editor == null) {\n            editor = findDefaultEditor(requiredType, descriptor);\n        }\n        convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType != null) {\n        if (convertedValue != null) {\n            if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (requiredType.isArray()) {\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection && CollectionFactory.isApproximableCollectionType(requiredType)) {\n                convertedValue = convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n            } else if (convertedValue instanceof Map && CollectionFactory.isApproximableMapType(requiredType)) {\n                convertedValue = convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n            } else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n                String strValue = ((String) convertedValue).trim();\n                if (requiredType.isEnum() && \"\".equals(strValue)) {\n                    return null;\n                }\n                try {\n                    Field enumField = requiredType.getField(strValue);\n                    convertedValue = enumField.get(null);\n                } catch (Throwable ex) {\n                    if (logger.isTraceEnabled()) {\n                        logger.trace(\"Field [\" + convertedValue + \"] isn't an enum value\", ex);\n                    }\n                }\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName != null) {\n                msg.append(\" for property '\").append(propertyName).append(\"'\");\n            }\n            if (editor != null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    return (T) convertedValue;\n}"
    },
    {
      "commit": "bf7a947559d8f9918cc738780bf04caf8ea46962",
      "startLine": 36,
      "endLine": 48,
      "methodCode": "protected Object convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class requiredType, PropertyDescriptor descriptor, MethodParameter methodParam) throws IllegalArgumentException {\n    Object convertedValue = newValue;\n    PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (editor == null) {\n            editor = findDefaultEditor(requiredType, descriptor);\n        }\n        convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType != null) {\n        if (convertedValue != null) {\n            if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return convertedValue.toString();\n            } else if (requiredType.isArray()) {\n                return convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection && CollectionFactory.isApproximableCollectionType(requiredType)) {\n                convertedValue = convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n            } else if (convertedValue instanceof Map && CollectionFactory.isApproximableMapType(requiredType)) {\n                convertedValue = convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n            } else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n                String strValue = ((String) convertedValue).trim();\n                if (requiredType.isEnum() && \"\".equals(strValue)) {\n                    return null;\n                }\n                try {\n                    Field enumField = requiredType.getField(strValue);\n                    convertedValue = enumField.get(null);\n                } catch (Throwable ex) {\n                    if (logger.isTraceEnabled()) {\n                        logger.trace(\"Field [\" + convertedValue + \"] isn't an enum value\", ex);\n                    }\n                }\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName != null) {\n                msg.append(\" for property '\").append(propertyName).append(\"'\");\n            }\n            if (editor != null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    return convertedValue;\n}"
    },
    {
      "commit": "29657105da133995b0b2277b82c75d1df2931b64",
      "startLine": 36,
      "endLine": 46,
      "methodCode": "protected Object convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class requiredType, PropertyDescriptor descriptor, MethodParameter methodParam) throws IllegalArgumentException {\n    Object convertedValue = newValue;\n    PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (editor == null) {\n            editor = findDefaultEditor(requiredType, descriptor);\n        }\n        convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType != null) {\n        if (convertedValue != null) {\n            if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return convertedValue.toString();\n            } else if (requiredType.isArray()) {\n                return convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection && CollectionFactory.isApproximableCollectionType(requiredType)) {\n                convertedValue = convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n            } else if (convertedValue instanceof Map && CollectionFactory.isApproximableMapType(requiredType)) {\n                convertedValue = convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n            } else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n                String strValue = ((String) convertedValue).trim();\n                if (requiredType.isEnum() && \"\".equals(strValue)) {\n                    return null;\n                }\n                try {\n                    Field enumField = requiredType.getField(strValue);\n                    convertedValue = enumField.get(null);\n                } catch (Throwable ex) {\n                    if (logger.isTraceEnabled()) {\n                        logger.trace(\"Field [\" + convertedValue + \"] isn't an enum value\", ex);\n                    }\n                }\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName != null) {\n                msg.append(\" for property '\").append(propertyName).append(\"'\");\n            }\n            if (editor != null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n            }\n            throw new IllegalArgumentException(msg.toString());\n        }\n    }\n    return convertedValue;\n}"
    },
    {
      "commit": "347f34c68a7a5bab46cf869e762fb3cee9a1fedc",
      "startLine": 36,
      "endLine": 46,
      "methodCode": "protected Object convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class requiredType, PropertyDescriptor descriptor, MethodParameter methodParam) throws IllegalArgumentException {\n    Object convertedValue = newValue;\n    PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (editor == null) {\n            editor = findDefaultEditor(requiredType, descriptor);\n        }\n        convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType != null) {\n        if (convertedValue != null) {\n            if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return convertedValue.toString();\n            } else if (requiredType.isArray()) {\n                return convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection && CollectionFactory.isApproximableCollectionType(requiredType)) {\n                convertedValue = convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n            } else if (convertedValue instanceof Map && CollectionFactory.isApproximableMapType(requiredType)) {\n                convertedValue = convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n            } else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n                String strValue = ((String) convertedValue).trim();\n                if (requiredType.isEnum() && \"\".equals(strValue)) {\n                    return null;\n                }\n                try {\n                    Field enumField = requiredType.getField(strValue);\n                    convertedValue = enumField.get(null);\n                } catch (Throwable ex) {\n                    if (logger.isTraceEnabled()) {\n                        logger.trace(\"Field [\" + convertedValue + \"] isn't an enum value\", ex);\n                    }\n                }\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName != null) {\n                msg.append(\" for property '\" + propertyName + \"'\");\n            }\n            if (editor != null) {\n                msg.append(\": PropertyEditor [\" + editor.getClass().getName() + \"] returned inappropriate value\");\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n            }\n            throw new IllegalArgumentException(msg.toString());\n        }\n    }\n    return convertedValue;\n}"
    },
    {
      "commit": "f11d3436ed21d3908b9e0b569f2d783df161c0a3",
      "startLine": 36,
      "endLine": 46,
      "methodCode": "protected Object convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class requiredType, PropertyDescriptor descriptor, MethodParameter methodParam) throws IllegalArgumentException {\n    Object convertedValue = newValue;\n    PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (editor == null) {\n            editor = findDefaultEditor(requiredType, descriptor);\n        }\n        convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType != null) {\n        if (convertedValue != null) {\n            if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return convertedValue.toString();\n            } else if (requiredType.isArray()) {\n                return convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection && CollectionFactory.isApproximableCollectionType(requiredType)) {\n                convertedValue = convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n            } else if (convertedValue instanceof Map && CollectionFactory.isApproximableMapType(requiredType)) {\n                convertedValue = convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n            } else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n                String strValue = ((String) convertedValue).trim();\n                if (JdkVersion.isAtLeastJava15() && requiredType.isEnum() && \"\".equals(strValue)) {\n                    return null;\n                }\n                try {\n                    Field enumField = requiredType.getField(strValue);\n                    convertedValue = enumField.get(null);\n                } catch (Throwable ex) {\n                    if (logger.isTraceEnabled()) {\n                        logger.trace(\"Field [\" + convertedValue + \"] isn't an enum value\", ex);\n                    }\n                }\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuffer msg = new StringBuffer();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName != null) {\n                msg.append(\" for property '\" + propertyName + \"'\");\n            }\n            if (editor != null) {\n                msg.append(\": PropertyEditor [\" + editor.getClass().getName() + \"] returned inappropriate value\");\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n            }\n            throw new IllegalArgumentException(msg.toString());\n        }\n    }\n    return convertedValue;\n}"
    }
  ]
}