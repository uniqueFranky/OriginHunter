{
  "statementVersions": [
    {
      "commit": "791449a6ab0696f4c0109908a4a0925e514b10d9",
      "startLine": 20,
      "endLine": 30,
      "methodCode": "@Override\npublic Optional<MethodUsage> solveMethodAsUsage(String name, List<ResolvedType> argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope().isPresent()) {\n        Expression scope = wrappedNode.getScope().get();\n        if (scope instanceof NameExpr) {\n            String className = ((NameExpr) scope).getName().getId();\n            SymbolReference<ResolvedTypeDeclaration> ref = solveType(className, typeSolver);\n            if (ref.isSolved()) {\n                SymbolReference<ResolvedMethodDeclaration> m = MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                if (m.isSolved()) {\n                    MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration());\n                    methodUsage = resolveMethodTypeParametersFromExplicitList(typeSolver, methodUsage);\n                    methodUsage = resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                    return Optional.of(methodUsage);\n                } else {\n                    throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\" + name + \"' with parameterTypes \" + argumentsTypes);\n                }\n            }\n        }\n        ResolvedType typeOfScope = JavaParserFacade.get(typeSolver).getType(scope);\n        Map<ResolvedTypeParameterDeclaration, ResolvedType> inferredTypes = new HashMap<>();\n        for (int i = 0; i < argumentsTypes.size(); i++) {\n            ResolvedType originalArgumentType = argumentsTypes.get(i);\n            ResolvedType updatedArgumentType = usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n        for (int i = 0; i < argumentsTypes.size(); i++) {\n            ResolvedType updatedArgumentType = applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n        return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n    } else {\n        Context parentContext = getParent();\n        while (parentContext instanceof MethodCallExprContext || parentContext instanceof ObjectCreationContext) {\n            parentContext = parentContext.getParent();\n        }\n        return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n    }\n}"
    },
    {
      "commit": "09232ff6b0ea19e850482f3a87ac6ef1c063c759",
      "startLine": 20,
      "endLine": 30,
      "methodCode": "@Override\npublic Optional<MethodUsage> solveMethodAsUsage(String name, List<ResolvedType> argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope().isPresent()) {\n        Expression scope = wrappedNode.getScope().get();\n        if (scope instanceof NameExpr) {\n            String className = ((NameExpr) scope).getName().getId();\n            SymbolReference<ResolvedTypeDeclaration> ref = solveType(className, typeSolver);\n            if (ref.isSolved()) {\n                SymbolReference<ResolvedMethodDeclaration> m = MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                if (m.isSolved()) {\n                    MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration());\n                    methodUsage = resolveMethodTypeParametersFromExplicitList(typeSolver, methodUsage);\n                    methodUsage = resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                    return Optional.of(methodUsage);\n                } else {\n                    throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\" + name + \"' with parameterTypes \" + argumentsTypes);\n                }\n            }\n        }\n        ResolvedType typeOfScope = JavaParserFacade.get(typeSolver).getType(scope);\n        Map<ResolvedTypeParameterDeclaration, ResolvedType> inferredTypes = new HashMap<>();\n        for (int i = 0; i < argumentsTypes.size(); i++) {\n            ResolvedType originalArgumentType = argumentsTypes.get(i);\n            ResolvedType updatedArgumentType = usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n        for (int i = 0; i < argumentsTypes.size(); i++) {\n            ResolvedType updatedArgumentType = applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n        return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n    } else {\n        Context parentContext = getParent();\n        while (parentContext instanceof MethodCallExprContext) {\n            parentContext = parentContext.getParent();\n        }\n        return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n    }\n}"
    },
    {
      "commit": "5d8d0cb7947efcf2282f7d056302dd905f348532",
      "startLine": 20,
      "endLine": 30,
      "methodCode": "@Override\npublic Optional<MethodUsage> solveMethodAsUsage(String name, List<ResolvedType> argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope().isPresent()) {\n        Expression scope = wrappedNode.getScope().get();\n        if (scope instanceof NameExpr) {\n            String className = ((NameExpr) scope).getName().getId();\n            SymbolReference<ResolvedTypeDeclaration> ref = solveType(className, typeSolver);\n            if (ref.isSolved()) {\n                SymbolReference<ResolvedMethodDeclaration> m = MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                if (m.isSolved()) {\n                    MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration());\n                    methodUsage = resolveMethodTypeParametersFromExplicitList(typeSolver, methodUsage);\n                    methodUsage = resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                    return Optional.of(methodUsage);\n                } else {\n                    throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\" + name + \"' with parameterTypes \" + argumentsTypes);\n                }\n            }\n        }\n        ResolvedType typeOfScope = JavaParserFacade.get(typeSolver).getType(scope);\n        Map<ResolvedTypeParameterDeclaration, ResolvedType> inferredTypes = new HashMap<>();\n        for (int i = 0; i < argumentsTypes.size(); i++) {\n            ResolvedType originalArgumentType = argumentsTypes.get(i);\n            ResolvedType updatedArgumentType = usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n        for (int i = 0; i < argumentsTypes.size(); i++) {\n            ResolvedType updatedArgumentType = applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n        return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n    } else {\n        Context parentContext = getParent();\n        while (parentContext instanceof MethodCallExprContext) {\n            parentContext = parentContext.getParent();\n        }\n        return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n    }\n}"
    },
    {
      "commit": "dd5c0a00fb9cbd9995d9141907848ec5a3342760",
      "startLine": 20,
      "endLine": 30,
      "methodCode": "@Override\npublic Optional<MethodUsage> solveMethodAsUsage(String name, List<Type> argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope().isPresent()) {\n        Expression scope = wrappedNode.getScope().get();\n        if (scope instanceof NameExpr) {\n            String className = ((NameExpr) scope).getName().getId();\n            SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n            if (ref.isSolved()) {\n                SymbolReference<MethodDeclaration> m = MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                if (m.isSolved()) {\n                    MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration());\n                    methodUsage = resolveMethodTypeParametersFromExplicitList(typeSolver, methodUsage);\n                    methodUsage = resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                    return Optional.of(methodUsage);\n                } else {\n                    throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\" + name + \"' with parameterTypes \" + argumentsTypes);\n                }\n            }\n        }\n        Type typeOfScope = JavaParserFacade.get(typeSolver).getType(scope);\n        Map<TypeParameterDeclaration, Type> inferredTypes = new HashMap<>();\n        for (int i = 0; i < argumentsTypes.size(); i++) {\n            Type originalArgumentType = argumentsTypes.get(i);\n            Type updatedArgumentType = usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n        for (int i = 0; i < argumentsTypes.size(); i++) {\n            Type updatedArgumentType = applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n        return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n    } else {\n        Context parentContext = getParent();\n        while (parentContext instanceof MethodCallExprContext) {\n            parentContext = parentContext.getParent();\n        }\n        return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n    }\n}"
    },
    {
      "commit": "acdac6790f4424f8097b3aa6c888e825cac485f9",
      "startLine": 19,
      "endLine": 29,
      "methodCode": "@Override\npublic Optional<MethodUsage> solveMethodAsUsage(String name, List<Type> argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope().isPresent()) {\n        Expression scope = wrappedNode.getScope().get();\n        if (scope instanceof NameExpr) {\n            String className = ((NameExpr) scope).getName().getId();\n            SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n            if (ref.isSolved()) {\n                SymbolReference<MethodDeclaration> m = MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                if (m.isSolved()) {\n                    MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration());\n                    methodUsage = resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                    return Optional.of(methodUsage);\n                } else {\n                    throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\" + name + \"' with parameterTypes \" + argumentsTypes);\n                }\n            }\n        }\n        Type typeOfScope = JavaParserFacade.get(typeSolver).getType(scope);\n        Map<TypeParameterDeclaration, Type> inferredTypes = new HashMap<>();\n        for (int i = 0; i < argumentsTypes.size(); i++) {\n            Type originalArgumentType = argumentsTypes.get(i);\n            Type updatedArgumentType = usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n        for (int i = 0; i < argumentsTypes.size(); i++) {\n            Type updatedArgumentType = applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n        return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n    } else {\n        Context parentContext = getParent();\n        while (parentContext instanceof MethodCallExprContext) {\n            parentContext = parentContext.getParent();\n        }\n        return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n    }\n}"
    },
    {
      "commit": "17ac5ada0476c72aa79a2e0c39311e90bfa0fe60",
      "startLine": 19,
      "endLine": 29,
      "methodCode": "@Override\npublic Optional<MethodUsage> solveMethodAsUsage(String name, List<Type> argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope().isPresent()) {\n        Expression scope = wrappedNode.getScope().get();\n        if (scope instanceof NameExpr) {\n            String className = ((NameExpr) scope).getName().getId();\n            SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n            if (ref.isSolved()) {\n                SymbolReference<MethodDeclaration> m = MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver, false);\n                if (m.isSolved()) {\n                    MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration());\n                    methodUsage = resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                    return Optional.of(methodUsage);\n                } else {\n                    throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\" + name + \"' with parameterTypes \" + argumentsTypes);\n                }\n            }\n        }\n        Type typeOfScope = JavaParserFacade.get(typeSolver).getType(scope);\n        Map<TypeParameterDeclaration, Type> inferredTypes = new HashMap<>();\n        for (int i = 0; i < argumentsTypes.size(); i++) {\n            Type originalArgumentType = argumentsTypes.get(i);\n            Type updatedArgumentType = usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n        for (int i = 0; i < argumentsTypes.size(); i++) {\n            Type updatedArgumentType = applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n        return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n    } else {\n        Context parentContext = getParent();\n        while (parentContext instanceof MethodCallExprContext) {\n            parentContext = parentContext.getParent();\n        }\n        return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n    }\n}"
    },
    {
      "commit": "065875981b4d1ffa4bf3535d7c89319a4a3345f1",
      "startLine": 19,
      "endLine": 29,
      "methodCode": "@Override\npublic Optional<MethodUsage> solveMethodAsUsage(String name, List<Type> argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope().isPresent()) {\n        Expression scope = wrappedNode.getScope().get();\n        if (scope instanceof NameExpr) {\n            String className = ((NameExpr) scope).getName().getId();\n            SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n            if (ref.isSolved()) {\n                SymbolReference<MethodDeclaration> m = MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                if (m.isSolved()) {\n                    MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration());\n                    methodUsage = resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                    return Optional.of(methodUsage);\n                } else {\n                    throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\" + name + \"' with parameterTypes \" + argumentsTypes);\n                }\n            }\n        }\n        Type typeOfScope = JavaParserFacade.get(typeSolver).getType(scope);\n        Map<TypeParameterDeclaration, Type> inferredTypes = new HashMap<>();\n        for (int i = 0; i < argumentsTypes.size(); i++) {\n            Type originalArgumentType = argumentsTypes.get(i);\n            Type updatedArgumentType = usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n        for (int i = 0; i < argumentsTypes.size(); i++) {\n            Type updatedArgumentType = applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n        return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n    } else {\n        Context parentContext = getParent();\n        while (parentContext instanceof MethodCallExprContext) {\n            parentContext = parentContext.getParent();\n        }\n        return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n    }\n}"
    },
    {
      "commit": "6e1380f412d334f1c887d15edf0b4610c3cf0da2",
      "startLine": 18,
      "endLine": 28,
      "methodCode": "@Override\npublic Optional<MethodUsage> solveMethodAsUsage(String name, List<Type> argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() != null) {\n        if (wrappedNode.getScope() instanceof NameExpr) {\n            String className = ((NameExpr) wrappedNode.getScope()).getName().getId();\n            SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n            if (ref.isSolved()) {\n                SymbolReference<MethodDeclaration> m = MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                if (m.isSolved()) {\n                    MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration());\n                    methodUsage = resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                    return Optional.of(methodUsage);\n                } else {\n                    throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\" + name + \"' with parameterTypes \" + argumentsTypes);\n                }\n            }\n        }\n        Type typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n        Map<TypeParameterDeclaration, Type> inferredTypes = new HashMap<>();\n        for (int i = 0; i < argumentsTypes.size(); i++) {\n            Type originalArgumentType = argumentsTypes.get(i);\n            Type updatedArgumentType = usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n        for (int i = 0; i < argumentsTypes.size(); i++) {\n            Type updatedArgumentType = applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n        return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n    } else {\n        Context parentContext = getParent();\n        while (parentContext instanceof MethodCallExprContext) {\n            parentContext = parentContext.getParent();\n        }\n        return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n    }\n}"
    },
    {
      "commit": "ca3e3a946698cf3a4f93e6fb7b4d2b16ee2e3ed5",
      "startLine": 18,
      "endLine": 28,
      "methodCode": "@Override\npublic Optional<MethodUsage> solveMethodAsUsage(String name, List<Type> argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() != null) {\n        if (wrappedNode.getScope() instanceof NameExpr) {\n            String className = ((NameExpr) wrappedNode.getScope()).getName();\n            SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n            if (ref.isSolved()) {\n                SymbolReference<MethodDeclaration> m = MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                if (m.isSolved()) {\n                    MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration());\n                    methodUsage = resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                    return Optional.of(methodUsage);\n                } else {\n                    throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\" + name + \"' with parameterTypes \" + argumentsTypes);\n                }\n            }\n        }\n        Type typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n        Map<TypeParameterDeclaration, Type> inferredTypes = new HashMap<>();\n        for (int i = 0; i < argumentsTypes.size(); i++) {\n            Type originalArgumentType = argumentsTypes.get(i);\n            Type updatedArgumentType = usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n        for (int i = 0; i < argumentsTypes.size(); i++) {\n            Type updatedArgumentType = applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n        return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n    } else {\n        Context parentContext = getParent();\n        while (parentContext instanceof MethodCallExprContext) {\n            parentContext = parentContext.getParent();\n        }\n        return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n    }\n}"
    },
    {
      "commit": "03055f925053b3970b9d14cce3a3b9a0d002366d",
      "startLine": 18,
      "endLine": 28,
      "methodCode": "@Override\npublic Optional<MethodUsage> solveMethodAsUsage(String name, List<Type> argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope().isPresent()) {\n        if (wrappedNode.getScope().get() instanceof NameExpr) {\n            String className = ((NameExpr) wrappedNode.getScope().get()).getName();\n            SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n            if (ref.isSolved()) {\n                SymbolReference<MethodDeclaration> m = MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                if (m.isSolved()) {\n                    MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration());\n                    methodUsage = resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                    return Optional.of(methodUsage);\n                } else {\n                    throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\" + name + \"' with parameterTypes \" + argumentsTypes);\n                }\n            }\n        }\n        Type typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n        Map<TypeParameterDeclaration, Type> inferredTypes = new HashMap<>();\n        for (int i = 0; i < argumentsTypes.size(); i++) {\n            Type originalArgumentType = argumentsTypes.get(i);\n            Type updatedArgumentType = usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n        for (int i = 0; i < argumentsTypes.size(); i++) {\n            Type updatedArgumentType = applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n        return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n    } else {\n        Context parentContext = getParent();\n        while (parentContext instanceof MethodCallExprContext) {\n            parentContext = parentContext.getParent();\n        }\n        return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n    }\n}"
    },
    {
      "commit": "a1c7c58143a592965f8378767adc69709e4c0043",
      "startLine": 18,
      "endLine": 28,
      "methodCode": "@Override\npublic Optional<MethodUsage> solveMethodAsUsage(String name, List<Type> argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope().isPresent()) {\n        if (wrappedNode.getScope().get() instanceof NameExpr) {\n            String className = ((NameExpr) wrappedNode.getScope().get()).getName();\n            SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n            if (ref.isSolved()) {\n                SymbolReference<MethodDeclaration> m = MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                if (m.isSolved()) {\n                    MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration());\n                    methodUsage = resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                    return Optional.of(methodUsage);\n                } else {\n                    throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\" + name + \"' with parameterTypes \" + argumentsTypes);\n                }\n            }\n        }\n        Type typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n        Map<TypeParameterDeclaration, Type> inferredTypes = new HashMap<>();\n        for (int i = 0; i < argumentsTypes.size(); i++) {\n            Type originalArgumentType = argumentsTypes.get(i);\n            Type updatedArgumentType = usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n        for (int i = 0; i < argumentsTypes.size(); i++) {\n            Type updatedArgumentType = applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n        return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n    } else {\n        Context parentContext = getParent();\n        while (parentContext instanceof MethodCallExprContext) {\n            parentContext = parentContext.getParent();\n        }\n        return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n    }\n}"
    },
    {
      "commit": "6df1aa26f75ff0d716a1290007e2b63cc05001ae",
      "startLine": 18,
      "endLine": 28,
      "methodCode": "@Override\npublic Optional<MethodUsage> solveMethodAsUsage(String name, List<Type> argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope().isPresent()) {\n        if (wrappedNode.getScope().get() instanceof NameExpr) {\n            String className = ((NameExpr) wrappedNode.getScope().get()).getName();\n            SymbolReference<ReferenceTypeDeclaration> ref = solveType(className, typeSolver);\n            if (ref.isSolved()) {\n                SymbolReference<MethodDeclaration> m = MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                if (m.isSolved()) {\n                    MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration());\n                    methodUsage = resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                    return Optional.of(methodUsage);\n                } else {\n                    throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\" + name + \"' with parameterTypes \" + argumentsTypes);\n                }\n            }\n        }\n        Type typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n        Map<TypeParameterDeclaration, Type> inferredTypes = new HashMap<>();\n        for (int i = 0; i < argumentsTypes.size(); i++) {\n            Type originalArgumentType = argumentsTypes.get(i);\n            Type updatedArgumentType = usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n        for (int i = 0; i < argumentsTypes.size(); i++) {\n            Type updatedArgumentType = applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n        return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n    } else {\n        Context parentContext = getParent();\n        while (parentContext instanceof MethodCallExprContext) {\n            parentContext = parentContext.getParent();\n        }\n        return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n    }\n}"
    },
    {
      "commit": "d017fb8caf6ccb3343da0062eb2c85262712772c",
      "startLine": 18,
      "endLine": 28,
      "methodCode": "@Override\npublic Optional<MethodUsage> solveMethodAsUsage(String name, List<Type> argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope().isPresent()) {\n        if (wrappedNode.getScope().get() instanceof NameExpr) {\n            String className = ((NameExpr) wrappedNode.getScope().get()).getName();\n            SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n            if (ref.isSolved()) {\n                SymbolReference<MethodDeclaration> m = MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                if (m.isSolved()) {\n                    MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration());\n                    methodUsage = resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                    return Optional.of(methodUsage);\n                } else {\n                    throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\" + name + \"' with parameterTypes \" + argumentsTypes);\n                }\n            }\n        }\n        Type typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n        Map<TypeParameterDeclaration, Type> inferredTypes = new HashMap<>();\n        for (int i = 0; i < argumentsTypes.size(); i++) {\n            Type originalArgumentType = argumentsTypes.get(i);\n            Type updatedArgumentType = usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n        for (int i = 0; i < argumentsTypes.size(); i++) {\n            Type updatedArgumentType = applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n        return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n    } else {\n        Context parentContext = getParent();\n        while (parentContext instanceof MethodCallExprContext) {\n            parentContext = parentContext.getParent();\n        }\n        return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n    }\n}"
    },
    {
      "commit": "2082034e8c3eb434e3df25dd420c98cae5a6d518",
      "startLine": 18,
      "endLine": 25,
      "methodCode": "@Override\npublic Optional<MethodUsage> solveMethodAsUsage(String name, List<Type> argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope().isPresent()) {\n        if (wrappedNode.getScope().get() instanceof NameExpr) {\n            String className = ((NameExpr) wrappedNode.getScope().get()).getName();\n            SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n            if (ref.isSolved()) {\n                SymbolReference<MethodDeclaration> m = MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                if (m.isSolved()) {\n                    MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration());\n                    methodUsage = resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                    return Optional.of(methodUsage);\n                } else {\n                    throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\" + name + \"' with parameterTypes \" + argumentsTypes);\n                }\n            }\n        }\n        Type typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n        Map<TypeParameterDeclaration, Type> inferredTypes = new HashMap<>();\n        for (int i = 0; i < argumentsTypes.size(); i++) {\n            argumentsTypes.set(i, usingParameterTypesFromScope(typeOfScope, argumentsTypes.get(i), inferredTypes));\n        }\n        for (int i = 0; i < argumentsTypes.size(); i++) {\n            argumentsTypes.set(i, applyInferredTypes(argumentsTypes.get(i), inferredTypes));\n        }\n        return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n    } else {\n        Context parentContext = getParent();\n        while (parentContext instanceof MethodCallExprContext) {\n            parentContext = parentContext.getParent();\n        }\n        return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n    }\n}"
    },
    {
      "commit": "13d789de30e6c3d29efb17a2acdff443f8c48db1",
      "startLine": 18,
      "endLine": 21,
      "methodCode": "@Override\npublic Optional<MethodUsage> solveMethodAsUsage(String name, List<Type> argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope().isPresent()) {\n        if (wrappedNode.getScope().get() instanceof NameExpr) {\n            String className = ((NameExpr) wrappedNode.getScope().get()).getName();\n            SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n            if (ref.isSolved()) {\n                SymbolReference<MethodDeclaration> m = MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                if (m.isSolved()) {\n                    MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration());\n                    methodUsage = resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                    return Optional.of(methodUsage);\n                } else {\n                    throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\" + name + \"' with parameterTypes \" + argumentsTypes);\n                }\n            }\n        }\n        Type typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n        for (int i = 0; i < argumentsTypes.size(); i++) {\n            argumentsTypes.set(i, usingParameterTypesFromScope(typeOfScope, argumentsTypes.get(i)));\n        }\n        return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n    } else {\n        Context parentContext = getParent();\n        while (parentContext instanceof MethodCallExprContext) {\n            parentContext = parentContext.getParent();\n        }\n        return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n    }\n}"
    },
    {
      "commit": "9c53c2cbc607ea694438ade8630be0c155a33162",
      "startLine": 5,
      "endLine": 8,
      "methodCode": "@Override\npublic Optional<MethodUsage> solveMethodAsUsage(String name, List<Type> argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope().isPresent()) {\n        try {\n            Type typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n            for (int i = 0; i < argumentsTypes.size(); i++) {\n                argumentsTypes.set(i, usingParameterTypesFromScope(typeOfScope, argumentsTypes.get(i)));\n            }\n            return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n        } catch (UnsolvedSymbolException e) {\n            if (wrappedNode.getScope().get() instanceof NameExpr) {\n                String className = ((NameExpr) wrappedNode.getScope().get()).getName();\n                SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference<MethodDeclaration> m = MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                    if (m.isSolved()) {\n                        MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration());\n                        methodUsage = resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                        return Optional.of(methodUsage);\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\" + name + \"' with parameterTypes \" + argumentsTypes);\n                    }\n                } else {\n                    throw e;\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else {\n        Context parentContext = getParent();\n        while (parentContext instanceof MethodCallExprContext) {\n            parentContext = parentContext.getParent();\n        }\n        return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n    }\n}"
    },
    {
      "commit": "03e407957d600a18ef0a4a83224c17d155ef8645",
      "startLine": 5,
      "endLine": 8,
      "methodCode": "@Override\npublic Optional<MethodUsage> solveMethodAsUsage(String name, List<Type> argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope().isPresent()) {\n        try {\n            Type typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n            for (int i = 0; i < argumentsTypes.size(); i++) {\n                argumentsTypes.set(i, usingParameterTypesFromScope(typeOfScope, argumentsTypes.get(i)));\n            }\n            return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n        } catch (UnsolvedSymbolException e) {\n            if (wrappedNode.getScope().get() instanceof NameExpr) {\n                String className = ((NameExpr) wrappedNode.getScope().get()).getName();\n                SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference<MethodDeclaration> m = MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                    if (m.isSolved()) {\n                        MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration());\n                        methodUsage = resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                        return Optional.of(methodUsage);\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\" + name + \"' with parameterTypes \" + argumentsTypes);\n                    }\n                } else {\n                    throw e;\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else {\n        Context parentContext = getParent();\n        while (parentContext instanceof MethodCallExprContext) {\n            parentContext = parentContext.getParent();\n        }\n        return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n    }\n}"
    },
    {
      "commit": "341e081a5f8909a3a467671befcca2941b786d3d",
      "startLine": 5,
      "endLine": 8,
      "methodCode": "@Override\npublic Optional<MethodUsage> solveMethodAsUsage(String name, List<Type> argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() != null) {\n        try {\n            Type typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n            for (int i = 0; i < argumentsTypes.size(); i++) {\n                argumentsTypes.set(i, usingParameterTypesFromScope(typeOfScope, argumentsTypes.get(i)));\n            }\n            return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n        } catch (UnsolvedSymbolException e) {\n            if (wrappedNode.getScope().get() instanceof NameExpr) {\n                String className = ((NameExpr) wrappedNode.getScope().get()).getName();\n                SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference<MethodDeclaration> m = MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                    if (m.isSolved()) {\n                        MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration());\n                        methodUsage = resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                        return Optional.of(methodUsage);\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\" + name + \"' with parameterTypes \" + argumentsTypes);\n                    }\n                } else {\n                    throw e;\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else {\n        Context parentContext = getParent();\n        while (parentContext instanceof MethodCallExprContext) {\n            parentContext = parentContext.getParent();\n        }\n        return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n    }\n}"
    },
    {
      "commit": "88db8b2a8b93bcc692cb8fd5085ba68b8bcf1968",
      "startLine": 5,
      "endLine": 8,
      "methodCode": "@Override\npublic Optional<MethodUsage> solveMethodAsUsage(String name, List<Type> argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() != null) {\n        try {\n            Type typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            for (int i = 0; i < argumentsTypes.size(); i++) {\n                argumentsTypes.set(i, usingParameterTypesFromScope(typeOfScope, argumentsTypes.get(i)));\n            }\n            return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n        } catch (UnsolvedSymbolException e) {\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                String className = ((NameExpr) wrappedNode.getScope()).getName();\n                SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference<MethodDeclaration> m = MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                    if (m.isSolved()) {\n                        MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration());\n                        methodUsage = resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                        return Optional.of(methodUsage);\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\" + name + \"' with parameterTypes \" + argumentsTypes);\n                    }\n                } else {\n                    throw e;\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else {\n        Context parentContext = getParent();\n        while (parentContext instanceof MethodCallExprContext) {\n            parentContext = parentContext.getParent();\n        }\n        return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n    }\n}"
    },
    {
      "commit": "656bb37a1dba87d61d24e69f2346f35dbc73d81d",
      "startLine": 5,
      "endLine": 8,
      "methodCode": "@Override\npublic Optional<MethodUsage> solveMethodAsUsage(String name, List<Type> parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() != null) {\n        try {\n            Type typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            for (int i = 0; i < parameterTypes.size(); i++) {\n                parameterTypes.set(i, usingParameterTypesFromScope(typeOfScope, parameterTypes.get(i)));\n            }\n            return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n        } catch (UnsolvedSymbolException e) {\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                String className = ((NameExpr) wrappedNode.getScope()).getName();\n                SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference<MethodDeclaration> m = MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, parameterTypes, typeSolver);\n                    if (m.isSolved()) {\n                        MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration());\n                        methodUsage = resolveMethodTypeParameters(methodUsage, parameterTypes);\n                        return Optional.of(methodUsage);\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\" + name + \"' with parameterTypes \" + parameterTypes);\n                    }\n                } else {\n                    throw e;\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else {\n        Context parentContext = getParent();\n        while (parentContext instanceof MethodCallExprContext) {\n            parentContext = parentContext.getParent();\n        }\n        return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n    }\n}"
    },
    {
      "commit": "8d234965b572759181da7787fead07b225e9e5ca",
      "startLine": 5,
      "endLine": 8,
      "methodCode": "@Override\npublic Optional<MethodUsage> solveMethodAsUsage(String name, List<Type> parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() != null) {\n        try {\n            Type typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            for (int i = 0; i < parameterTypes.size(); i++) {\n                parameterTypes.set(i, usingParameterTypesFromScope(typeOfScope, parameterTypes.get(i)));\n            }\n            return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n        } catch (UnsolvedSymbolException e) {\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                String className = ((NameExpr) wrappedNode.getScope()).getName();\n                SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference<MethodDeclaration> m = ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes);\n                    if (m.isSolved()) {\n                        MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration());\n                        methodUsage = resolveMethodTypeParameters(methodUsage, parameterTypes);\n                        return Optional.of(methodUsage);\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\" + name + \"' with parameterTypes \" + parameterTypes);\n                    }\n                } else {\n                    throw e;\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else {\n        Context parentContext = getParent();\n        while (parentContext instanceof MethodCallExprContext) {\n            parentContext = parentContext.getParent();\n        }\n        return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n    }\n}"
    },
    {
      "commit": "82eb44707b620803d424188a1eb8708fcaf093cb",
      "startLine": 5,
      "endLine": 8,
      "methodCode": "@Override\npublic Optional<MethodUsage> solveMethodAsUsage(String name, List<Type> parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() != null) {\n        try {\n            Type typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            for (int i = 0; i < parameterTypes.size(); i++) {\n                parameterTypes.set(i, usingParameterTypesFromScope(typeOfScope, parameterTypes.get(i)));\n            }\n            return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n        } catch (UnsolvedSymbolException e) {\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                String className = ((NameExpr) wrappedNode.getScope()).getName();\n                SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference<MethodDeclaration> m = ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes);\n                    if (m.isSolved()) {\n                        MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration(), typeSolver);\n                        methodUsage = resolveMethodTypeParameters(methodUsage, parameterTypes);\n                        return Optional.of(methodUsage);\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\" + name + \"' with parameterTypes \" + parameterTypes);\n                    }\n                } else {\n                    throw e;\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else {\n        Context parentContext = getParent();\n        while (parentContext instanceof MethodCallExprContext) {\n            parentContext = parentContext.getParent();\n        }\n        return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n    }\n}"
    },
    {
      "commit": "38d780df85a22c9baffb1f772a45b063cad73aab",
      "startLine": 5,
      "endLine": 8,
      "methodCode": "@Override\npublic Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() != null) {\n        try {\n            TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            for (int i = 0; i < parameterTypes.size(); i++) {\n                parameterTypes.set(i, usingParameterTypesFromScope(typeOfScope, parameterTypes.get(i)));\n            }\n            return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n        } catch (UnsolvedSymbolException e) {\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                String className = ((NameExpr) wrappedNode.getScope()).getName();\n                SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference<MethodDeclaration> m = ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes);\n                    if (m.isSolved()) {\n                        MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration(), typeSolver);\n                        methodUsage = resolveMethodTypeParameters(methodUsage, parameterTypes);\n                        return Optional.of(methodUsage);\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\" + name + \"' with parameterTypes \" + parameterTypes);\n                    }\n                } else {\n                    throw e;\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else {\n        Context parentContext = getParent();\n        while (parentContext instanceof MethodCallExprContext) {\n            parentContext = parentContext.getParent();\n        }\n        return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n    }\n}"
    },
    {
      "commit": "d36b028172c0a183a0f32f66d2c5dff6f4b1dd76",
      "startLine": 5,
      "endLine": 5,
      "methodCode": "@Override\npublic Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() != null) {\n        try {\n            TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n        } catch (UnsolvedSymbolException e) {\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                String className = ((NameExpr) wrappedNode.getScope()).getName();\n                SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference<MethodDeclaration> m = ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes);\n                    if (m.isSolved()) {\n                        MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration(), typeSolver);\n                        methodUsage = resolveMethodTypeParameters(methodUsage, parameterTypes);\n                        return Optional.of(methodUsage);\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\" + name + \"' with parameterTypes \" + parameterTypes);\n                    }\n                } else {\n                    throw e;\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else {\n        Context parentContext = getParent();\n        while (parentContext instanceof MethodCallExprContext) {\n            parentContext = parentContext.getParent();\n        }\n        return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n    }\n}"
    },
    {
      "commit": "8e655d386a595ea1927ebeded58939d7b8a7ce0c",
      "startLine": 5,
      "endLine": 5,
      "methodCode": "@Override\npublic Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() != null) {\n        try {\n            TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n        } catch (UnsolvedSymbolException e) {\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                String className = ((NameExpr) wrappedNode.getScope()).getName();\n                SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference<MethodDeclaration> m = ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes);\n                    if (m.isSolved()) {\n                        MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration(), typeSolver);\n                        methodUsage = resolveMethodTypeParameters(methodUsage, parameterTypes);\n                        return Optional.of(methodUsage);\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\" + name + \"' with parameterTypes \" + parameterTypes);\n                    }\n                } else {\n                    throw e;\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else {\n        if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr parent = (MethodCallExpr) wrappedNode.getParentNode();\n            if (parent.getScope() == wrappedNode) {\n                return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n            }\n        }\n        Context parentContext = getParent();\n        return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n    }\n}"
    },
    {
      "commit": "ead147279ca0b84d2f479a714943b20cd689e7c7",
      "startLine": 5,
      "endLine": 5,
      "methodCode": "@Override\npublic Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() != null) {\n        try {\n            TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n        } catch (UnsolvedSymbolException e) {\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                String className = ((NameExpr) wrappedNode.getScope()).getName();\n                SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference<MethodDeclaration> m = ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes);\n                    if (m.isSolved()) {\n                        MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration(), typeSolver);\n                        methodUsage = resolveMethodTypeParameters(methodUsage, parameterTypes);\n                        return Optional.of(methodUsage);\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\" + name + \"' with parameterTypes \" + parameterTypes);\n                    }\n                } else {\n                    throw e;\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else {\n        if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr parent = (MethodCallExpr) wrappedNode.getParentNode();\n            if (parent.getScope() == wrappedNode) {\n                return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n            }\n        }\n        Context parentContext = getParent();\n        return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n    }\n}"
    },
    {
      "commit": "f4b07b1a2deac6d1b562424ac2380b92cec77a90",
      "startLine": 5,
      "endLine": 5,
      "methodCode": "@Override\npublic Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() != null) {\n        try {\n            TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n        } catch (UnsolvedSymbolException e) {\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                String className = ((NameExpr) wrappedNode.getScope()).getName();\n                SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference<MethodDeclaration> m = ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes);\n                    if (m.isSolved()) {\n                        return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\" + name + \"' with parameterTypes \" + parameterTypes);\n                    }\n                } else {\n                    throw e;\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else {\n        if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr parent = (MethodCallExpr) wrappedNode.getParentNode();\n            if (parent.getScope() == wrappedNode) {\n                return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n            }\n        }\n        Context parentContext = getParent();\n        return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n    }\n}"
    },
    {
      "commit": "e21fca16e413a8bf31d613aa97a744d075c374dd",
      "startLine": 5,
      "endLine": 5,
      "methodCode": "@Override\npublic Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() != null) {\n        try {\n            TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n        } catch (UnsolvedSymbolException e) {\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                String className = ((NameExpr) wrappedNode.getScope()).getName();\n                SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference<MethodDeclaration> m = ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes);\n                    if (m.isSolved()) {\n                        return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\" + name + \"' with parameterTypes \" + parameterTypes);\n                    }\n                } else {\n                    throw e;\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else {\n        if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr parent = (MethodCallExpr) wrappedNode.getParentNode();\n            if (parent.getScope() == wrappedNode) {\n                return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n            }\n        }\n        Context parentContext = getParent();\n        return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n    }\n}"
    },
    {
      "commit": "0e81f51c40996b42cb262dc2397126cee8f60965",
      "startLine": 5,
      "endLine": 5,
      "methodCode": "@Override\npublic Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() != null) {\n        try {\n            TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n        } catch (UnsolvedSymbolException e) {\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                String className = ((NameExpr) wrappedNode.getScope()).getName();\n                SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference<MethodDeclaration> m = ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n                    if (m.isSolved()) {\n                        return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\" + name + \"' with parameterTypes \" + parameterTypes);\n                    }\n                } else {\n                    throw e;\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else {\n        if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr parent = (MethodCallExpr) wrappedNode.getParentNode();\n            if (parent.getScope() == wrappedNode) {\n                return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n            }\n        }\n        Context parentContext = getParent();\n        return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n    }\n}"
    },
    {
      "commit": "b36f33050149a62a5b3c8c7451ae93f736715029",
      "startLine": 5,
      "endLine": 5,
      "methodCode": "@Override\npublic Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() != null) {\n        try {\n            TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n        } catch (UnsolvedSymbolException e) {\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                String className = ((NameExpr) wrappedNode.getScope()).getName();\n                SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference<MethodDeclaration> m = ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n                    if (m.isSolved()) {\n                        return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\" + name + \"' with parameterTypes \" + parameterTypes);\n                    }\n                } else {\n                    throw e;\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else {\n        if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr parent = (MethodCallExpr) wrappedNode.getParentNode();\n            if (parent.getScope() == wrappedNode) {\n                return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n            }\n        }\n        Context parentContext = getParent();\n        return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n    }\n}"
    },
    {
      "commit": "640eb2479a4e05bb8ee0d95f74172be9dfa283f6",
      "startLine": 5,
      "endLine": 5,
      "methodCode": "@Override\npublic Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() != null) {\n        try {\n            TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n        } catch (UnsolvedSymbolException e) {\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                String className = ((NameExpr) wrappedNode.getScope()).getName();\n                SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference<MethodDeclaration> m = ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n                    if (m.isSolved()) {\n                        return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\" + name + \"' with parameterTypes \" + parameterTypes);\n                    }\n                } else {\n                    throw e;\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else {\n        if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr parent = (MethodCallExpr) wrappedNode.getParentNode();\n            if (parent.getScope() == wrappedNode) {\n                return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n            }\n        }\n        Context parentContext = getParent();\n        return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n    }\n}"
    },
    {
      "commit": "f821be8dfe72fcd3f4e14f75420617b87ddb8689",
      "startLine": 8,
      "endLine": 8,
      "methodCode": "@Override\npublic Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n    if (name.equals(\"cloneNodes\")) {\n        System.out.println(\"FOO\");\n    }\n    if (wrappedNode.getScope() != null) {\n        try {\n            TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n        } catch (UnsolvedSymbolException e) {\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                String className = ((NameExpr) wrappedNode.getScope()).getName();\n                SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference<MethodDeclaration> m = ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n                    if (m.isSolved()) {\n                        return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\" + name + \"' with parameterTypes \" + parameterTypes);\n                    }\n                } else {\n                    throw e;\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else {\n        if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr parent = (MethodCallExpr) wrappedNode.getParentNode();\n            if (parent.getScope() == wrappedNode) {\n                return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n            }\n        }\n        Context parentContext = getParent();\n        return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n    }\n}"
    },
    {
      "commit": "1ae290f6f5e0c7ba62eab797aba22308957b9257",
      "startLine": 5,
      "endLine": 5,
      "methodCode": "@Override\npublic Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() != null) {\n        try {\n            TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n        } catch (UnsolvedSymbolException e) {\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                String className = ((NameExpr) wrappedNode.getScope()).getName();\n                SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    if (name.equals(\"getModifiers\") && !ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver).isSolved()) {\n                        System.out.println(\"FOO\");\n                    }\n                    SymbolReference<MethodDeclaration> m = ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n                    if (m.isSolved()) {\n                        return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\" + name + \"' with parameterTypes \" + parameterTypes);\n                    }\n                } else {\n                    throw e;\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else {\n        if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr parent = (MethodCallExpr) wrappedNode.getParentNode();\n            if (parent.getScope() == wrappedNode) {\n                return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n            }\n        }\n        Context parentContext = getParent();\n        return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n    }\n}"
    },
    {
      "commit": "c08a0391fd27b2ecc75a264cce9eb4606d0f7b30",
      "startLine": 5,
      "endLine": 5,
      "methodCode": "@Override\npublic Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() != null) {\n        try {\n            TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n        } catch (UnsolvedSymbolException e) {\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                String className = ((NameExpr) wrappedNode.getScope()).getName();\n                SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    if (name.equals(\"getModifiers\") && !ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver).isSolved()) {\n                        System.out.println(\"FOO\");\n                    }\n                    SymbolReference<MethodDeclaration> m = ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n                    if (m.isSolved()) {\n                        return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \" + name + \" with parameterTypes \" + parameterTypes);\n                    }\n                } else {\n                    throw e;\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else {\n        if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr parent = (MethodCallExpr) wrappedNode.getParentNode();\n            if (parent.getScope() == wrappedNode) {\n                return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n            }\n        }\n        Context parentContext = getParent();\n        return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n    }\n}"
    },
    {
      "commit": "6a15cd55028fc9b7c73158d05f5ee335cab1f481",
      "startLine": 5,
      "endLine": 5,
      "methodCode": "@Override\npublic Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() != null) {\n        try {\n            TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n        } catch (UnsolvedSymbolException e) {\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                String className = ((NameExpr) wrappedNode.getScope()).getName();\n                SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference<MethodDeclaration> m = ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n                    if (m.isSolved()) {\n                        return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \" + name + \" with parameterTypes \" + parameterTypes);\n                    }\n                } else {\n                    throw e;\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else {\n        if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr parent = (MethodCallExpr) wrappedNode.getParentNode();\n            if (parent.getScope() == wrappedNode) {\n                return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n            }\n        }\n        Context parentContext = getParent();\n        return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n    }\n}"
    },
    {
      "commit": "46aefdd68f2f2597a19b72da36681123cb3090e6",
      "startLine": 5,
      "endLine": 5,
      "methodCode": "@Override\npublic Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() != null) {\n        try {\n            TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n        } catch (UnsolvedSymbolException e) {\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                String className = ((NameExpr) wrappedNode.getScope()).getName();\n                SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference<MethodDeclaration> m = ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n                    if (m.isSolved()) {\n                        return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                    }\n                }\n            }\n            throw e;\n        }\n    } else {\n        if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr parent = (MethodCallExpr) wrappedNode.getParentNode();\n            if (parent.getScope() == wrappedNode) {\n                return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n            }\n        }\n        Context parentContext = getParent();\n        return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n    }\n}"
    },
    {
      "commit": "6c297529e31036058837adbaa57cee652d4cc918",
      "startLine": 5,
      "endLine": 5,
      "methodCode": "@Override\npublic Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() != null) {\n        try {\n            TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n        } catch (UnsolvedSymbolException e) {\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                String className = ((NameExpr) wrappedNode.getScope()).getName();\n                SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference<MethodDeclaration> m = ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n                    if (m.isSolved()) {\n                        return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                    }\n                }\n            }\n            throw e;\n        }\n    } else {\n        return getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n    }\n}"
    },
    {
      "commit": "7b2a0b366461674aa6320b11a38a17909d8a74a3",
      "startLine": 5,
      "endLine": 5,
      "methodCode": "@Override\npublic Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() != null) {\n        try {\n            TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n        } catch (UnsolvedSymbolException e) {\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                String className = ((NameExpr) wrappedNode.getScope()).getName();\n                SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference<MethodDeclaration> m = ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n                    if (m.isSolved()) {\n                        return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                    }\n                }\n            }\n            throw e;\n        }\n    } else {\n        TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n    }\n}"
    },
    {
      "commit": "be64d2e61b56eafd01abc7236a7a0dcd6ce6dafd",
      "startLine": 4,
      "endLine": 4,
      "methodCode": "@Override\npublic Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() != null) {\n        TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n        return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n    } else {\n        TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n    }\n}"
    },
    {
      "commit": "850c0caa4c64df32d5fc44a5512d6d41f4534a08",
      "startLine": 4,
      "endLine": 4,
      "methodCode": "@Override\npublic Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() != null) {\n        TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n        return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n    } else {\n        TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n    }\n}"
    },
    {
      "commit": "df3e1a46a12fcc1ecafc00e59e7b7481c28ce731",
      "startLine": 4,
      "endLine": 4,
      "methodCode": "@Override\npublic Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() != null) {\n        TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n        return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n    } else {\n        throw new UnsupportedOperationException();\n    }\n}"
    },
    {
      "commit": "627b56302d259409e9bc50b20d77803484f18b5c",
      "startLine": 4,
      "endLine": 4,
      "methodCode": "@Override\npublic Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() != null) {\n        TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n        return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver);\n    } else {\n        throw new UnsupportedOperationException();\n    }\n}"
    },
    {
      "commit": "fd2e083224d3ee0e9ccca4431d63a84601e0d606",
      "startLine": 4,
      "endLine": 4,
      "methodCode": "@Override\npublic Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() != null) {\n        TypeUsage typeOfScope = new JavaParserFacade(typeSolver).getType(wrappedNode.getScope());\n        return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver);\n    } else {\n        throw new UnsupportedOperationException();\n    }\n}"
    }
  ]
}