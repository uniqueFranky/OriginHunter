{
  "statementVersions": [
    {
      "commit": "f5c6d3c8d9fa2158734858fa0a7ac917c384cb97",
      "startLine": 5,
      "endLine": 20,
      "methodCode": "    @cached_property\n    def changed_data(self):\n        data = []\n        for name, field in self.fields.items():\n            prefixed_name = self.add_prefix(name)\n            data_value = field.widget.value_from_datadict(self.data, self.files, prefixed_name)\n            if not field.show_hidden_initial:\n                # Use the BoundField's initial as this is the value passed to\n                # the widget.\n                initial_value = self[name].initial\n            else:\n                initial_prefixed_name = self.add_initial_prefix(name)\n                hidden_widget = field.hidden_widget()\n                try:\n                    initial_value = field.to_python(hidden_widget.value_from_datadict(\n                        self.data, self.files, initial_prefixed_name))\n                except ValidationError:\n                    # Always assume data has changed if validation fails.\n                    data.append(name)\n                    continue\n            if field.has_changed(initial_value, data_value):\n                data.append(name)\n        return data\n"
    },
    {
      "commit": "c6c00fbfbb659de4beaad3c612c271ac74f892a7",
      "startLine": 5,
      "endLine": 20,
      "methodCode": "    @cached_property\n    def changed_data(self):\n        data = []\n        for name, field in self.fields.items():\n            prefixed_name = self.add_prefix(name)\n            data_value = field.widget.value_from_datadict(self.data, self.files, prefixed_name)\n            if not field.show_hidden_initial:\n                initial_value = self.initial.get(name, field.initial)\n                if callable(initial_value):\n                    initial_value = initial_value()\n            else:\n                initial_prefixed_name = self.add_initial_prefix(name)\n                hidden_widget = field.hidden_widget()\n                try:\n                    initial_value = field.to_python(hidden_widget.value_from_datadict(\n                        self.data, self.files, initial_prefixed_name))\n                except ValidationError:\n                    # Always assume data has changed if validation fails.\n                    data.append(name)\n                    continue\n            if field.has_changed(initial_value, data_value):\n                data.append(name)\n        return data\n"
    },
    {
      "commit": "deed00c0d803d324a3dfdeba52458b6b009c1a90",
      "startLine": 12,
      "endLine": 27,
      "methodCode": "    @property\n    def changed_data(self):\n        if self._changed_data is None:\n            self._changed_data = []\n            # XXX: For now we're asking the individual fields whether or not the\n            # data has changed. It would probably be more efficient to hash the\n            # initial data, store it in a hidden field, and compare a hash of the\n            # submitted data, but we'd need a way to easily get the string value\n            # for a given field. Right now, that logic is embedded in the render\n            # method of each widget.\n            for name, field in self.fields.items():\n                prefixed_name = self.add_prefix(name)\n                data_value = field.widget.value_from_datadict(self.data, self.files, prefixed_name)\n                if not field.show_hidden_initial:\n                    initial_value = self.initial.get(name, field.initial)\n                    if callable(initial_value):\n                        initial_value = initial_value()\n                else:\n                    initial_prefixed_name = self.add_initial_prefix(name)\n                    hidden_widget = field.hidden_widget()\n                    try:\n                        initial_value = field.to_python(hidden_widget.value_from_datadict(\n                            self.data, self.files, initial_prefixed_name))\n                    except ValidationError:\n                        # Always assume data has changed if validation fails.\n                        self._changed_data.append(name)\n                        continue\n                if field.has_changed(initial_value, data_value):\n                    self._changed_data.append(name)\n        return self._changed_data\n"
    },
    {
      "commit": "d74e33eb0ec289d3125a5a8048d756f9d232bd62",
      "startLine": 12,
      "endLine": 27,
      "methodCode": "    @property\n    def changed_data(self):\n        if self._changed_data is None:\n            self._changed_data = []\n            # XXX: For now we're asking the individual widgets whether or not the\n            # data has changed. It would probably be more efficient to hash the\n            # initial data, store it in a hidden field, and compare a hash of the\n            # submitted data, but we'd need a way to easily get the string value\n            # for a given field. Right now, that logic is embedded in the render\n            # method of each widget.\n            for name, field in self.fields.items():\n                prefixed_name = self.add_prefix(name)\n                data_value = field.widget.value_from_datadict(self.data, self.files, prefixed_name)\n                if not field.show_hidden_initial:\n                    initial_value = self.initial.get(name, field.initial)\n                    if callable(initial_value):\n                        initial_value = initial_value()\n                else:\n                    initial_prefixed_name = self.add_initial_prefix(name)\n                    hidden_widget = field.hidden_widget()\n                    try:\n                        initial_value = field.to_python(hidden_widget.value_from_datadict(\n                            self.data, self.files, initial_prefixed_name))\n                    except ValidationError:\n                        # Always assume data has changed if validation fails.\n                        self._changed_data.append(name)\n                        continue\n                if field._has_changed(initial_value, data_value):\n                    self._changed_data.append(name)\n        return self._changed_data\n"
    },
    {
      "commit": "210d0489c5daad56b806f8165f9fe09fb3c2a019",
      "startLine": 12,
      "endLine": 27,
      "methodCode": "    @property\n    def changed_data(self):\n        if self._changed_data is None:\n            self._changed_data = []\n            # XXX: For now we're asking the individual widgets whether or not the\n            # data has changed. It would probably be more efficient to hash the\n            # initial data, store it in a hidden field, and compare a hash of the\n            # submitted data, but we'd need a way to easily get the string value\n            # for a given field. Right now, that logic is embedded in the render\n            # method of each widget.\n            for name, field in self.fields.items():\n                prefixed_name = self.add_prefix(name)\n                data_value = field.widget.value_from_datadict(self.data, self.files, prefixed_name)\n                if not field.show_hidden_initial:\n                    initial_value = self.initial.get(name, field.initial)\n                    if callable(initial_value):\n                        initial_value = initial_value()\n                else:\n                    initial_prefixed_name = self.add_initial_prefix(name)\n                    hidden_widget = field.hidden_widget()\n                    try:\n                        initial_value = field.to_python(hidden_widget.value_from_datadict(\n                            self.data, self.files, initial_prefixed_name))\n                    except ValidationError:\n                        # Always assume data has changed if validation fails.\n                        self._changed_data.append(name)\n                        continue\n                if hasattr(field.widget, '_has_changed'):\n                    warnings.warn(\"The _has_changed method on widgets is deprecated,\"\n                        \" define it at field level instead.\",\n                        RemovedInDjango18Warning, stacklevel=2)\n                    if field.widget._has_changed(initial_value, data_value):\n                        self._changed_data.append(name)\n                elif field._has_changed(initial_value, data_value):\n                    self._changed_data.append(name)\n        return self._changed_data\n"
    },
    {
      "commit": "acd7b34aafe352ef604edcb73f75041c5cbba6b9",
      "startLine": 12,
      "endLine": 27,
      "methodCode": "    @property\n    def changed_data(self):\n        if self._changed_data is None:\n            self._changed_data = []\n            # XXX: For now we're asking the individual widgets whether or not the\n            # data has changed. It would probably be more efficient to hash the\n            # initial data, store it in a hidden field, and compare a hash of the\n            # submitted data, but we'd need a way to easily get the string value\n            # for a given field. Right now, that logic is embedded in the render\n            # method of each widget.\n            for name, field in self.fields.items():\n                prefixed_name = self.add_prefix(name)\n                data_value = field.widget.value_from_datadict(self.data, self.files, prefixed_name)\n                if not field.show_hidden_initial:\n                    initial_value = self.initial.get(name, field.initial)\n                    if callable(initial_value):\n                        initial_value = initial_value()\n                else:\n                    initial_prefixed_name = self.add_initial_prefix(name)\n                    hidden_widget = field.hidden_widget()\n                    try:\n                        initial_value = field.to_python(hidden_widget.value_from_datadict(\n                            self.data, self.files, initial_prefixed_name))\n                    except ValidationError:\n                        # Always assume data has changed if validation fails.\n                        self._changed_data.append(name)\n                        continue\n                if hasattr(field.widget, '_has_changed'):\n                    warnings.warn(\"The _has_changed method on widgets is deprecated,\"\n                        \" define it at field level instead.\",\n                        DeprecationWarning, stacklevel=2)\n                    if field.widget._has_changed(initial_value, data_value):\n                        self._changed_data.append(name)\n                elif field._has_changed(initial_value, data_value):\n                    self._changed_data.append(name)\n        return self._changed_data\n"
    },
    {
      "commit": "d0788c277035727b7b070abd0f02d075acffc84f",
      "startLine": 12,
      "endLine": 27,
      "methodCode": "    @property\n    def changed_data(self):\n        if self._changed_data is None:\n            self._changed_data = []\n            # XXX: For now we're asking the individual widgets whether or not the\n            # data has changed. It would probably be more efficient to hash the\n            # initial data, store it in a hidden field, and compare a hash of the\n            # submitted data, but we'd need a way to easily get the string value\n            # for a given field. Right now, that logic is embedded in the render\n            # method of each widget.\n            for name, field in self.fields.items():\n                prefixed_name = self.add_prefix(name)\n                data_value = field.widget.value_from_datadict(self.data, self.files, prefixed_name)\n                if not field.show_hidden_initial:\n                    initial_value = self.initial.get(name, field.initial)\n                    if callable(initial_value):\n                        initial_value = initial_value()\n                else:\n                    initial_prefixed_name = self.add_initial_prefix(name)\n                    hidden_widget = field.hidden_widget()\n                    try:\n                        initial_value = field.to_python(hidden_widget.value_from_datadict(\n                            self.data, self.files, initial_prefixed_name))\n                    except ValidationError:\n                        # Always assume data has changed if validation fails.\n                        self._changed_data.append(name)\n                        continue\n                if hasattr(field.widget, '_has_changed'):\n                    warnings.warn(\"The _has_changed method on widgets is deprecated,\"\n                        \" define it at field level instead.\",\n                        PendingDeprecationWarning, stacklevel=2)\n                    if field.widget._has_changed(initial_value, data_value):\n                        self._changed_data.append(name)\n                elif field._has_changed(initial_value, data_value):\n                    self._changed_data.append(name)\n        return self._changed_data\n"
    },
    {
      "commit": "cbfb8ed53b31ec9701f5fb8e519a8644fd4c8095",
      "startLine": 12,
      "endLine": 25,
      "methodCode": "    @property\n    def changed_data(self):\n        if self._changed_data is None:\n            self._changed_data = []\n            # XXX: For now we're asking the individual widgets whether or not the\n            # data has changed. It would probably be more efficient to hash the\n            # initial data, store it in a hidden field, and compare a hash of the\n            # submitted data, but we'd need a way to easily get the string value\n            # for a given field. Right now, that logic is embedded in the render\n            # method of each widget.\n            for name, field in self.fields.items():\n                prefixed_name = self.add_prefix(name)\n                data_value = field.widget.value_from_datadict(self.data, self.files, prefixed_name)\n                if not field.show_hidden_initial:\n                    initial_value = self.initial.get(name, field.initial)\n                else:\n                    initial_prefixed_name = self.add_initial_prefix(name)\n                    hidden_widget = field.hidden_widget()\n                    try:\n                        initial_value = field.to_python(hidden_widget.value_from_datadict(\n                            self.data, self.files, initial_prefixed_name))\n                    except ValidationError:\n                        # Always assume data has changed if validation fails.\n                        self._changed_data.append(name)\n                        continue\n                if hasattr(field.widget, '_has_changed'):\n                    warnings.warn(\"The _has_changed method on widgets is deprecated,\"\n                        \" define it at field level instead.\",\n                        PendingDeprecationWarning, stacklevel=2)\n                    if field.widget._has_changed(initial_value, data_value):\n                        self._changed_data.append(name)\n                elif field._has_changed(initial_value, data_value):\n                    self._changed_data.append(name)\n        return self._changed_data\n"
    },
    {
      "commit": "892bc91cb0036d6868081363628f65094c4790d6",
      "startLine": 12,
      "endLine": 20,
      "methodCode": "    @property\n    def changed_data(self):\n        if self._changed_data is None:\n            self._changed_data = []\n            # XXX: For now we're asking the individual widgets whether or not the\n            # data has changed. It would probably be more efficient to hash the\n            # initial data, store it in a hidden field, and compare a hash of the\n            # submitted data, but we'd need a way to easily get the string value\n            # for a given field. Right now, that logic is embedded in the render\n            # method of each widget.\n            for name, field in self.fields.items():\n                prefixed_name = self.add_prefix(name)\n                data_value = field.widget.value_from_datadict(self.data, self.files, prefixed_name)\n                if not field.show_hidden_initial:\n                    initial_value = self.initial.get(name, field.initial)\n                else:\n                    initial_prefixed_name = self.add_initial_prefix(name)\n                    hidden_widget = field.hidden_widget()\n                    initial_value = field.to_python(hidden_widget.value_from_datadict(\n                        self.data, self.files, initial_prefixed_name))\n                if hasattr(field.widget, '_has_changed'):\n                    warnings.warn(\"The _has_changed method on widgets is deprecated,\"\n                        \" define it at field level instead.\",\n                        PendingDeprecationWarning, stacklevel=2)\n                    if field.widget._has_changed(initial_value, data_value):\n                        self._changed_data.append(name)\n                elif field._has_changed(initial_value, data_value):\n                    self._changed_data.append(name)\n        return self._changed_data\n"
    },
    {
      "commit": "58062a6302a2bf1013d100deb053ccae2298bb84",
      "startLine": 12,
      "endLine": 20,
      "methodCode": "    @property\n    def changed_data(self):\n        if self._changed_data is None:\n            self._changed_data = []\n            # XXX: For now we're asking the individual widgets whether or not the\n            # data has changed. It would probably be more efficient to hash the\n            # initial data, store it in a hidden field, and compare a hash of the\n            # submitted data, but we'd need a way to easily get the string value\n            # for a given field. Right now, that logic is embedded in the render\n            # method of each widget.\n            for name, field in self.fields.items():\n                prefixed_name = self.add_prefix(name)\n                data_value = field.widget.value_from_datadict(self.data, self.files, prefixed_name)\n                if not field.show_hidden_initial:\n                    initial_value = self.initial.get(name, field.initial)\n                else:\n                    initial_prefixed_name = self.add_initial_prefix(name)\n                    hidden_widget = field.hidden_widget()\n                    initial_value = hidden_widget.value_from_datadict(\n                        self.data, self.files, initial_prefixed_name)\n                if hasattr(field.widget, '_has_changed'):\n                    warnings.warn(\"The _has_changed method on widgets is deprecated,\"\n                        \" define it at field level instead.\",\n                        PendingDeprecationWarning, stacklevel=2)\n                    if field.widget._has_changed(initial_value, data_value):\n                        self._changed_data.append(name)\n                elif field._has_changed(initial_value, data_value):\n                    self._changed_data.append(name)\n        return self._changed_data\n"
    },
    {
      "commit": "ebb504db692cac496f4f45762d1d14644c9fa6fa",
      "startLine": 11,
      "endLine": 19,
      "methodCode": "    def _get_changed_data(self):\n        if self._changed_data is None:\n            self._changed_data = []\n            # XXX: For now we're asking the individual widgets whether or not the\n            # data has changed. It would probably be more efficient to hash the\n            # initial data, store it in a hidden field, and compare a hash of the\n            # submitted data, but we'd need a way to easily get the string value\n            # for a given field. Right now, that logic is embedded in the render\n            # method of each widget.\n            for name, field in self.fields.items():\n                prefixed_name = self.add_prefix(name)\n                data_value = field.widget.value_from_datadict(self.data, self.files, prefixed_name)\n                if not field.show_hidden_initial:\n                    initial_value = self.initial.get(name, field.initial)\n                else:\n                    initial_prefixed_name = self.add_initial_prefix(name)\n                    hidden_widget = field.hidden_widget()\n                    initial_value = hidden_widget.value_from_datadict(\n                        self.data, self.files, initial_prefixed_name)\n                if hasattr(field.widget, '_has_changed'):\n                    warnings.warn(\"The _has_changed method on widgets is deprecated,\"\n                        \" define it at field level instead.\",\n                        PendingDeprecationWarning, stacklevel=2)\n                    if field.widget._has_changed(initial_value, data_value):\n                        self._changed_data.append(name)\n                elif field._has_changed(initial_value, data_value):\n                    self._changed_data.append(name)\n        return self._changed_data"
    },
    {
      "commit": "7c7ad041b358a9819b3bd9f93d4834df4a5b5d57",
      "startLine": 11,
      "endLine": 19,
      "methodCode": "    def _get_changed_data(self):\n        if self._changed_data is None:\n            self._changed_data = []\n            # XXX: For now we're asking the individual widgets whether or not the\n            # data has changed. It would probably be more efficient to hash the\n            # initial data, store it in a hidden field, and compare a hash of the\n            # submitted data, but we'd need a way to easily get the string value\n            # for a given field. Right now, that logic is embedded in the render\n            # method of each widget.\n            for name, field in self.fields.items():\n                prefixed_name = self.add_prefix(name)\n                data_value = field.widget.value_from_datadict(self.data, self.files, prefixed_name)\n                if not field.show_hidden_initial:\n                    initial_value = self.initial.get(name, field.initial)\n                else:\n                    initial_prefixed_name = self.add_initial_prefix(name)\n                    hidden_widget = field.hidden_widget()\n                    initial_value = hidden_widget.value_from_datadict(\n                        self.data, self.files, initial_prefixed_name)\n                if field.widget._has_changed(initial_value, data_value):\n                    self._changed_data.append(name)\n        return self._changed_data"
    },
    {
      "commit": "46786b4193e04d398532bbfc3dcf63c03c1793cb",
      "startLine": 11,
      "endLine": 13,
      "methodCode": "    def _get_changed_data(self):\n        if self._changed_data is None:\n            self._changed_data = []\n            # XXX: For now we're asking the individual widgets whether or not the\n            # data has changed. It would probably be more efficient to hash the\n            # initial data, store it in a hidden field, and compare a hash of the\n            # submitted data, but we'd need a way to easily get the string value\n            # for a given field. Right now, that logic is embedded in the render\n            # method of each widget.\n            for name, field in self.fields.items():\n                prefixed_name = self.add_prefix(name)\n                data_value = field.widget.value_from_datadict(self.data, self.files, prefixed_name)\n                initial_value = self.initial.get(name, field.initial)\n                if field.widget._has_changed(initial_value, data_value):\n                    self._changed_data.append(name)\n        return self._changed_data"
    },
    {
      "commit": "a19ed8aea395e8e07164ff7d85bd7dff2f24edca",
      "startLine": 11,
      "endLine": 13,
      "methodCode": "    def _get_changed_data(self):\n        if self._changed_data is None:\n            self._changed_data = []\n            # XXX: For now we're asking the individual widgets whether or not the\n            # data has changed. It would probably be more efficient to hash the\n            # initial data, store it in a hidden field, and compare a hash of the\n            # submitted data, but we'd need a way to easily get the string value\n            # for a given field. Right now, that logic is embedded in the render\n            # method of each widget.\n            for name, field in self.fields.items():\n                prefixed_name = self.add_prefix(name)\n                data_value = field.widget.value_from_datadict(self.data, self.files, prefixed_name)\n                initial_value = self.initial.get(name, field.initial)\n                if field.widget._has_changed(initial_value, data_value):\n                    self._changed_data.append(name)\n        return self._changed_data"
    }
  ]
}