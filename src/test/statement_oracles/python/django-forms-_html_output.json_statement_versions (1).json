{
  "statementVersions": [
    {
      "commit": "7c7bc6391a3e83566f9ace59955e63503bc76cee",
      "startLine": 19,
      "endLine": 35,
      "methodCode": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Output HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors = self.non_field_errors()  # Errors that should be displayed above all fields.\n        output, hidden_fields = [], []\n\n        for name, field in self.fields.items():\n            html_class_attr = ''\n            bf = self[name]\n            bf_errors = self.error_class(bf.errors)\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend(\n                        [_('(Hidden field %(name)s) %(error)s') % {'name': name, 'error': str(e)}\n                         for e in bf_errors])\n                hidden_fields.append(str(bf))\n            else:\n                # Create a 'class=\"...\"' attribute if the row should have any\n                # CSS classes applied.\n                css_classes = bf.css_classes()\n                if css_classes:\n                    html_class_attr = ' class=\"%s\"' % css_classes\n\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % str(bf_errors))\n\n                if bf.label:\n                    label = conditional_escape(bf.label)\n                    label = bf.label_tag(label) or ''\n                else:\n                    label = ''\n\n                if field.help_text:\n                    help_text = help_text_html % field.help_text\n                else:\n                    help_text = ''\n\n                output.append(normal_row % {\n                    'errors': bf_errors,\n                    'label': label,\n                    'field': bf,\n                    'help_text': help_text,\n                    'html_class_attr': html_class_attr,\n                    'css_classes': css_classes,\n                    'field_name': bf.html_name,\n                })\n\n        if top_errors:\n            output.insert(0, error_row % top_errors)\n\n        if hidden_fields:  # Insert any hidden fields in the last row.\n            str_hidden = ''.join(hidden_fields)\n            if output:\n                last_row = output[-1]\n                # Chop off the trailing row_ender (e.g. '</td></tr>') and\n                # insert the hidden fields.\n                if not last_row.endswith(row_ender):\n                    # This can happen in the as_p() case (and possibly others\n                    # that users write): if there are only top errors, we may\n                    # not be able to conscript the last row for our purposes,\n                    # so insert a new, empty row.\n                    last_row = (normal_row % {\n                        'errors': '',\n                        'label': '',\n                        'field': '',\n                        'help_text': '',\n                        'html_class_attr': html_class_attr,\n                        'css_classes': '',\n                        'field_name': '',\n                    })\n                    output.append(last_row)\n                output[-1] = last_row[:-len(row_ender)] + str_hidden + row_ender\n            else:\n                # If there aren't any rows in the output, just append the\n                # hidden fields.\n                output.append(str_hidden)\n        return mark_safe('\\n'.join(output))\n"
    },
    {
      "commit": "301de774c21d055e9e5a7073e5bffdb52bc71079",
      "startLine": 20,
      "endLine": 36,
      "methodCode": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Output HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors = self.non_field_errors()  # Errors that should be displayed above all fields.\n        output, hidden_fields = [], []\n\n        for name, field in self.fields.items():\n            html_class_attr = ''\n            bf = self[name]\n            # Escape and cache in local variable.\n            bf_errors = self.error_class([conditional_escape(error) for error in bf.errors])\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend(\n                        [_('(Hidden field %(name)s) %(error)s') % {'name': name, 'error': str(e)}\n                         for e in bf_errors])\n                hidden_fields.append(str(bf))\n            else:\n                # Create a 'class=\"...\"' attribute if the row should have any\n                # CSS classes applied.\n                css_classes = bf.css_classes()\n                if css_classes:\n                    html_class_attr = ' class=\"%s\"' % css_classes\n\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % str(bf_errors))\n\n                if bf.label:\n                    label = conditional_escape(bf.label)\n                    label = bf.label_tag(label) or ''\n                else:\n                    label = ''\n\n                if field.help_text:\n                    help_text = help_text_html % field.help_text\n                else:\n                    help_text = ''\n\n                output.append(normal_row % {\n                    'errors': bf_errors,\n                    'label': label,\n                    'field': bf,\n                    'help_text': help_text,\n                    'html_class_attr': html_class_attr,\n                    'css_classes': css_classes,\n                    'field_name': bf.html_name,\n                })\n\n        if top_errors:\n            output.insert(0, error_row % top_errors)\n\n        if hidden_fields:  # Insert any hidden fields in the last row.\n            str_hidden = ''.join(hidden_fields)\n            if output:\n                last_row = output[-1]\n                # Chop off the trailing row_ender (e.g. '</td></tr>') and\n                # insert the hidden fields.\n                if not last_row.endswith(row_ender):\n                    # This can happen in the as_p() case (and possibly others\n                    # that users write): if there are only top errors, we may\n                    # not be able to conscript the last row for our purposes,\n                    # so insert a new, empty row.\n                    last_row = (normal_row % {\n                        'errors': '',\n                        'label': '',\n                        'field': '',\n                        'help_text': '',\n                        'html_class_attr': html_class_attr,\n                        'css_classes': '',\n                        'field_name': '',\n                    })\n                    output.append(last_row)\n                output[-1] = last_row[:-len(row_ender)] + str_hidden + row_ender\n            else:\n                # If there aren't any rows in the output, just append the\n                # hidden fields.\n                output.append(str_hidden)\n        return mark_safe('\\n'.join(output))\n"
    },
    {
      "commit": "8346680e1ca4a8ddc8190baf3f5f944f6418d5cf",
      "startLine": 20,
      "endLine": 36,
      "methodCode": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Output HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors = self.non_field_errors()  # Errors that should be displayed above all fields.\n        output, hidden_fields = [], []\n\n        for name, field in self.fields.items():\n            html_class_attr = ''\n            bf = self[name]\n            # Escape and cache in local variable.\n            bf_errors = self.error_class([conditional_escape(error) for error in bf.errors])\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend(\n                        [_('(Hidden field %(name)s) %(error)s') % {'name': name, 'error': force_text(e)}\n                         for e in bf_errors])\n                hidden_fields.append(str(bf))\n            else:\n                # Create a 'class=\"...\"' attribute if the row should have any\n                # CSS classes applied.\n                css_classes = bf.css_classes()\n                if css_classes:\n                    html_class_attr = ' class=\"%s\"' % css_classes\n\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % force_text(bf_errors))\n\n                if bf.label:\n                    label = conditional_escape(force_text(bf.label))\n                    label = bf.label_tag(label) or ''\n                else:\n                    label = ''\n\n                if field.help_text:\n                    help_text = help_text_html % field.help_text\n                else:\n                    help_text = ''\n\n                output.append(normal_row % {\n                    'errors': bf_errors,\n                    'label': label,\n                    'field': bf,\n                    'help_text': help_text,\n                    'html_class_attr': html_class_attr,\n                    'css_classes': css_classes,\n                    'field_name': bf.html_name,\n                })\n\n        if top_errors:\n            output.insert(0, error_row % top_errors)\n\n        if hidden_fields:  # Insert any hidden fields in the last row.\n            str_hidden = ''.join(hidden_fields)\n            if output:\n                last_row = output[-1]\n                # Chop off the trailing row_ender (e.g. '</td></tr>') and\n                # insert the hidden fields.\n                if not last_row.endswith(row_ender):\n                    # This can happen in the as_p() case (and possibly others\n                    # that users write): if there are only top errors, we may\n                    # not be able to conscript the last row for our purposes,\n                    # so insert a new, empty row.\n                    last_row = (normal_row % {\n                        'errors': '',\n                        'label': '',\n                        'field': '',\n                        'help_text': '',\n                        'html_class_attr': html_class_attr,\n                        'css_classes': '',\n                        'field_name': '',\n                    })\n                    output.append(last_row)\n                output[-1] = last_row[:-len(row_ender)] + str_hidden + row_ender\n            else:\n                # If there aren't any rows in the output, just append the\n                # hidden fields.\n                output.append(str_hidden)\n        return mark_safe('\\n'.join(output))\n"
    },
    {
      "commit": "3eb679a86956d9eedf24492f0002de002f7180f5",
      "startLine": 20,
      "endLine": 36,
      "methodCode": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Output HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors = self.non_field_errors()  # Errors that should be displayed above all fields.\n        output, hidden_fields = [], []\n\n        for name, field in self.fields.items():\n            html_class_attr = ''\n            bf = self[name]\n            # Escape and cache in local variable.\n            bf_errors = self.error_class([conditional_escape(error) for error in bf.errors])\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend(\n                        [_('(Hidden field %(name)s) %(error)s') % {'name': name, 'error': force_text(e)}\n                         for e in bf_errors])\n                hidden_fields.append(str(bf))\n            else:\n                # Create a 'class=\"...\"' attribute if the row should have any\n                # CSS classes applied.\n                css_classes = bf.css_classes()\n                if css_classes:\n                    html_class_attr = ' class=\"%s\"' % css_classes\n\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % force_text(bf_errors))\n\n                if bf.label:\n                    label = conditional_escape(force_text(bf.label))\n                    label = bf.label_tag(label) or ''\n                else:\n                    label = ''\n\n                if field.help_text:\n                    help_text = help_text_html % force_text(field.help_text)\n                else:\n                    help_text = ''\n\n                output.append(normal_row % {\n                    'errors': force_text(bf_errors),\n                    'label': force_text(label),\n                    'field': str(bf),\n                    'help_text': help_text,\n                    'html_class_attr': html_class_attr,\n                    'css_classes': css_classes,\n                    'field_name': bf.html_name,\n                })\n\n        if top_errors:\n            output.insert(0, error_row % force_text(top_errors))\n\n        if hidden_fields:  # Insert any hidden fields in the last row.\n            str_hidden = ''.join(hidden_fields)\n            if output:\n                last_row = output[-1]\n                # Chop off the trailing row_ender (e.g. '</td></tr>') and\n                # insert the hidden fields.\n                if not last_row.endswith(row_ender):\n                    # This can happen in the as_p() case (and possibly others\n                    # that users write): if there are only top errors, we may\n                    # not be able to conscript the last row for our purposes,\n                    # so insert a new, empty row.\n                    last_row = (normal_row % {\n                        'errors': '',\n                        'label': '',\n                        'field': '',\n                        'help_text': '',\n                        'html_class_attr': html_class_attr,\n                        'css_classes': '',\n                        'field_name': '',\n                    })\n                    output.append(last_row)\n                output[-1] = last_row[:-len(row_ender)] + str_hidden + row_ender\n            else:\n                # If there aren't any rows in the output, just append the\n                # hidden fields.\n                output.append(str_hidden)\n        return mark_safe('\\n'.join(output))\n"
    },
    {
      "commit": "7b2f2e74adb36a4334e83130f6abc2f79d395235",
      "startLine": 20,
      "endLine": 36,
      "methodCode": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors = self.non_field_errors()  # Errors that should be displayed above all fields.\n        output, hidden_fields = [], []\n\n        for name, field in self.fields.items():\n            html_class_attr = ''\n            bf = self[name]\n            # Escape and cache in local variable.\n            bf_errors = self.error_class([conditional_escape(error) for error in bf.errors])\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend(\n                        [_('(Hidden field %(name)s) %(error)s') % {'name': name, 'error': force_text(e)}\n                         for e in bf_errors])\n                hidden_fields.append(str(bf))\n            else:\n                # Create a 'class=\"...\"' attribute if the row should have any\n                # CSS classes applied.\n                css_classes = bf.css_classes()\n                if css_classes:\n                    html_class_attr = ' class=\"%s\"' % css_classes\n\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % force_text(bf_errors))\n\n                if bf.label:\n                    label = conditional_escape(force_text(bf.label))\n                    label = bf.label_tag(label) or ''\n                else:\n                    label = ''\n\n                if field.help_text:\n                    help_text = help_text_html % force_text(field.help_text)\n                else:\n                    help_text = ''\n\n                output.append(normal_row % {\n                    'errors': force_text(bf_errors),\n                    'label': force_text(label),\n                    'field': str(bf),\n                    'help_text': help_text,\n                    'html_class_attr': html_class_attr,\n                    'css_classes': css_classes,\n                    'field_name': bf.html_name,\n                })\n\n        if top_errors:\n            output.insert(0, error_row % force_text(top_errors))\n\n        if hidden_fields:  # Insert any hidden fields in the last row.\n            str_hidden = ''.join(hidden_fields)\n            if output:\n                last_row = output[-1]\n                # Chop off the trailing row_ender (e.g. '</td></tr>') and\n                # insert the hidden fields.\n                if not last_row.endswith(row_ender):\n                    # This can happen in the as_p() case (and possibly others\n                    # that users write): if there are only top errors, we may\n                    # not be able to conscript the last row for our purposes,\n                    # so insert a new, empty row.\n                    last_row = (normal_row % {\n                        'errors': '',\n                        'label': '',\n                        'field': '',\n                        'help_text': '',\n                        'html_class_attr': html_class_attr,\n                        'css_classes': '',\n                        'field_name': '',\n                    })\n                    output.append(last_row)\n                output[-1] = last_row[:-len(row_ender)] + str_hidden + row_ender\n            else:\n                # If there aren't any rows in the output, just append the\n                # hidden fields.\n                output.append(str_hidden)\n        return mark_safe('\\n'.join(output))\n"
    },
    {
      "commit": "1884bf8e8e9fb3f9f44a9ec216aca96f63974268",
      "startLine": 20,
      "endLine": 36,
      "methodCode": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors = self.non_field_errors()  # Errors that should be displayed above all fields.\n        output, hidden_fields = [], []\n\n        for name, field in self.fields.items():\n            html_class_attr = ''\n            bf = self[name]\n            # Escape and cache in local variable.\n            bf_errors = self.error_class([conditional_escape(error) for error in bf.errors])\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend(\n                        [_('(Hidden field %(name)s) %(error)s') % {'name': name, 'error': force_text(e)}\n                         for e in bf_errors])\n                hidden_fields.append(six.text_type(bf))\n            else:\n                # Create a 'class=\"...\"' attribute if the row should have any\n                # CSS classes applied.\n                css_classes = bf.css_classes()\n                if css_classes:\n                    html_class_attr = ' class=\"%s\"' % css_classes\n\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % force_text(bf_errors))\n\n                if bf.label:\n                    label = conditional_escape(force_text(bf.label))\n                    label = bf.label_tag(label) or ''\n                else:\n                    label = ''\n\n                if field.help_text:\n                    help_text = help_text_html % force_text(field.help_text)\n                else:\n                    help_text = ''\n\n                output.append(normal_row % {\n                    'errors': force_text(bf_errors),\n                    'label': force_text(label),\n                    'field': six.text_type(bf),\n                    'help_text': help_text,\n                    'html_class_attr': html_class_attr,\n                    'css_classes': css_classes,\n                    'field_name': bf.html_name,\n                })\n\n        if top_errors:\n            output.insert(0, error_row % force_text(top_errors))\n\n        if hidden_fields:  # Insert any hidden fields in the last row.\n            str_hidden = ''.join(hidden_fields)\n            if output:\n                last_row = output[-1]\n                # Chop off the trailing row_ender (e.g. '</td></tr>') and\n                # insert the hidden fields.\n                if not last_row.endswith(row_ender):\n                    # This can happen in the as_p() case (and possibly others\n                    # that users write): if there are only top errors, we may\n                    # not be able to conscript the last row for our purposes,\n                    # so insert a new, empty row.\n                    last_row = (normal_row % {\n                        'errors': '',\n                        'label': '',\n                        'field': '',\n                        'help_text': '',\n                        'html_class_attr': html_class_attr,\n                        'css_classes': '',\n                        'field_name': '',\n                    })\n                    output.append(last_row)\n                output[-1] = last_row[:-len(row_ender)] + str_hidden + row_ender\n            else:\n                # If there aren't any rows in the output, just append the\n                # hidden fields.\n                output.append(str_hidden)\n        return mark_safe('\\n'.join(output))\n"
    },
    {
      "commit": "3f9ec12d9c9eff9a3b1a205d87c7e66587cf9967",
      "startLine": 20,
      "endLine": 36,
      "methodCode": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors = self.non_field_errors()  # Errors that should be displayed above all fields.\n        output, hidden_fields = [], []\n\n        for name, field in self.fields.items():\n            html_class_attr = ''\n            bf = self[name]\n            # Escape and cache in local variable.\n            bf_errors = self.error_class([conditional_escape(error) for error in bf.errors])\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend(\n                        [_('(Hidden field %(name)s) %(error)s') % {'name': name, 'error': force_text(e)}\n                         for e in bf_errors])\n                hidden_fields.append(six.text_type(bf))\n            else:\n                # Create a 'class=\"...\"' attribute if the row should have any\n                # CSS classes applied.\n                css_classes = bf.css_classes()\n                if css_classes:\n                    html_class_attr = ' class=\"%s\"' % css_classes\n\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % force_text(bf_errors))\n\n                if bf.label:\n                    label = conditional_escape(force_text(bf.label))\n                    label = bf.label_tag(label) or ''\n                else:\n                    label = ''\n\n                if field.help_text:\n                    help_text = help_text_html % force_text(field.help_text)\n                else:\n                    help_text = ''\n\n                output.append(normal_row % {\n                    'errors': force_text(bf_errors),\n                    'label': force_text(label),\n                    'field': six.text_type(bf),\n                    'help_text': help_text,\n                    'html_class_attr': html_class_attr,\n                    'field_name': bf.html_name,\n                })\n\n        if top_errors:\n            output.insert(0, error_row % force_text(top_errors))\n\n        if hidden_fields:  # Insert any hidden fields in the last row.\n            str_hidden = ''.join(hidden_fields)\n            if output:\n                last_row = output[-1]\n                # Chop off the trailing row_ender (e.g. '</td></tr>') and\n                # insert the hidden fields.\n                if not last_row.endswith(row_ender):\n                    # This can happen in the as_p() case (and possibly others\n                    # that users write): if there are only top errors, we may\n                    # not be able to conscript the last row for our purposes,\n                    # so insert a new, empty row.\n                    last_row = (normal_row % {\n                        'errors': '',\n                        'label': '',\n                        'field': '',\n                        'help_text': '',\n                        'html_class_attr': html_class_attr,\n                        'field_name': '',\n                    })\n                    output.append(last_row)\n                output[-1] = last_row[:-len(row_ender)] + str_hidden + row_ender\n            else:\n                # If there aren't any rows in the output, just append the\n                # hidden fields.\n                output.append(str_hidden)\n        return mark_safe('\\n'.join(output))\n"
    },
    {
      "commit": "053de6131af83c63ec17d38578889c71de913d24",
      "startLine": 20,
      "endLine": 36,
      "methodCode": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors = self.non_field_errors() # Errors that should be displayed above all fields.\n        output, hidden_fields = [], []\n\n        for name, field in self.fields.items():\n            html_class_attr = ''\n            bf = self[name]\n            # Escape and cache in local variable.\n            bf_errors = self.error_class([conditional_escape(error) for error in bf.errors])\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend(\n                        [_('(Hidden field %(name)s) %(error)s') % {'name': name, 'error': force_text(e)}\n                         for e in bf_errors])\n                hidden_fields.append(six.text_type(bf))\n            else:\n                # Create a 'class=\"...\"' atribute if the row should have any\n                # CSS classes applied.\n                css_classes = bf.css_classes()\n                if css_classes:\n                    html_class_attr = ' class=\"%s\"' % css_classes\n\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % force_text(bf_errors))\n\n                if bf.label:\n                    label = conditional_escape(force_text(bf.label))\n                    label = bf.label_tag(label) or ''\n                else:\n                    label = ''\n\n                if field.help_text:\n                    help_text = help_text_html % force_text(field.help_text)\n                else:\n                    help_text = ''\n\n                output.append(normal_row % {\n                    'errors': force_text(bf_errors),\n                    'label': force_text(label),\n                    'field': six.text_type(bf),\n                    'help_text': help_text,\n                    'html_class_attr': html_class_attr,\n                    'field_name': bf.html_name,\n                })\n\n        if top_errors:\n            output.insert(0, error_row % force_text(top_errors))\n\n        if hidden_fields: # Insert any hidden fields in the last row.\n            str_hidden = ''.join(hidden_fields)\n            if output:\n                last_row = output[-1]\n                # Chop off the trailing row_ender (e.g. '</td></tr>') and\n                # insert the hidden fields.\n                if not last_row.endswith(row_ender):\n                    # This can happen in the as_p() case (and possibly others\n                    # that users write): if there are only top errors, we may\n                    # not be able to conscript the last row for our purposes,\n                    # so insert a new, empty row.\n                    last_row = (normal_row % {'errors': '', 'label': '',\n                                              'field': '', 'help_text':'',\n                                              'html_class_attr': html_class_attr})\n                    output.append(last_row)\n                output[-1] = last_row[:-len(row_ender)] + str_hidden + row_ender\n            else:\n                # If there aren't any rows in the output, just append the\n                # hidden fields.\n                output.append(str_hidden)\n        return mark_safe('\\n'.join(output))\n"
    },
    {
      "commit": "584bd14dcfdee9585fec7794d53ce120ea73d0bc",
      "startLine": 20,
      "endLine": 36,
      "methodCode": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors = self.non_field_errors() # Errors that should be displayed above all fields.\n        output, hidden_fields = [], []\n\n        for name, field in self.fields.items():\n            html_class_attr = ''\n            bf = self[name]\n            # Escape and cache in local variable.\n            bf_errors = self.error_class([conditional_escape(error) for error in bf.errors])\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend(\n                        [_('(Hidden field %(name)s) %(error)s') % {'name': name, 'error': force_text(e)}\n                         for e in bf_errors])\n                hidden_fields.append(six.text_type(bf))\n            else:\n                # Create a 'class=\"...\"' atribute if the row should have any\n                # CSS classes applied.\n                css_classes = bf.css_classes()\n                if css_classes:\n                    html_class_attr = ' class=\"%s\"' % css_classes\n\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % force_text(bf_errors))\n\n                if bf.label:\n                    label = conditional_escape(force_text(bf.label))\n                    label = bf.label_tag(label) or ''\n                else:\n                    label = ''\n\n                if field.help_text:\n                    help_text = help_text_html % force_text(field.help_text)\n                else:\n                    help_text = ''\n\n                output.append(normal_row % {\n                    'errors': force_text(bf_errors),\n                    'label': force_text(label),\n                    'field': six.text_type(bf),\n                    'help_text': help_text,\n                    'html_class_attr': html_class_attr\n                })\n\n        if top_errors:\n            output.insert(0, error_row % force_text(top_errors))\n\n        if hidden_fields: # Insert any hidden fields in the last row.\n            str_hidden = ''.join(hidden_fields)\n            if output:\n                last_row = output[-1]\n                # Chop off the trailing row_ender (e.g. '</td></tr>') and\n                # insert the hidden fields.\n                if not last_row.endswith(row_ender):\n                    # This can happen in the as_p() case (and possibly others\n                    # that users write): if there are only top errors, we may\n                    # not be able to conscript the last row for our purposes,\n                    # so insert a new, empty row.\n                    last_row = (normal_row % {'errors': '', 'label': '',\n                                              'field': '', 'help_text':'',\n                                              'html_class_attr': html_class_attr})\n                    output.append(last_row)\n                output[-1] = last_row[:-len(row_ender)] + str_hidden + row_ender\n            else:\n                # If there aren't any rows in the output, just append the\n                # hidden fields.\n                output.append(str_hidden)\n        return mark_safe('\\n'.join(output))\n"
    },
    {
      "commit": "962f133f72abe2a1174d48baa52aa8549762a022",
      "startLine": 20,
      "endLine": 41,
      "methodCode": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors = self.non_field_errors() # Errors that should be displayed above all fields.\n        output, hidden_fields = [], []\n\n        for name, field in self.fields.items():\n            html_class_attr = ''\n            bf = self[name]\n            # Escape and cache in local variable.\n            bf_errors = self.error_class([conditional_escape(error) for error in bf.errors])\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend(\n                        [_('(Hidden field %(name)s) %(error)s') % {'name': name, 'error': force_text(e)}\n                         for e in bf_errors])\n                hidden_fields.append(six.text_type(bf))\n            else:\n                # Create a 'class=\"...\"' atribute if the row should have any\n                # CSS classes applied.\n                css_classes = bf.css_classes()\n                if css_classes:\n                    html_class_attr = ' class=\"%s\"' % css_classes\n\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % force_text(bf_errors))\n\n                if bf.label:\n                    label = conditional_escape(force_text(bf.label))\n                    # Only add the suffix if the label does not end in\n                    # punctuation.\n                    if self.label_suffix:\n                        if label[-1] not in ':?.!':\n                            label = format_html('{0}{1}', label, self.label_suffix)\n                    label = bf.label_tag(label) or ''\n                else:\n                    label = ''\n\n                if field.help_text:\n                    help_text = help_text_html % force_text(field.help_text)\n                else:\n                    help_text = ''\n\n                output.append(normal_row % {\n                    'errors': force_text(bf_errors),\n                    'label': force_text(label),\n                    'field': six.text_type(bf),\n                    'help_text': help_text,\n                    'html_class_attr': html_class_attr\n                })\n\n        if top_errors:\n            output.insert(0, error_row % force_text(top_errors))\n\n        if hidden_fields: # Insert any hidden fields in the last row.\n            str_hidden = ''.join(hidden_fields)\n            if output:\n                last_row = output[-1]\n                # Chop off the trailing row_ender (e.g. '</td></tr>') and\n                # insert the hidden fields.\n                if not last_row.endswith(row_ender):\n                    # This can happen in the as_p() case (and possibly others\n                    # that users write): if there are only top errors, we may\n                    # not be able to conscript the last row for our purposes,\n                    # so insert a new, empty row.\n                    last_row = (normal_row % {'errors': '', 'label': '',\n                                              'field': '', 'help_text':'',\n                                              'html_class_attr': html_class_attr})\n                    output.append(last_row)\n                output[-1] = last_row[:-len(row_ender)] + str_hidden + row_ender\n            else:\n                # If there aren't any rows in the output, just append the\n                # hidden fields.\n                output.append(str_hidden)\n        return mark_safe('\\n'.join(output))\n"
    },
    {
      "commit": "c5ef65bcf324f4c90b53be90f4aec069a68e8c59",
      "startLine": 17,
      "endLine": 38,
      "methodCode": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors = self.non_field_errors() # Errors that should be displayed above all fields.\n        output, hidden_fields = [], []\n\n        for name, field in self.fields.items():\n            html_class_attr = ''\n            bf = self[name]\n            bf_errors = self.error_class([conditional_escape(error) for error in bf.errors]) # Escape and cache in local variable.\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend(['(Hidden field %s) %s' % (name, force_text(e)) for e in bf_errors])\n                hidden_fields.append(six.text_type(bf))\n            else:\n                # Create a 'class=\"...\"' atribute if the row should have any\n                # CSS classes applied.\n                css_classes = bf.css_classes()\n                if css_classes:\n                    html_class_attr = ' class=\"%s\"' % css_classes\n\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % force_text(bf_errors))\n\n                if bf.label:\n                    label = conditional_escape(force_text(bf.label))\n                    # Only add the suffix if the label does not end in\n                    # punctuation.\n                    if self.label_suffix:\n                        if label[-1] not in ':?.!':\n                            label = format_html('{0}{1}', label, self.label_suffix)\n                    label = bf.label_tag(label) or ''\n                else:\n                    label = ''\n\n                if field.help_text:\n                    help_text = help_text_html % force_text(field.help_text)\n                else:\n                    help_text = ''\n\n                output.append(normal_row % {\n                    'errors': force_text(bf_errors),\n                    'label': force_text(label),\n                    'field': six.text_type(bf),\n                    'help_text': help_text,\n                    'html_class_attr': html_class_attr\n                })\n\n        if top_errors:\n            output.insert(0, error_row % force_text(top_errors))\n\n        if hidden_fields: # Insert any hidden fields in the last row.\n            str_hidden = ''.join(hidden_fields)\n            if output:\n                last_row = output[-1]\n                # Chop off the trailing row_ender (e.g. '</td></tr>') and\n                # insert the hidden fields.\n                if not last_row.endswith(row_ender):\n                    # This can happen in the as_p() case (and possibly others\n                    # that users write): if there are only top errors, we may\n                    # not be able to conscript the last row for our purposes,\n                    # so insert a new, empty row.\n                    last_row = (normal_row % {'errors': '', 'label': '',\n                                              'field': '', 'help_text':'',\n                                              'html_class_attr': html_class_attr})\n                    output.append(last_row)\n                output[-1] = last_row[:-len(row_ender)] + str_hidden + row_ender\n            else:\n                # If there aren't any rows in the output, just append the\n                # hidden fields.\n                output.append(str_hidden)\n        return mark_safe('\\n'.join(output))\n"
    },
    {
      "commit": "bdca5ea345c548a82a80d198906818c9ccbef896",
      "startLine": 17,
      "endLine": 38,
      "methodCode": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors = self.non_field_errors() # Errors that should be displayed above all fields.\n        output, hidden_fields = [], []\n\n        for name, field in self.fields.items():\n            html_class_attr = ''\n            bf = self[name]\n            bf_errors = self.error_class([conditional_escape(error) for error in bf.errors]) # Escape and cache in local variable.\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend(['(Hidden field %s) %s' % (name, force_unicode(e)) for e in bf_errors])\n                hidden_fields.append(six.text_type(bf))\n            else:\n                # Create a 'class=\"...\"' atribute if the row should have any\n                # CSS classes applied.\n                css_classes = bf.css_classes()\n                if css_classes:\n                    html_class_attr = ' class=\"%s\"' % css_classes\n\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % force_unicode(bf_errors))\n\n                if bf.label:\n                    label = conditional_escape(force_unicode(bf.label))\n                    # Only add the suffix if the label does not end in\n                    # punctuation.\n                    if self.label_suffix:\n                        if label[-1] not in ':?.!':\n                            label = format_html('{0}{1}', label, self.label_suffix)\n                    label = bf.label_tag(label) or ''\n                else:\n                    label = ''\n\n                if field.help_text:\n                    help_text = help_text_html % force_unicode(field.help_text)\n                else:\n                    help_text = ''\n\n                output.append(normal_row % {\n                    'errors': force_unicode(bf_errors),\n                    'label': force_unicode(label),\n                    'field': six.text_type(bf),\n                    'help_text': help_text,\n                    'html_class_attr': html_class_attr\n                })\n\n        if top_errors:\n            output.insert(0, error_row % force_unicode(top_errors))\n\n        if hidden_fields: # Insert any hidden fields in the last row.\n            str_hidden = ''.join(hidden_fields)\n            if output:\n                last_row = output[-1]\n                # Chop off the trailing row_ender (e.g. '</td></tr>') and\n                # insert the hidden fields.\n                if not last_row.endswith(row_ender):\n                    # This can happen in the as_p() case (and possibly others\n                    # that users write): if there are only top errors, we may\n                    # not be able to conscript the last row for our purposes,\n                    # so insert a new, empty row.\n                    last_row = (normal_row % {'errors': '', 'label': '',\n                                              'field': '', 'help_text':'',\n                                              'html_class_attr': html_class_attr})\n                    output.append(last_row)\n                output[-1] = last_row[:-len(row_ender)] + str_hidden + row_ender\n            else:\n                # If there aren't any rows in the output, just append the\n                # hidden fields.\n                output.append(str_hidden)\n        return mark_safe('\\n'.join(output))\n"
    },
    {
      "commit": "8fdc56d2a6f7537cdd52272501af9e94cab96ed4",
      "startLine": 17,
      "endLine": 38,
      "methodCode": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors = self.non_field_errors() # Errors that should be displayed above all fields.\n        output, hidden_fields = [], []\n\n        for name, field in self.fields.items():\n            html_class_attr = ''\n            bf = self[name]\n            bf_errors = self.error_class([conditional_escape(error) for error in bf.errors]) # Escape and cache in local variable.\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend(['(Hidden field %s) %s' % (name, force_unicode(e)) for e in bf_errors])\n                hidden_fields.append(unicode(bf))\n            else:\n                # Create a 'class=\"...\"' atribute if the row should have any\n                # CSS classes applied.\n                css_classes = bf.css_classes()\n                if css_classes:\n                    html_class_attr = ' class=\"%s\"' % css_classes\n\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % force_unicode(bf_errors))\n\n                if bf.label:\n                    label = conditional_escape(force_unicode(bf.label))\n                    # Only add the suffix if the label does not end in\n                    # punctuation.\n                    if self.label_suffix:\n                        if label[-1] not in ':?.!':\n                            label = format_html('{0}{1}', label, self.label_suffix)\n                    label = bf.label_tag(label) or ''\n                else:\n                    label = ''\n\n                if field.help_text:\n                    help_text = help_text_html % force_unicode(field.help_text)\n                else:\n                    help_text = ''\n\n                output.append(normal_row % {\n                    'errors': force_unicode(bf_errors),\n                    'label': force_unicode(label),\n                    'field': unicode(bf),\n                    'help_text': help_text,\n                    'html_class_attr': html_class_attr\n                })\n\n        if top_errors:\n            output.insert(0, error_row % force_unicode(top_errors))\n\n        if hidden_fields: # Insert any hidden fields in the last row.\n            str_hidden = ''.join(hidden_fields)\n            if output:\n                last_row = output[-1]\n                # Chop off the trailing row_ender (e.g. '</td></tr>') and\n                # insert the hidden fields.\n                if not last_row.endswith(row_ender):\n                    # This can happen in the as_p() case (and possibly others\n                    # that users write): if there are only top errors, we may\n                    # not be able to conscript the last row for our purposes,\n                    # so insert a new, empty row.\n                    last_row = (normal_row % {'errors': '', 'label': '',\n                                              'field': '', 'help_text':'',\n                                              'html_class_attr': html_class_attr})\n                    output.append(last_row)\n                output[-1] = last_row[:-len(row_ender)] + str_hidden + row_ender\n            else:\n                # If there aren't any rows in the output, just append the\n                # hidden fields.\n                output.append(str_hidden)\n        return mark_safe('\\n'.join(output))\n"
    },
    {
      "commit": "a92e7f37c4ae84b6b8d8016cc6783211e9047219",
      "startLine": 17,
      "endLine": 38,
      "methodCode": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors = self.non_field_errors() # Errors that should be displayed above all fields.\n        output, hidden_fields = [], []\n\n        for name, field in self.fields.items():\n            html_class_attr = ''\n            bf = self[name]\n            bf_errors = self.error_class([conditional_escape(error) for error in bf.errors]) # Escape and cache in local variable.\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend(['(Hidden field %s) %s' % (name, force_unicode(e)) for e in bf_errors])\n                hidden_fields.append(unicode(bf))\n            else:\n                # Create a 'class=\"...\"' atribute if the row should have any\n                # CSS classes applied.\n                css_classes = bf.css_classes()\n                if css_classes:\n                    html_class_attr = ' class=\"%s\"' % css_classes\n\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % force_unicode(bf_errors))\n\n                if bf.label:\n                    label = conditional_escape(force_unicode(bf.label))\n                    # Only add the suffix if the label does not end in\n                    # punctuation.\n                    if self.label_suffix:\n                        if label[-1] not in ':?.!':\n                            label = format_html('{}{}', label, self.label_suffix)\n                    label = bf.label_tag(label) or ''\n                else:\n                    label = ''\n\n                if field.help_text:\n                    help_text = help_text_html % force_unicode(field.help_text)\n                else:\n                    help_text = ''\n\n                output.append(normal_row % {\n                    'errors': force_unicode(bf_errors),\n                    'label': force_unicode(label),\n                    'field': unicode(bf),\n                    'help_text': help_text,\n                    'html_class_attr': html_class_attr\n                })\n\n        if top_errors:\n            output.insert(0, error_row % force_unicode(top_errors))\n\n        if hidden_fields: # Insert any hidden fields in the last row.\n            str_hidden = ''.join(hidden_fields)\n            if output:\n                last_row = output[-1]\n                # Chop off the trailing row_ender (e.g. '</td></tr>') and\n                # insert the hidden fields.\n                if not last_row.endswith(row_ender):\n                    # This can happen in the as_p() case (and possibly others\n                    # that users write): if there are only top errors, we may\n                    # not be able to conscript the last row for our purposes,\n                    # so insert a new, empty row.\n                    last_row = (normal_row % {'errors': '', 'label': '',\n                                              'field': '', 'help_text':'',\n                                              'html_class_attr': html_class_attr})\n                    output.append(last_row)\n                output[-1] = last_row[:-len(row_ender)] + str_hidden + row_ender\n            else:\n                # If there aren't any rows in the output, just append the\n                # hidden fields.\n                output.append(str_hidden)\n        return mark_safe('\\n'.join(output))\n"
    },
    {
      "commit": "4a103086d5c67fa4fcc53c106c9fdf644c742dd8",
      "startLine": 17,
      "endLine": 38,
      "methodCode": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors = self.non_field_errors() # Errors that should be displayed above all fields.\n        output, hidden_fields = [], []\n\n        for name, field in self.fields.items():\n            html_class_attr = ''\n            bf = self[name]\n            bf_errors = self.error_class([conditional_escape(error) for error in bf.errors]) # Escape and cache in local variable.\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend(['(Hidden field %s) %s' % (name, force_unicode(e)) for e in bf_errors])\n                hidden_fields.append(unicode(bf))\n            else:\n                # Create a 'class=\"...\"' atribute if the row should have any\n                # CSS classes applied.\n                css_classes = bf.css_classes()\n                if css_classes:\n                    html_class_attr = ' class=\"%s\"' % css_classes\n\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % force_unicode(bf_errors))\n\n                if bf.label:\n                    label = conditional_escape(force_unicode(bf.label))\n                    # Only add the suffix if the label does not end in\n                    # punctuation.\n                    if self.label_suffix:\n                        if label[-1] not in ':?.!':\n                            label += self.label_suffix\n                    label = bf.label_tag(label) or ''\n                else:\n                    label = ''\n\n                if field.help_text:\n                    help_text = help_text_html % force_unicode(field.help_text)\n                else:\n                    help_text = ''\n\n                output.append(normal_row % {\n                    'errors': force_unicode(bf_errors),\n                    'label': force_unicode(label),\n                    'field': unicode(bf),\n                    'help_text': help_text,\n                    'html_class_attr': html_class_attr\n                })\n\n        if top_errors:\n            output.insert(0, error_row % force_unicode(top_errors))\n\n        if hidden_fields: # Insert any hidden fields in the last row.\n            str_hidden = ''.join(hidden_fields)\n            if output:\n                last_row = output[-1]\n                # Chop off the trailing row_ender (e.g. '</td></tr>') and\n                # insert the hidden fields.\n                if not last_row.endswith(row_ender):\n                    # This can happen in the as_p() case (and possibly others\n                    # that users write): if there are only top errors, we may\n                    # not be able to conscript the last row for our purposes,\n                    # so insert a new, empty row.\n                    last_row = (normal_row % {'errors': '', 'label': '',\n                                              'field': '', 'help_text':'',\n                                              'html_class_attr': html_class_attr})\n                    output.append(last_row)\n                output[-1] = last_row[:-len(row_ender)] + str_hidden + row_ender\n            else:\n                # If there aren't any rows in the output, just append the\n                # hidden fields.\n                output.append(str_hidden)\n        return mark_safe('\\n'.join(output))\n"
    },
    {
      "commit": "477f4d80616392bbd3352cad50faedb9c1494b33",
      "startLine": 17,
      "endLine": 38,
      "methodCode": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors = self.non_field_errors() # Errors that should be displayed above all fields.\n        output, hidden_fields = [], []\n\n        for name, field in self.fields.items():\n            html_class_attr = ''\n            bf = self[name]\n            bf_errors = self.error_class([conditional_escape(error) for error in bf.errors]) # Escape and cache in local variable.\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend([u'(Hidden field %s) %s' % (name, force_unicode(e)) for e in bf_errors])\n                hidden_fields.append(unicode(bf))\n            else:\n                # Create a 'class=\"...\"' atribute if the row should have any\n                # CSS classes applied.\n                css_classes = bf.css_classes()\n                if css_classes:\n                    html_class_attr = ' class=\"%s\"' % css_classes\n\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % force_unicode(bf_errors))\n\n                if bf.label:\n                    label = conditional_escape(force_unicode(bf.label))\n                    # Only add the suffix if the label does not end in\n                    # punctuation.\n                    if self.label_suffix:\n                        if label[-1] not in ':?.!':\n                            label += self.label_suffix\n                    label = bf.label_tag(label) or ''\n                else:\n                    label = ''\n\n                if field.help_text:\n                    help_text = help_text_html % force_unicode(field.help_text)\n                else:\n                    help_text = u''\n\n                output.append(normal_row % {\n                    'errors': force_unicode(bf_errors),\n                    'label': force_unicode(label),\n                    'field': unicode(bf),\n                    'help_text': help_text,\n                    'html_class_attr': html_class_attr\n                })\n\n        if top_errors:\n            output.insert(0, error_row % force_unicode(top_errors))\n\n        if hidden_fields: # Insert any hidden fields in the last row.\n            str_hidden = u''.join(hidden_fields)\n            if output:\n                last_row = output[-1]\n                # Chop off the trailing row_ender (e.g. '</td></tr>') and\n                # insert the hidden fields.\n                if not last_row.endswith(row_ender):\n                    # This can happen in the as_p() case (and possibly others\n                    # that users write): if there are only top errors, we may\n                    # not be able to conscript the last row for our purposes,\n                    # so insert a new, empty row.\n                    last_row = (normal_row % {'errors': '', 'label': '',\n                                              'field': '', 'help_text':'',\n                                              'html_class_attr': html_class_attr})\n                    output.append(last_row)\n                output[-1] = last_row[:-len(row_ender)] + str_hidden + row_ender\n            else:\n                # If there aren't any rows in the output, just append the\n                # hidden fields.\n                output.append(str_hidden)\n        return mark_safe(u'\\n'.join(output))\n"
    },
    {
      "commit": "5e83b79d260598fcdcc2014f99e6669c5b2a44f7",
      "startLine": 17,
      "endLine": 38,
      "methodCode": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors = self.non_field_errors() # Errors that should be displayed above all fields.\n        output, hidden_fields = [], []\n\n        for name, field in self.fields.items():\n            html_class_attr = ''\n            bf = BoundField(self, field, name)\n            bf_errors = self.error_class([conditional_escape(error) for error in bf.errors]) # Escape and cache in local variable.\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend([u'(Hidden field %s) %s' % (name, force_unicode(e)) for e in bf_errors])\n                hidden_fields.append(unicode(bf))\n            else:\n                # Create a 'class=\"...\"' atribute if the row should have any\n                # CSS classes applied.\n                css_classes = bf.css_classes()\n                if css_classes:\n                    html_class_attr = ' class=\"%s\"' % css_classes\n\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % force_unicode(bf_errors))\n\n                if bf.label:\n                    label = conditional_escape(force_unicode(bf.label))\n                    # Only add the suffix if the label does not end in\n                    # punctuation.\n                    if self.label_suffix:\n                        if label[-1] not in ':?.!':\n                            label += self.label_suffix\n                    label = bf.label_tag(label) or ''\n                else:\n                    label = ''\n\n                if field.help_text:\n                    help_text = help_text_html % force_unicode(field.help_text)\n                else:\n                    help_text = u''\n\n                output.append(normal_row % {\n                    'errors': force_unicode(bf_errors),\n                    'label': force_unicode(label),\n                    'field': unicode(bf),\n                    'help_text': help_text,\n                    'html_class_attr': html_class_attr\n                })\n\n        if top_errors:\n            output.insert(0, error_row % force_unicode(top_errors))\n\n        if hidden_fields: # Insert any hidden fields in the last row.\n            str_hidden = u''.join(hidden_fields)\n            if output:\n                last_row = output[-1]\n                # Chop off the trailing row_ender (e.g. '</td></tr>') and\n                # insert the hidden fields.\n                if not last_row.endswith(row_ender):\n                    # This can happen in the as_p() case (and possibly others\n                    # that users write): if there are only top errors, we may\n                    # not be able to conscript the last row for our purposes,\n                    # so insert a new, empty row.\n                    last_row = (normal_row % {'errors': '', 'label': '',\n                                              'field': '', 'help_text':'',\n                                              'html_class_attr': html_class_attr})\n                    output.append(last_row)\n                output[-1] = last_row[:-len(row_ender)] + str_hidden + row_ender\n            else:\n                # If there aren't any rows in the output, just append the\n                # hidden fields.\n                output.append(str_hidden)\n        return mark_safe(u'\\n'.join(output))\n"
    },
    {
      "commit": "92803205cbcaaee16ac0eb724c45019a9d896aac",
      "startLine": 17,
      "endLine": 38,
      "methodCode": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors = self.non_field_errors() # Errors that should be displayed above all fields.\n        output, hidden_fields = [], []\n        html_class_attr = ''\n\n        for name, field in self.fields.items():\n            bf = BoundField(self, field, name)\n            bf_errors = self.error_class([conditional_escape(error) for error in bf.errors]) # Escape and cache in local variable.\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend([u'(Hidden field %s) %s' % (name, force_unicode(e)) for e in bf_errors])\n                hidden_fields.append(unicode(bf))\n            else:\n                # Create a 'class=\"...\"' atribute if the row should have any\n                # CSS classes applied.\n                css_classes = bf.css_classes()\n                if css_classes:\n                    html_class_attr = ' class=\"%s\"' % css_classes\n\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % force_unicode(bf_errors))\n\n                if bf.label:\n                    label = conditional_escape(force_unicode(bf.label))\n                    # Only add the suffix if the label does not end in\n                    # punctuation.\n                    if self.label_suffix:\n                        if label[-1] not in ':?.!':\n                            label += self.label_suffix\n                    label = bf.label_tag(label) or ''\n                else:\n                    label = ''\n\n                if field.help_text:\n                    help_text = help_text_html % force_unicode(field.help_text)\n                else:\n                    help_text = u''\n\n                output.append(normal_row % {\n                    'errors': force_unicode(bf_errors),\n                    'label': force_unicode(label),\n                    'field': unicode(bf),\n                    'help_text': help_text,\n                    'html_class_attr': html_class_attr\n                })\n\n        if top_errors:\n            output.insert(0, error_row % force_unicode(top_errors))\n\n        if hidden_fields: # Insert any hidden fields in the last row.\n            str_hidden = u''.join(hidden_fields)\n            if output:\n                last_row = output[-1]\n                # Chop off the trailing row_ender (e.g. '</td></tr>') and\n                # insert the hidden fields.\n                if not last_row.endswith(row_ender):\n                    # This can happen in the as_p() case (and possibly others\n                    # that users write): if there are only top errors, we may\n                    # not be able to conscript the last row for our purposes,\n                    # so insert a new, empty row.\n                    last_row = (normal_row % {'errors': '', 'label': '',\n                                              'field': '', 'help_text':'',\n                                              'html_class_attr': html_class_attr})\n                    output.append(last_row)\n                output[-1] = last_row[:-len(row_ender)] + str_hidden + row_ender\n            else:\n                # If there aren't any rows in the output, just append the\n                # hidden fields.\n                output.append(str_hidden)\n        return mark_safe(u'\\n'.join(output))\n"
    },
    {
      "commit": "bcd63cbfb0590a2e2bed3e4beab3f467279ad3db",
      "startLine": 13,
      "endLine": 28,
      "methodCode": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors = self.non_field_errors() # Errors that should be displayed above all fields.\n        output, hidden_fields = [], []\n        for name, field in self.fields.items():\n            bf = BoundField(self, field, name)\n            bf_errors = self.error_class([conditional_escape(error) for error in bf.errors]) # Escape and cache in local variable.\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend([u'(Hidden field %s) %s' % (name, force_unicode(e)) for e in bf_errors])\n                hidden_fields.append(unicode(bf))\n            else:\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % force_unicode(bf_errors))\n                if bf.label:\n                    label = conditional_escape(force_unicode(bf.label))\n                    # Only add the suffix if the label does not end in\n                    # punctuation.\n                    if self.label_suffix:\n                        if label[-1] not in ':?.!':\n                            label += self.label_suffix\n                    label = bf.label_tag(label) or ''\n                else:\n                    label = ''\n                if field.help_text:\n                    help_text = help_text_html % force_unicode(field.help_text)\n                else:\n                    help_text = u''\n                output.append(normal_row % {'errors': force_unicode(bf_errors), 'label': force_unicode(label), 'field': unicode(bf), 'help_text': help_text})\n        if top_errors:\n            output.insert(0, error_row % force_unicode(top_errors))\n        if hidden_fields: # Insert any hidden fields in the last row.\n            str_hidden = u''.join(hidden_fields)\n            if output:\n                last_row = output[-1]\n                # Chop off the trailing row_ender (e.g. '</td></tr>') and\n                # insert the hidden fields.\n                if not last_row.endswith(row_ender):\n                    # This can happen in the as_p() case (and possibly others\n                    # that users write): if there are only top errors, we may\n                    # not be able to conscript the last row for our purposes,\n                    # so insert a new, empty row.\n                    last_row = normal_row % {'errors': '', 'label': '', 'field': '', 'help_text': ''}\n                    output.append(last_row)\n                output[-1] = last_row[:-len(row_ender)] + str_hidden + row_ender\n            else:\n                # If there aren't any rows in the output, just append the\n                # hidden fields.\n                output.append(str_hidden)\n        return mark_safe(u'\\n'.join(output))\n"
    },
    {
      "commit": "9931c9e1321e3290b065bc0f5ec8353b1bcb71f3",
      "startLine": 13,
      "endLine": 28,
      "methodCode": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors = self.non_field_errors() # Errors that should be displayed above all fields.\n        output, hidden_fields = [], []\n        for name, field in self.fields.items():\n            bf = BoundField(self, field, name)\n            bf_errors = self.error_class([escape(error) for error in bf.errors]) # Escape and cache in local variable.\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend([u'(Hidden field %s) %s' % (name, force_unicode(e)) for e in bf_errors])\n                hidden_fields.append(unicode(bf))\n            else:\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % force_unicode(bf_errors))\n                if bf.label:\n                    label = escape(force_unicode(bf.label))\n                    # Only add the suffix if the label does not end in\n                    # punctuation.\n                    if self.label_suffix:\n                        if label[-1] not in ':?.!':\n                            label += self.label_suffix\n                    label = bf.label_tag(label) or ''\n                else:\n                    label = ''\n                if field.help_text:\n                    help_text = help_text_html % force_unicode(field.help_text)\n                else:\n                    help_text = u''\n                output.append(normal_row % {'errors': force_unicode(bf_errors), 'label': force_unicode(label), 'field': unicode(bf), 'help_text': help_text})\n        if top_errors:\n            output.insert(0, error_row % force_unicode(top_errors))\n        if hidden_fields: # Insert any hidden fields in the last row.\n            str_hidden = u''.join(hidden_fields)\n            if output:\n                last_row = output[-1]\n                # Chop off the trailing row_ender (e.g. '</td></tr>') and\n                # insert the hidden fields.\n                if not last_row.endswith(row_ender):\n                    # This can happen in the as_p() case (and possibly others\n                    # that users write): if there are only top errors, we may\n                    # not be able to conscript the last row for our purposes,\n                    # so insert a new, empty row.\n                    last_row = normal_row % {'errors': '', 'label': '', 'field': '', 'help_text': ''}\n                    output.append(last_row)\n                output[-1] = last_row[:-len(row_ender)] + str_hidden + row_ender\n            else:\n                # If there aren't any rows in the output, just append the\n                # hidden fields.\n                output.append(str_hidden)\n        return mark_safe(u'\\n'.join(output))\n"
    },
    {
      "commit": "46786b4193e04d398532bbfc3dcf63c03c1793cb",
      "startLine": 13,
      "endLine": 28,
      "methodCode": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors = self.non_field_errors() # Errors that should be displayed above all fields.\n        output, hidden_fields = [], []\n        for name, field in self.fields.items():\n            bf = BoundField(self, field, name)\n            bf_errors = self.error_class([escape(error) for error in bf.errors]) # Escape and cache in local variable.\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend([u'(Hidden field %s) %s' % (name, force_unicode(e)) for e in bf_errors])\n                hidden_fields.append(unicode(bf))\n            else:\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % force_unicode(bf_errors))\n                if bf.label:\n                    label = escape(force_unicode(bf.label))\n                    # Only add the suffix if the label does not end in\n                    # punctuation.\n                    if self.label_suffix:\n                        if label[-1] not in ':?.!':\n                            label += self.label_suffix\n                    label = bf.label_tag(label) or ''\n                else:\n                    label = ''\n                if field.help_text:\n                    help_text = help_text_html % force_unicode(field.help_text)\n                else:\n                    help_text = u''\n                output.append(normal_row % {'errors': force_unicode(bf_errors), 'label': force_unicode(label), 'field': unicode(bf), 'help_text': help_text})\n        if top_errors:\n            output.insert(0, error_row % force_unicode(top_errors))\n        if hidden_fields: # Insert any hidden fields in the last row.\n            str_hidden = u''.join(hidden_fields)\n            if output:\n                last_row = output[-1]\n                # Chop off the trailing row_ender (e.g. '</td></tr>') and\n                # insert the hidden fields.\n                output[-1] = last_row[:-len(row_ender)] + str_hidden + row_ender\n            else:\n                # If there aren't any rows in the output, just append the\n                # hidden fields.\n                output.append(str_hidden)\n        return mark_safe(u'\\n'.join(output))\n"
    },
    {
      "commit": "931b9f310854e30a814cb3073c67007e709f6e5f",
      "startLine": 13,
      "endLine": 28,
      "methodCode": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors = self.non_field_errors() # Errors that should be displayed above all fields.\n        output, hidden_fields = [], []\n        for name, field in self.fields.items():\n            bf = BoundField(self, field, name)\n            bf_errors = self.error_class([escape(error) for error in bf.errors]) # Escape and cache in local variable.\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend([u'(Hidden field %s) %s' % (name, force_unicode(e)) for e in bf_errors])\n                hidden_fields.append(unicode(bf))\n            else:\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % force_unicode(bf_errors))\n                if bf.label:\n                    label = escape(force_unicode(bf.label))\n                    # Only add the suffix if the label does not end in\n                    # punctuation.\n                    if self.label_suffix:\n                        if label[-1] not in ':?.!':\n                            label += self.label_suffix\n                    label = bf.label_tag(label) or ''\n                else:\n                    label = ''\n                if field.help_text:\n                    help_text = help_text_html % force_unicode(field.help_text)\n                else:\n                    help_text = u''\n                output.append(normal_row % {'errors': force_unicode(bf_errors), 'label': force_unicode(label), 'field': unicode(bf), 'help_text': help_text})\n        if top_errors:\n            output.insert(0, error_row % force_unicode(top_errors))\n        if hidden_fields: # Insert any hidden fields in the last row.\n            str_hidden = u''.join(hidden_fields)\n            if output:\n                last_row = output[-1]\n                # Chop off the trailing row_ender (e.g. '</td></tr>') and\n                # insert the hidden fields.\n                output[-1] = last_row[:-len(row_ender)] + str_hidden + row_ender\n            else:\n                # If there aren't any rows in the output, just append the\n                # hidden fields.\n                output.append(str_hidden)\n        return mark_safe(u'\\n'.join(output))\n"
    },
    {
      "commit": "356662cf74c99fac90afb0f5e6aac8d2d573e62a",
      "startLine": 13,
      "endLine": 28,
      "methodCode": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors = self.non_field_errors() # Errors that should be displayed above all fields.\n        output, hidden_fields = [], []\n        for name, field in self.fields.items():\n            bf = BoundField(self, field, name)\n            bf_errors = self.error_class([escape(error) for error in bf.errors]) # Escape and cache in local variable.\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend(['(Hidden field %s) %s' % (name, force_unicode(e)) for e in bf_errors])\n                hidden_fields.append(unicode(bf))\n            else:\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % force_unicode(bf_errors))\n                if bf.label:\n                    label = escape(force_unicode(bf.label))\n                    # Only add the suffix if the label does not end in\n                    # punctuation.\n                    if self.label_suffix:\n                        if label[-1] not in ':?.!':\n                            label += self.label_suffix\n                    label = bf.label_tag(label) or ''\n                else:\n                    label = ''\n                if field.help_text:\n                    help_text = help_text_html % force_unicode(field.help_text)\n                else:\n                    help_text = u''\n                output.append(normal_row % {'errors': force_unicode(bf_errors), 'label': force_unicode(label), 'field': unicode(bf), 'help_text': help_text})\n        if top_errors:\n            output.insert(0, error_row % top_errors)\n        if hidden_fields: # Insert any hidden fields in the last row.\n            str_hidden = u''.join(hidden_fields)\n            if output:\n                last_row = output[-1]\n                # Chop off the trailing row_ender (e.g. '</td></tr>') and\n                # insert the hidden fields.\n                output[-1] = last_row[:-len(row_ender)] + str_hidden + row_ender\n            else:\n                # If there aren't any rows in the output, just append the\n                # hidden fields.\n                output.append(str_hidden)\n        return mark_safe(u'\\n'.join(output))\n"
    },
    {
      "commit": "748e55b1daa1260964d9ec29f50e01b4b4c0f5d8",
      "startLine": 13,
      "endLine": 27,
      "methodCode": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors = self.non_field_errors() # Errors that should be displayed above all fields.\n        output, hidden_fields = [], []\n        for name, field in self.fields.items():\n            bf = BoundField(self, field, name)\n            bf_errors = self.error_class([escape(error) for error in bf.errors]) # Escape and cache in local variable.\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend(['(Hidden field %s) %s' % (name, force_unicode(e)) for e in bf_errors])\n                hidden_fields.append(unicode(bf))\n            else:\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % force_unicode(bf_errors))\n                if bf.label:\n                    label = escape(force_unicode(bf.label))\n                    # Only add the suffix if the label does not end in punctuation.\n                    if self.label_suffix:\n                        if label[-1] not in ':?.!':\n                            label += self.label_suffix\n                    label = bf.label_tag(label) or ''\n                else:\n                    label = ''\n                if field.help_text:\n                    help_text = help_text_html % force_unicode(field.help_text)\n                else:\n                    help_text = u''\n                output.append(normal_row % {'errors': force_unicode(bf_errors), 'label': force_unicode(label), 'field': unicode(bf), 'help_text': help_text})\n        if top_errors:\n            output.insert(0, error_row % top_errors)\n        if hidden_fields: # Insert any hidden fields in the last row.\n            str_hidden = u''.join(hidden_fields)\n            if output:\n                last_row = output[-1]\n                # Chop off the trailing row_ender (e.g. '</td></tr>') and insert the hidden fields.\n                output[-1] = last_row[:-len(row_ender)] + str_hidden + row_ender\n            else: # If there aren't any rows in the output, just append the hidden fields.\n                output.append(str_hidden)\n        return u'\\n'.join(output)\n"
    },
    {
      "commit": "ce249d4366a800ebc033cefb8beb33b9b0dba051",
      "startLine": 13,
      "endLine": 26,
      "methodCode": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors = self.non_field_errors() # Errors that should be displayed above all fields.\n        output, hidden_fields = [], []\n        for name, field in self.fields.items():\n            bf = BoundField(self, field, name)\n            bf_errors = self.error_class([escape(error) for error in bf.errors]) # Escape and cache in local variable.\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend(['(Hidden field %s) %s' % (name, force_unicode(e)) for e in bf_errors])\n                hidden_fields.append(unicode(bf))\n            else:\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % force_unicode(bf_errors))\n                if bf.label:\n                    label = escape(force_unicode(bf.label))\n                    # Only add a colon if the label does not end in punctuation.\n                    if label[-1] not in ':?.!':\n                        label += ':'\n                    label = bf.label_tag(label) or ''\n                else:\n                    label = ''\n                if field.help_text:\n                    help_text = help_text_html % force_unicode(field.help_text)\n                else:\n                    help_text = u''\n                output.append(normal_row % {'errors': force_unicode(bf_errors), 'label': force_unicode(label), 'field': unicode(bf), 'help_text': help_text})\n        if top_errors:\n            output.insert(0, error_row % top_errors)\n        if hidden_fields: # Insert any hidden fields in the last row.\n            str_hidden = u''.join(hidden_fields)\n            if output:\n                last_row = output[-1]\n                # Chop off the trailing row_ender (e.g. '</td></tr>') and insert the hidden fields.\n                output[-1] = last_row[:-len(row_ender)] + str_hidden + row_ender\n            else: # If there aren't any rows in the output, just append the hidden fields.\n                output.append(str_hidden)\n        return u'\\n'.join(output)\n"
    },
    {
      "commit": "953badbea5a04159adbfa970f5805c0232b6a401",
      "startLine": 13,
      "endLine": 26,
      "methodCode": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors = self.non_field_errors() # Errors that should be displayed above all fields.\n        output, hidden_fields = [], []\n        for name, field in self.fields.items():\n            bf = BoundField(self, field, name)\n            bf_errors = ErrorList([escape(error) for error in bf.errors]) # Escape and cache in local variable.\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend(['(Hidden field %s) %s' % (name, force_unicode(e)) for e in bf_errors])\n                hidden_fields.append(unicode(bf))\n            else:\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % force_unicode(bf_errors))\n                if bf.label:\n                    label = escape(force_unicode(bf.label))\n                    # Only add a colon if the label does not end in punctuation.\n                    if label[-1] not in ':?.!':\n                        label += ':'\n                    label = bf.label_tag(label) or ''\n                else:\n                    label = ''\n                if field.help_text:\n                    help_text = help_text_html % force_unicode(field.help_text)\n                else:\n                    help_text = u''\n                output.append(normal_row % {'errors': force_unicode(bf_errors), 'label': force_unicode(label), 'field': unicode(bf), 'help_text': help_text})\n        if top_errors:\n            output.insert(0, error_row % top_errors)\n        if hidden_fields: # Insert any hidden fields in the last row.\n            str_hidden = u''.join(hidden_fields)\n            if output:\n                last_row = output[-1]\n                # Chop off the trailing row_ender (e.g. '</td></tr>') and insert the hidden fields.\n                output[-1] = last_row[:-len(row_ender)] + str_hidden + row_ender\n            else: # If there aren't any rows in the output, just append the hidden fields.\n                output.append(str_hidden)\n        return u'\\n'.join(output)\n"
    },
    {
      "commit": "8a4a8023d61cb31093db7b511e58ea3502e47cb6",
      "startLine": 13,
      "endLine": 26,
      "methodCode": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors = self.non_field_errors() # Errors that should be displayed above all fields.\n        output, hidden_fields = [], []\n        for name, field in self.fields.items():\n            bf = BoundField(self, field, name)\n            bf_errors = ErrorList([escape(error) for error in bf.errors]) # Escape and cache in local variable.\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend(['(Hidden field %s) %s' % (name, e) for e in bf_errors])\n                hidden_fields.append(unicode(bf))\n            else:\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % bf_errors)\n                if bf.label:\n                    label = escape(bf.label)\n                    # Only add a colon if the label does not end in punctuation.\n                    if label[-1] not in ':?.!':\n                        label += ':'\n                    label = bf.label_tag(label) or ''\n                else:\n                    label = ''\n                if field.help_text:\n                    help_text = help_text_html % field.help_text\n                else:\n                    help_text = u''\n                output.append(normal_row % {'errors': bf_errors, 'label': label, 'field': unicode(bf), 'help_text': help_text})\n        if top_errors:\n            output.insert(0, error_row % top_errors)\n        if hidden_fields: # Insert any hidden fields in the last row.\n            str_hidden = u''.join(hidden_fields)\n            if output:\n                last_row = output[-1]\n                # Chop off the trailing row_ender (e.g. '</td></tr>') and insert the hidden fields.\n                output[-1] = last_row[:-len(row_ender)] + str_hidden + row_ender\n            else: # If there aren't any rows in the output, just append the hidden fields.\n                output.append(str_hidden)\n        return u'\\n'.join(output)\n"
    },
    {
      "commit": "b8fa80bd0020eee186e5288e3fd2552695093025",
      "startLine": 13,
      "endLine": 19,
      "methodCode": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors = self.non_field_errors() # Errors that should be displayed above all fields.\n        output, hidden_fields = [], []\n        for name, field in self.fields.items():\n            bf = BoundField(self, field, name)\n            bf_errors = ErrorList([escape(error) for error in bf.errors]) # Escape and cache in local variable.\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend(['(Hidden field %s) %s' % (name, e) for e in bf_errors])\n                hidden_fields.append(unicode(bf))\n            else:\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % bf_errors)\n                label = bf.label and bf.label_tag(escape(bf.label + ':')) or ''\n                if field.help_text:\n                    help_text = help_text_html % field.help_text\n                else:\n                    help_text = u''\n                output.append(normal_row % {'errors': bf_errors, 'label': label, 'field': unicode(bf), 'help_text': help_text})\n        if top_errors:\n            output.insert(0, error_row % top_errors)\n        if hidden_fields: # Insert any hidden fields in the last row.\n            str_hidden = u''.join(hidden_fields)\n            if output:\n                last_row = output[-1]\n                # Chop off the trailing row_ender (e.g. '</td></tr>') and insert the hidden fields.\n                output[-1] = last_row[:-len(row_ender)] + str_hidden + row_ender\n            else: # If there aren't any rows in the output, just append the hidden fields.\n                output.append(str_hidden)\n        return u'\\n'.join(output)\n"
    },
    {
      "commit": "cf75fcc8321b822cb4758d167f1fade56a60ad4f",
      "startLine": 13,
      "endLine": 19,
      "methodCode": "    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors = self.non_field_errors() # Errors that should be displayed above all fields.\n        output, hidden_fields = [], []\n        for name, field in self.fields.items():\n            bf = BoundField(self, field, name)\n            bf_errors = bf.errors # Cache in local variable.\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend(['(Hidden field %s) %s' % (name, e) for e in bf_errors])\n                hidden_fields.append(unicode(bf))\n            else:\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % bf_errors)\n                label = bf.label and bf.label_tag(escape(bf.label + ':')) or ''\n                if field.help_text:\n                    help_text = help_text_html % field.help_text\n                else:\n                    help_text = u''\n                output.append(normal_row % {'errors': bf_errors, 'label': label, 'field': unicode(bf), 'help_text': help_text})\n        if top_errors:\n            output.insert(0, error_row % top_errors)\n        if hidden_fields: # Insert any hidden fields in the last row.\n            str_hidden = u''.join(hidden_fields)\n            if output:\n                last_row = output[-1]\n                # Chop off the trailing row_ender (e.g. '</td></tr>') and insert the hidden fields.\n                output[-1] = last_row[:-len(row_ender)] + str_hidden + row_ender\n            else: # If there aren't any rows in the output, just append the hidden fields.\n                output.append(str_hidden)\n        return u'\\n'.join(output)\n"
    },
    {
      "commit": "54b8277ffb4cad90fb65ca4edf69d8279b8df898",
      "startLine": 13,
      "endLine": 15,
      "methodCode": "    def _html_output(self, normal_row, error_row, row_ender, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors = self.non_field_errors() # Errors that should be displayed above all fields.\n        output, hidden_fields = [], []\n        for name, field in self.fields.items():\n            bf = BoundField(self, field, name)\n            bf_errors = bf.errors # Cache in local variable.\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend(['(Hidden field %s) %s' % (name, e) for e in bf_errors])\n                hidden_fields.append(unicode(bf))\n            else:\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % bf_errors)\n                label = bf.label and bf.label_tag(escape(bf.label + ':')) or ''\n                output.append(normal_row % {'errors': bf_errors, 'label': label, 'field': unicode(bf)})\n        if top_errors:\n            output.insert(0, error_row % top_errors)\n        if hidden_fields: # Insert any hidden fields in the last row.\n            str_hidden = u''.join(hidden_fields)\n            if output:\n                last_row = output[-1]\n                # Chop off the trailing row_ender (e.g. '</td></tr>') and insert the hidden fields.\n                output[-1] = last_row[:-len(row_ender)] + str_hidden + row_ender\n            else: # If there aren't any rows in the output, just append the hidden fields.\n                output.append(str_hidden)\n        return u'\\n'.join(output)\n"
    },
    {
      "commit": "d0fcef9db0f53ef84535694f4fbcb135f0648e24",
      "startLine": 13,
      "endLine": 15,
      "methodCode": "    def _html_output(self, normal_row, error_row, row_ender, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors = self.non_field_errors() # Errors that should be displayed above all fields.\n        output, hidden_fields = [], []\n        for name, field in self.fields.items():\n            bf = BoundField(self, field, name)\n            bf_errors = bf.errors # Cache in local variable.\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend(['(Hidden field %s) %s' % (name, e) for e in bf_errors])\n                hidden_fields.append(unicode(bf))\n            else:\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % bf_errors)\n                label = bf.label and bf.label_tag(escape(bf.label + ':')) or ''\n                output.append(normal_row % {'errors': bf_errors, 'label': label, 'field': bf})\n        if top_errors:\n            output.insert(0, error_row % top_errors)\n        if hidden_fields: # Insert any hidden fields in the last row.\n            str_hidden = u''.join(hidden_fields)\n            if output:\n                last_row = output[-1]\n                # Chop off the trailing row_ender (e.g. '</td></tr>') and insert the hidden fields.\n                output[-1] = last_row[:-len(row_ender)] + str_hidden + row_ender\n            else: # If there aren't any rows in the output, just append the hidden fields.\n                output.append(str_hidden)\n        return u'\\n'.join(output)\n"
    },
    {
      "commit": "d93021eb10b1ff8c49a4f4746789c22589886260",
      "startLine": 13,
      "endLine": 14,
      "methodCode": "    def _html_output(self, normal_row, error_row, row_ender, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors = self.non_field_errors() # Errors that should be displayed above all fields.\n        output, hidden_fields = [], []\n        for name, field in self.fields.items():\n            bf = BoundField(self, field, name)\n            bf_errors = bf.errors # Cache in local variable.\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend(['(Hidden field %s) %s' % (name, e) for e in bf_errors])\n                hidden_fields.append(unicode(bf))\n            else:\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % bf_errors)\n                output.append(normal_row % {'errors': bf_errors, 'label': bf.label_tag(escape(bf.label+':')), 'field': bf})\n        if top_errors:\n            output.insert(0, error_row % top_errors)\n        if hidden_fields: # Insert any hidden fields in the last row.\n            str_hidden = u''.join(hidden_fields)\n            if output:\n                last_row = output[-1]\n                # Chop off the trailing row_ender (e.g. '</td></tr>') and insert the hidden fields.\n                output[-1] = last_row[:-len(row_ender)] + str_hidden + row_ender\n            else: # If there aren't any rows in the output, just append the hidden fields.\n                output.append(str_hidden)\n        return u'\\n'.join(output)\n"
    },
    {
      "commit": "c50d333c23a3c53d05623ce15df79e624c57f37c",
      "startLine": 13,
      "endLine": 14,
      "methodCode": "    def _html_output(self, normal_row, error_row, row_ender, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors = self.non_field_errors() # Errors that should be displayed above all fields.\n        output, hidden_fields = [], []\n        for name, field in self.fields.items():\n            bf = BoundField(self, field, name)\n            bf_errors = bf.errors # Cache in local variable.\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend(['(Hidden field %s) %s' % (name, e) for e in bf_errors])\n                hidden_fields.append(unicode(bf))\n            else:\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % bf_errors)\n                output.append(normal_row % {'errors': bf_errors, 'label': bf.label_tag(escape(bf.verbose_name+':')), 'field': bf})\n        if top_errors:\n            output.insert(0, error_row % top_errors)\n        if hidden_fields: # Insert any hidden fields in the last row.\n            str_hidden = u''.join(hidden_fields)\n            if output:\n                last_row = output[-1]\n                # Chop off the trailing row_ender (e.g. '</td></tr>') and insert the hidden fields.\n                output[-1] = last_row[:-len(row_ender)] + str_hidden + row_ender\n            else: # If there aren't any rows in the output, just append the hidden fields.\n                output.append(str_hidden)\n        return u'\\n'.join(output)\n"
    }
  ]
}