{
  "statementVersions": [
    {
      "commit": "109d682215eeaded5966de5d898c2832bc98ebe0",
      "startLine": 16,
      "endLine": 37,
      "methodCode": "def isin(comps, values) -> np.ndarray:\n    \"\"\"\n    Compute the isin boolean array.\n\n    Parameters\n    ----------\n    comps : array-like\n    values : array-like\n\n    Returns\n    -------\n    ndarray[bool]\n        Same length as `comps`.\n    \"\"\"\n\n    if not is_list_like(comps):\n        raise TypeError(\n            \"only list-like objects are allowed to be passed\"\n            \" to isin(), you passed a [{comps_type}]\".format(\n                comps_type=type(comps).__name__\n            )\n        )\n    if not is_list_like(values):\n        raise TypeError(\n            \"only list-like objects are allowed to be passed\"\n            \" to isin(), you passed a [{values_type}]\".format(\n                values_type=type(values).__name__\n            )\n        )\n\n    if not isinstance(values, (ABCIndex, ABCSeries, np.ndarray)):\n        values = construct_1d_object_array_from_listlike(list(values))\n\n    if is_categorical_dtype(comps):\n        # TODO(extension)\n        # handle categoricals\n        return comps._values.isin(values)\n\n    comps = com.values_from_object(comps)\n\n    comps, dtype = _ensure_data(comps)\n    values, _ = _ensure_data(values, dtype=dtype)\n\n    # faster for larger cases to use np.in1d\n    f = htable.ismember_object\n\n    # GH16012\n    # Ensure np.in1d doesn't get object types or it *may* throw an exception\n    if len(comps) > 1000000 and not is_object_dtype(comps):\n        f = np.in1d\n    elif is_integer_dtype(comps):\n        try:\n            values = values.astype(\"int64\", copy=False)\n            comps = comps.astype(\"int64\", copy=False)\n            f = htable.ismember_int64\n        except (TypeError, ValueError, OverflowError):\n            values = values.astype(object)\n            comps = comps.astype(object)\n\n    elif is_float_dtype(comps):\n        try:\n            values = values.astype(\"float64\", copy=False)\n            comps = comps.astype(\"float64\", copy=False)\n            f = htable.ismember_float64\n        except (TypeError, ValueError):\n            values = values.astype(object)\n            comps = comps.astype(object)\n\n    return f(comps, values)\n\n"
    },
    {
      "commit": "bb6135880e5e453d7701764b9f2e4ad3356a68d7",
      "startLine": 15,
      "endLine": 36,
      "methodCode": "def isin(comps, values):\n    \"\"\"\n    Compute the isin boolean array\n\n    Parameters\n    ----------\n    comps : array-like\n    values : array-like\n\n    Returns\n    -------\n    boolean array same length as comps\n    \"\"\"\n\n    if not is_list_like(comps):\n        raise TypeError(\n            \"only list-like objects are allowed to be passed\"\n            \" to isin(), you passed a [{comps_type}]\".format(\n                comps_type=type(comps).__name__\n            )\n        )\n    if not is_list_like(values):\n        raise TypeError(\n            \"only list-like objects are allowed to be passed\"\n            \" to isin(), you passed a [{values_type}]\".format(\n                values_type=type(values).__name__\n            )\n        )\n\n    if not isinstance(values, (ABCIndex, ABCSeries, np.ndarray)):\n        values = construct_1d_object_array_from_listlike(list(values))\n\n    if is_categorical_dtype(comps):\n        # TODO(extension)\n        # handle categoricals\n        return comps._values.isin(values)\n\n    comps = com.values_from_object(comps)\n\n    comps, dtype, _ = _ensure_data(comps)\n    values, _, _ = _ensure_data(values, dtype=dtype)\n\n    # faster for larger cases to use np.in1d\n    f = lambda x, y: htable.ismember_object(x, values)\n\n    # GH16012\n    # Ensure np.in1d doesn't get object types or it *may* throw an exception\n    if len(comps) > 1000000 and not is_object_dtype(comps):\n        f = lambda x, y: np.in1d(x, y)\n    elif is_integer_dtype(comps):\n        try:\n            values = values.astype(\"int64\", copy=False)\n            comps = comps.astype(\"int64\", copy=False)\n            f = lambda x, y: htable.ismember_int64(x, y)\n        except (TypeError, ValueError, OverflowError):\n            values = values.astype(object)\n            comps = comps.astype(object)\n\n    elif is_float_dtype(comps):\n        try:\n            values = values.astype(\"float64\", copy=False)\n            comps = comps.astype(\"float64\", copy=False)\n            f = lambda x, y: htable.ismember_float64(x, y)\n        except (TypeError, ValueError):\n            values = values.astype(object)\n            comps = comps.astype(object)\n\n    return f(comps, values)\n\n"
    },
    {
      "commit": "1a42c70e532ae01c95596d071ab62dc535e2bac9",
      "startLine": 15,
      "endLine": 30,
      "methodCode": "def isin(comps, values):\n    \"\"\"\n    Compute the isin boolean array\n\n    Parameters\n    ----------\n    comps : array-like\n    values : array-like\n\n    Returns\n    -------\n    boolean array same length as comps\n    \"\"\"\n\n    if not is_list_like(comps):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a [{comps_type}]\"\n                        .format(comps_type=type(comps).__name__))\n    if not is_list_like(values):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a [{values_type}]\"\n                        .format(values_type=type(values).__name__))\n\n    if not isinstance(values, (ABCIndex, ABCSeries, np.ndarray)):\n        values = construct_1d_object_array_from_listlike(list(values))\n\n    if is_categorical_dtype(comps):\n        # TODO(extension)\n        # handle categoricals\n        return comps._values.isin(values)\n\n    comps = com.values_from_object(comps)\n\n    comps, dtype, _ = _ensure_data(comps)\n    values, _, _ = _ensure_data(values, dtype=dtype)\n\n    # faster for larger cases to use np.in1d\n    f = lambda x, y: htable.ismember_object(x, values)\n\n    # GH16012\n    # Ensure np.in1d doesn't get object types or it *may* throw an exception\n    if len(comps) > 1000000 and not is_object_dtype(comps):\n        f = lambda x, y: np.in1d(x, y)\n    elif is_integer_dtype(comps):\n        try:\n            values = values.astype('int64', copy=False)\n            comps = comps.astype('int64', copy=False)\n            f = lambda x, y: htable.ismember_int64(x, y)\n        except (TypeError, ValueError, OverflowError):\n            values = values.astype(object)\n            comps = comps.astype(object)\n\n    elif is_float_dtype(comps):\n        try:\n            values = values.astype('float64', copy=False)\n            comps = comps.astype('float64', copy=False)\n            f = lambda x, y: htable.ismember_float64(x, y)\n        except (TypeError, ValueError):\n            values = values.astype(object)\n            comps = comps.astype(object)\n\n    return f(comps, values)\n\n"
    },
    {
      "commit": "2c2b6585c1c45889d32491b4a0403617a2d48e17",
      "startLine": 15,
      "endLine": 30,
      "methodCode": "def isin(comps, values):\n    \"\"\"\n    Compute the isin boolean array\n\n    Parameters\n    ----------\n    comps: array-like\n    values: array-like\n\n    Returns\n    -------\n    boolean array same length as comps\n    \"\"\"\n\n    if not is_list_like(comps):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a [{comps_type}]\"\n                        .format(comps_type=type(comps).__name__))\n    if not is_list_like(values):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a [{values_type}]\"\n                        .format(values_type=type(values).__name__))\n\n    if not isinstance(values, (ABCIndex, ABCSeries, np.ndarray)):\n        values = construct_1d_object_array_from_listlike(list(values))\n\n    if is_categorical_dtype(comps):\n        # TODO(extension)\n        # handle categoricals\n        return comps._values.isin(values)\n\n    comps = com.values_from_object(comps)\n\n    comps, dtype, _ = _ensure_data(comps)\n    values, _, _ = _ensure_data(values, dtype=dtype)\n\n    # faster for larger cases to use np.in1d\n    f = lambda x, y: htable.ismember_object(x, values)\n\n    # GH16012\n    # Ensure np.in1d doesn't get object types or it *may* throw an exception\n    if len(comps) > 1000000 and not is_object_dtype(comps):\n        f = lambda x, y: np.in1d(x, y)\n    elif is_integer_dtype(comps):\n        try:\n            values = values.astype('int64', copy=False)\n            comps = comps.astype('int64', copy=False)\n            f = lambda x, y: htable.ismember_int64(x, y)\n        except (TypeError, ValueError, OverflowError):\n            values = values.astype(object)\n            comps = comps.astype(object)\n\n    elif is_float_dtype(comps):\n        try:\n            values = values.astype('float64', copy=False)\n            comps = comps.astype('float64', copy=False)\n            f = lambda x, y: htable.ismember_float64(x, y)\n        except (TypeError, ValueError):\n            values = values.astype(object)\n            comps = comps.astype(object)\n\n    return f(comps, values)\n\n"
    },
    {
      "commit": "020e9485baf9889c508154fe95663b5ab2210bc4",
      "startLine": 15,
      "endLine": 30,
      "methodCode": "def isin(comps, values):\n    \"\"\"\n    Compute the isin boolean array\n\n    Parameters\n    ----------\n    comps: array-like\n    values: array-like\n\n    Returns\n    -------\n    boolean array same length as comps\n    \"\"\"\n\n    if not is_list_like(comps):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a [{comps_type}]\"\n                        .format(comps_type=type(comps).__name__))\n    if not is_list_like(values):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a [{values_type}]\"\n                        .format(values_type=type(values).__name__))\n\n    if not isinstance(values, (ABCIndex, ABCSeries, np.ndarray)):\n        values = construct_1d_object_array_from_listlike(list(values))\n\n    if is_categorical_dtype(comps):\n        # TODO(extension)\n        # handle categoricals\n        return comps._values.isin(values)\n\n    comps = com.values_from_object(comps)\n\n    comps, dtype, _ = _ensure_data(comps)\n    values, _, _ = _ensure_data(values, dtype=dtype)\n\n    # faster for larger cases to use np.in1d\n    f = lambda x, y: htable.ismember_object(x, values)\n\n    # GH16012\n    # Ensure np.in1d doesn't get object types or it *may* throw an exception\n    if len(comps) > 1000000 and not is_object_dtype(comps):\n        f = lambda x, y: np.in1d(x, y)\n    elif is_integer_dtype(comps):\n        try:\n            values = values.astype('int64', copy=False)\n            comps = comps.astype('int64', copy=False)\n            f = lambda x, y: htable.ismember_int64(x, y)\n        except (TypeError, ValueError, OverflowError):\n            values = values.astype(object)\n            comps = comps.astype(object)\n\n    elif is_float_dtype(comps):\n        try:\n            values = values.astype('float64', copy=False)\n            comps = comps.astype('float64', copy=False)\n            checknull = isna(values).any()\n            f = lambda x, y: htable.ismember_float64(x, y, checknull)\n        except (TypeError, ValueError):\n            values = values.astype(object)\n            comps = comps.astype(object)\n\n    return f(comps, values)\n\n"
    },
    {
      "commit": "2d0c96119391c85bd4f7ffbb847759ee3777162a",
      "startLine": 15,
      "endLine": 30,
      "methodCode": "def isin(comps, values):\n    \"\"\"\n    Compute the isin boolean array\n\n    Parameters\n    ----------\n    comps: array-like\n    values: array-like\n\n    Returns\n    -------\n    boolean array same length as comps\n    \"\"\"\n\n    if not is_list_like(comps):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a [{comps_type}]\"\n                        .format(comps_type=type(comps).__name__))\n    if not is_list_like(values):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a [{values_type}]\"\n                        .format(values_type=type(values).__name__))\n\n    if not isinstance(values, (ABCIndex, ABCSeries, np.ndarray)):\n        values = construct_1d_object_array_from_listlike(list(values))\n\n    if is_categorical_dtype(comps):\n        # TODO(extension)\n        # handle categoricals\n        return comps._values.isin(values)\n\n    comps = com.values_from_object(comps)\n\n    comps, dtype, _ = _ensure_data(comps)\n    values, _, _ = _ensure_data(values, dtype=dtype)\n\n    # faster for larger cases to use np.in1d\n    f = lambda x, y: htable.ismember_object(x, values)\n\n    # GH16012\n    # Ensure np.in1d doesn't get object types or it *may* throw an exception\n    if len(comps) > 1000000 and not is_object_dtype(comps):\n        f = lambda x, y: np.in1d(x, y)\n    elif is_integer_dtype(comps):\n        try:\n            values = values.astype('int64', copy=False)\n            comps = comps.astype('int64', copy=False)\n            f = lambda x, y: htable.ismember_int64(x, y)\n        except (TypeError, ValueError):\n            values = values.astype(object)\n            comps = comps.astype(object)\n\n    elif is_float_dtype(comps):\n        try:\n            values = values.astype('float64', copy=False)\n            comps = comps.astype('float64', copy=False)\n            checknull = isna(values).any()\n            f = lambda x, y: htable.ismember_float64(x, y, checknull)\n        except (TypeError, ValueError):\n            values = values.astype(object)\n            comps = comps.astype(object)\n\n    return f(comps, values)\n\n"
    },
    {
      "commit": "60fe82c8a2829e831d28cf6d4b3595637c3c5802",
      "startLine": 15,
      "endLine": 30,
      "methodCode": "def isin(comps, values):\n    \"\"\"\n    Compute the isin boolean array\n\n    Parameters\n    ----------\n    comps: array-like\n    values: array-like\n\n    Returns\n    -------\n    boolean array same length as comps\n    \"\"\"\n\n    if not is_list_like(comps):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a [{comps_type}]\"\n                        .format(comps_type=type(comps).__name__))\n    if not is_list_like(values):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a [{values_type}]\"\n                        .format(values_type=type(values).__name__))\n\n    if not isinstance(values, (ABCIndex, ABCSeries, np.ndarray)):\n        values = construct_1d_object_array_from_listlike(list(values))\n\n    if is_categorical_dtype(comps):\n        # TODO(extension)\n        # handle categoricals\n        return comps._values.isin(values)\n\n    comps = com._values_from_object(comps)\n\n    comps, dtype, _ = _ensure_data(comps)\n    values, _, _ = _ensure_data(values, dtype=dtype)\n\n    # faster for larger cases to use np.in1d\n    f = lambda x, y: htable.ismember_object(x, values)\n\n    # GH16012\n    # Ensure np.in1d doesn't get object types or it *may* throw an exception\n    if len(comps) > 1000000 and not is_object_dtype(comps):\n        f = lambda x, y: np.in1d(x, y)\n    elif is_integer_dtype(comps):\n        try:\n            values = values.astype('int64', copy=False)\n            comps = comps.astype('int64', copy=False)\n            f = lambda x, y: htable.ismember_int64(x, y)\n        except (TypeError, ValueError):\n            values = values.astype(object)\n            comps = comps.astype(object)\n\n    elif is_float_dtype(comps):\n        try:\n            values = values.astype('float64', copy=False)\n            comps = comps.astype('float64', copy=False)\n            checknull = isna(values).any()\n            f = lambda x, y: htable.ismember_float64(x, y, checknull)\n        except (TypeError, ValueError):\n            values = values.astype(object)\n            comps = comps.astype(object)\n\n    return f(comps, values)\n\n"
    },
    {
      "commit": "04db779d4c93d286bb0ab87780a85d50ec490266",
      "startLine": 15,
      "endLine": 25,
      "methodCode": "def isin(comps, values):\n    \"\"\"\n    Compute the isin boolean array\n\n    Parameters\n    ----------\n    comps: array-like\n    values: array-like\n\n    Returns\n    -------\n    boolean array same length as comps\n    \"\"\"\n\n    if not is_list_like(comps):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a [{comps_type}]\"\n                        .format(comps_type=type(comps).__name__))\n    if not is_list_like(values):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a [{values_type}]\"\n                        .format(values_type=type(values).__name__))\n\n    if not isinstance(values, (ABCIndex, ABCSeries, np.ndarray)):\n        values = construct_1d_object_array_from_listlike(list(values))\n\n    comps, dtype, _ = _ensure_data(comps)\n    values, _, _ = _ensure_data(values, dtype=dtype)\n\n    # faster for larger cases to use np.in1d\n    f = lambda x, y: htable.ismember_object(x, values)\n\n    # GH16012\n    # Ensure np.in1d doesn't get object types or it *may* throw an exception\n    if len(comps) > 1000000 and not is_object_dtype(comps):\n        f = lambda x, y: np.in1d(x, y)\n    elif is_integer_dtype(comps):\n        try:\n            values = values.astype('int64', copy=False)\n            comps = comps.astype('int64', copy=False)\n            f = lambda x, y: htable.ismember_int64(x, y)\n        except (TypeError, ValueError):\n            values = values.astype(object)\n            comps = comps.astype(object)\n\n    elif is_float_dtype(comps):\n        try:\n            values = values.astype('float64', copy=False)\n            comps = comps.astype('float64', copy=False)\n            checknull = isna(values).any()\n            f = lambda x, y: htable.ismember_float64(x, y, checknull)\n        except (TypeError, ValueError):\n            values = values.astype(object)\n            comps = comps.astype(object)\n\n    return f(comps, values)\n\n"
    },
    {
      "commit": "dfaf8c6918ff20ef781d3177f464a29e70ee5d65",
      "startLine": 15,
      "endLine": 25,
      "methodCode": "def isin(comps, values):\n    \"\"\"\n    Compute the isin boolean array\n\n    Parameters\n    ----------\n    comps: array-like\n    values: array-like\n\n    Returns\n    -------\n    boolean array same length as comps\n    \"\"\"\n\n    if not is_list_like(comps):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a [{comps_type}]\"\n                        .format(comps_type=type(comps).__name__))\n    if not is_list_like(values):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a [{values_type}]\"\n                        .format(values_type=type(values).__name__))\n\n    if not isinstance(values, (ABCIndex, ABCSeries, np.ndarray)):\n        values = lib.list_to_object_array(list(values))\n\n    comps, dtype, _ = _ensure_data(comps)\n    values, _, _ = _ensure_data(values, dtype=dtype)\n\n    # faster for larger cases to use np.in1d\n    f = lambda x, y: htable.ismember_object(x, values)\n\n    # GH16012\n    # Ensure np.in1d doesn't get object types or it *may* throw an exception\n    if len(comps) > 1000000 and not is_object_dtype(comps):\n        f = lambda x, y: np.in1d(x, y)\n    elif is_integer_dtype(comps):\n        try:\n            values = values.astype('int64', copy=False)\n            comps = comps.astype('int64', copy=False)\n            f = lambda x, y: htable.ismember_int64(x, y)\n        except (TypeError, ValueError):\n            values = values.astype(object)\n            comps = comps.astype(object)\n\n    elif is_float_dtype(comps):\n        try:\n            values = values.astype('float64', copy=False)\n            comps = comps.astype('float64', copy=False)\n            checknull = isna(values).any()\n            f = lambda x, y: htable.ismember_float64(x, y, checknull)\n        except (TypeError, ValueError):\n            values = values.astype(object)\n            comps = comps.astype(object)\n\n    return f(comps, values)\n\n"
    },
    {
      "commit": "870b6a6d6415c76d051b287adcb180ac3020b6e8",
      "startLine": 15,
      "endLine": 25,
      "methodCode": "def isin(comps, values):\n    \"\"\"\n    Compute the isin boolean array\n\n    Parameters\n    ----------\n    comps: array-like\n    values: array-like\n\n    Returns\n    -------\n    boolean array same length as comps\n    \"\"\"\n\n    if not is_list_like(comps):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a \"\n                        \"[{0}]\".format(type(comps).__name__))\n    if not is_list_like(values):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a \"\n                        \"[{0}]\".format(type(values).__name__))\n\n    if not isinstance(values, (ABCIndex, ABCSeries, np.ndarray)):\n        values = lib.list_to_object_array(list(values))\n\n    comps, dtype, _ = _ensure_data(comps)\n    values, _, _ = _ensure_data(values, dtype=dtype)\n\n    # faster for larger cases to use np.in1d\n    f = lambda x, y: htable.ismember_object(x, values)\n\n    # GH16012\n    # Ensure np.in1d doesn't get object types or it *may* throw an exception\n    if len(comps) > 1000000 and not is_object_dtype(comps):\n        f = lambda x, y: np.in1d(x, y)\n    elif is_integer_dtype(comps):\n        try:\n            values = values.astype('int64', copy=False)\n            comps = comps.astype('int64', copy=False)\n            f = lambda x, y: htable.ismember_int64(x, y)\n        except (TypeError, ValueError):\n            values = values.astype(object)\n            comps = comps.astype(object)\n\n    elif is_float_dtype(comps):\n        try:\n            values = values.astype('float64', copy=False)\n            comps = comps.astype('float64', copy=False)\n            checknull = isna(values).any()\n            f = lambda x, y: htable.ismember_float64(x, y, checknull)\n        except (TypeError, ValueError):\n            values = values.astype(object)\n            comps = comps.astype(object)\n\n    return f(comps, values)\n\n"
    },
    {
      "commit": "793020293ee1e5fa023f45c12943a4ac51cc23d0",
      "startLine": 15,
      "endLine": 25,
      "methodCode": "def isin(comps, values):\n    \"\"\"\n    Compute the isin boolean array\n\n    Parameters\n    ----------\n    comps: array-like\n    values: array-like\n\n    Returns\n    -------\n    boolean array same length as comps\n    \"\"\"\n\n    if not is_list_like(comps):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a \"\n                        \"[{0}]\".format(type(comps).__name__))\n    if not is_list_like(values):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a \"\n                        \"[{0}]\".format(type(values).__name__))\n\n    if not isinstance(values, (ABCIndex, ABCSeries, np.ndarray)):\n        values = lib.list_to_object_array(list(values))\n\n    comps, dtype, _ = _ensure_data(comps)\n    values, _, _ = _ensure_data(values, dtype=dtype)\n\n    # GH11232\n    # work-around for numpy < 1.8 and comparisions on py3\n    # faster for larger cases to use np.in1d\n    f = lambda x, y: htable.ismember_object(x, values)\n    # GH16012\n    # Ensure np.in1d doesn't get object types or it *may* throw an exception\n    if ((_np_version_under1p8 and compat.PY3) or len(comps) > 1000000 and\n       not is_object_dtype(comps)):\n        f = lambda x, y: np.in1d(x, y)\n    elif is_integer_dtype(comps):\n        try:\n            values = values.astype('int64', copy=False)\n            comps = comps.astype('int64', copy=False)\n            f = lambda x, y: htable.ismember_int64(x, y)\n        except (TypeError, ValueError):\n            values = values.astype(object)\n            comps = comps.astype(object)\n\n    elif is_float_dtype(comps):\n        try:\n            values = values.astype('float64', copy=False)\n            comps = comps.astype('float64', copy=False)\n            checknull = isna(values).any()\n            f = lambda x, y: htable.ismember_float64(x, y, checknull)\n        except (TypeError, ValueError):\n            values = values.astype(object)\n            comps = comps.astype(object)\n\n    return f(comps, values)\n\n"
    },
    {
      "commit": "a1dfb037de79e6982a0e7ccf883e5af11e9cc843",
      "startLine": 15,
      "endLine": 25,
      "methodCode": "def isin(comps, values):\n    \"\"\"\n    Compute the isin boolean array\n\n    Parameters\n    ----------\n    comps: array-like\n    values: array-like\n\n    Returns\n    -------\n    boolean array same length as comps\n    \"\"\"\n\n    if not is_list_like(comps):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a \"\n                        \"[{0}]\".format(type(comps).__name__))\n    if not is_list_like(values):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a \"\n                        \"[{0}]\".format(type(values).__name__))\n\n    if not isinstance(values, (ABCIndex, ABCSeries, np.ndarray)):\n        values = lib.list_to_object_array(list(values))\n\n    comps, dtype, _ = _ensure_data(comps)\n    values, _, _ = _ensure_data(values, dtype=dtype)\n\n    # GH11232\n    # work-around for numpy < 1.8 and comparisions on py3\n    # faster for larger cases to use np.in1d\n    f = lambda x, y: htable.ismember_object(x, values)\n    # GH16012\n    # Ensure np.in1d doesn't get object types or it *may* throw an exception\n    if ((_np_version_under1p8 and compat.PY3) or len(comps) > 1000000 and\n       not is_object_dtype(comps)):\n        f = lambda x, y: np.in1d(x, y)\n    elif is_integer_dtype(comps):\n        try:\n            values = values.astype('int64', copy=False)\n            comps = comps.astype('int64', copy=False)\n            f = lambda x, y: htable.ismember_int64(x, y)\n        except (TypeError, ValueError):\n            values = values.astype(object)\n            comps = comps.astype(object)\n\n    elif is_float_dtype(comps):\n        try:\n            values = values.astype('float64', copy=False)\n            comps = comps.astype('float64', copy=False)\n            checknull = isnull(values).any()\n            f = lambda x, y: htable.ismember_float64(x, y, checknull)\n        except (TypeError, ValueError):\n            values = values.astype(object)\n            comps = comps.astype(object)\n\n    return f(comps, values)\n\n"
    },
    {
      "commit": "e053ee301d82a44ddc86dc7e164fea2d5c5178f8",
      "startLine": 15,
      "endLine": 25,
      "methodCode": "def isin(comps, values):\n    \"\"\"\n    Compute the isin boolean array\n\n    Parameters\n    ----------\n    comps: array-like\n    values: array-like\n\n    Returns\n    -------\n    boolean array same length as comps\n    \"\"\"\n\n    if not is_list_like(comps):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a \"\n                        \"[{0}]\".format(type(comps).__name__))\n    if not is_list_like(values):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a \"\n                        \"[{0}]\".format(type(values).__name__))\n\n    if not isinstance(values, (ABCIndex, ABCSeries, np.ndarray)):\n        values = lib.list_to_object_array(list(values))\n\n    comps, dtype, _ = _ensure_data(comps)\n    values, _, _ = _ensure_data(values, dtype=dtype)\n\n    # GH11232\n    # work-around for numpy < 1.8 and comparisions on py3\n    # faster for larger cases to use np.in1d\n    f = lambda x, y: htable.ismember_object(x, values)\n    if (_np_version_under1p8 and compat.PY3) or len(comps) > 1000000:\n        f = lambda x, y: np.in1d(x, y)\n    elif is_integer_dtype(comps):\n        try:\n            values = values.astype('int64', copy=False)\n            comps = comps.astype('int64', copy=False)\n            f = lambda x, y: htable.ismember_int64(x, y)\n        except (TypeError, ValueError):\n            values = values.astype(object)\n            comps = comps.astype(object)\n\n    elif is_float_dtype(comps):\n        try:\n            values = values.astype('float64', copy=False)\n            comps = comps.astype('float64', copy=False)\n            checknull = isnull(values).any()\n            f = lambda x, y: htable.ismember_float64(x, y, checknull)\n        except (TypeError, ValueError):\n            values = values.astype(object)\n            comps = comps.astype(object)\n\n    return f(comps, values)\n\n"
    },
    {
      "commit": "0cfc08cf4584e8442c84c30d53f1dceafeac5abf",
      "startLine": 15,
      "endLine": 25,
      "methodCode": "def isin(comps, values):\n    \"\"\"\n    Compute the isin boolean array\n\n    Parameters\n    ----------\n    comps: array-like\n    values: array-like\n\n    Returns\n    -------\n    boolean array same length as comps\n    \"\"\"\n\n    if not is_list_like(comps):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a \"\n                        \"[{0}]\".format(type(comps).__name__))\n    if not is_list_like(values):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a \"\n                        \"[{0}]\".format(type(values).__name__))\n\n    if not isinstance(values, (ABCIndex, ABCSeries, np.ndarray)):\n        values = np.array(list(values), dtype='object')\n\n    comps, dtype, _ = _ensure_data(comps)\n    values, _, _ = _ensure_data(values, dtype=dtype)\n\n    # GH11232\n    # work-around for numpy < 1.8 and comparisions on py3\n    # faster for larger cases to use np.in1d\n    f = lambda x, y: htable.ismember_object(x, values)\n    if (_np_version_under1p8 and compat.PY3) or len(comps) > 1000000:\n        f = lambda x, y: np.in1d(x, y)\n    elif is_integer_dtype(comps):\n        try:\n            values = values.astype('int64', copy=False)\n            comps = comps.astype('int64', copy=False)\n            f = lambda x, y: htable.ismember_int64(x, y)\n        except (TypeError, ValueError):\n            values = values.astype(object)\n            comps = comps.astype(object)\n\n    elif is_float_dtype(comps):\n        try:\n            values = values.astype('float64', copy=False)\n            comps = comps.astype('float64', copy=False)\n            checknull = isnull(values).any()\n            f = lambda x, y: htable.ismember_float64(x, y, checknull)\n        except (TypeError, ValueError):\n            values = values.astype(object)\n            comps = comps.astype(object)\n\n    return f(comps, values)\n\n"
    },
    {
      "commit": "179363765110611ad10883bab55d79785369da9b",
      "startLine": 15,
      "endLine": 27,
      "methodCode": "def isin(comps, values):\n    \"\"\"\n    Compute the isin boolean array\n\n    Parameters\n    ----------\n    comps: array-like\n    values: array-like\n\n    Returns\n    -------\n    boolean array same length as comps\n    \"\"\"\n\n    if not is_list_like(comps):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a \"\n                        \"[{0}]\".format(type(comps).__name__))\n    if not is_list_like(values):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a \"\n                        \"[{0}]\".format(type(values).__name__))\n\n    from pandas import DatetimeIndex, TimedeltaIndex, PeriodIndex\n\n    if not isinstance(values, (ABCIndex, ABCSeries, np.ndarray)):\n        values = np.array(list(values), dtype='object')\n\n    if needs_i8_conversion(comps):\n        if is_period_dtype(values):\n            comps = PeriodIndex(comps)\n            values = PeriodIndex(values)\n        elif is_timedelta64_dtype(comps):\n            comps = TimedeltaIndex(comps)\n            values = TimedeltaIndex(values)\n        else:\n            comps = DatetimeIndex(comps)\n            values = DatetimeIndex(values)\n\n        values = values.asi8\n        comps = comps.asi8\n    elif is_bool_dtype(comps):\n\n        try:\n            comps = np.asarray(comps).view('uint8')\n            values = np.asarray(values).view('uint8')\n        except TypeError:\n            # object array conversion will fail\n            pass\n    elif is_numeric_dtype(comps):\n        comps = np.asarray(comps)\n        values = np.asarray(values)\n    else:\n        comps = np.asarray(comps).astype(object)\n        values = np.asarray(values).astype(object)\n\n    # GH11232\n    # work-around for numpy < 1.8 and comparisions on py3\n    # faster for larger cases to use np.in1d\n    f = lambda x, y: htable.ismember_object(x, values)\n    if (_np_version_under1p8 and compat.PY3) or len(comps) > 1000000:\n        f = lambda x, y: np.in1d(x, y)\n    elif is_integer_dtype(comps):\n        try:\n            values = values.astype('int64', copy=False)\n            comps = comps.astype('int64', copy=False)\n            f = lambda x, y: htable.ismember_int64(x, y)\n        except (TypeError, ValueError):\n            values = values.astype(object)\n            comps = comps.astype(object)\n\n    elif is_float_dtype(comps):\n        try:\n            values = values.astype('float64', copy=False)\n            comps = comps.astype('float64', copy=False)\n            checknull = isnull(values).any()\n            f = lambda x, y: htable.ismember_float64(x, y, checknull)\n        except (TypeError, ValueError):\n            values = values.astype(object)\n            comps = comps.astype(object)\n\n    return f(comps, values)\n\n"
    },
    {
      "commit": "32dd92912f15a5c66035f5674c116d23f21bdbca",
      "startLine": 15,
      "endLine": 27,
      "methodCode": "def isin(comps, values):\n    \"\"\"\n    Compute the isin boolean array\n\n    Parameters\n    ----------\n    comps: array-like\n    values: array-like\n\n    Returns\n    -------\n    boolean array same length as comps\n    \"\"\"\n\n    if not is_list_like(comps):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a \"\n                        \"[{0}]\".format(type(comps).__name__))\n    if not is_list_like(values):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a \"\n                        \"[{0}]\".format(type(values).__name__))\n\n    from pandas import DatetimeIndex, PeriodIndex\n\n    if not isinstance(values, (ABCIndex, ABCSeries, np.ndarray)):\n        values = np.array(list(values), dtype='object')\n\n    if needs_i8_conversion(comps):\n        if is_period_dtype(values):\n            comps = PeriodIndex(comps)\n            values = PeriodIndex(values)\n        else:\n            comps = DatetimeIndex(comps)\n            values = DatetimeIndex(values)\n\n        values = values.asi8\n        comps = comps.asi8\n    elif is_bool_dtype(comps):\n\n        try:\n            comps = np.asarray(comps).view('uint8')\n            values = np.asarray(values).view('uint8')\n        except TypeError:\n            # object array conversion will fail\n            pass\n    elif is_numeric_dtype(comps):\n        comps = np.asarray(comps)\n        values = np.asarray(values)\n    else:\n        comps = np.asarray(comps).astype(object)\n        values = np.asarray(values).astype(object)\n\n    # GH11232\n    # work-around for numpy < 1.8 and comparisions on py3\n    # faster for larger cases to use np.in1d\n    f = lambda x, y: htable.ismember_object(x, values)\n    if (_np_version_under1p8 and compat.PY3) or len(comps) > 1000000:\n        f = lambda x, y: np.in1d(x, y)\n    elif is_integer_dtype(comps):\n        try:\n            values = values.astype('int64', copy=False)\n            comps = comps.astype('int64', copy=False)\n            f = lambda x, y: htable.ismember_int64(x, y)\n        except (TypeError, ValueError):\n            values = values.astype(object)\n            comps = comps.astype(object)\n\n    elif is_float_dtype(comps):\n        try:\n            values = values.astype('float64', copy=False)\n            comps = comps.astype('float64', copy=False)\n            checknull = isnull(values).any()\n            f = lambda x, y: htable.ismember_float64(x, y, checknull)\n        except (TypeError, ValueError):\n            values = values.astype(object)\n            comps = comps.astype(object)\n\n    return f(comps, values)\n\n"
    },
    {
      "commit": "aa9d0cf7fa0061058125d79d22d86f82f69c9185",
      "startLine": 15,
      "endLine": 27,
      "methodCode": "def isin(comps, values):\n    \"\"\"\n    Compute the isin boolean array\n\n    Parameters\n    ----------\n    comps: array-like\n    values: array-like\n\n    Returns\n    -------\n    boolean array same length as comps\n    \"\"\"\n\n    if not is_list_like(comps):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a \"\n                        \"[{0}]\".format(type(comps).__name__))\n    if not is_list_like(values):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a \"\n                        \"[{0}]\".format(type(values).__name__))\n\n    from pandas import DatetimeIndex, PeriodIndex\n\n    if not isinstance(values, (ABCIndex, ABCSeries, np.ndarray)):\n        values = np.array(list(values), dtype='object')\n\n    if needs_i8_conversion(comps):\n        if is_period_dtype(values):\n            comps = PeriodIndex(comps)\n            values = PeriodIndex(values)\n        else:\n            comps = DatetimeIndex(comps)\n            values = DatetimeIndex(values)\n\n        values = values.asi8\n        comps = comps.asi8\n    elif is_bool_dtype(comps):\n\n        try:\n            comps = np.asarray(comps).view('uint8')\n            values = np.asarray(values).view('uint8')\n        except TypeError:\n            # object array conversion will fail\n            pass\n    else:\n        comps = np.asarray(comps)\n        values = np.asarray(values)\n\n    # GH11232\n    # work-around for numpy < 1.8 and comparisions on py3\n    # faster for larger cases to use np.in1d\n    if (_np_version_under1p8 and compat.PY3) or len(comps) > 1000000:\n        f = lambda x, y: np.in1d(x, np.asarray(list(y)))\n    elif is_int64_dtype(comps):\n        f = lambda x, y: lib.ismember_int64(x, set(y))\n    else:\n        f = lambda x, y: lib.ismember(x, set(values))\n\n    return f(comps, values)\n\n"
    },
    {
      "commit": "7dd4091458d9117e57d2ad9ce3126855bd00108c",
      "startLine": 15,
      "endLine": 25,
      "methodCode": "def isin(comps, values):\n    \"\"\"\n    Compute the isin boolean array\n\n    Parameters\n    ----------\n    comps: array-like\n    values: array-like\n\n    Returns\n    -------\n    boolean array same length as comps\n    \"\"\"\n\n    if not is_list_like(comps):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a \"\n                        \"[{0}]\".format(type(comps).__name__))\n    comps = np.asarray(comps)\n    if not is_list_like(values):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a \"\n                        \"[{0}]\".format(type(values).__name__))\n    if not isinstance(values, np.ndarray):\n        values = list(values)\n\n    # GH11232\n    # work-around for numpy < 1.8 and comparisions on py3\n    # faster for larger cases to use np.in1d\n    if (_np_version_under1p8 and compat.PY3) or len(comps) > 1000000:\n        f = lambda x, y: np.in1d(x, np.asarray(list(y)))\n    else:\n        f = lambda x, y: lib.ismember_int64(x, set(y))\n\n    # may need i8 conversion for proper membership testing\n    if is_datetime64_dtype(comps):\n        from pandas.tseries.tools import to_datetime\n        values = to_datetime(values)._values.view('i8')\n        comps = comps.view('i8')\n    elif is_timedelta64_dtype(comps):\n        from pandas.tseries.timedeltas import to_timedelta\n        values = to_timedelta(values)._values.view('i8')\n        comps = comps.view('i8')\n    elif is_int64_dtype(comps):\n        pass\n    else:\n        f = lambda x, y: lib.ismember(x, set(values))\n\n    return f(comps, values)\n\n"
    },
    {
      "commit": "05e734ab171be0fda838c6b12839c38fa588da2c",
      "startLine": 15,
      "endLine": 25,
      "methodCode": "def isin(comps, values):\n    \"\"\"\n    Compute the isin boolean array\n\n    Parameters\n    ----------\n    comps: array-like\n    values: array-like\n\n    Returns\n    -------\n    boolean array same length as comps\n    \"\"\"\n\n    if not com.is_list_like(comps):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a \"\n                        \"[{0}]\".format(type(comps).__name__))\n    comps = np.asarray(comps)\n    if not com.is_list_like(values):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a \"\n                        \"[{0}]\".format(type(values).__name__))\n    if not isinstance(values, np.ndarray):\n        values = list(values)\n\n    # GH11232\n    # work-around for numpy < 1.8 and comparisions on py3\n    # faster for larger cases to use np.in1d\n    if (_np_version_under1p8 and compat.PY3) or len(comps) > 1000000:\n        f = lambda x, y: np.in1d(x, np.asarray(list(y)))\n    else:\n        f = lambda x, y: lib.ismember_int64(x, set(y))\n\n    # may need i8 conversion for proper membership testing\n    if com.is_datetime64_dtype(comps):\n        from pandas.tseries.tools import to_datetime\n        values = to_datetime(values)._values.view('i8')\n        comps = comps.view('i8')\n    elif com.is_timedelta64_dtype(comps):\n        from pandas.tseries.timedeltas import to_timedelta\n        values = to_timedelta(values)._values.view('i8')\n        comps = comps.view('i8')\n    elif com.is_int64_dtype(comps):\n        pass\n    else:\n        f = lambda x, y: lib.ismember(x, set(values))\n\n    return f(comps, values)\n\n"
    },
    {
      "commit": "77257662de12ea14e753c4d9ad8c2796f4825254",
      "startLine": 15,
      "endLine": 23,
      "methodCode": "def isin(comps, values):\n    \"\"\"\n    Compute the isin boolean array\n\n    Parameters\n    ----------\n    comps: array-like\n    values: array-like\n\n    Returns\n    -------\n    boolean array same length as comps\n    \"\"\"\n\n    if not com.is_list_like(comps):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a \"\n                        \"[{0}]\".format(type(comps).__name__))\n    comps = np.asarray(comps)\n    if not com.is_list_like(values):\n        raise TypeError(\"only list-like objects are allowed to be passed\"\n                        \" to isin(), you passed a \"\n                        \"[{0}]\".format(type(values).__name__))\n\n    # GH11232\n    # work-around for numpy < 1.8 and comparisions on py3\n    # faster for larger cases to use np.in1d\n    if (_np_version_under1p8 and compat.PY3) or len(comps) > 1000000:\n        f = lambda x, y: np.in1d(x,np.asarray(list(y)))\n    else:\n        f = lambda x, y: lib.ismember_int64(x,set(y))\n\n    # may need i8 conversion for proper membership testing\n    if com.is_datetime64_dtype(comps):\n        from pandas.tseries.tools import to_datetime\n        values = to_datetime(values)._values.view('i8')\n        comps = comps.view('i8')\n    elif com.is_timedelta64_dtype(comps):\n        from pandas.tseries.timedeltas import to_timedelta\n        values = to_timedelta(values)._values.view('i8')\n        comps = comps.view('i8')\n    elif com.is_int64_dtype(comps):\n        pass\n    else:\n        f = lambda x, y: lib.ismember(x, set(values))\n\n    return f(comps, values)\n"
    }
  ]
}