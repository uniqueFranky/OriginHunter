{
  "statementVersions": [
    {
      "commit": "32798dcfdb00662a640f0ff2915766591d21e287",
      "startLine": 19,
      "endLine": 32,
      "methodCode": "private void findObjectsToPack(@NonNull ProgressMonitor countingMonitor, @NonNull ObjectWalk walker, @NonNull Set<? extends ObjectId> want, @NonNull Set<? extends ObjectId> have, @NonNull Set<? extends ObjectId> noBitmaps) throws IOException {\n    final long countingStart = System.currentTimeMillis();\n    beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n    stats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n    stats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n    excludeFromBitmapSelection = noBitmaps;\n    canBuildBitmaps = config.isBuildBitmaps() && !shallowPack && have.isEmpty() && (excludeInPacks == null || excludeInPacks.length == 0);\n    if (!shallowPack && useBitmaps) {\n        BitmapIndex bitmapIndex = reader.getBitmapIndex();\n        if (bitmapIndex != null) {\n            BitmapWalker bitmapWalker = new BitmapWalker(walker, bitmapIndex, countingMonitor);\n            findObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n            endPhase(countingMonitor);\n            stats.timeCounting = System.currentTimeMillis() - countingStart;\n            stats.bitmapIndexMisses = bitmapWalker.getCountOfBitmapIndexMisses();\n            return;\n        }\n    }\n    List<ObjectId> all = new ArrayList<>(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final RevFlag include = walker.newFlag(\"include\");\n    final RevFlag added = walker.newFlag(\"added\");\n    walker.carry(include);\n    int haveEst = have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List<RevObject> wantObjs = new ArrayList<>(want.size());\n    List<RevObject> haveObjs = new ArrayList<>(haveEst);\n    List<RevTag> wantTags = new ArrayList<>(want.size());\n    AsyncRevObjectQueue q = walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o = q.next();\n                if (o == null)\n                    break;\n                if (have.contains(o))\n                    haveObjs.add(o);\n                if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    if (o instanceof RevTag)\n                        wantTags.add((RevTag) o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting && have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    if (!wantTags.isEmpty()) {\n        all = new ArrayList<>(wantTags.size());\n        for (RevTag tag : wantTags) all.add(tag.getObject());\n        q = walker.parseAny(all, true);\n        try {\n            while (q.next() != null) {\n            }\n        } finally {\n            q.release();\n        }\n    }\n    if (walker instanceof DepthWalk.ObjectWalk) {\n        DepthWalk.ObjectWalk depthWalk = (DepthWalk.ObjectWalk) walker;\n        for (RevObject obj : wantObjs) {\n            depthWalk.markRoot(obj);\n        }\n        for (RevObject obj : haveObjs) {\n            if (obj instanceof RevCommit) {\n                RevTree t = ((RevCommit) obj).getTree();\n                depthWalk.markUninteresting(t);\n            }\n        }\n        if (unshallowObjects != null) {\n            for (ObjectId id : unshallowObjects) {\n                depthWalk.markUnshallow(walker.parseAny(id));\n            }\n        }\n    } else {\n        for (RevObject obj : wantObjs) walker.markStart(obj);\n    }\n    for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n    final int maxBases = config.getDeltaSearchWindowSize();\n    Set<RevTree> baseTrees = new HashSet<>();\n    BlockList<RevCommit> commits = new BlockList<>();\n    Set<ObjectId> roots = new HashSet<>();\n    RevCommit c;\n    while ((c = walker.next()) != null) {\n        if (exclude(c))\n            continue;\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() <= maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        if (c.getParentCount() == 0) {\n            roots.add(c.copy());\n        }\n        countingMonitor.update(1);\n    }\n    stats.rootCommits = Collections.unmodifiableSet(roots);\n    if (shallowPack) {\n        for (RevCommit cmit : commits) {\n            addObject(cmit, 0);\n        }\n    } else {\n        int commitCnt = 0;\n        boolean putTagTargets = false;\n        for (RevCommit cmit : commits) {\n            if (!cmit.has(added)) {\n                cmit.add(added);\n                addObject(cmit, 0);\n                commitCnt++;\n            }\n            for (int i = 0; i < cmit.getParentCount(); i++) {\n                RevCommit p = cmit.getParent(i);\n                if (!p.has(added) && !p.has(RevFlag.UNINTERESTING) && !exclude(p)) {\n                    p.add(added);\n                    addObject(p, 0);\n                    commitCnt++;\n                }\n            }\n            if (!putTagTargets && 4096 < commitCnt) {\n                for (ObjectId id : tagTargets) {\n                    RevObject obj = walker.lookupOrNull(id);\n                    if (obj instanceof RevCommit && obj.has(include) && !obj.has(RevFlag.UNINTERESTING) && !obj.has(added)) {\n                        obj.add(added);\n                        addObject(obj, 0);\n                    }\n                }\n                putTagTargets = true;\n            }\n        }\n    }\n    commits = null;\n    if (thin && !baseTrees.isEmpty()) {\n        BaseSearch bases = new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n        RevObject o;\n        while ((o = walker.nextObject()) != null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            int pathHash = walker.getPathHashCode();\n            byte[] pathBuf = walker.getPathBuffer();\n            int pathLen = walker.getPathLength();\n            bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n            filterAndAddObject(o, o.getType(), pathHash, want);\n            countingMonitor.update(1);\n        }\n    } else {\n        RevObject o;\n        while ((o = walker.nextObject()) != null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            filterAndAddObject(o, o.getType(), walker.getPathHashCode(), want);\n            countingMonitor.update(1);\n        }\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    endPhase(countingMonitor);\n    stats.timeCounting = System.currentTimeMillis() - countingStart;\n    stats.bitmapIndexMisses = -1;\n}"
    },
    {
      "commit": "4ac32e79b751944107470d5f4cb290eacd1b7cf9",
      "startLine": 19,
      "endLine": 32,
      "methodCode": "private void findObjectsToPack(@NonNull ProgressMonitor countingMonitor, @NonNull ObjectWalk walker, @NonNull Set<? extends ObjectId> want, @NonNull Set<? extends ObjectId> have, @NonNull Set<? extends ObjectId> noBitmaps) throws IOException {\n    final long countingStart = System.currentTimeMillis();\n    beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n    stats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n    stats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n    excludeFromBitmapSelection = noBitmaps;\n    canBuildBitmaps = config.isBuildBitmaps() && !shallowPack && have.isEmpty() && (excludeInPacks == null || excludeInPacks.length == 0);\n    if (!shallowPack && useBitmaps) {\n        BitmapIndex bitmapIndex = reader.getBitmapIndex();\n        if (bitmapIndex != null) {\n            BitmapWalker bitmapWalker = new BitmapWalker(walker, bitmapIndex, countingMonitor);\n            findObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n            endPhase(countingMonitor);\n            stats.timeCounting = System.currentTimeMillis() - countingStart;\n            stats.bitmapIndexMisses = bitmapWalker.getCountOfBitmapIndexMisses();\n            return;\n        }\n    }\n    List<ObjectId> all = new ArrayList<>(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final RevFlag include = walker.newFlag(\"include\");\n    final RevFlag added = walker.newFlag(\"added\");\n    walker.carry(include);\n    int haveEst = have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List<RevObject> wantObjs = new ArrayList<>(want.size());\n    List<RevObject> haveObjs = new ArrayList<>(haveEst);\n    List<RevTag> wantTags = new ArrayList<>(want.size());\n    AsyncRevObjectQueue q = walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o = q.next();\n                if (o == null)\n                    break;\n                if (have.contains(o))\n                    haveObjs.add(o);\n                if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    if (o instanceof RevTag)\n                        wantTags.add((RevTag) o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting && have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    if (!wantTags.isEmpty()) {\n        all = new ArrayList<>(wantTags.size());\n        for (RevTag tag : wantTags) all.add(tag.getObject());\n        q = walker.parseAny(all, true);\n        try {\n            while (q.next() != null) {\n            }\n        } finally {\n            q.release();\n        }\n    }\n    if (walker instanceof DepthWalk.ObjectWalk) {\n        DepthWalk.ObjectWalk depthWalk = (DepthWalk.ObjectWalk) walker;\n        for (RevObject obj : wantObjs) {\n            depthWalk.markRoot(obj);\n        }\n        for (RevObject obj : haveObjs) {\n            if (obj instanceof RevCommit) {\n                RevTree t = ((RevCommit) obj).getTree();\n                depthWalk.markUninteresting(t);\n            }\n        }\n        if (unshallowObjects != null) {\n            for (ObjectId id : unshallowObjects) {\n                depthWalk.markUnshallow(walker.parseAny(id));\n            }\n        }\n    } else {\n        for (RevObject obj : wantObjs) walker.markStart(obj);\n    }\n    for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n    final int maxBases = config.getDeltaSearchWindowSize();\n    Set<RevTree> baseTrees = new HashSet<>();\n    BlockList<RevCommit> commits = new BlockList<>();\n    Set<ObjectId> roots = new HashSet<>();\n    RevCommit c;\n    while ((c = walker.next()) != null) {\n        if (exclude(c))\n            continue;\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() <= maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        if (c.getParentCount() == 0) {\n            roots.add(c.copy());\n        }\n        countingMonitor.update(1);\n    }\n    stats.rootCommits = Collections.unmodifiableSet(roots);\n    if (shallowPack) {\n        for (RevCommit cmit : commits) {\n            addObject(cmit, 0);\n        }\n    } else {\n        int commitCnt = 0;\n        boolean putTagTargets = false;\n        for (RevCommit cmit : commits) {\n            if (!cmit.has(added)) {\n                cmit.add(added);\n                addObject(cmit, 0);\n                commitCnt++;\n            }\n            for (int i = 0; i < cmit.getParentCount(); i++) {\n                RevCommit p = cmit.getParent(i);\n                if (!p.has(added) && !p.has(RevFlag.UNINTERESTING) && !exclude(p)) {\n                    p.add(added);\n                    addObject(p, 0);\n                    commitCnt++;\n                }\n            }\n            if (!putTagTargets && 4096 < commitCnt) {\n                for (ObjectId id : tagTargets) {\n                    RevObject obj = walker.lookupOrNull(id);\n                    if (obj instanceof RevCommit && obj.has(include) && !obj.has(RevFlag.UNINTERESTING) && !obj.has(added)) {\n                        obj.add(added);\n                        addObject(obj, 0);\n                    }\n                }\n                putTagTargets = true;\n            }\n        }\n    }\n    commits = null;\n    if (thin && !baseTrees.isEmpty()) {\n        BaseSearch bases = new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n        RevObject o;\n        while ((o = walker.nextObject()) != null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            int pathHash = walker.getPathHashCode();\n            byte[] pathBuf = walker.getPathBuffer();\n            int pathLen = walker.getPathLength();\n            bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n            filterAndAddObject(o, o.getType(), pathHash);\n            countingMonitor.update(1);\n        }\n    } else {\n        RevObject o;\n        while ((o = walker.nextObject()) != null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            filterAndAddObject(o, o.getType(), walker.getPathHashCode());\n            countingMonitor.update(1);\n        }\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    endPhase(countingMonitor);\n    stats.timeCounting = System.currentTimeMillis() - countingStart;\n    stats.bitmapIndexMisses = -1;\n}"
    },
    {
      "commit": "ccf25f95411d7faae7b7aa5a75d74c62e6c47e07",
      "startLine": 19,
      "endLine": 32,
      "methodCode": "private void findObjectsToPack(@NonNull ProgressMonitor countingMonitor, @NonNull ObjectWalk walker, @NonNull Set<? extends ObjectId> want, @NonNull Set<? extends ObjectId> have, @NonNull Set<? extends ObjectId> noBitmaps) throws IOException {\n    final long countingStart = System.currentTimeMillis();\n    beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n    stats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n    stats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n    excludeFromBitmapSelection = noBitmaps;\n    canBuildBitmaps = config.isBuildBitmaps() && !shallowPack && have.isEmpty() && (excludeInPacks == null || excludeInPacks.length == 0);\n    if (!shallowPack && useBitmaps) {\n        BitmapIndex bitmapIndex = reader.getBitmapIndex();\n        if (bitmapIndex != null) {\n            BitmapWalker bitmapWalker = new BitmapWalker(walker, bitmapIndex, countingMonitor);\n            findObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n            endPhase(countingMonitor);\n            stats.timeCounting = System.currentTimeMillis() - countingStart;\n            stats.bitmapIndexMisses = bitmapWalker.getCountOfBitmapIndexMisses();\n            return;\n        }\n    }\n    List<ObjectId> all = new ArrayList<>(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final RevFlag include = walker.newFlag(\"include\");\n    final RevFlag added = walker.newFlag(\"added\");\n    walker.carry(include);\n    int haveEst = have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List<RevObject> wantObjs = new ArrayList<>(want.size());\n    List<RevObject> haveObjs = new ArrayList<>(haveEst);\n    List<RevTag> wantTags = new ArrayList<>(want.size());\n    AsyncRevObjectQueue q = walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o = q.next();\n                if (o == null)\n                    break;\n                if (have.contains(o))\n                    haveObjs.add(o);\n                if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    if (o instanceof RevTag)\n                        wantTags.add((RevTag) o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting && have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    if (!wantTags.isEmpty()) {\n        all = new ArrayList<>(wantTags.size());\n        for (RevTag tag : wantTags) all.add(tag.getObject());\n        q = walker.parseAny(all, true);\n        try {\n            while (q.next() != null) {\n            }\n        } finally {\n            q.release();\n        }\n    }\n    if (walker instanceof DepthWalk.ObjectWalk) {\n        DepthWalk.ObjectWalk depthWalk = (DepthWalk.ObjectWalk) walker;\n        for (RevObject obj : wantObjs) {\n            depthWalk.markRoot(obj);\n        }\n        for (RevObject obj : haveObjs) {\n            if (obj instanceof RevCommit) {\n                RevTree t = ((RevCommit) obj).getTree();\n                depthWalk.markUninteresting(t);\n            }\n        }\n        if (unshallowObjects != null) {\n            for (ObjectId id : unshallowObjects) {\n                depthWalk.markUnshallow(walker.parseAny(id));\n            }\n        }\n    } else {\n        for (RevObject obj : wantObjs) walker.markStart(obj);\n    }\n    for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n    final int maxBases = config.getDeltaSearchWindowSize();\n    Set<RevTree> baseTrees = new HashSet<>();\n    BlockList<RevCommit> commits = new BlockList<>();\n    Set<ObjectId> roots = new HashSet<>();\n    RevCommit c;\n    while ((c = walker.next()) != null) {\n        if (exclude(c))\n            continue;\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() <= maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        if (c.getParentCount() == 0) {\n            roots.add(c.copy());\n        }\n        countingMonitor.update(1);\n    }\n    stats.rootCommits = Collections.unmodifiableSet(roots);\n    if (shallowPack) {\n        for (RevCommit cmit : commits) {\n            addObject(cmit, 0);\n        }\n    } else {\n        int commitCnt = 0;\n        boolean putTagTargets = false;\n        for (RevCommit cmit : commits) {\n            if (!cmit.has(added)) {\n                cmit.add(added);\n                addObject(cmit, 0);\n                commitCnt++;\n            }\n            for (int i = 0; i < cmit.getParentCount(); i++) {\n                RevCommit p = cmit.getParent(i);\n                if (!p.has(added) && !p.has(RevFlag.UNINTERESTING) && !exclude(p)) {\n                    p.add(added);\n                    addObject(p, 0);\n                    commitCnt++;\n                }\n            }\n            if (!putTagTargets && 4096 < commitCnt) {\n                for (ObjectId id : tagTargets) {\n                    RevObject obj = walker.lookupOrNull(id);\n                    if (obj instanceof RevCommit && obj.has(include) && !obj.has(RevFlag.UNINTERESTING) && !obj.has(added)) {\n                        obj.add(added);\n                        addObject(obj, 0);\n                    }\n                }\n                putTagTargets = true;\n            }\n        }\n    }\n    commits = null;\n    if (thin && !baseTrees.isEmpty()) {\n        BaseSearch bases = new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n        RevObject o;\n        while ((o = walker.nextObject()) != null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            int pathHash = walker.getPathHashCode();\n            byte[] pathBuf = walker.getPathBuffer();\n            int pathLen = walker.getPathLength();\n            bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n            addObject(o, pathHash);\n            countingMonitor.update(1);\n        }\n    } else {\n        RevObject o;\n        while ((o = walker.nextObject()) != null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            addObject(o, walker.getPathHashCode());\n            countingMonitor.update(1);\n        }\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    endPhase(countingMonitor);\n    stats.timeCounting = System.currentTimeMillis() - countingStart;\n    stats.bitmapIndexMisses = -1;\n}"
    },
    {
      "commit": "c46c720e99baa081bff0dd7bcc1ae8ca48b5e3d1",
      "startLine": 19,
      "endLine": 32,
      "methodCode": "private void findObjectsToPack(@NonNull ProgressMonitor countingMonitor, @NonNull ObjectWalk walker, @NonNull Set<? extends ObjectId> want, @NonNull Set<? extends ObjectId> have, @NonNull Set<? extends ObjectId> noBitmaps) throws IOException {\n    final long countingStart = System.currentTimeMillis();\n    beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n    stats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n    stats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n    excludeFromBitmapSelection = noBitmaps;\n    canBuildBitmaps = config.isBuildBitmaps() && !shallowPack && have.isEmpty() && (excludeInPacks == null || excludeInPacks.length == 0);\n    if (!shallowPack && useBitmaps) {\n        BitmapIndex bitmapIndex = reader.getBitmapIndex();\n        if (bitmapIndex != null) {\n            PackWriterBitmapWalker bitmapWalker = new PackWriterBitmapWalker(walker, bitmapIndex, countingMonitor);\n            findObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n            endPhase(countingMonitor);\n            stats.timeCounting = System.currentTimeMillis() - countingStart;\n            stats.bitmapIndexMisses = bitmapWalker.getCountOfBitmapIndexMisses();\n            return;\n        }\n    }\n    List<ObjectId> all = new ArrayList<>(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final RevFlag include = walker.newFlag(\"include\");\n    final RevFlag added = walker.newFlag(\"added\");\n    walker.carry(include);\n    int haveEst = have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List<RevObject> wantObjs = new ArrayList<>(want.size());\n    List<RevObject> haveObjs = new ArrayList<>(haveEst);\n    List<RevTag> wantTags = new ArrayList<>(want.size());\n    AsyncRevObjectQueue q = walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o = q.next();\n                if (o == null)\n                    break;\n                if (have.contains(o))\n                    haveObjs.add(o);\n                if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    if (o instanceof RevTag)\n                        wantTags.add((RevTag) o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting && have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    if (!wantTags.isEmpty()) {\n        all = new ArrayList<>(wantTags.size());\n        for (RevTag tag : wantTags) all.add(tag.getObject());\n        q = walker.parseAny(all, true);\n        try {\n            while (q.next() != null) {\n            }\n        } finally {\n            q.release();\n        }\n    }\n    if (walker instanceof DepthWalk.ObjectWalk) {\n        DepthWalk.ObjectWalk depthWalk = (DepthWalk.ObjectWalk) walker;\n        for (RevObject obj : wantObjs) {\n            depthWalk.markRoot(obj);\n        }\n        for (RevObject obj : haveObjs) {\n            if (obj instanceof RevCommit) {\n                RevTree t = ((RevCommit) obj).getTree();\n                depthWalk.markUninteresting(t);\n            }\n        }\n        if (unshallowObjects != null) {\n            for (ObjectId id : unshallowObjects) {\n                depthWalk.markUnshallow(walker.parseAny(id));\n            }\n        }\n    } else {\n        for (RevObject obj : wantObjs) walker.markStart(obj);\n    }\n    for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n    final int maxBases = config.getDeltaSearchWindowSize();\n    Set<RevTree> baseTrees = new HashSet<>();\n    BlockList<RevCommit> commits = new BlockList<>();\n    Set<ObjectId> roots = new HashSet<>();\n    RevCommit c;\n    while ((c = walker.next()) != null) {\n        if (exclude(c))\n            continue;\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() <= maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        if (c.getParentCount() == 0) {\n            roots.add(c.copy());\n        }\n        countingMonitor.update(1);\n    }\n    stats.rootCommits = Collections.unmodifiableSet(roots);\n    if (shallowPack) {\n        for (RevCommit cmit : commits) {\n            addObject(cmit, 0);\n        }\n    } else {\n        int commitCnt = 0;\n        boolean putTagTargets = false;\n        for (RevCommit cmit : commits) {\n            if (!cmit.has(added)) {\n                cmit.add(added);\n                addObject(cmit, 0);\n                commitCnt++;\n            }\n            for (int i = 0; i < cmit.getParentCount(); i++) {\n                RevCommit p = cmit.getParent(i);\n                if (!p.has(added) && !p.has(RevFlag.UNINTERESTING) && !exclude(p)) {\n                    p.add(added);\n                    addObject(p, 0);\n                    commitCnt++;\n                }\n            }\n            if (!putTagTargets && 4096 < commitCnt) {\n                for (ObjectId id : tagTargets) {\n                    RevObject obj = walker.lookupOrNull(id);\n                    if (obj instanceof RevCommit && obj.has(include) && !obj.has(RevFlag.UNINTERESTING) && !obj.has(added)) {\n                        obj.add(added);\n                        addObject(obj, 0);\n                    }\n                }\n                putTagTargets = true;\n            }\n        }\n    }\n    commits = null;\n    if (thin && !baseTrees.isEmpty()) {\n        BaseSearch bases = new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n        RevObject o;\n        while ((o = walker.nextObject()) != null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            int pathHash = walker.getPathHashCode();\n            byte[] pathBuf = walker.getPathBuffer();\n            int pathLen = walker.getPathLength();\n            bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n            addObject(o, pathHash);\n            countingMonitor.update(1);\n        }\n    } else {\n        RevObject o;\n        while ((o = walker.nextObject()) != null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            addObject(o, walker.getPathHashCode());\n            countingMonitor.update(1);\n        }\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    endPhase(countingMonitor);\n    stats.timeCounting = System.currentTimeMillis() - countingStart;\n    stats.bitmapIndexMisses = -1;\n}"
    },
    {
      "commit": "3b4448637fbb9d74e0c9d44048ba76bb7c1214ce",
      "startLine": 18,
      "endLine": 31,
      "methodCode": "private void findObjectsToPack(@NonNull ProgressMonitor countingMonitor, @NonNull ObjectWalk walker, @NonNull Set<? extends ObjectId> want, @NonNull Set<? extends ObjectId> have) throws IOException {\n    final long countingStart = System.currentTimeMillis();\n    beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n    stats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n    stats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n    canBuildBitmaps = config.isBuildBitmaps() && !shallowPack && have.isEmpty() && (excludeInPacks == null || excludeInPacks.length == 0);\n    if (!shallowPack && useBitmaps) {\n        BitmapIndex bitmapIndex = reader.getBitmapIndex();\n        if (bitmapIndex != null) {\n            PackWriterBitmapWalker bitmapWalker = new PackWriterBitmapWalker(walker, bitmapIndex, countingMonitor);\n            findObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n            endPhase(countingMonitor);\n            stats.timeCounting = System.currentTimeMillis() - countingStart;\n            stats.bitmapIndexMisses = bitmapWalker.getCountOfBitmapIndexMisses();\n            return;\n        }\n    }\n    List<ObjectId> all = new ArrayList<>(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final RevFlag include = walker.newFlag(\"include\");\n    final RevFlag added = walker.newFlag(\"added\");\n    walker.carry(include);\n    int haveEst = have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List<RevObject> wantObjs = new ArrayList<>(want.size());\n    List<RevObject> haveObjs = new ArrayList<>(haveEst);\n    List<RevTag> wantTags = new ArrayList<>(want.size());\n    AsyncRevObjectQueue q = walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o = q.next();\n                if (o == null)\n                    break;\n                if (have.contains(o))\n                    haveObjs.add(o);\n                if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    if (o instanceof RevTag)\n                        wantTags.add((RevTag) o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting && have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    if (!wantTags.isEmpty()) {\n        all = new ArrayList<>(wantTags.size());\n        for (RevTag tag : wantTags) all.add(tag.getObject());\n        q = walker.parseAny(all, true);\n        try {\n            while (q.next() != null) {\n            }\n        } finally {\n            q.release();\n        }\n    }\n    if (walker instanceof DepthWalk.ObjectWalk) {\n        DepthWalk.ObjectWalk depthWalk = (DepthWalk.ObjectWalk) walker;\n        for (RevObject obj : wantObjs) {\n            depthWalk.markRoot(obj);\n        }\n        for (RevObject obj : haveObjs) {\n            if (obj instanceof RevCommit) {\n                RevTree t = ((RevCommit) obj).getTree();\n                depthWalk.markUninteresting(t);\n            }\n        }\n        if (unshallowObjects != null) {\n            for (ObjectId id : unshallowObjects) {\n                depthWalk.markUnshallow(walker.parseAny(id));\n            }\n        }\n    } else {\n        for (RevObject obj : wantObjs) walker.markStart(obj);\n    }\n    for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n    final int maxBases = config.getDeltaSearchWindowSize();\n    Set<RevTree> baseTrees = new HashSet<>();\n    BlockList<RevCommit> commits = new BlockList<>();\n    Set<ObjectId> roots = new HashSet<>();\n    RevCommit c;\n    while ((c = walker.next()) != null) {\n        if (exclude(c))\n            continue;\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() <= maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        if (c.getParentCount() == 0) {\n            roots.add(c.copy());\n        }\n        countingMonitor.update(1);\n    }\n    stats.rootCommits = Collections.unmodifiableSet(roots);\n    if (shallowPack) {\n        for (RevCommit cmit : commits) {\n            addObject(cmit, 0);\n        }\n    } else {\n        int commitCnt = 0;\n        boolean putTagTargets = false;\n        for (RevCommit cmit : commits) {\n            if (!cmit.has(added)) {\n                cmit.add(added);\n                addObject(cmit, 0);\n                commitCnt++;\n            }\n            for (int i = 0; i < cmit.getParentCount(); i++) {\n                RevCommit p = cmit.getParent(i);\n                if (!p.has(added) && !p.has(RevFlag.UNINTERESTING) && !exclude(p)) {\n                    p.add(added);\n                    addObject(p, 0);\n                    commitCnt++;\n                }\n            }\n            if (!putTagTargets && 4096 < commitCnt) {\n                for (ObjectId id : tagTargets) {\n                    RevObject obj = walker.lookupOrNull(id);\n                    if (obj instanceof RevCommit && obj.has(include) && !obj.has(RevFlag.UNINTERESTING) && !obj.has(added)) {\n                        obj.add(added);\n                        addObject(obj, 0);\n                    }\n                }\n                putTagTargets = true;\n            }\n        }\n    }\n    commits = null;\n    if (thin && !baseTrees.isEmpty()) {\n        BaseSearch bases = new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n        RevObject o;\n        while ((o = walker.nextObject()) != null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            int pathHash = walker.getPathHashCode();\n            byte[] pathBuf = walker.getPathBuffer();\n            int pathLen = walker.getPathLength();\n            bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n            addObject(o, pathHash);\n            countingMonitor.update(1);\n        }\n    } else {\n        RevObject o;\n        while ((o = walker.nextObject()) != null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            addObject(o, walker.getPathHashCode());\n            countingMonitor.update(1);\n        }\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    endPhase(countingMonitor);\n    stats.timeCounting = System.currentTimeMillis() - countingStart;\n    stats.bitmapIndexMisses = -1;\n}"
    },
    {
      "commit": "d385a7a5e5cacd875da4301ddeb46a7c56a725fa",
      "startLine": 18,
      "endLine": 31,
      "methodCode": "private void findObjectsToPack(@NonNull ProgressMonitor countingMonitor, @NonNull ObjectWalk walker, @NonNull Set<? extends ObjectId> want, @NonNull Set<? extends ObjectId> have) throws IOException {\n    final long countingStart = System.currentTimeMillis();\n    beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n    stats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n    stats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n    canBuildBitmaps = config.isBuildBitmaps() && !shallowPack && have.isEmpty() && (excludeInPacks == null || excludeInPacks.length == 0);\n    if (!shallowPack && useBitmaps) {\n        BitmapIndex bitmapIndex = reader.getBitmapIndex();\n        if (bitmapIndex != null) {\n            PackWriterBitmapWalker bitmapWalker = new PackWriterBitmapWalker(walker, bitmapIndex, countingMonitor);\n            findObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n            endPhase(countingMonitor);\n            stats.timeCounting = System.currentTimeMillis() - countingStart;\n            stats.bitmapIndexMisses = bitmapWalker.getCountOfBitmapIndexMisses();\n            return;\n        }\n    }\n    List<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final RevFlag include = walker.newFlag(\"include\");\n    final RevFlag added = walker.newFlag(\"added\");\n    walker.carry(include);\n    int haveEst = have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n    List<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n    List<RevTag> wantTags = new ArrayList<RevTag>(want.size());\n    AsyncRevObjectQueue q = walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o = q.next();\n                if (o == null)\n                    break;\n                if (have.contains(o))\n                    haveObjs.add(o);\n                if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    if (o instanceof RevTag)\n                        wantTags.add((RevTag) o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting && have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    if (!wantTags.isEmpty()) {\n        all = new ArrayList<ObjectId>(wantTags.size());\n        for (RevTag tag : wantTags) all.add(tag.getObject());\n        q = walker.parseAny(all, true);\n        try {\n            while (q.next() != null) {\n            }\n        } finally {\n            q.release();\n        }\n    }\n    if (walker instanceof DepthWalk.ObjectWalk) {\n        DepthWalk.ObjectWalk depthWalk = (DepthWalk.ObjectWalk) walker;\n        for (RevObject obj : wantObjs) {\n            depthWalk.markRoot(obj);\n        }\n        for (RevObject obj : haveObjs) {\n            if (obj instanceof RevCommit) {\n                RevTree t = ((RevCommit) obj).getTree();\n                depthWalk.markUninteresting(t);\n            }\n        }\n        if (unshallowObjects != null) {\n            for (ObjectId id : unshallowObjects) {\n                depthWalk.markUnshallow(walker.parseAny(id));\n            }\n        }\n    } else {\n        for (RevObject obj : wantObjs) walker.markStart(obj);\n    }\n    for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n    final int maxBases = config.getDeltaSearchWindowSize();\n    Set<RevTree> baseTrees = new HashSet<RevTree>();\n    BlockList<RevCommit> commits = new BlockList<RevCommit>();\n    Set<ObjectId> roots = new HashSet<>();\n    RevCommit c;\n    while ((c = walker.next()) != null) {\n        if (exclude(c))\n            continue;\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() <= maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        if (c.getParentCount() == 0) {\n            roots.add(c.copy());\n        }\n        countingMonitor.update(1);\n    }\n    stats.rootCommits = Collections.unmodifiableSet(roots);\n    if (shallowPack) {\n        for (RevCommit cmit : commits) {\n            addObject(cmit, 0);\n        }\n    } else {\n        int commitCnt = 0;\n        boolean putTagTargets = false;\n        for (RevCommit cmit : commits) {\n            if (!cmit.has(added)) {\n                cmit.add(added);\n                addObject(cmit, 0);\n                commitCnt++;\n            }\n            for (int i = 0; i < cmit.getParentCount(); i++) {\n                RevCommit p = cmit.getParent(i);\n                if (!p.has(added) && !p.has(RevFlag.UNINTERESTING) && !exclude(p)) {\n                    p.add(added);\n                    addObject(p, 0);\n                    commitCnt++;\n                }\n            }\n            if (!putTagTargets && 4096 < commitCnt) {\n                for (ObjectId id : tagTargets) {\n                    RevObject obj = walker.lookupOrNull(id);\n                    if (obj instanceof RevCommit && obj.has(include) && !obj.has(RevFlag.UNINTERESTING) && !obj.has(added)) {\n                        obj.add(added);\n                        addObject(obj, 0);\n                    }\n                }\n                putTagTargets = true;\n            }\n        }\n    }\n    commits = null;\n    if (thin && !baseTrees.isEmpty()) {\n        BaseSearch bases = new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n        RevObject o;\n        while ((o = walker.nextObject()) != null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            int pathHash = walker.getPathHashCode();\n            byte[] pathBuf = walker.getPathBuffer();\n            int pathLen = walker.getPathLength();\n            bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n            addObject(o, pathHash);\n            countingMonitor.update(1);\n        }\n    } else {\n        RevObject o;\n        while ((o = walker.nextObject()) != null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            addObject(o, walker.getPathHashCode());\n            countingMonitor.update(1);\n        }\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    endPhase(countingMonitor);\n    stats.timeCounting = System.currentTimeMillis() - countingStart;\n    stats.bitmapIndexMisses = -1;\n}"
    },
    {
      "commit": "7edf05530d83d7f8971db4262ea43e11124c6b63",
      "startLine": 18,
      "endLine": 31,
      "methodCode": "private void findObjectsToPack(@NonNull ProgressMonitor countingMonitor, @NonNull ObjectWalk walker, @NonNull Set<? extends ObjectId> want, @NonNull Set<? extends ObjectId> have) throws IOException {\n    final long countingStart = System.currentTimeMillis();\n    beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n    stats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n    stats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n    canBuildBitmaps = config.isBuildBitmaps() && !shallowPack && have.isEmpty() && (excludeInPacks == null || excludeInPacks.length == 0);\n    if (!shallowPack && useBitmaps) {\n        BitmapIndex bitmapIndex = reader.getBitmapIndex();\n        if (bitmapIndex != null) {\n            PackWriterBitmapWalker bitmapWalker = new PackWriterBitmapWalker(walker, bitmapIndex, countingMonitor);\n            findObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n            endPhase(countingMonitor);\n            stats.timeCounting = System.currentTimeMillis() - countingStart;\n            stats.bitmapIndexMisses = bitmapWalker.getCountOfBitmapIndexMisses();\n            return;\n        }\n    }\n    List<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final RevFlag include = walker.newFlag(\"include\");\n    final RevFlag added = walker.newFlag(\"added\");\n    walker.carry(include);\n    int haveEst = have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n    List<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n    List<RevTag> wantTags = new ArrayList<RevTag>(want.size());\n    AsyncRevObjectQueue q = walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o = q.next();\n                if (o == null)\n                    break;\n                if (have.contains(o))\n                    haveObjs.add(o);\n                if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    if (o instanceof RevTag)\n                        wantTags.add((RevTag) o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting && have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    if (!wantTags.isEmpty()) {\n        all = new ArrayList<ObjectId>(wantTags.size());\n        for (RevTag tag : wantTags) all.add(tag.getObject());\n        q = walker.parseAny(all, true);\n        try {\n            while (q.next() != null) {\n            }\n        } finally {\n            q.release();\n        }\n    }\n    if (walker instanceof DepthWalk.ObjectWalk) {\n        DepthWalk.ObjectWalk depthWalk = (DepthWalk.ObjectWalk) walker;\n        for (RevObject obj : wantObjs) {\n            depthWalk.markRoot(obj);\n        }\n        for (RevObject obj : haveObjs) {\n            if (obj instanceof RevCommit) {\n                RevTree t = ((RevCommit) obj).getTree();\n                depthWalk.markUninteresting(t);\n            }\n        }\n        if (unshallowObjects != null) {\n            for (ObjectId id : unshallowObjects) {\n                depthWalk.markUnshallow(walker.parseAny(id));\n            }\n        }\n    } else {\n        for (RevObject obj : wantObjs) walker.markStart(obj);\n    }\n    for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n    final int maxBases = config.getDeltaSearchWindowSize();\n    Set<RevTree> baseTrees = new HashSet<RevTree>();\n    BlockList<RevCommit> commits = new BlockList<RevCommit>();\n    Set<ObjectId> roots = new HashSet<>();\n    RevCommit c;\n    while ((c = walker.next()) != null) {\n        if (exclude(c))\n            continue;\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() <= maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        if (c.getParentCount() == 0) {\n            roots.add(c.copy());\n        }\n        countingMonitor.update(1);\n    }\n    stats.rootCommits = Collections.unmodifiableSet(roots);\n    if (shallowPack) {\n        for (RevCommit cmit : commits) {\n            addObject(cmit, 0);\n        }\n    } else {\n        int commitCnt = 0;\n        boolean putTagTargets = false;\n        for (RevCommit cmit : commits) {\n            if (!cmit.has(added)) {\n                cmit.add(added);\n                addObject(cmit, 0);\n                commitCnt++;\n            }\n            for (int i = 0; i < cmit.getParentCount(); i++) {\n                RevCommit p = cmit.getParent(i);\n                if (!p.has(added) && !p.has(RevFlag.UNINTERESTING) && !exclude(p)) {\n                    p.add(added);\n                    addObject(p, 0);\n                    commitCnt++;\n                }\n            }\n            if (!putTagTargets && 4096 < commitCnt) {\n                for (ObjectId id : tagTargets) {\n                    RevObject obj = walker.lookupOrNull(id);\n                    if (obj instanceof RevCommit && obj.has(include) && !obj.has(RevFlag.UNINTERESTING) && !obj.has(added)) {\n                        obj.add(added);\n                        addObject(obj, 0);\n                    }\n                }\n                putTagTargets = true;\n            }\n        }\n    }\n    commits = null;\n    if (thin && !baseTrees.isEmpty()) {\n        BaseSearch bases = new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n        RevObject o;\n        while ((o = walker.nextObject()) != null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            int pathHash = walker.getPathHashCode();\n            byte[] pathBuf = walker.getPathBuffer();\n            int pathLen = walker.getPathLength();\n            bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n            addObject(o, pathHash);\n            countingMonitor.update(1);\n        }\n    } else {\n        RevObject o;\n        while ((o = walker.nextObject()) != null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            addObject(o, walker.getPathHashCode());\n            countingMonitor.update(1);\n        }\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    endPhase(countingMonitor);\n    stats.timeCounting = System.currentTimeMillis() - countingStart;\n    stats.bitmapIndexMisses = -1;\n}"
    },
    {
      "commit": "4e650c0d76b716c0e9cb3592d30def9e609066c1",
      "startLine": 18,
      "endLine": 31,
      "methodCode": "private void findObjectsToPack(@NonNull ProgressMonitor countingMonitor, @NonNull ObjectWalk walker, @NonNull Set<? extends ObjectId> want, @NonNull Set<? extends ObjectId> have) throws IOException {\n    final long countingStart = System.currentTimeMillis();\n    beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n    stats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n    stats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n    canBuildBitmaps = config.isBuildBitmaps() && !shallowPack && have.isEmpty() && (excludeInPacks == null || excludeInPacks.length == 0);\n    if (!shallowPack && useBitmaps) {\n        BitmapIndex bitmapIndex = reader.getBitmapIndex();\n        if (bitmapIndex != null) {\n            PackWriterBitmapWalker bitmapWalker = new PackWriterBitmapWalker(walker, bitmapIndex, countingMonitor);\n            findObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n            endPhase(countingMonitor);\n            stats.timeCounting = System.currentTimeMillis() - countingStart;\n            stats.bitmapIndexMisses = bitmapWalker.getCountOfBitmapIndexMisses();\n            return;\n        }\n    }\n    List<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final RevFlag include = walker.newFlag(\"include\");\n    final RevFlag added = walker.newFlag(\"added\");\n    walker.carry(include);\n    int haveEst = have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n    List<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n    List<RevTag> wantTags = new ArrayList<RevTag>(want.size());\n    AsyncRevObjectQueue q = walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o = q.next();\n                if (o == null)\n                    break;\n                if (have.contains(o))\n                    haveObjs.add(o);\n                if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    if (o instanceof RevTag)\n                        wantTags.add((RevTag) o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting && have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    if (!wantTags.isEmpty()) {\n        all = new ArrayList<ObjectId>(wantTags.size());\n        for (RevTag tag : wantTags) all.add(tag.getObject());\n        q = walker.parseAny(all, true);\n        try {\n            while (q.next() != null) {\n            }\n        } finally {\n            q.release();\n        }\n    }\n    if (walker instanceof DepthWalk.ObjectWalk) {\n        DepthWalk.ObjectWalk depthWalk = (DepthWalk.ObjectWalk) walker;\n        for (RevObject obj : wantObjs) depthWalk.markRoot(obj);\n        if (unshallowObjects != null) {\n            for (ObjectId id : unshallowObjects) depthWalk.markUnshallow(walker.parseAny(id));\n        }\n    } else {\n        for (RevObject obj : wantObjs) walker.markStart(obj);\n    }\n    for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n    final int maxBases = config.getDeltaSearchWindowSize();\n    Set<RevTree> baseTrees = new HashSet<RevTree>();\n    BlockList<RevCommit> commits = new BlockList<RevCommit>();\n    Set<ObjectId> roots = new HashSet<>();\n    RevCommit c;\n    while ((c = walker.next()) != null) {\n        if (exclude(c))\n            continue;\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() <= maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        if (c.getParentCount() == 0) {\n            roots.add(c.copy());\n        }\n        countingMonitor.update(1);\n    }\n    stats.rootCommits = Collections.unmodifiableSet(roots);\n    if (shallowPack) {\n        for (RevCommit cmit : commits) {\n            addObject(cmit, 0);\n        }\n    } else {\n        int commitCnt = 0;\n        boolean putTagTargets = false;\n        for (RevCommit cmit : commits) {\n            if (!cmit.has(added)) {\n                cmit.add(added);\n                addObject(cmit, 0);\n                commitCnt++;\n            }\n            for (int i = 0; i < cmit.getParentCount(); i++) {\n                RevCommit p = cmit.getParent(i);\n                if (!p.has(added) && !p.has(RevFlag.UNINTERESTING) && !exclude(p)) {\n                    p.add(added);\n                    addObject(p, 0);\n                    commitCnt++;\n                }\n            }\n            if (!putTagTargets && 4096 < commitCnt) {\n                for (ObjectId id : tagTargets) {\n                    RevObject obj = walker.lookupOrNull(id);\n                    if (obj instanceof RevCommit && obj.has(include) && !obj.has(RevFlag.UNINTERESTING) && !obj.has(added)) {\n                        obj.add(added);\n                        addObject(obj, 0);\n                    }\n                }\n                putTagTargets = true;\n            }\n        }\n    }\n    commits = null;\n    if (thin && !baseTrees.isEmpty()) {\n        BaseSearch bases = new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n        RevObject o;\n        while ((o = walker.nextObject()) != null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            int pathHash = walker.getPathHashCode();\n            byte[] pathBuf = walker.getPathBuffer();\n            int pathLen = walker.getPathLength();\n            bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n            addObject(o, pathHash);\n            countingMonitor.update(1);\n        }\n    } else {\n        RevObject o;\n        while ((o = walker.nextObject()) != null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            addObject(o, walker.getPathHashCode());\n            countingMonitor.update(1);\n        }\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    endPhase(countingMonitor);\n    stats.timeCounting = System.currentTimeMillis() - countingStart;\n    stats.bitmapIndexMisses = -1;\n}"
    },
    {
      "commit": "1d7d0f95e0be8121ee16640fa1cd3b0805fd9092",
      "startLine": 20,
      "endLine": 33,
      "methodCode": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Set<? extends ObjectId> want, Set<? extends ObjectId> have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    final long countingStart = System.currentTimeMillis();\n    beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n    if (have == null)\n        have = Collections.emptySet();\n    stats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n    stats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n    canBuildBitmaps = config.isBuildBitmaps() && !shallowPack && have.isEmpty() && (excludeInPacks == null || excludeInPacks.length == 0);\n    if (!shallowPack && useBitmaps) {\n        BitmapIndex bitmapIndex = reader.getBitmapIndex();\n        if (bitmapIndex != null) {\n            PackWriterBitmapWalker bitmapWalker = new PackWriterBitmapWalker(walker, bitmapIndex, countingMonitor);\n            findObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n            endPhase(countingMonitor);\n            stats.timeCounting = System.currentTimeMillis() - countingStart;\n            stats.bitmapIndexMisses = bitmapWalker.getCountOfBitmapIndexMisses();\n            return;\n        }\n    }\n    List<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final RevFlag include = walker.newFlag(\"include\");\n    final RevFlag added = walker.newFlag(\"added\");\n    walker.carry(include);\n    int haveEst = have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n    List<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n    List<RevTag> wantTags = new ArrayList<RevTag>(want.size());\n    AsyncRevObjectQueue q = walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o = q.next();\n                if (o == null)\n                    break;\n                if (have.contains(o))\n                    haveObjs.add(o);\n                if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    if (o instanceof RevTag)\n                        wantTags.add((RevTag) o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting && have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    if (!wantTags.isEmpty()) {\n        all = new ArrayList<ObjectId>(wantTags.size());\n        for (RevTag tag : wantTags) all.add(tag.getObject());\n        q = walker.parseAny(all, true);\n        try {\n            while (q.next() != null) {\n            }\n        } finally {\n            q.release();\n        }\n    }\n    if (walker instanceof DepthWalk.ObjectWalk) {\n        DepthWalk.ObjectWalk depthWalk = (DepthWalk.ObjectWalk) walker;\n        for (RevObject obj : wantObjs) depthWalk.markRoot(obj);\n        if (unshallowObjects != null) {\n            for (ObjectId id : unshallowObjects) depthWalk.markUnshallow(walker.parseAny(id));\n        }\n    } else {\n        for (RevObject obj : wantObjs) walker.markStart(obj);\n    }\n    for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n    final int maxBases = config.getDeltaSearchWindowSize();\n    Set<RevTree> baseTrees = new HashSet<RevTree>();\n    BlockList<RevCommit> commits = new BlockList<RevCommit>();\n    Set<ObjectId> roots = new HashSet<>();\n    RevCommit c;\n    while ((c = walker.next()) != null) {\n        if (exclude(c))\n            continue;\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() <= maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        if (c.getParentCount() == 0) {\n            roots.add(c.copy());\n        }\n        countingMonitor.update(1);\n    }\n    stats.rootCommits = Collections.unmodifiableSet(roots);\n    if (shallowPack) {\n        for (RevCommit cmit : commits) {\n            addObject(cmit, 0);\n        }\n    } else {\n        int commitCnt = 0;\n        boolean putTagTargets = false;\n        for (RevCommit cmit : commits) {\n            if (!cmit.has(added)) {\n                cmit.add(added);\n                addObject(cmit, 0);\n                commitCnt++;\n            }\n            for (int i = 0; i < cmit.getParentCount(); i++) {\n                RevCommit p = cmit.getParent(i);\n                if (!p.has(added) && !p.has(RevFlag.UNINTERESTING) && !exclude(p)) {\n                    p.add(added);\n                    addObject(p, 0);\n                    commitCnt++;\n                }\n            }\n            if (!putTagTargets && 4096 < commitCnt) {\n                for (ObjectId id : tagTargets) {\n                    RevObject obj = walker.lookupOrNull(id);\n                    if (obj instanceof RevCommit && obj.has(include) && !obj.has(RevFlag.UNINTERESTING) && !obj.has(added)) {\n                        obj.add(added);\n                        addObject(obj, 0);\n                    }\n                }\n                putTagTargets = true;\n            }\n        }\n    }\n    commits = null;\n    if (thin && !baseTrees.isEmpty()) {\n        BaseSearch bases = new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n        RevObject o;\n        while ((o = walker.nextObject()) != null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            int pathHash = walker.getPathHashCode();\n            byte[] pathBuf = walker.getPathBuffer();\n            int pathLen = walker.getPathLength();\n            bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n            addObject(o, pathHash);\n            countingMonitor.update(1);\n        }\n    } else {\n        RevObject o;\n        while ((o = walker.nextObject()) != null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            addObject(o, walker.getPathHashCode());\n            countingMonitor.update(1);\n        }\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    endPhase(countingMonitor);\n    stats.timeCounting = System.currentTimeMillis() - countingStart;\n    stats.bitmapIndexMisses = -1;\n}"
    },
    {
      "commit": "dd22bc831a0ec47ecc999eb19be1bd8fad899e9b",
      "startLine": 20,
      "endLine": 33,
      "methodCode": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Set<? extends ObjectId> want, Set<? extends ObjectId> have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    final long countingStart = System.currentTimeMillis();\n    beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n    if (have == null)\n        have = Collections.emptySet();\n    stats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n    stats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n    canBuildBitmaps = config.isBuildBitmaps() && !shallowPack && have.isEmpty() && (excludeInPacks == null || excludeInPacks.length == 0);\n    if (!shallowPack && useBitmaps) {\n        BitmapIndex bitmapIndex = reader.getBitmapIndex();\n        if (bitmapIndex != null) {\n            PackWriterBitmapWalker bitmapWalker = new PackWriterBitmapWalker(walker, bitmapIndex, countingMonitor);\n            findObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n            endPhase(countingMonitor);\n            stats.timeCounting = System.currentTimeMillis() - countingStart;\n            stats.bitmapIndexMisses = bitmapWalker.getCountOfBitmapIndexMisses();\n            return;\n        }\n    }\n    List<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final RevFlag include = walker.newFlag(\"include\");\n    final RevFlag added = walker.newFlag(\"added\");\n    walker.carry(include);\n    int haveEst = have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n    List<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n    List<RevTag> wantTags = new ArrayList<RevTag>(want.size());\n    AsyncRevObjectQueue q = walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o = q.next();\n                if (o == null)\n                    break;\n                if (have.contains(o))\n                    haveObjs.add(o);\n                if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    if (o instanceof RevTag)\n                        wantTags.add((RevTag) o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting && have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    if (!wantTags.isEmpty()) {\n        all = new ArrayList<ObjectId>(wantTags.size());\n        for (RevTag tag : wantTags) all.add(tag.getObject());\n        q = walker.parseAny(all, true);\n        try {\n            while (q.next() != null) {\n            }\n        } finally {\n            q.release();\n        }\n    }\n    if (walker instanceof DepthWalk.ObjectWalk) {\n        DepthWalk.ObjectWalk depthWalk = (DepthWalk.ObjectWalk) walker;\n        for (RevObject obj : wantObjs) depthWalk.markRoot(obj);\n        if (unshallowObjects != null) {\n            for (ObjectId id : unshallowObjects) depthWalk.markUnshallow(walker.parseAny(id));\n        }\n    } else {\n        for (RevObject obj : wantObjs) walker.markStart(obj);\n    }\n    for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n    final int maxBases = config.getDeltaSearchWindowSize();\n    Set<RevTree> baseTrees = new HashSet<RevTree>();\n    BlockList<RevCommit> commits = new BlockList<RevCommit>();\n    RevCommit c;\n    while ((c = walker.next()) != null) {\n        if (exclude(c))\n            continue;\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() <= maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        countingMonitor.update(1);\n    }\n    if (shallowPack) {\n        for (RevCommit cmit : commits) {\n            addObject(cmit, 0);\n        }\n    } else {\n        int commitCnt = 0;\n        boolean putTagTargets = false;\n        for (RevCommit cmit : commits) {\n            if (!cmit.has(added)) {\n                cmit.add(added);\n                addObject(cmit, 0);\n                commitCnt++;\n            }\n            for (int i = 0; i < cmit.getParentCount(); i++) {\n                RevCommit p = cmit.getParent(i);\n                if (!p.has(added) && !p.has(RevFlag.UNINTERESTING) && !exclude(p)) {\n                    p.add(added);\n                    addObject(p, 0);\n                    commitCnt++;\n                }\n            }\n            if (!putTagTargets && 4096 < commitCnt) {\n                for (ObjectId id : tagTargets) {\n                    RevObject obj = walker.lookupOrNull(id);\n                    if (obj instanceof RevCommit && obj.has(include) && !obj.has(RevFlag.UNINTERESTING) && !obj.has(added)) {\n                        obj.add(added);\n                        addObject(obj, 0);\n                    }\n                }\n                putTagTargets = true;\n            }\n        }\n    }\n    commits = null;\n    if (thin && !baseTrees.isEmpty()) {\n        BaseSearch bases = new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n        RevObject o;\n        while ((o = walker.nextObject()) != null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            int pathHash = walker.getPathHashCode();\n            byte[] pathBuf = walker.getPathBuffer();\n            int pathLen = walker.getPathLength();\n            bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n            addObject(o, pathHash);\n            countingMonitor.update(1);\n        }\n    } else {\n        RevObject o;\n        while ((o = walker.nextObject()) != null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            addObject(o, walker.getPathHashCode());\n            countingMonitor.update(1);\n        }\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    endPhase(countingMonitor);\n    stats.timeCounting = System.currentTimeMillis() - countingStart;\n    stats.bitmapIndexMisses = -1;\n}"
    },
    {
      "commit": "0e8ac496cd9bbfa3fa306ac45706f501fc24ac38",
      "startLine": 20,
      "endLine": 33,
      "methodCode": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Set<? extends ObjectId> want, Set<? extends ObjectId> have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    final long countingStart = System.currentTimeMillis();\n    beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n    if (have == null)\n        have = Collections.emptySet();\n    stats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n    stats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n    canBuildBitmaps = config.isBuildBitmaps() && !shallowPack && have.isEmpty() && (excludeInPacks == null || excludeInPacks.length == 0);\n    if (!shallowPack && useBitmaps) {\n        BitmapIndex bitmapIndex = reader.getBitmapIndex();\n        if (bitmapIndex != null) {\n            PackWriterBitmapWalker bitmapWalker = new PackWriterBitmapWalker(walker, bitmapIndex, countingMonitor);\n            findObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n            endPhase(countingMonitor);\n            stats.timeCounting = System.currentTimeMillis() - countingStart;\n            stats.bitmapIndexMisses = bitmapWalker.getCountOfBitmapIndexMisses();\n            return;\n        }\n    }\n    List<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final RevFlag include = walker.newFlag(\"include\");\n    final RevFlag added = walker.newFlag(\"added\");\n    walker.carry(include);\n    int haveEst = have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n    List<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n    List<RevTag> wantTags = new ArrayList<RevTag>(want.size());\n    AsyncRevObjectQueue q = walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o = q.next();\n                if (o == null)\n                    break;\n                if (have.contains(o))\n                    haveObjs.add(o);\n                if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    if (o instanceof RevTag)\n                        wantTags.add((RevTag) o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting && have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    if (!wantTags.isEmpty()) {\n        all = new ArrayList<ObjectId>(wantTags.size());\n        for (RevTag tag : wantTags) all.add(tag.getObject());\n        q = walker.parseAny(all, true);\n        try {\n            while (q.next() != null) {\n            }\n        } finally {\n            q.release();\n        }\n    }\n    if (walker instanceof DepthWalk.ObjectWalk) {\n        DepthWalk.ObjectWalk depthWalk = (DepthWalk.ObjectWalk) walker;\n        for (RevObject obj : wantObjs) depthWalk.markRoot(obj);\n        if (unshallowObjects != null) {\n            for (ObjectId id : unshallowObjects) depthWalk.markUnshallow(walker.parseAny(id));\n        }\n    } else {\n        for (RevObject obj : wantObjs) walker.markStart(obj);\n    }\n    for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n    final int maxBases = config.getDeltaSearchWindowSize();\n    Set<RevTree> baseTrees = new HashSet<RevTree>();\n    BlockList<RevCommit> commits = new BlockList<RevCommit>();\n    RevCommit c;\n    while ((c = walker.next()) != null) {\n        if (exclude(c))\n            continue;\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() <= maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        countingMonitor.update(1);\n    }\n    if (shallowPack) {\n        for (RevCommit cmit : commits) {\n            addObject(cmit, 0);\n        }\n    } else {\n        int commitCnt = 0;\n        boolean putTagTargets = false;\n        for (RevCommit cmit : commits) {\n            if (!cmit.has(added)) {\n                cmit.add(added);\n                addObject(cmit, 0);\n                commitCnt++;\n            }\n            for (int i = 0; i < cmit.getParentCount(); i++) {\n                RevCommit p = cmit.getParent(i);\n                if (!p.has(added) && !p.has(RevFlag.UNINTERESTING) && !exclude(p)) {\n                    p.add(added);\n                    addObject(p, 0);\n                    commitCnt++;\n                }\n            }\n            if (!putTagTargets && 4096 < commitCnt) {\n                for (ObjectId id : tagTargets) {\n                    RevObject obj = walker.lookupOrNull(id);\n                    if (obj instanceof RevCommit && obj.has(include) && !obj.has(RevFlag.UNINTERESTING) && !obj.has(added)) {\n                        obj.add(added);\n                        addObject(obj, 0);\n                    }\n                }\n                putTagTargets = true;\n            }\n        }\n    }\n    commits = null;\n    if (thin && !baseTrees.isEmpty()) {\n        BaseSearch bases = new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n        RevObject o;\n        while ((o = walker.nextObject()) != null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            int pathHash = walker.getPathHashCode();\n            byte[] pathBuf = walker.getPathBuffer();\n            int pathLen = walker.getPathLength();\n            bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n            addObject(o, pathHash);\n            countingMonitor.update(1);\n        }\n    } else {\n        RevObject o;\n        while ((o = walker.nextObject()) != null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            addObject(o, walker.getPathHashCode());\n            countingMonitor.update(1);\n        }\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    endPhase(countingMonitor);\n    stats.timeCounting = System.currentTimeMillis() - countingStart;\n}"
    },
    {
      "commit": "53e39094bf012a4f5b3fe5557219707cb7b0f010",
      "startLine": 19,
      "endLine": 32,
      "methodCode": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Set<? extends ObjectId> want, Set<? extends ObjectId> have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    final long countingStart = System.currentTimeMillis();\n    beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n    if (have == null)\n        have = Collections.emptySet();\n    stats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n    stats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n    canBuildBitmaps = config.isBuildBitmaps() && !shallowPack && have.isEmpty() && (excludeInPacks == null || excludeInPacks.length == 0);\n    if (!shallowPack && useBitmaps) {\n        BitmapIndex bitmapIndex = reader.getBitmapIndex();\n        if (bitmapIndex != null) {\n            PackWriterBitmapWalker bitmapWalker = new PackWriterBitmapWalker(walker, bitmapIndex, countingMonitor);\n            findObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n            endPhase(countingMonitor);\n            stats.timeCounting = System.currentTimeMillis() - countingStart;\n            return;\n        }\n    }\n    List<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final RevFlag include = walker.newFlag(\"include\");\n    final RevFlag added = walker.newFlag(\"added\");\n    walker.carry(include);\n    int haveEst = have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n    List<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n    List<RevTag> wantTags = new ArrayList<RevTag>(want.size());\n    AsyncRevObjectQueue q = walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o = q.next();\n                if (o == null)\n                    break;\n                if (have.contains(o))\n                    haveObjs.add(o);\n                if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    if (o instanceof RevTag)\n                        wantTags.add((RevTag) o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting && have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    if (!wantTags.isEmpty()) {\n        all = new ArrayList<ObjectId>(wantTags.size());\n        for (RevTag tag : wantTags) all.add(tag.getObject());\n        q = walker.parseAny(all, true);\n        try {\n            while (q.next() != null) {\n            }\n        } finally {\n            q.release();\n        }\n    }\n    if (walker instanceof DepthWalk.ObjectWalk) {\n        DepthWalk.ObjectWalk depthWalk = (DepthWalk.ObjectWalk) walker;\n        for (RevObject obj : wantObjs) depthWalk.markRoot(obj);\n        if (unshallowObjects != null) {\n            for (ObjectId id : unshallowObjects) depthWalk.markUnshallow(walker.parseAny(id));\n        }\n    } else {\n        for (RevObject obj : wantObjs) walker.markStart(obj);\n    }\n    for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n    final int maxBases = config.getDeltaSearchWindowSize();\n    Set<RevTree> baseTrees = new HashSet<RevTree>();\n    BlockList<RevCommit> commits = new BlockList<RevCommit>();\n    RevCommit c;\n    while ((c = walker.next()) != null) {\n        if (exclude(c))\n            continue;\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() <= maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        countingMonitor.update(1);\n    }\n    if (shallowPack) {\n        for (RevCommit cmit : commits) {\n            addObject(cmit, 0);\n        }\n    } else {\n        int commitCnt = 0;\n        boolean putTagTargets = false;\n        for (RevCommit cmit : commits) {\n            if (!cmit.has(added)) {\n                cmit.add(added);\n                addObject(cmit, 0);\n                commitCnt++;\n            }\n            for (int i = 0; i < cmit.getParentCount(); i++) {\n                RevCommit p = cmit.getParent(i);\n                if (!p.has(added) && !p.has(RevFlag.UNINTERESTING) && !exclude(p)) {\n                    p.add(added);\n                    addObject(p, 0);\n                    commitCnt++;\n                }\n            }\n            if (!putTagTargets && 4096 < commitCnt) {\n                for (ObjectId id : tagTargets) {\n                    RevObject obj = walker.lookupOrNull(id);\n                    if (obj instanceof RevCommit && obj.has(include) && !obj.has(RevFlag.UNINTERESTING) && !obj.has(added)) {\n                        obj.add(added);\n                        addObject(obj, 0);\n                    }\n                }\n                putTagTargets = true;\n            }\n        }\n    }\n    commits = null;\n    if (thin && !baseTrees.isEmpty()) {\n        BaseSearch bases = new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n        RevObject o;\n        while ((o = walker.nextObject()) != null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            int pathHash = walker.getPathHashCode();\n            byte[] pathBuf = walker.getPathBuffer();\n            int pathLen = walker.getPathLength();\n            bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n            addObject(o, pathHash);\n            countingMonitor.update(1);\n        }\n    } else {\n        RevObject o;\n        while ((o = walker.nextObject()) != null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            addObject(o, walker.getPathHashCode());\n            countingMonitor.update(1);\n        }\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    endPhase(countingMonitor);\n    stats.timeCounting = System.currentTimeMillis() - countingStart;\n}"
    },
    {
      "commit": "f32b8612433e499090c76ded014dd5e94322b786",
      "startLine": 20,
      "endLine": 33,
      "methodCode": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Set<? extends ObjectId> want, Set<? extends ObjectId> have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    final long countingStart = System.currentTimeMillis();\n    beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n    if (have == null)\n        have = Collections.emptySet();\n    stats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n    stats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n    walker.setRetainBody(false);\n    canBuildBitmaps = config.isBuildBitmaps() && !shallowPack && have.isEmpty() && (excludeInPacks == null || excludeInPacks.length == 0);\n    if (!shallowPack && useBitmaps) {\n        BitmapIndex bitmapIndex = reader.getBitmapIndex();\n        if (bitmapIndex != null) {\n            PackWriterBitmapWalker bitmapWalker = new PackWriterBitmapWalker(walker, bitmapIndex, countingMonitor);\n            findObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n            endPhase(countingMonitor);\n            stats.timeCounting = System.currentTimeMillis() - countingStart;\n            return;\n        }\n    }\n    List<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final RevFlag include = walker.newFlag(\"include\");\n    final RevFlag added = walker.newFlag(\"added\");\n    walker.carry(include);\n    int haveEst = have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n    List<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n    List<RevTag> wantTags = new ArrayList<RevTag>(want.size());\n    AsyncRevObjectQueue q = walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o = q.next();\n                if (o == null)\n                    break;\n                if (have.contains(o))\n                    haveObjs.add(o);\n                if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    if (o instanceof RevTag)\n                        wantTags.add((RevTag) o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting && have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    if (!wantTags.isEmpty()) {\n        all = new ArrayList<ObjectId>(wantTags.size());\n        for (RevTag tag : wantTags) all.add(tag.getObject());\n        q = walker.parseAny(all, true);\n        try {\n            while (q.next() != null) {\n            }\n        } finally {\n            q.release();\n        }\n    }\n    if (walker instanceof DepthWalk.ObjectWalk) {\n        DepthWalk.ObjectWalk depthWalk = (DepthWalk.ObjectWalk) walker;\n        for (RevObject obj : wantObjs) depthWalk.markRoot(obj);\n        if (unshallowObjects != null) {\n            for (ObjectId id : unshallowObjects) depthWalk.markUnshallow(walker.parseAny(id));\n        }\n    } else {\n        for (RevObject obj : wantObjs) walker.markStart(obj);\n    }\n    for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n    final int maxBases = config.getDeltaSearchWindowSize();\n    Set<RevTree> baseTrees = new HashSet<RevTree>();\n    BlockList<RevCommit> commits = new BlockList<RevCommit>();\n    RevCommit c;\n    while ((c = walker.next()) != null) {\n        if (exclude(c))\n            continue;\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() <= maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        countingMonitor.update(1);\n    }\n    if (shallowPack) {\n        for (RevCommit cmit : commits) {\n            addObject(cmit, 0);\n        }\n    } else {\n        int commitCnt = 0;\n        boolean putTagTargets = false;\n        for (RevCommit cmit : commits) {\n            if (!cmit.has(added)) {\n                cmit.add(added);\n                addObject(cmit, 0);\n                commitCnt++;\n            }\n            for (int i = 0; i < cmit.getParentCount(); i++) {\n                RevCommit p = cmit.getParent(i);\n                if (!p.has(added) && !p.has(RevFlag.UNINTERESTING) && !exclude(p)) {\n                    p.add(added);\n                    addObject(p, 0);\n                    commitCnt++;\n                }\n            }\n            if (!putTagTargets && 4096 < commitCnt) {\n                for (ObjectId id : tagTargets) {\n                    RevObject obj = walker.lookupOrNull(id);\n                    if (obj instanceof RevCommit && obj.has(include) && !obj.has(RevFlag.UNINTERESTING) && !obj.has(added)) {\n                        obj.add(added);\n                        addObject(obj, 0);\n                    }\n                }\n                putTagTargets = true;\n            }\n        }\n    }\n    commits = null;\n    if (thin && !baseTrees.isEmpty()) {\n        BaseSearch bases = new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n        RevObject o;\n        while ((o = walker.nextObject()) != null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            int pathHash = walker.getPathHashCode();\n            byte[] pathBuf = walker.getPathBuffer();\n            int pathLen = walker.getPathLength();\n            bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n            addObject(o, pathHash);\n            countingMonitor.update(1);\n        }\n    } else {\n        RevObject o;\n        while ((o = walker.nextObject()) != null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            addObject(o, walker.getPathHashCode());\n            countingMonitor.update(1);\n        }\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    endPhase(countingMonitor);\n    stats.timeCounting = System.currentTimeMillis() - countingStart;\n}"
    },
    {
      "commit": "3760e4319b02ce79ff1eeae021fd88faebf739d5",
      "startLine": 20,
      "endLine": 33,
      "methodCode": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Set<? extends ObjectId> want, Set<? extends ObjectId> have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    final long countingStart = System.currentTimeMillis();\n    beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n    if (have == null)\n        have = Collections.emptySet();\n    stats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n    stats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n    walker.setRetainBody(false);\n    canBuildBitmaps = config.isBuildBitmaps() && !shallowPack && have.isEmpty() && (excludeInPacks == null || excludeInPacks.length == 0);\n    if (!shallowPack && useBitmaps) {\n        BitmapIndex bitmapIndex = reader.getBitmapIndex();\n        if (bitmapIndex != null) {\n            PackWriterBitmapWalker bitmapWalker = new PackWriterBitmapWalker(walker, bitmapIndex, countingMonitor);\n            findObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n            endPhase(countingMonitor);\n            stats.timeCounting = System.currentTimeMillis() - countingStart;\n            return;\n        }\n    }\n    List<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final RevFlag include = walker.newFlag(\"include\");\n    final RevFlag added = walker.newFlag(\"added\");\n    walker.carry(include);\n    int haveEst = have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n    List<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n    List<RevTag> wantTags = new ArrayList<RevTag>(want.size());\n    AsyncRevObjectQueue q = walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o = q.next();\n                if (o == null)\n                    break;\n                if (have.contains(o))\n                    haveObjs.add(o);\n                if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    if (o instanceof RevTag)\n                        wantTags.add((RevTag) o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting && have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    if (!wantTags.isEmpty()) {\n        all = new ArrayList<ObjectId>(wantTags.size());\n        for (RevTag tag : wantTags) all.add(tag.getObject());\n        q = walker.parseAny(all, true);\n        try {\n            while (q.next() != null) {\n            }\n        } finally {\n            q.release();\n        }\n    }\n    if (walker instanceof DepthWalk.ObjectWalk) {\n        DepthWalk.ObjectWalk depthWalk = (DepthWalk.ObjectWalk) walker;\n        for (RevObject obj : wantObjs) depthWalk.markRoot(obj);\n        if (unshallowObjects != null) {\n            for (ObjectId id : unshallowObjects) depthWalk.markUnshallow(walker.parseAny(id));\n        }\n    } else {\n        for (RevObject obj : wantObjs) walker.markStart(obj);\n    }\n    for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n    final int maxBases = config.getDeltaSearchWindowSize();\n    Set<RevTree> baseTrees = new HashSet<RevTree>();\n    BlockList<RevCommit> commits = new BlockList<RevCommit>();\n    RevCommit c;\n    while ((c = walker.next()) != null) {\n        if (exclude(c))\n            continue;\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() <= maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        countingMonitor.update(1);\n    }\n    if (shallowPack) {\n        for (RevCommit cmit : commits) {\n            addObject(cmit, 0);\n        }\n    } else {\n        int commitCnt = 0;\n        boolean putTagTargets = false;\n        for (RevCommit cmit : commits) {\n            if (!cmit.has(added)) {\n                cmit.add(added);\n                addObject(cmit, 0);\n                commitCnt++;\n            }\n            for (int i = 0; i < cmit.getParentCount(); i++) {\n                RevCommit p = cmit.getParent(i);\n                if (!p.has(added) && !p.has(RevFlag.UNINTERESTING) && !exclude(p)) {\n                    p.add(added);\n                    addObject(p, 0);\n                    commitCnt++;\n                }\n            }\n            if (!putTagTargets && 4096 < commitCnt) {\n                for (ObjectId id : tagTargets) {\n                    RevObject obj = walker.lookupOrNull(id);\n                    if (obj instanceof RevCommit && obj.has(include) && !obj.has(RevFlag.UNINTERESTING) && !obj.has(added)) {\n                        obj.add(added);\n                        addObject(obj, 0);\n                    }\n                }\n                putTagTargets = true;\n            }\n        }\n    }\n    commits = null;\n    if (thin && !baseTrees.isEmpty()) {\n        BaseSearch bases = new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n        RevObject o;\n        while ((o = walker.nextObject()) != null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            int pathHash = walker.getPathHashCode();\n            byte[] pathBuf = walker.getPathBuffer();\n            int pathLen = walker.getPathLength();\n            bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n            addObject(o, pathHash);\n            countingMonitor.update(1);\n        }\n    } else {\n        RevObject o;\n        while ((o = walker.nextObject()) != null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            addObject(o, walker.getPathHashCode());\n            countingMonitor.update(1);\n        }\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    endPhase(countingMonitor);\n    stats.timeCounting = System.currentTimeMillis() - countingStart;\n}"
    },
    {
      "commit": "dafcb8f6db82b899c917832768f1c240d273190c",
      "startLine": 20,
      "endLine": 59,
      "methodCode": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Set<? extends ObjectId> want, Set<? extends ObjectId> have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    final long countingStart = System.currentTimeMillis();\n    beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n    if (have == null)\n        have = Collections.emptySet();\n    stats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n    stats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n    walker.setRetainBody(false);\n    canBuildBitmaps = config.isBuildBitmaps() && !shallowPack && have.isEmpty() && (excludeInPacks == null || excludeInPacks.length == 0);\n    if (!shallowPack && useBitmaps) {\n        BitmapIndex bitmapIndex = reader.getBitmapIndex();\n        if (bitmapIndex != null) {\n            PackWriterBitmapWalker bitmapWalker = new PackWriterBitmapWalker(walker, bitmapIndex, countingMonitor);\n            findObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n            endPhase(countingMonitor);\n            stats.timeCounting = System.currentTimeMillis() - countingStart;\n            return;\n        }\n    }\n    List<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final Map<ObjectId, CachedPack> tipToPack = new HashMap<ObjectId, CachedPack>();\n    final RevFlag inCachedPack = walker.newFlag(\"inCachedPack\");\n    final RevFlag include = walker.newFlag(\"include\");\n    final RevFlag added = walker.newFlag(\"added\");\n    final RevFlagSet keepOnRestart = new RevFlagSet();\n    keepOnRestart.add(inCachedPack);\n    walker.carry(include);\n    int haveEst = have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n        if (useCachedPacks && reuseSupport != null) {\n            Set<ObjectId> need = new HashSet<ObjectId>(want);\n            List<CachedPack> shortCircuit = new LinkedList<CachedPack>();\n            for (CachedPack pack : reuseSupport.getCachedPacks()) {\n                if (need.containsAll(pack.getTips())) {\n                    need.removeAll(pack.getTips());\n                    shortCircuit.add(pack);\n                }\n                for (ObjectId id : pack.getTips()) {\n                    tipToPack.put(id, pack);\n                    all.add(id);\n                }\n            }\n            if (need.isEmpty() && !shortCircuit.isEmpty()) {\n                cachedPacks.addAll(shortCircuit);\n                for (CachedPack pack : shortCircuit) countingMonitor.update((int) pack.getObjectCount());\n                endPhase(countingMonitor);\n                stats.timeCounting = System.currentTimeMillis() - countingStart;\n                return;\n            }\n            haveEst += tipToPack.size();\n        }\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n    List<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n    List<RevTag> wantTags = new ArrayList<RevTag>(want.size());\n    AsyncRevObjectQueue q = walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o = q.next();\n                if (o == null)\n                    break;\n                if (tipToPack.containsKey(o))\n                    o.add(inCachedPack);\n                if (have.contains(o))\n                    haveObjs.add(o);\n                if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    if (o instanceof RevTag)\n                        wantTags.add((RevTag) o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting && have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    if (!wantTags.isEmpty()) {\n        all = new ArrayList<ObjectId>(wantTags.size());\n        for (RevTag tag : wantTags) all.add(tag.getObject());\n        q = walker.parseAny(all, true);\n        try {\n            while (q.next() != null) {\n            }\n        } finally {\n            q.release();\n        }\n    }\n    if (walker instanceof DepthWalk.ObjectWalk) {\n        DepthWalk.ObjectWalk depthWalk = (DepthWalk.ObjectWalk) walker;\n        for (RevObject obj : wantObjs) depthWalk.markRoot(obj);\n        if (unshallowObjects != null) {\n            for (ObjectId id : unshallowObjects) depthWalk.markUnshallow(walker.parseAny(id));\n        }\n    } else {\n        for (RevObject obj : wantObjs) walker.markStart(obj);\n    }\n    for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n    final int maxBases = config.getDeltaSearchWindowSize();\n    Set<RevTree> baseTrees = new HashSet<RevTree>();\n    BlockList<RevCommit> commits = new BlockList<RevCommit>();\n    RevCommit c;\n    while ((c = walker.next()) != null) {\n        if (exclude(c))\n            continue;\n        if (c.has(inCachedPack)) {\n            CachedPack pack = tipToPack.get(c);\n            if (includesAllTips(pack, include, walker)) {\n                useCachedPack(walker, keepOnRestart, wantObjs, haveObjs, pack);\n                commits = new BlockList<RevCommit>();\n                endPhase(countingMonitor);\n                beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n                continue;\n            }\n        }\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() <= maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        countingMonitor.update(1);\n    }\n    if (shallowPack) {\n        for (RevCommit cmit : commits) {\n            addObject(cmit, 0);\n        }\n    } else {\n        int commitCnt = 0;\n        boolean putTagTargets = false;\n        for (RevCommit cmit : commits) {\n            if (!cmit.has(added)) {\n                cmit.add(added);\n                addObject(cmit, 0);\n                commitCnt++;\n            }\n            for (int i = 0; i < cmit.getParentCount(); i++) {\n                RevCommit p = cmit.getParent(i);\n                if (!p.has(added) && !p.has(RevFlag.UNINTERESTING) && !exclude(p)) {\n                    p.add(added);\n                    addObject(p, 0);\n                    commitCnt++;\n                }\n            }\n            if (!putTagTargets && 4096 < commitCnt) {\n                for (ObjectId id : tagTargets) {\n                    RevObject obj = walker.lookupOrNull(id);\n                    if (obj instanceof RevCommit && obj.has(include) && !obj.has(RevFlag.UNINTERESTING) && !obj.has(added)) {\n                        obj.add(added);\n                        addObject(obj, 0);\n                    }\n                }\n                putTagTargets = true;\n            }\n        }\n    }\n    commits = null;\n    if (thin && !baseTrees.isEmpty()) {\n        BaseSearch bases = new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n        RevObject o;\n        while ((o = walker.nextObject()) != null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            int pathHash = walker.getPathHashCode();\n            byte[] pathBuf = walker.getPathBuffer();\n            int pathLen = walker.getPathLength();\n            bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n            addObject(o, pathHash);\n            countingMonitor.update(1);\n        }\n    } else {\n        RevObject o;\n        while ((o = walker.nextObject()) != null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            addObject(o, walker.getPathHashCode());\n            countingMonitor.update(1);\n        }\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    endPhase(countingMonitor);\n    stats.timeCounting = System.currentTimeMillis() - countingStart;\n}"
    },
    {
      "commit": "c310fa0c802f40a774edb58641de3ac5bfad0e2c",
      "startLine": 8,
      "endLine": 48,
      "methodCode": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Set<? extends ObjectId> want, Set<? extends ObjectId> have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    final long countingStart = System.currentTimeMillis();\n    beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n    if (have == null)\n        have = Collections.emptySet();\n    stats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n    stats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n    List<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final Map<ObjectId, CachedPack> tipToPack = new HashMap<ObjectId, CachedPack>();\n    final RevFlag inCachedPack = walker.newFlag(\"inCachedPack\");\n    final RevFlag include = walker.newFlag(\"include\");\n    final RevFlag added = walker.newFlag(\"added\");\n    final RevFlagSet keepOnRestart = new RevFlagSet();\n    keepOnRestart.add(inCachedPack);\n    walker.setRetainBody(false);\n    walker.carry(include);\n    int haveEst = have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n        if (useCachedPacks && reuseSupport != null) {\n            Set<ObjectId> need = new HashSet<ObjectId>(want);\n            List<CachedPack> shortCircuit = new LinkedList<CachedPack>();\n            for (CachedPack pack : reuseSupport.getCachedPacks()) {\n                if (need.containsAll(pack.getTips())) {\n                    need.removeAll(pack.getTips());\n                    shortCircuit.add(pack);\n                }\n                for (ObjectId id : pack.getTips()) {\n                    tipToPack.put(id, pack);\n                    all.add(id);\n                }\n            }\n            if (need.isEmpty() && !shortCircuit.isEmpty()) {\n                cachedPacks.addAll(shortCircuit);\n                for (CachedPack pack : shortCircuit) countingMonitor.update((int) pack.getObjectCount());\n                endPhase(countingMonitor);\n                stats.timeCounting = System.currentTimeMillis() - countingStart;\n                return;\n            }\n            haveEst += tipToPack.size();\n        }\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n    List<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n    List<RevTag> wantTags = new ArrayList<RevTag>(want.size());\n    AsyncRevObjectQueue q = walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o = q.next();\n                if (o == null)\n                    break;\n                if (tipToPack.containsKey(o))\n                    o.add(inCachedPack);\n                if (have.contains(o))\n                    haveObjs.add(o);\n                if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    if (o instanceof RevTag)\n                        wantTags.add((RevTag) o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting && have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    if (!wantTags.isEmpty()) {\n        all = new ArrayList<ObjectId>(wantTags.size());\n        for (RevTag tag : wantTags) all.add(tag.getObject());\n        q = walker.parseAny(all, true);\n        try {\n            while (q.next() != null) {\n            }\n        } finally {\n            q.release();\n        }\n    }\n    if (walker instanceof DepthWalk.ObjectWalk) {\n        DepthWalk.ObjectWalk depthWalk = (DepthWalk.ObjectWalk) walker;\n        for (RevObject obj : wantObjs) depthWalk.markRoot(obj);\n        if (unshallowObjects != null) {\n            for (ObjectId id : unshallowObjects) depthWalk.markUnshallow(walker.parseAny(id));\n        }\n    } else {\n        for (RevObject obj : wantObjs) walker.markStart(obj);\n    }\n    for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n    final int maxBases = config.getDeltaSearchWindowSize();\n    Set<RevTree> baseTrees = new HashSet<RevTree>();\n    BlockList<RevCommit> commits = new BlockList<RevCommit>();\n    RevCommit c;\n    while ((c = walker.next()) != null) {\n        if (exclude(c))\n            continue;\n        if (c.has(inCachedPack)) {\n            CachedPack pack = tipToPack.get(c);\n            if (includesAllTips(pack, include, walker)) {\n                useCachedPack(walker, keepOnRestart, wantObjs, haveObjs, pack);\n                commits = new BlockList<RevCommit>();\n                endPhase(countingMonitor);\n                beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n                continue;\n            }\n        }\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() <= maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        countingMonitor.update(1);\n    }\n    if (shallowPack) {\n        for (RevCommit cmit : commits) {\n            addObject(cmit, 0);\n        }\n    } else {\n        int commitCnt = 0;\n        boolean putTagTargets = false;\n        for (RevCommit cmit : commits) {\n            if (!cmit.has(added)) {\n                cmit.add(added);\n                addObject(cmit, 0);\n                commitCnt++;\n            }\n            for (int i = 0; i < cmit.getParentCount(); i++) {\n                RevCommit p = cmit.getParent(i);\n                if (!p.has(added) && !p.has(RevFlag.UNINTERESTING) && !exclude(p)) {\n                    p.add(added);\n                    addObject(p, 0);\n                    commitCnt++;\n                }\n            }\n            if (!putTagTargets && 4096 < commitCnt) {\n                for (ObjectId id : tagTargets) {\n                    RevObject obj = walker.lookupOrNull(id);\n                    if (obj instanceof RevCommit && obj.has(include) && !obj.has(RevFlag.UNINTERESTING) && !obj.has(added)) {\n                        obj.add(added);\n                        addObject(obj, 0);\n                    }\n                }\n                putTagTargets = true;\n            }\n        }\n    }\n    commits = null;\n    if (thin && !baseTrees.isEmpty()) {\n        BaseSearch bases = new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n        RevObject o;\n        while ((o = walker.nextObject()) != null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            int pathHash = walker.getPathHashCode();\n            byte[] pathBuf = walker.getPathBuffer();\n            int pathLen = walker.getPathLength();\n            bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n            addObject(o, pathHash);\n            countingMonitor.update(1);\n        }\n    } else {\n        RevObject o;\n        while ((o = walker.nextObject()) != null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            addObject(o, walker.getPathHashCode());\n            countingMonitor.update(1);\n        }\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    endPhase(countingMonitor);\n    stats.timeCounting = System.currentTimeMillis() - countingStart;\n}"
    },
    {
      "commit": "0f84b86e01da4680633c32bad101d021e0cb98ad",
      "startLine": 8,
      "endLine": 48,
      "methodCode": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Set<? extends ObjectId> want, Set<? extends ObjectId> have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    final long countingStart = System.currentTimeMillis();\n    beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n    if (have == null)\n        have = Collections.emptySet();\n    stats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n    stats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n    List<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final Map<ObjectId, CachedPack> tipToPack = new HashMap<ObjectId, CachedPack>();\n    final RevFlag inCachedPack = walker.newFlag(\"inCachedPack\");\n    final RevFlag include = walker.newFlag(\"include\");\n    final RevFlag added = walker.newFlag(\"added\");\n    final RevFlagSet keepOnRestart = new RevFlagSet();\n    keepOnRestart.add(inCachedPack);\n    walker.setRetainBody(false);\n    walker.carry(include);\n    int haveEst = have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n        if (useCachedPacks && reuseSupport != null) {\n            Set<ObjectId> need = new HashSet<ObjectId>(want);\n            List<CachedPack> shortCircuit = new LinkedList<CachedPack>();\n            for (CachedPack pack : reuseSupport.getCachedPacks()) {\n                if (need.containsAll(pack.getTips())) {\n                    need.removeAll(pack.getTips());\n                    shortCircuit.add(pack);\n                }\n                for (ObjectId id : pack.getTips()) {\n                    tipToPack.put(id, pack);\n                    all.add(id);\n                }\n            }\n            if (need.isEmpty() && !shortCircuit.isEmpty()) {\n                cachedPacks.addAll(shortCircuit);\n                for (CachedPack pack : shortCircuit) countingMonitor.update((int) pack.getObjectCount());\n                endPhase(countingMonitor);\n                stats.timeCounting = System.currentTimeMillis() - countingStart;\n                return;\n            }\n            haveEst += tipToPack.size();\n        }\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n    List<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n    List<RevTag> wantTags = new ArrayList<RevTag>(want.size());\n    AsyncRevObjectQueue q = walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o = q.next();\n                if (o == null)\n                    break;\n                if (tipToPack.containsKey(o))\n                    o.add(inCachedPack);\n                if (have.contains(o))\n                    haveObjs.add(o);\n                if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    if (o instanceof RevTag)\n                        wantTags.add((RevTag) o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting && have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    if (!wantTags.isEmpty()) {\n        all = new ArrayList<ObjectId>(wantTags.size());\n        for (RevTag tag : wantTags) all.add(tag.getObject());\n        q = walker.parseAny(all, true);\n        try {\n            while (q.next() != null) {\n            }\n        } finally {\n            q.release();\n        }\n    }\n    if (walker instanceof DepthWalk.ObjectWalk) {\n        DepthWalk.ObjectWalk depthWalk = (DepthWalk.ObjectWalk) walker;\n        for (RevObject obj : wantObjs) depthWalk.markRoot(obj);\n        if (unshallowObjects != null) {\n            for (ObjectId id : unshallowObjects) depthWalk.markUnshallow(walker.parseAny(id));\n        }\n    } else {\n        for (RevObject obj : wantObjs) walker.markStart(obj);\n    }\n    for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n    final int maxBases = config.getDeltaSearchWindowSize();\n    Set<RevTree> baseTrees = new HashSet<RevTree>();\n    BlockList<RevCommit> commits = new BlockList<RevCommit>();\n    RevCommit c;\n    while ((c = walker.next()) != null) {\n        if (exclude(c))\n            continue;\n        if (c.has(inCachedPack)) {\n            CachedPack pack = tipToPack.get(c);\n            if (includesAllTips(pack, include, walker)) {\n                useCachedPack(walker, keepOnRestart, wantObjs, haveObjs, pack);\n                commits = new BlockList<RevCommit>();\n                endPhase(countingMonitor);\n                beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n                continue;\n            }\n        }\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() <= maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        countingMonitor.update(1);\n    }\n    if (shallowPack) {\n        for (RevCommit cmit : commits) {\n            addObject(cmit, 0);\n        }\n    } else {\n        int commitCnt = 0;\n        boolean putTagTargets = false;\n        for (RevCommit cmit : commits) {\n            if (!cmit.has(added)) {\n                cmit.add(added);\n                addObject(cmit, 0);\n                commitCnt++;\n            }\n            for (int i = 0; i < cmit.getParentCount(); i++) {\n                RevCommit p = cmit.getParent(i);\n                if (!p.has(added) && !p.has(RevFlag.UNINTERESTING) && !exclude(p)) {\n                    p.add(added);\n                    addObject(p, 0);\n                    commitCnt++;\n                }\n            }\n            if (!putTagTargets && 4096 < commitCnt) {\n                for (ObjectId id : tagTargets) {\n                    RevObject obj = walker.lookupOrNull(id);\n                    if (obj instanceof RevCommit && obj.has(include) && !obj.has(RevFlag.UNINTERESTING) && !obj.has(added)) {\n                        obj.add(added);\n                        addObject(obj, 0);\n                    }\n                }\n                putTagTargets = true;\n            }\n        }\n    }\n    commits = null;\n    if (thin && !baseTrees.isEmpty()) {\n        BaseSearch bases = new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n        RevObject o;\n        while ((o = walker.nextObject()) != null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            int pathHash = walker.getPathHashCode();\n            byte[] pathBuf = walker.getPathBuffer();\n            int pathLen = walker.getPathLength();\n            bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n            addObject(o, pathHash);\n            countingMonitor.update(1);\n        }\n    } else {\n        RevObject o;\n        while ((o = walker.nextObject()) != null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            addObject(o, walker.getPathHashCode());\n            countingMonitor.update(1);\n        }\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    endPhase(countingMonitor);\n    stats.timeCounting = System.currentTimeMillis() - countingStart;\n}"
    },
    {
      "commit": "16b8ebf2d1d099ac355767b1b1853ae7bf8854f1",
      "startLine": 8,
      "endLine": 48,
      "methodCode": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Set<? extends ObjectId> want, Set<? extends ObjectId> have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    final long countingStart = System.currentTimeMillis();\n    beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n    if (have == null)\n        have = Collections.emptySet();\n    stats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n    stats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n    List<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final Map<ObjectId, CachedPack> tipToPack = new HashMap<ObjectId, CachedPack>();\n    final RevFlag inCachedPack = walker.newFlag(\"inCachedPack\");\n    final RevFlag include = walker.newFlag(\"include\");\n    final RevFlag added = walker.newFlag(\"added\");\n    final RevFlagSet keepOnRestart = new RevFlagSet();\n    keepOnRestart.add(inCachedPack);\n    walker.setRetainBody(false);\n    walker.carry(include);\n    int haveEst = have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n        if (useCachedPacks && reuseSupport != null) {\n            Set<ObjectId> need = new HashSet<ObjectId>(want);\n            List<CachedPack> shortCircuit = new LinkedList<CachedPack>();\n            for (CachedPack pack : reuseSupport.getCachedPacks()) {\n                if (need.containsAll(pack.getTips())) {\n                    need.removeAll(pack.getTips());\n                    shortCircuit.add(pack);\n                }\n                for (ObjectId id : pack.getTips()) {\n                    tipToPack.put(id, pack);\n                    all.add(id);\n                }\n            }\n            if (need.isEmpty() && !shortCircuit.isEmpty()) {\n                cachedPacks.addAll(shortCircuit);\n                for (CachedPack pack : shortCircuit) countingMonitor.update((int) pack.getObjectCount());\n                endPhase(countingMonitor);\n                stats.timeCounting = System.currentTimeMillis() - countingStart;\n                return;\n            }\n            haveEst += tipToPack.size();\n        }\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n    List<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n    List<RevTag> wantTags = new ArrayList<RevTag>(want.size());\n    AsyncRevObjectQueue q = walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o = q.next();\n                if (o == null)\n                    break;\n                if (tipToPack.containsKey(o))\n                    o.add(inCachedPack);\n                if (have.contains(o))\n                    haveObjs.add(o);\n                if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    if (o instanceof RevTag)\n                        wantTags.add((RevTag) o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting && have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    if (!wantTags.isEmpty()) {\n        all = new ArrayList<ObjectId>(wantTags.size());\n        for (RevTag tag : wantTags) all.add(tag.getObject());\n        q = walker.parseAny(all, true);\n        try {\n            while (q.next() != null) {\n            }\n        } finally {\n            q.release();\n        }\n    }\n    if (walker instanceof DepthWalk.ObjectWalk) {\n        DepthWalk.ObjectWalk depthWalk = (DepthWalk.ObjectWalk) walker;\n        for (RevObject obj : wantObjs) depthWalk.markRoot(obj);\n        if (unshallowObjects != null) {\n            for (ObjectId id : unshallowObjects) depthWalk.markUnshallow(walker.parseAny(id));\n        }\n    } else {\n        for (RevObject obj : wantObjs) walker.markStart(obj);\n    }\n    for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n    final int maxBases = config.getDeltaSearchWindowSize();\n    Set<RevTree> baseTrees = new HashSet<RevTree>();\n    BlockList<RevCommit> commits = new BlockList<RevCommit>();\n    RevCommit c;\n    while ((c = walker.next()) != null) {\n        if (exclude(c))\n            continue;\n        if (c.has(inCachedPack)) {\n            CachedPack pack = tipToPack.get(c);\n            if (includesAllTips(pack, include, walker)) {\n                useCachedPack(walker, keepOnRestart, wantObjs, haveObjs, pack);\n                commits = new BlockList<RevCommit>();\n                endPhase(countingMonitor);\n                beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n                continue;\n            }\n        }\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() <= maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        countingMonitor.update(1);\n    }\n    if (shallowPack) {\n        for (RevCommit cmit : commits) {\n            addObject(cmit, 0);\n        }\n    } else {\n        int commitCnt = 0;\n        boolean putTagTargets = false;\n        for (RevCommit cmit : commits) {\n            if (!cmit.has(added)) {\n                cmit.add(added);\n                addObject(cmit, 0);\n                commitCnt++;\n            }\n            for (int i = 0; i < cmit.getParentCount(); i++) {\n                RevCommit p = cmit.getParent(i);\n                if (!p.has(added) && !p.has(RevFlag.UNINTERESTING)) {\n                    p.add(added);\n                    addObject(p, 0);\n                    commitCnt++;\n                }\n            }\n            if (!putTagTargets && 4096 < commitCnt) {\n                for (ObjectId id : tagTargets) {\n                    RevObject obj = walker.lookupOrNull(id);\n                    if (obj instanceof RevCommit && obj.has(include) && !obj.has(RevFlag.UNINTERESTING) && !obj.has(added)) {\n                        obj.add(added);\n                        addObject(obj, 0);\n                    }\n                }\n                putTagTargets = true;\n            }\n        }\n    }\n    commits = null;\n    if (thin && !baseTrees.isEmpty()) {\n        BaseSearch bases = new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n        RevObject o;\n        while ((o = walker.nextObject()) != null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            int pathHash = walker.getPathHashCode();\n            byte[] pathBuf = walker.getPathBuffer();\n            int pathLen = walker.getPathLength();\n            bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n            addObject(o, pathHash);\n            countingMonitor.update(1);\n        }\n    } else {\n        RevObject o;\n        while ((o = walker.nextObject()) != null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            addObject(o, walker.getPathHashCode());\n            countingMonitor.update(1);\n        }\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    endPhase(countingMonitor);\n    stats.timeCounting = System.currentTimeMillis() - countingStart;\n}"
    },
    {
      "commit": "9952223e0645fd7a8cddc6093a7f449c6390238d",
      "startLine": 8,
      "endLine": 48,
      "methodCode": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Set<? extends ObjectId> want, Set<? extends ObjectId> have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    final long countingStart = System.currentTimeMillis();\n    countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n    if (have == null)\n        have = Collections.emptySet();\n    stats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n    stats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n    List<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final Map<ObjectId, CachedPack> tipToPack = new HashMap<ObjectId, CachedPack>();\n    final RevFlag inCachedPack = walker.newFlag(\"inCachedPack\");\n    final RevFlag include = walker.newFlag(\"include\");\n    final RevFlag added = walker.newFlag(\"added\");\n    final RevFlagSet keepOnRestart = new RevFlagSet();\n    keepOnRestart.add(inCachedPack);\n    walker.setRetainBody(false);\n    walker.carry(include);\n    int haveEst = have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n        if (useCachedPacks && reuseSupport != null) {\n            Set<ObjectId> need = new HashSet<ObjectId>(want);\n            List<CachedPack> shortCircuit = new LinkedList<CachedPack>();\n            for (CachedPack pack : reuseSupport.getCachedPacks()) {\n                if (need.containsAll(pack.getTips())) {\n                    need.removeAll(pack.getTips());\n                    shortCircuit.add(pack);\n                }\n                for (ObjectId id : pack.getTips()) {\n                    tipToPack.put(id, pack);\n                    all.add(id);\n                }\n            }\n            if (need.isEmpty() && !shortCircuit.isEmpty()) {\n                cachedPacks.addAll(shortCircuit);\n                for (CachedPack pack : shortCircuit) countingMonitor.update((int) pack.getObjectCount());\n                countingMonitor.endTask();\n                stats.timeCounting = System.currentTimeMillis() - countingStart;\n                return;\n            }\n            haveEst += tipToPack.size();\n        }\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n    List<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n    List<RevTag> wantTags = new ArrayList<RevTag>(want.size());\n    AsyncRevObjectQueue q = walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o = q.next();\n                if (o == null)\n                    break;\n                if (tipToPack.containsKey(o))\n                    o.add(inCachedPack);\n                if (have.contains(o))\n                    haveObjs.add(o);\n                if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    if (o instanceof RevTag)\n                        wantTags.add((RevTag) o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting && have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    if (!wantTags.isEmpty()) {\n        all = new ArrayList<ObjectId>(wantTags.size());\n        for (RevTag tag : wantTags) all.add(tag.getObject());\n        q = walker.parseAny(all, true);\n        try {\n            while (q.next() != null) {\n            }\n        } finally {\n            q.release();\n        }\n    }\n    if (walker instanceof DepthWalk.ObjectWalk) {\n        DepthWalk.ObjectWalk depthWalk = (DepthWalk.ObjectWalk) walker;\n        for (RevObject obj : wantObjs) depthWalk.markRoot(obj);\n        if (unshallowObjects != null) {\n            for (ObjectId id : unshallowObjects) depthWalk.markUnshallow(walker.parseAny(id));\n        }\n    } else {\n        for (RevObject obj : wantObjs) walker.markStart(obj);\n    }\n    for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n    final int maxBases = config.getDeltaSearchWindowSize();\n    Set<RevTree> baseTrees = new HashSet<RevTree>();\n    BlockList<RevCommit> commits = new BlockList<RevCommit>();\n    RevCommit c;\n    while ((c = walker.next()) != null) {\n        if (exclude(c))\n            continue;\n        if (c.has(inCachedPack)) {\n            CachedPack pack = tipToPack.get(c);\n            if (includesAllTips(pack, include, walker)) {\n                useCachedPack(walker, keepOnRestart, wantObjs, haveObjs, pack);\n                commits = new BlockList<RevCommit>();\n                countingMonitor.endTask();\n                countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n                continue;\n            }\n        }\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() <= maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        countingMonitor.update(1);\n    }\n    if (shallowPack) {\n        for (RevCommit cmit : commits) {\n            addObject(cmit, 0);\n        }\n    } else {\n        int commitCnt = 0;\n        boolean putTagTargets = false;\n        for (RevCommit cmit : commits) {\n            if (!cmit.has(added)) {\n                cmit.add(added);\n                addObject(cmit, 0);\n                commitCnt++;\n            }\n            for (int i = 0; i < cmit.getParentCount(); i++) {\n                RevCommit p = cmit.getParent(i);\n                if (!p.has(added) && !p.has(RevFlag.UNINTERESTING)) {\n                    p.add(added);\n                    addObject(p, 0);\n                    commitCnt++;\n                }\n            }\n            if (!putTagTargets && 4096 < commitCnt) {\n                for (ObjectId id : tagTargets) {\n                    RevObject obj = walker.lookupOrNull(id);\n                    if (obj instanceof RevCommit && obj.has(include) && !obj.has(RevFlag.UNINTERESTING) && !obj.has(added)) {\n                        obj.add(added);\n                        addObject(obj, 0);\n                    }\n                }\n                putTagTargets = true;\n            }\n        }\n    }\n    commits = null;\n    if (thin && !baseTrees.isEmpty()) {\n        BaseSearch bases = new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n        RevObject o;\n        while ((o = walker.nextObject()) != null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            int pathHash = walker.getPathHashCode();\n            byte[] pathBuf = walker.getPathBuffer();\n            int pathLen = walker.getPathLength();\n            bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n            addObject(o, pathHash);\n            countingMonitor.update(1);\n        }\n    } else {\n        RevObject o;\n        while ((o = walker.nextObject()) != null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            addObject(o, walker.getPathHashCode());\n            countingMonitor.update(1);\n        }\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    countingMonitor.endTask();\n    stats.timeCounting = System.currentTimeMillis() - countingStart;\n}"
    },
    {
      "commit": "a1a8c6d77ec5bea13c4f5ca428e425d95e14e003",
      "startLine": 8,
      "endLine": 48,
      "methodCode": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Set<? extends ObjectId> want, Set<? extends ObjectId> have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    final long countingStart = System.currentTimeMillis();\n    countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n    if (have == null)\n        have = Collections.emptySet();\n    stats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n    stats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n    List<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final Map<ObjectId, CachedPack> tipToPack = new HashMap<ObjectId, CachedPack>();\n    final RevFlag inCachedPack = walker.newFlag(\"inCachedPack\");\n    final RevFlag include = walker.newFlag(\"include\");\n    final RevFlag added = walker.newFlag(\"added\");\n    final RevFlagSet keepOnRestart = new RevFlagSet();\n    keepOnRestart.add(inCachedPack);\n    walker.setRetainBody(false);\n    walker.carry(include);\n    int haveEst = have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n        if (useCachedPacks && reuseSupport != null) {\n            Set<ObjectId> need = new HashSet<ObjectId>(want);\n            List<CachedPack> shortCircuit = new LinkedList<CachedPack>();\n            for (CachedPack pack : reuseSupport.getCachedPacks()) {\n                if (need.containsAll(pack.getTips())) {\n                    need.removeAll(pack.getTips());\n                    shortCircuit.add(pack);\n                }\n                for (ObjectId id : pack.getTips()) {\n                    tipToPack.put(id, pack);\n                    all.add(id);\n                }\n            }\n            if (need.isEmpty() && !shortCircuit.isEmpty()) {\n                cachedPacks.addAll(shortCircuit);\n                for (CachedPack pack : shortCircuit) countingMonitor.update((int) pack.getObjectCount());\n                countingMonitor.endTask();\n                stats.timeCounting = System.currentTimeMillis() - countingStart;\n                return;\n            }\n            haveEst += tipToPack.size();\n        }\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n    List<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n    List<RevTag> wantTags = new ArrayList<RevTag>(want.size());\n    AsyncRevObjectQueue q = walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o = q.next();\n                if (o == null)\n                    break;\n                if (tipToPack.containsKey(o))\n                    o.add(inCachedPack);\n                if (have.contains(o)) {\n                    haveObjs.add(o);\n                } else if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    if (o instanceof RevTag)\n                        wantTags.add((RevTag) o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting && have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    if (!wantTags.isEmpty()) {\n        all = new ArrayList<ObjectId>(wantTags.size());\n        for (RevTag tag : wantTags) all.add(tag.getObject());\n        q = walker.parseAny(all, true);\n        try {\n            while (q.next() != null) {\n            }\n        } finally {\n            q.release();\n        }\n    }\n    for (RevObject obj : wantObjs) walker.markStart(obj);\n    for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n    final int maxBases = config.getDeltaSearchWindowSize();\n    Set<RevTree> baseTrees = new HashSet<RevTree>();\n    BlockList<RevCommit> commits = new BlockList<RevCommit>();\n    RevCommit c;\n    while ((c = walker.next()) != null) {\n        if (exclude(c))\n            continue;\n        if (c.has(inCachedPack)) {\n            CachedPack pack = tipToPack.get(c);\n            if (includesAllTips(pack, include, walker)) {\n                useCachedPack(walker, keepOnRestart, wantObjs, haveObjs, pack);\n                commits = new BlockList<RevCommit>();\n                countingMonitor.endTask();\n                countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n                continue;\n            }\n        }\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() <= maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        countingMonitor.update(1);\n    }\n    int commitCnt = 0;\n    boolean putTagTargets = false;\n    for (RevCommit cmit : commits) {\n        if (!cmit.has(added)) {\n            cmit.add(added);\n            addObject(cmit, 0);\n            commitCnt++;\n        }\n        for (int i = 0; i < cmit.getParentCount(); i++) {\n            RevCommit p = cmit.getParent(i);\n            if (!p.has(added) && !p.has(RevFlag.UNINTERESTING)) {\n                p.add(added);\n                addObject(p, 0);\n                commitCnt++;\n            }\n        }\n        if (!putTagTargets && 4096 < commitCnt) {\n            for (ObjectId id : tagTargets) {\n                RevObject obj = walker.lookupOrNull(id);\n                if (obj instanceof RevCommit && obj.has(include) && !obj.has(RevFlag.UNINTERESTING) && !obj.has(added)) {\n                    obj.add(added);\n                    addObject(obj, 0);\n                }\n            }\n            putTagTargets = true;\n        }\n    }\n    commits = null;\n    if (thin && !baseTrees.isEmpty()) {\n        BaseSearch bases = new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n        RevObject o;\n        while ((o = walker.nextObject()) != null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            int pathHash = walker.getPathHashCode();\n            byte[] pathBuf = walker.getPathBuffer();\n            int pathLen = walker.getPathLength();\n            bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n            addObject(o, pathHash);\n            countingMonitor.update(1);\n        }\n    } else {\n        RevObject o;\n        while ((o = walker.nextObject()) != null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            addObject(o, walker.getPathHashCode());\n            countingMonitor.update(1);\n        }\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    countingMonitor.endTask();\n    stats.timeCounting = System.currentTimeMillis() - countingStart;\n}"
    },
    {
      "commit": "74333e63b60440be5ff9f591f2203b635e26e3a0",
      "startLine": 8,
      "endLine": 48,
      "methodCode": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Set<? extends ObjectId> want, Set<? extends ObjectId> have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    final long countingStart = System.currentTimeMillis();\n    countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n    if (have == null)\n        have = Collections.emptySet();\n    stats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n    stats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n    List<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final Map<ObjectId, CachedPack> tipToPack = new HashMap<ObjectId, CachedPack>();\n    final RevFlag inCachedPack = walker.newFlag(\"inCachedPack\");\n    final RevFlag include = walker.newFlag(\"include\");\n    final RevFlag added = walker.newFlag(\"added\");\n    final RevFlagSet keepOnRestart = new RevFlagSet();\n    keepOnRestart.add(inCachedPack);\n    walker.setRetainBody(false);\n    walker.carry(include);\n    int haveEst = have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n        if (useCachedPacks && reuseSupport != null) {\n            Set<ObjectId> need = new HashSet<ObjectId>(want);\n            List<CachedPack> shortCircuit = new LinkedList<CachedPack>();\n            for (CachedPack pack : reuseSupport.getCachedPacks()) {\n                if (need.containsAll(pack.getTips())) {\n                    need.removeAll(pack.getTips());\n                    shortCircuit.add(pack);\n                }\n                for (ObjectId id : pack.getTips()) {\n                    tipToPack.put(id, pack);\n                    all.add(id);\n                }\n            }\n            if (need.isEmpty() && !shortCircuit.isEmpty()) {\n                cachedPacks.addAll(shortCircuit);\n                for (CachedPack pack : shortCircuit) countingMonitor.update((int) pack.getObjectCount());\n                countingMonitor.endTask();\n                stats.timeCounting = System.currentTimeMillis() - countingStart;\n                return;\n            }\n            haveEst += tipToPack.size();\n        }\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n    List<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n    List<RevTag> wantTags = new ArrayList<RevTag>(want.size());\n    AsyncRevObjectQueue q = walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o = q.next();\n                if (o == null)\n                    break;\n                if (tipToPack.containsKey(o))\n                    o.add(inCachedPack);\n                if (have.contains(o)) {\n                    haveObjs.add(o);\n                } else if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    if (o instanceof RevTag)\n                        wantTags.add((RevTag) o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting && have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    if (!wantTags.isEmpty()) {\n        all = new ArrayList<ObjectId>(wantTags.size());\n        for (RevTag tag : wantTags) all.add(tag.getObject());\n        q = walker.parseAny(all, true);\n        try {\n            while (q.next() != null) {\n            }\n        } finally {\n            q.release();\n        }\n    }\n    for (RevObject obj : wantObjs) walker.markStart(obj);\n    for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n    final int maxBases = config.getDeltaSearchWindowSize();\n    Set<RevTree> baseTrees = new HashSet<RevTree>();\n    BlockList<RevCommit> commits = new BlockList<RevCommit>();\n    RevCommit c;\n    while ((c = walker.next()) != null) {\n        if (c.has(inCachedPack)) {\n            CachedPack pack = tipToPack.get(c);\n            if (includesAllTips(pack, include, walker)) {\n                useCachedPack(walker, keepOnRestart, wantObjs, haveObjs, pack);\n                commits = new BlockList<RevCommit>();\n                countingMonitor.endTask();\n                countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n                continue;\n            }\n        }\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() <= maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        countingMonitor.update(1);\n    }\n    int commitCnt = 0;\n    boolean putTagTargets = false;\n    for (RevCommit cmit : commits) {\n        if (!cmit.has(added)) {\n            cmit.add(added);\n            addObject(cmit, 0);\n            commitCnt++;\n        }\n        for (int i = 0; i < cmit.getParentCount(); i++) {\n            RevCommit p = cmit.getParent(i);\n            if (!p.has(added) && !p.has(RevFlag.UNINTERESTING)) {\n                p.add(added);\n                addObject(p, 0);\n                commitCnt++;\n            }\n        }\n        if (!putTagTargets && 4096 < commitCnt) {\n            for (ObjectId id : tagTargets) {\n                RevObject obj = walker.lookupOrNull(id);\n                if (obj instanceof RevCommit && obj.has(include) && !obj.has(RevFlag.UNINTERESTING) && !obj.has(added)) {\n                    obj.add(added);\n                    addObject(obj, 0);\n                }\n            }\n            putTagTargets = true;\n        }\n    }\n    commits = null;\n    if (thin && !baseTrees.isEmpty()) {\n        BaseSearch bases = new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n        RevObject o;\n        while ((o = walker.nextObject()) != null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            int pathHash = walker.getPathHashCode();\n            byte[] pathBuf = walker.getPathBuffer();\n            int pathLen = walker.getPathLength();\n            bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n            addObject(o, pathHash);\n            countingMonitor.update(1);\n        }\n    } else {\n        RevObject o;\n        while ((o = walker.nextObject()) != null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            addObject(o, walker.getPathHashCode());\n            countingMonitor.update(1);\n        }\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    countingMonitor.endTask();\n    stats.timeCounting = System.currentTimeMillis() - countingStart;\n}"
    },
    {
      "commit": "99e6cfb131bb407247acbc8c0a73e7c7cf37ebc2",
      "startLine": 8,
      "endLine": 48,
      "methodCode": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Collection<? extends ObjectId> want, Collection<? extends ObjectId> have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    final long countingStart = System.currentTimeMillis();\n    countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n    if (have == null)\n        have = Collections.emptySet();\n    stats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n    stats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n    List<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final Map<ObjectId, CachedPack> tipToPack = new HashMap<ObjectId, CachedPack>();\n    final RevFlag inCachedPack = walker.newFlag(\"inCachedPack\");\n    final RevFlag include = walker.newFlag(\"include\");\n    final RevFlag added = walker.newFlag(\"added\");\n    final RevFlagSet keepOnRestart = new RevFlagSet();\n    keepOnRestart.add(inCachedPack);\n    walker.setRetainBody(false);\n    walker.carry(include);\n    int haveEst = have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n        if (useCachedPacks && reuseSupport != null) {\n            Set<ObjectId> need = new HashSet<ObjectId>(want);\n            List<CachedPack> shortCircuit = new LinkedList<CachedPack>();\n            for (CachedPack pack : reuseSupport.getCachedPacks()) {\n                if (need.containsAll(pack.getTips())) {\n                    need.removeAll(pack.getTips());\n                    shortCircuit.add(pack);\n                }\n                for (ObjectId id : pack.getTips()) {\n                    tipToPack.put(id, pack);\n                    all.add(id);\n                }\n            }\n            if (need.isEmpty() && !shortCircuit.isEmpty()) {\n                cachedPacks.addAll(shortCircuit);\n                for (CachedPack pack : shortCircuit) countingMonitor.update((int) pack.getObjectCount());\n                countingMonitor.endTask();\n                stats.timeCounting = System.currentTimeMillis() - countingStart;\n                return;\n            }\n            haveEst += tipToPack.size();\n        }\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n    List<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n    List<RevTag> wantTags = new ArrayList<RevTag>(want.size());\n    AsyncRevObjectQueue q = walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o = q.next();\n                if (o == null)\n                    break;\n                if (tipToPack.containsKey(o))\n                    o.add(inCachedPack);\n                if (have.contains(o)) {\n                    haveObjs.add(o);\n                } else if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    if (o instanceof RevTag)\n                        wantTags.add((RevTag) o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting && have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    if (!wantTags.isEmpty()) {\n        all = new ArrayList<ObjectId>(wantTags.size());\n        for (RevTag tag : wantTags) all.add(tag.getObject());\n        q = walker.parseAny(all, true);\n        try {\n            while (q.next() != null) {\n            }\n        } finally {\n            q.release();\n        }\n    }\n    for (RevObject obj : wantObjs) walker.markStart(obj);\n    for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n    final int maxBases = config.getDeltaSearchWindowSize();\n    Set<RevTree> baseTrees = new HashSet<RevTree>();\n    BlockList<RevCommit> commits = new BlockList<RevCommit>();\n    RevCommit c;\n    while ((c = walker.next()) != null) {\n        if (c.has(inCachedPack)) {\n            CachedPack pack = tipToPack.get(c);\n            if (includesAllTips(pack, include, walker)) {\n                useCachedPack(walker, keepOnRestart, wantObjs, haveObjs, pack);\n                commits = new BlockList<RevCommit>();\n                countingMonitor.endTask();\n                countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n                continue;\n            }\n        }\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() <= maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        countingMonitor.update(1);\n    }\n    int commitCnt = 0;\n    boolean putTagTargets = false;\n    for (RevCommit cmit : commits) {\n        if (!cmit.has(added)) {\n            cmit.add(added);\n            addObject(cmit, 0);\n            commitCnt++;\n        }\n        for (int i = 0; i < cmit.getParentCount(); i++) {\n            RevCommit p = cmit.getParent(i);\n            if (!p.has(added) && !p.has(RevFlag.UNINTERESTING)) {\n                p.add(added);\n                addObject(p, 0);\n                commitCnt++;\n            }\n        }\n        if (!putTagTargets && 4096 < commitCnt) {\n            for (ObjectId id : tagTargets) {\n                RevObject obj = walker.lookupOrNull(id);\n                if (obj instanceof RevCommit && obj.has(include) && !obj.has(RevFlag.UNINTERESTING) && !obj.has(added)) {\n                    obj.add(added);\n                    addObject(obj, 0);\n                }\n            }\n            putTagTargets = true;\n        }\n    }\n    commits = null;\n    if (thin && !baseTrees.isEmpty()) {\n        BaseSearch bases = new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n        RevObject o;\n        while ((o = walker.nextObject()) != null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            int pathHash = walker.getPathHashCode();\n            byte[] pathBuf = walker.getPathBuffer();\n            int pathLen = walker.getPathLength();\n            bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n            addObject(o, pathHash);\n            countingMonitor.update(1);\n        }\n    } else {\n        RevObject o;\n        while ((o = walker.nextObject()) != null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            addObject(o, walker.getPathHashCode());\n            countingMonitor.update(1);\n        }\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    countingMonitor.endTask();\n    stats.timeCounting = System.currentTimeMillis() - countingStart;\n}"
    },
    {
      "commit": "9f5bbb5dd41f87d6428eb49c021e00d8099d0c17",
      "startLine": 8,
      "endLine": 48,
      "methodCode": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Collection<? extends ObjectId> want, Collection<? extends ObjectId> have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    final long countingStart = System.currentTimeMillis();\n    countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n    if (have == null)\n        have = Collections.emptySet();\n    stats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n    stats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n    List<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final Map<ObjectId, CachedPack> tipToPack = new HashMap<ObjectId, CachedPack>();\n    final RevFlag inCachedPack = walker.newFlag(\"inCachedPack\");\n    final RevFlag include = walker.newFlag(\"include\");\n    final RevFlag added = walker.newFlag(\"added\");\n    final RevFlagSet keepOnRestart = new RevFlagSet();\n    keepOnRestart.add(inCachedPack);\n    walker.setRetainBody(false);\n    walker.carry(include);\n    int haveEst = have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n        if (useCachedPacks && reuseSupport != null) {\n            Set<ObjectId> need = new HashSet<ObjectId>(want);\n            List<CachedPack> shortCircuit = new LinkedList<CachedPack>();\n            for (CachedPack pack : reuseSupport.getCachedPacks()) {\n                if (need.containsAll(pack.getTips())) {\n                    need.removeAll(pack.getTips());\n                    shortCircuit.add(pack);\n                }\n                for (ObjectId id : pack.getTips()) {\n                    tipToPack.put(id, pack);\n                    all.add(id);\n                }\n            }\n            if (need.isEmpty() && !shortCircuit.isEmpty()) {\n                cachedPacks.addAll(shortCircuit);\n                for (CachedPack pack : shortCircuit) countingMonitor.update((int) pack.getObjectCount());\n                countingMonitor.endTask();\n                stats.timeCounting = System.currentTimeMillis() - countingStart;\n                return;\n            }\n            haveEst += tipToPack.size();\n        }\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n    List<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n    List<RevTag> wantTags = new ArrayList<RevTag>(want.size());\n    AsyncRevObjectQueue q = walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o = q.next();\n                if (o == null)\n                    break;\n                if (tipToPack.containsKey(o))\n                    o.add(inCachedPack);\n                if (have.contains(o)) {\n                    haveObjs.add(o);\n                } else if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    if (o instanceof RevTag)\n                        wantTags.add((RevTag) o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting && have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    if (!wantTags.isEmpty()) {\n        all = new ArrayList<ObjectId>(wantTags.size());\n        for (RevTag tag : wantTags) all.add(tag.getObject());\n        q = walker.parseAny(all, true);\n        try {\n            while (q.next() != null) {\n            }\n        } finally {\n            q.release();\n        }\n    }\n    for (RevObject obj : wantObjs) walker.markStart(obj);\n    for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n    final int maxBases = config.getDeltaSearchWindowSize();\n    Set<RevTree> baseTrees = new HashSet<RevTree>();\n    BlockList<RevCommit> commits = new BlockList<RevCommit>();\n    RevCommit c;\n    while ((c = walker.next()) != null) {\n        if (c.has(inCachedPack)) {\n            CachedPack pack = tipToPack.get(c);\n            if (includesAllTips(pack, include, walker)) {\n                useCachedPack(walker, keepOnRestart, wantObjs, haveObjs, pack);\n                commits = new BlockList<RevCommit>();\n                countingMonitor.endTask();\n                countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n                continue;\n            }\n        }\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() <= maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        countingMonitor.update(1);\n    }\n    int commitCnt = 0;\n    boolean putTagTargets = false;\n    for (RevCommit cmit : commits) {\n        if (!cmit.has(added)) {\n            cmit.add(added);\n            addObject(cmit, 0);\n            commitCnt++;\n        }\n        for (int i = 0; i < cmit.getParentCount(); i++) {\n            RevCommit p = cmit.getParent(i);\n            if (!p.has(added) && !p.has(RevFlag.UNINTERESTING)) {\n                p.add(added);\n                addObject(p, 0);\n                commitCnt++;\n            }\n        }\n        if (!putTagTargets && 4096 < commitCnt) {\n            for (ObjectId id : tagTargets) {\n                RevObject obj = walker.lookupOrNull(id);\n                if (obj instanceof RevCommit && obj.has(include) && !obj.has(RevFlag.UNINTERESTING) && !obj.has(added)) {\n                    obj.add(added);\n                    addObject(obj, 0);\n                }\n            }\n            putTagTargets = true;\n        }\n    }\n    commits = null;\n    BaseSearch bases = new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n    RevObject o;\n    while ((o = walker.nextObject()) != null) {\n        if (o.has(RevFlag.UNINTERESTING))\n            continue;\n        int pathHash = walker.getPathHashCode();\n        byte[] pathBuf = walker.getPathBuffer();\n        int pathLen = walker.getPathLength();\n        bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n        addObject(o, pathHash);\n        countingMonitor.update(1);\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    countingMonitor.endTask();\n    stats.timeCounting = System.currentTimeMillis() - countingStart;\n}"
    },
    {
      "commit": "f67e5602af72b7b2238eb6f6fcdc206a47edabd5",
      "startLine": 8,
      "endLine": 48,
      "methodCode": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Collection<? extends ObjectId> want, Collection<? extends ObjectId> have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    final long countingStart = System.currentTimeMillis();\n    countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n    if (have == null)\n        have = Collections.emptySet();\n    stats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n    stats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n    List<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final Map<ObjectId, CachedPack> tipToPack = new HashMap<ObjectId, CachedPack>();\n    final RevFlag inCachedPack = walker.newFlag(\"inCachedPack\");\n    final RevFlag include = walker.newFlag(\"include\");\n    final RevFlag added = walker.newFlag(\"added\");\n    final RevFlagSet keepOnRestart = new RevFlagSet();\n    keepOnRestart.add(inCachedPack);\n    walker.setRetainBody(false);\n    walker.carry(include);\n    int haveEst = have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n        if (useCachedPacks && reuseSupport != null) {\n            Set<ObjectId> need = new HashSet<ObjectId>(want);\n            List<CachedPack> shortCircuit = new LinkedList<CachedPack>();\n            for (CachedPack pack : reuseSupport.getCachedPacks()) {\n                if (need.containsAll(pack.getTips())) {\n                    need.removeAll(pack.getTips());\n                    shortCircuit.add(pack);\n                }\n                for (ObjectId id : pack.getTips()) {\n                    tipToPack.put(id, pack);\n                    all.add(id);\n                }\n            }\n            if (need.isEmpty() && !shortCircuit.isEmpty()) {\n                cachedPacks.addAll(shortCircuit);\n                for (CachedPack pack : shortCircuit) countingMonitor.update((int) pack.getObjectCount());\n                countingMonitor.endTask();\n                stats.timeCounting = System.currentTimeMillis() - countingStart;\n                return;\n            }\n            haveEst += tipToPack.size();\n        }\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n    List<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n    List<RevTag> wantTags = new ArrayList<RevTag>(want.size());\n    AsyncRevObjectQueue q = walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o = q.next();\n                if (o == null)\n                    break;\n                if (tipToPack.containsKey(o))\n                    o.add(inCachedPack);\n                if (have.contains(o)) {\n                    haveObjs.add(o);\n                } else if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    if (o instanceof RevTag)\n                        wantTags.add((RevTag) o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting && have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    if (!wantTags.isEmpty()) {\n        all = new ArrayList<ObjectId>(wantTags.size());\n        for (RevTag tag : wantTags) all.add(tag.getObject());\n        q = walker.parseAny(all, true);\n        try {\n            while (q.next() != null) {\n            }\n        } finally {\n            q.release();\n        }\n    }\n    for (RevObject obj : wantObjs) walker.markStart(obj);\n    for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n    int typesToPrune = 0;\n    final int maxBases = config.getDeltaSearchWindowSize();\n    Set<RevTree> baseTrees = new HashSet<RevTree>();\n    BlockList<RevCommit> commits = new BlockList<RevCommit>();\n    RevCommit c;\n    while ((c = walker.next()) != null) {\n        if (c.has(inCachedPack)) {\n            CachedPack pack = tipToPack.get(c);\n            if (includesAllTips(pack, include, walker)) {\n                useCachedPack(walker, keepOnRestart, wantObjs, haveObjs, pack);\n                commits = new BlockList<RevCommit>();\n                countingMonitor.endTask();\n                countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n                continue;\n            }\n        }\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() <= maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        countingMonitor.update(1);\n    }\n    int commitCnt = 0;\n    boolean putTagTargets = false;\n    for (RevCommit cmit : commits) {\n        if (!cmit.has(added)) {\n            cmit.add(added);\n            addObject(cmit, 0);\n            commitCnt++;\n        }\n        for (int i = 0; i < cmit.getParentCount(); i++) {\n            RevCommit p = cmit.getParent(i);\n            if (!p.has(added) && !p.has(RevFlag.UNINTERESTING)) {\n                p.add(added);\n                addObject(p, 0);\n                commitCnt++;\n            }\n        }\n        if (!putTagTargets && 4096 < commitCnt) {\n            for (ObjectId id : tagTargets) {\n                RevObject obj = walker.lookupOrNull(id);\n                if (obj instanceof RevCommit && obj.has(include) && !obj.has(RevFlag.UNINTERESTING) && !obj.has(added)) {\n                    obj.add(added);\n                    addObject(obj, 0);\n                }\n            }\n            putTagTargets = true;\n        }\n    }\n    commits = null;\n    for (CachedPack p : cachedPacks) {\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_COMMIT])) {\n            if (baseTrees.size() <= maxBases)\n                baseTrees.add(walker.lookupCommit(d).getTree());\n            objectsMap.get(d).setEdge();\n            typesToPrune |= 1 << Constants.OBJ_COMMIT;\n        }\n    }\n    BaseSearch bases = new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n    RevObject o;\n    while ((o = walker.nextObject()) != null) {\n        if (o.has(RevFlag.UNINTERESTING))\n            continue;\n        int pathHash = walker.getPathHashCode();\n        byte[] pathBuf = walker.getPathBuffer();\n        int pathLen = walker.getPathLength();\n        bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n        addObject(o, pathHash);\n        countingMonitor.update(1);\n    }\n    for (CachedPack p : cachedPacks) {\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TREE])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |= 1 << Constants.OBJ_TREE;\n        }\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_BLOB])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |= 1 << Constants.OBJ_BLOB;\n        }\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TAG])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |= 1 << Constants.OBJ_TAG;\n        }\n    }\n    if (typesToPrune != 0) {\n        pruneObjectList(typesToPrune, Constants.OBJ_COMMIT);\n        pruneObjectList(typesToPrune, Constants.OBJ_TREE);\n        pruneObjectList(typesToPrune, Constants.OBJ_BLOB);\n        pruneObjectList(typesToPrune, Constants.OBJ_TAG);\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    countingMonitor.endTask();\n    stats.timeCounting = System.currentTimeMillis() - countingStart;\n}"
    },
    {
      "commit": "8f865bfffed575c3a4db6d7db92dc5f752f97237",
      "startLine": 8,
      "endLine": 48,
      "methodCode": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Collection<? extends ObjectId> want, Collection<? extends ObjectId> have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    final long countingStart = System.currentTimeMillis();\n    countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n    if (have == null)\n        have = Collections.emptySet();\n    stats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n    stats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n    List<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final Map<ObjectId, CachedPack> tipToPack = new HashMap<ObjectId, CachedPack>();\n    final RevFlag inCachedPack = walker.newFlag(\"inCachedPack\");\n    final RevFlag include = walker.newFlag(\"include\");\n    final RevFlag added = walker.newFlag(\"added\");\n    final RevFlagSet keepOnRestart = new RevFlagSet();\n    keepOnRestart.add(inCachedPack);\n    walker.setRetainBody(false);\n    walker.carry(include);\n    int haveEst = have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n        if (useCachedPacks && reuseSupport != null) {\n            Set<ObjectId> need = new HashSet<ObjectId>(want);\n            List<CachedPack> shortCircuit = new LinkedList<CachedPack>();\n            for (CachedPack pack : reuseSupport.getCachedPacks()) {\n                if (need.containsAll(pack.getTips())) {\n                    need.removeAll(pack.getTips());\n                    shortCircuit.add(pack);\n                }\n                for (ObjectId id : pack.getTips()) {\n                    tipToPack.put(id, pack);\n                    all.add(id);\n                }\n            }\n            if (need.isEmpty() && !shortCircuit.isEmpty()) {\n                cachedPacks.addAll(shortCircuit);\n                for (CachedPack pack : shortCircuit) countingMonitor.update((int) pack.getObjectCount());\n                countingMonitor.endTask();\n                stats.timeCounting = System.currentTimeMillis() - countingStart;\n                return;\n            }\n            haveEst += tipToPack.size();\n        }\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n    List<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n    List<RevTag> wantTags = new ArrayList<RevTag>(want.size());\n    AsyncRevObjectQueue q = walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o = q.next();\n                if (o == null)\n                    break;\n                if (tipToPack.containsKey(o))\n                    o.add(inCachedPack);\n                if (have.contains(o)) {\n                    haveObjs.add(o);\n                } else if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    if (o instanceof RevTag)\n                        wantTags.add((RevTag) o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting && have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    if (!wantTags.isEmpty()) {\n        all = new ArrayList<ObjectId>(wantTags.size());\n        for (RevTag tag : wantTags) all.add(tag.getObject());\n        q = walker.parseAny(all, true);\n        try {\n            while (q.next() != null) {\n            }\n        } finally {\n            q.release();\n        }\n    }\n    for (RevObject obj : wantObjs) walker.markStart(obj);\n    for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n    int typesToPrune = 0;\n    final int maxBases = config.getDeltaSearchWindowSize();\n    Set<RevTree> baseTrees = new HashSet<RevTree>();\n    List<RevCommit> commits = new ArrayList<RevCommit>();\n    RevCommit c;\n    while ((c = walker.next()) != null) {\n        if (c.has(inCachedPack)) {\n            CachedPack pack = tipToPack.get(c);\n            if (includesAllTips(pack, include, walker)) {\n                useCachedPack(walker, keepOnRestart, wantObjs, haveObjs, pack);\n                commits = new ArrayList<RevCommit>();\n                countingMonitor.endTask();\n                countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n                continue;\n            }\n        }\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() <= maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        countingMonitor.update(1);\n    }\n    if (objectsLists[Constants.OBJ_COMMIT] instanceof ArrayList) {\n        ArrayList<ObjectToPack> list = (ArrayList<ObjectToPack>) objectsLists[Constants.OBJ_COMMIT];\n        list.ensureCapacity(list.size() + commits.size());\n    }\n    int commitCnt = 0;\n    boolean putTagTargets = false;\n    for (RevCommit cmit : commits) {\n        if (!cmit.has(added)) {\n            cmit.add(added);\n            addObject(cmit, 0);\n            commitCnt++;\n        }\n        for (int i = 0; i < cmit.getParentCount(); i++) {\n            RevCommit p = cmit.getParent(i);\n            if (!p.has(added) && !p.has(RevFlag.UNINTERESTING)) {\n                p.add(added);\n                addObject(p, 0);\n                commitCnt++;\n            }\n        }\n        if (!putTagTargets && 4096 < commitCnt) {\n            for (ObjectId id : tagTargets) {\n                RevObject obj = walker.lookupOrNull(id);\n                if (obj instanceof RevCommit && obj.has(include) && !obj.has(RevFlag.UNINTERESTING) && !obj.has(added)) {\n                    obj.add(added);\n                    addObject(obj, 0);\n                }\n            }\n            putTagTargets = true;\n        }\n    }\n    commits = null;\n    for (CachedPack p : cachedPacks) {\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_COMMIT])) {\n            if (baseTrees.size() <= maxBases)\n                baseTrees.add(walker.lookupCommit(d).getTree());\n            objectsMap.get(d).setEdge();\n            typesToPrune |= 1 << Constants.OBJ_COMMIT;\n        }\n    }\n    BaseSearch bases = new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n    RevObject o;\n    while ((o = walker.nextObject()) != null) {\n        if (o.has(RevFlag.UNINTERESTING))\n            continue;\n        int pathHash = walker.getPathHashCode();\n        byte[] pathBuf = walker.getPathBuffer();\n        int pathLen = walker.getPathLength();\n        bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n        addObject(o, pathHash);\n        countingMonitor.update(1);\n    }\n    for (CachedPack p : cachedPacks) {\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TREE])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |= 1 << Constants.OBJ_TREE;\n        }\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_BLOB])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |= 1 << Constants.OBJ_BLOB;\n        }\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TAG])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |= 1 << Constants.OBJ_TAG;\n        }\n    }\n    if (typesToPrune != 0) {\n        pruneObjectList(typesToPrune, Constants.OBJ_COMMIT);\n        pruneObjectList(typesToPrune, Constants.OBJ_TREE);\n        pruneObjectList(typesToPrune, Constants.OBJ_BLOB);\n        pruneObjectList(typesToPrune, Constants.OBJ_TAG);\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    countingMonitor.endTask();\n    stats.timeCounting = System.currentTimeMillis() - countingStart;\n}"
    },
    {
      "commit": "19037e8cfc2d9534f79e40c898fdaeacaf499e82",
      "startLine": 8,
      "endLine": 48,
      "methodCode": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Collection<? extends ObjectId> want, Collection<? extends ObjectId> have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    final long countingStart = System.currentTimeMillis();\n    countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n    if (have == null)\n        have = Collections.emptySet();\n    stats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n    stats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n    List<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final Map<ObjectId, CachedPack> tipToPack = new HashMap<ObjectId, CachedPack>();\n    final RevFlag inCachedPack = walker.newFlag(\"inCachedPack\");\n    final RevFlag include = walker.newFlag(\"include\");\n    final RevFlag added = walker.newFlag(\"added\");\n    final RevFlagSet keepOnRestart = new RevFlagSet();\n    keepOnRestart.add(inCachedPack);\n    walker.setRetainBody(false);\n    walker.carry(include);\n    int haveEst = have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n        if (useCachedPacks && reuseSupport != null) {\n            Set<ObjectId> need = new HashSet<ObjectId>(want);\n            List<CachedPack> shortCircuit = new LinkedList<CachedPack>();\n            for (CachedPack pack : reuseSupport.getCachedPacks()) {\n                if (need.containsAll(pack.getTips())) {\n                    need.removeAll(pack.getTips());\n                    shortCircuit.add(pack);\n                }\n                for (ObjectId id : pack.getTips()) {\n                    tipToPack.put(id, pack);\n                    all.add(id);\n                }\n            }\n            if (need.isEmpty() && !shortCircuit.isEmpty()) {\n                cachedPacks.addAll(shortCircuit);\n                for (CachedPack pack : shortCircuit) countingMonitor.update((int) pack.getObjectCount());\n                countingMonitor.endTask();\n                stats.timeCounting = System.currentTimeMillis() - countingStart;\n                return;\n            }\n            haveEst += tipToPack.size();\n        }\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n    List<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n    List<RevTag> wantTags = new ArrayList<RevTag>(want.size());\n    AsyncRevObjectQueue q = walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o = q.next();\n                if (o == null)\n                    break;\n                if (tipToPack.containsKey(o))\n                    o.add(inCachedPack);\n                if (have.contains(o)) {\n                    haveObjs.add(o);\n                } else if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    if (o instanceof RevTag)\n                        wantTags.add((RevTag) o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting && have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    if (!wantTags.isEmpty()) {\n        all = new ArrayList<ObjectId>(wantTags.size());\n        for (RevTag tag : wantTags) all.add(tag.getObject());\n        q = walker.parseAny(all, true);\n        try {\n            while (q.next() != null) {\n            }\n        } finally {\n            q.release();\n        }\n    }\n    for (RevObject obj : wantObjs) walker.markStart(obj);\n    for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n    int typesToPrune = 0;\n    final int maxBases = config.getDeltaSearchWindowSize();\n    Set<RevTree> baseTrees = new HashSet<RevTree>();\n    List<RevCommit> commits = new ArrayList<RevCommit>();\n    RevCommit c;\n    while ((c = walker.next()) != null) {\n        if (c.has(inCachedPack)) {\n            CachedPack pack = tipToPack.get(c);\n            if (includesAllTips(pack, include, walker)) {\n                useCachedPack(walker, keepOnRestart, wantObjs, haveObjs, pack);\n                commits = new ArrayList<RevCommit>();\n                countingMonitor.endTask();\n                countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n                continue;\n            }\n        }\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() <= maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        countingMonitor.update(1);\n    }\n    if (objectsLists[Constants.OBJ_COMMIT] instanceof ArrayList) {\n        ArrayList<ObjectToPack> list = (ArrayList<ObjectToPack>) objectsLists[Constants.OBJ_COMMIT];\n        list.ensureCapacity(list.size() + commits.size());\n    }\n    for (RevCommit cmit : commits) {\n        if (!cmit.has(added)) {\n            cmit.add(added);\n            addObject(cmit, 0);\n        }\n        for (int i = 0; i < cmit.getParentCount(); i++) {\n            RevCommit p = cmit.getParent(i);\n            if (!p.has(added) && !p.has(RevFlag.UNINTERESTING)) {\n                p.add(added);\n                addObject(p, 0);\n            }\n        }\n    }\n    commits = null;\n    for (CachedPack p : cachedPacks) {\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_COMMIT])) {\n            if (baseTrees.size() <= maxBases)\n                baseTrees.add(walker.lookupCommit(d).getTree());\n            objectsMap.get(d).setEdge();\n            typesToPrune |= 1 << Constants.OBJ_COMMIT;\n        }\n    }\n    BaseSearch bases = new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n    RevObject o;\n    while ((o = walker.nextObject()) != null) {\n        if (o.has(RevFlag.UNINTERESTING))\n            continue;\n        int pathHash = walker.getPathHashCode();\n        byte[] pathBuf = walker.getPathBuffer();\n        int pathLen = walker.getPathLength();\n        bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n        addObject(o, pathHash);\n        countingMonitor.update(1);\n    }\n    for (CachedPack p : cachedPacks) {\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TREE])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |= 1 << Constants.OBJ_TREE;\n        }\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_BLOB])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |= 1 << Constants.OBJ_BLOB;\n        }\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TAG])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |= 1 << Constants.OBJ_TAG;\n        }\n    }\n    if (typesToPrune != 0) {\n        pruneObjectList(typesToPrune, Constants.OBJ_COMMIT);\n        pruneObjectList(typesToPrune, Constants.OBJ_TREE);\n        pruneObjectList(typesToPrune, Constants.OBJ_BLOB);\n        pruneObjectList(typesToPrune, Constants.OBJ_TAG);\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    countingMonitor.endTask();\n    stats.timeCounting = System.currentTimeMillis() - countingStart;\n}"
    },
    {
      "commit": "3e64b928d51b3a28e89cfe2a3f0eeae35ef07839",
      "startLine": 8,
      "endLine": 48,
      "methodCode": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Collection<? extends ObjectId> want, Collection<? extends ObjectId> have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    final long countingStart = System.currentTimeMillis();\n    countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n    if (have == null)\n        have = Collections.emptySet();\n    stats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n    stats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n    List<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final Map<ObjectId, CachedPack> tipToPack = new HashMap<ObjectId, CachedPack>();\n    final RevFlag inCachedPack = walker.newFlag(\"inCachedPack\");\n    final RevFlag include = walker.newFlag(\"include\");\n    final RevFlag added = walker.newFlag(\"added\");\n    final RevFlagSet keepOnRestart = new RevFlagSet();\n    keepOnRestart.add(inCachedPack);\n    walker.setRetainBody(false);\n    walker.carry(include);\n    int haveEst = have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n        if (useCachedPacks && reuseSupport != null) {\n            Set<ObjectId> need = new HashSet<ObjectId>(want);\n            List<CachedPack> shortCircuit = new LinkedList<CachedPack>();\n            for (CachedPack pack : reuseSupport.getCachedPacks()) {\n                if (need.containsAll(pack.getTips())) {\n                    need.removeAll(pack.getTips());\n                    shortCircuit.add(pack);\n                }\n                for (ObjectId id : pack.getTips()) {\n                    tipToPack.put(id, pack);\n                    all.add(id);\n                }\n            }\n            if (need.isEmpty() && !shortCircuit.isEmpty()) {\n                cachedPacks.addAll(shortCircuit);\n                for (CachedPack pack : shortCircuit) countingMonitor.update((int) pack.getObjectCount());\n                countingMonitor.endTask();\n                stats.timeCounting = System.currentTimeMillis() - countingStart;\n                return;\n            }\n            haveEst += tipToPack.size();\n        }\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n    List<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n    AsyncRevObjectQueue q = walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o = q.next();\n                if (o == null)\n                    break;\n                if (tipToPack.containsKey(o))\n                    o.add(inCachedPack);\n                if (have.contains(o)) {\n                    haveObjs.add(o);\n                    walker.markUninteresting(o);\n                } else if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    walker.markStart(o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting && have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    int typesToPrune = 0;\n    final int maxBases = config.getDeltaSearchWindowSize();\n    Set<RevTree> baseTrees = new HashSet<RevTree>();\n    List<RevCommit> commits = new ArrayList<RevCommit>();\n    RevCommit c;\n    while ((c = walker.next()) != null) {\n        if (c.has(inCachedPack)) {\n            CachedPack pack = tipToPack.get(c);\n            if (includesAllTips(pack, include, walker)) {\n                useCachedPack(walker, keepOnRestart, wantObjs, haveObjs, pack);\n                commits = new ArrayList<RevCommit>();\n                countingMonitor.endTask();\n                countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n                continue;\n            }\n        }\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() <= maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        countingMonitor.update(1);\n    }\n    if (objectsLists[Constants.OBJ_COMMIT] instanceof ArrayList) {\n        ArrayList<ObjectToPack> list = (ArrayList<ObjectToPack>) objectsLists[Constants.OBJ_COMMIT];\n        list.ensureCapacity(list.size() + commits.size());\n    }\n    for (RevCommit cmit : commits) {\n        if (!cmit.has(added)) {\n            cmit.add(added);\n            addObject(cmit, 0);\n        }\n        for (int i = 0; i < cmit.getParentCount(); i++) {\n            RevCommit p = cmit.getParent(i);\n            if (!p.has(added) && !p.has(RevFlag.UNINTERESTING)) {\n                p.add(added);\n                addObject(p, 0);\n            }\n        }\n    }\n    commits = null;\n    for (CachedPack p : cachedPacks) {\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_COMMIT])) {\n            if (baseTrees.size() <= maxBases)\n                baseTrees.add(walker.lookupCommit(d).getTree());\n            objectsMap.get(d).setEdge();\n            typesToPrune |= 1 << Constants.OBJ_COMMIT;\n        }\n    }\n    BaseSearch bases = new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n    RevObject o;\n    while ((o = walker.nextObject()) != null) {\n        if (o.has(RevFlag.UNINTERESTING))\n            continue;\n        int pathHash = walker.getPathHashCode();\n        byte[] pathBuf = walker.getPathBuffer();\n        int pathLen = walker.getPathLength();\n        bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n        addObject(o, pathHash);\n        countingMonitor.update(1);\n    }\n    for (CachedPack p : cachedPacks) {\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TREE])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |= 1 << Constants.OBJ_TREE;\n        }\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_BLOB])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |= 1 << Constants.OBJ_BLOB;\n        }\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TAG])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |= 1 << Constants.OBJ_TAG;\n        }\n    }\n    if (typesToPrune != 0) {\n        pruneObjectList(typesToPrune, Constants.OBJ_COMMIT);\n        pruneObjectList(typesToPrune, Constants.OBJ_TREE);\n        pruneObjectList(typesToPrune, Constants.OBJ_BLOB);\n        pruneObjectList(typesToPrune, Constants.OBJ_TAG);\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    countingMonitor.endTask();\n    stats.timeCounting = System.currentTimeMillis() - countingStart;\n}"
    },
    {
      "commit": "4275c4c1cffeffae6b12eb6aa2df957c23107b48",
      "startLine": 8,
      "endLine": 35,
      "methodCode": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Collection<? extends ObjectId> want, Collection<? extends ObjectId> have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    final long countingStart = System.currentTimeMillis();\n    countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n    if (have == null)\n        have = Collections.emptySet();\n    stats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n    stats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n    List<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final Map<ObjectId, CachedPack> tipToPack = new HashMap<ObjectId, CachedPack>();\n    final RevFlag inCachedPack = walker.newFlag(\"inCachedPack\");\n    final RevFlag include = walker.newFlag(\"include\");\n    final RevFlag added = walker.newFlag(\"added\");\n    final RevFlagSet keepOnRestart = new RevFlagSet();\n    keepOnRestart.add(inCachedPack);\n    walker.setRetainBody(false);\n    walker.carry(include);\n    int haveEst = have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n        if (useCachedPacks && reuseSupport != null) {\n            for (CachedPack pack : reuseSupport.getCachedPacks()) {\n                for (ObjectId id : pack.getTips()) {\n                    tipToPack.put(id, pack);\n                    all.add(id);\n                }\n            }\n            haveEst += tipToPack.size();\n        }\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n    List<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n    AsyncRevObjectQueue q = walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o = q.next();\n                if (o == null)\n                    break;\n                if (tipToPack.containsKey(o))\n                    o.add(inCachedPack);\n                if (have.contains(o)) {\n                    haveObjs.add(o);\n                    walker.markUninteresting(o);\n                } else if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    walker.markStart(o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting && have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    int typesToPrune = 0;\n    final int maxBases = config.getDeltaSearchWindowSize();\n    Set<RevTree> baseTrees = new HashSet<RevTree>();\n    List<RevCommit> commits = new ArrayList<RevCommit>();\n    RevCommit c;\n    while ((c = walker.next()) != null) {\n        if (c.has(inCachedPack)) {\n            CachedPack pack = tipToPack.get(c);\n            if (includesAllTips(pack, include, walker)) {\n                useCachedPack(walker, keepOnRestart, wantObjs, haveObjs, pack);\n                commits = new ArrayList<RevCommit>();\n                countingMonitor.endTask();\n                countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n                continue;\n            }\n        }\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() <= maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        countingMonitor.update(1);\n    }\n    if (objectsLists[Constants.OBJ_COMMIT] instanceof ArrayList) {\n        ArrayList<ObjectToPack> list = (ArrayList<ObjectToPack>) objectsLists[Constants.OBJ_COMMIT];\n        list.ensureCapacity(list.size() + commits.size());\n    }\n    for (RevCommit cmit : commits) {\n        if (!cmit.has(added)) {\n            cmit.add(added);\n            addObject(cmit, 0);\n        }\n        for (int i = 0; i < cmit.getParentCount(); i++) {\n            RevCommit p = cmit.getParent(i);\n            if (!p.has(added) && !p.has(RevFlag.UNINTERESTING)) {\n                p.add(added);\n                addObject(p, 0);\n            }\n        }\n    }\n    commits = null;\n    for (CachedPack p : cachedPacks) {\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_COMMIT])) {\n            if (baseTrees.size() <= maxBases)\n                baseTrees.add(walker.lookupCommit(d).getTree());\n            objectsMap.get(d).setEdge();\n            typesToPrune |= 1 << Constants.OBJ_COMMIT;\n        }\n    }\n    BaseSearch bases = new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n    RevObject o;\n    while ((o = walker.nextObject()) != null) {\n        if (o.has(RevFlag.UNINTERESTING))\n            continue;\n        int pathHash = walker.getPathHashCode();\n        byte[] pathBuf = walker.getPathBuffer();\n        int pathLen = walker.getPathLength();\n        bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n        addObject(o, pathHash);\n        countingMonitor.update(1);\n    }\n    for (CachedPack p : cachedPacks) {\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TREE])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |= 1 << Constants.OBJ_TREE;\n        }\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_BLOB])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |= 1 << Constants.OBJ_BLOB;\n        }\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TAG])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |= 1 << Constants.OBJ_TAG;\n        }\n    }\n    if (typesToPrune != 0) {\n        pruneObjectList(typesToPrune, Constants.OBJ_COMMIT);\n        pruneObjectList(typesToPrune, Constants.OBJ_TREE);\n        pruneObjectList(typesToPrune, Constants.OBJ_BLOB);\n        pruneObjectList(typesToPrune, Constants.OBJ_TAG);\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    countingMonitor.endTask();\n    stats.timeCounting = System.currentTimeMillis() - countingStart;\n}"
    },
    {
      "commit": "733780e8a158b7bc45b8b687ac353ecadc905a63",
      "startLine": 8,
      "endLine": 35,
      "methodCode": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Collection<? extends ObjectId> want, Collection<? extends ObjectId> have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    final long countingStart = System.currentTimeMillis();\n    countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n    if (have == null)\n        have = Collections.emptySet();\n    stats.interestingObjects = Collections.unmodifiableSet(new HashSet(want));\n    stats.uninterestingObjects = Collections.unmodifiableSet(new HashSet(have));\n    List<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final Map<ObjectId, CachedPack> tipToPack = new HashMap<ObjectId, CachedPack>();\n    final RevFlag inCachedPack = walker.newFlag(\"inCachedPack\");\n    final RevFlag include = walker.newFlag(\"include\");\n    final RevFlag added = walker.newFlag(\"added\");\n    final RevFlagSet keepOnRestart = new RevFlagSet();\n    keepOnRestart.add(inCachedPack);\n    walker.setRetainBody(false);\n    walker.carry(include);\n    int haveEst = have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n        if (useCachedPacks && reuseSupport != null) {\n            for (CachedPack pack : reuseSupport.getCachedPacks()) {\n                for (ObjectId id : pack.getTips()) {\n                    tipToPack.put(id, pack);\n                    all.add(id);\n                }\n            }\n            haveEst += tipToPack.size();\n        }\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n    List<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n    AsyncRevObjectQueue q = walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o = q.next();\n                if (o == null)\n                    break;\n                if (tipToPack.containsKey(o))\n                    o.add(inCachedPack);\n                if (have.contains(o)) {\n                    haveObjs.add(o);\n                    walker.markUninteresting(o);\n                } else if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    walker.markStart(o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting && have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    int typesToPrune = 0;\n    final int maxBases = config.getDeltaSearchWindowSize();\n    Set<RevTree> baseTrees = new HashSet<RevTree>();\n    List<RevCommit> commits = new ArrayList<RevCommit>();\n    RevCommit c;\n    while ((c = walker.next()) != null) {\n        if (c.has(inCachedPack)) {\n            CachedPack pack = tipToPack.get(c);\n            if (includesAllTips(pack, include, walker)) {\n                useCachedPack(walker, keepOnRestart, wantObjs, haveObjs, pack);\n                commits = new ArrayList<RevCommit>();\n                countingMonitor.endTask();\n                countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n                continue;\n            }\n        }\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() <= maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        countingMonitor.update(1);\n    }\n    if (objectsLists[Constants.OBJ_COMMIT] instanceof ArrayList) {\n        ArrayList<ObjectToPack> list = (ArrayList<ObjectToPack>) objectsLists[Constants.OBJ_COMMIT];\n        list.ensureCapacity(list.size() + commits.size());\n    }\n    for (RevCommit cmit : commits) {\n        if (!cmit.has(added)) {\n            cmit.add(added);\n            addObject(cmit, 0);\n        }\n        for (int i = 0; i < cmit.getParentCount(); i++) {\n            RevCommit p = cmit.getParent(i);\n            if (!p.has(added) && !p.has(RevFlag.UNINTERESTING)) {\n                p.add(added);\n                addObject(p, 0);\n            }\n        }\n    }\n    commits = null;\n    for (CachedPack p : cachedPacks) {\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_COMMIT])) {\n            if (baseTrees.size() <= maxBases)\n                baseTrees.add(walker.lookupCommit(d).getTree());\n            objectsMap.get(d).setEdge();\n            typesToPrune |= 1 << Constants.OBJ_COMMIT;\n        }\n    }\n    BaseSearch bases = new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n    RevObject o;\n    while ((o = walker.nextObject()) != null) {\n        if (o.has(RevFlag.UNINTERESTING))\n            continue;\n        int pathHash = walker.getPathHashCode();\n        byte[] pathBuf = walker.getPathBuffer();\n        int pathLen = walker.getPathLength();\n        bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n        addObject(o, pathHash);\n        countingMonitor.update(1);\n    }\n    for (CachedPack p : cachedPacks) {\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TREE])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |= 1 << Constants.OBJ_TREE;\n        }\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_BLOB])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |= 1 << Constants.OBJ_BLOB;\n        }\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TAG])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |= 1 << Constants.OBJ_TAG;\n        }\n    }\n    if (typesToPrune != 0) {\n        pruneObjectList(typesToPrune, Constants.OBJ_COMMIT);\n        pruneObjectList(typesToPrune, Constants.OBJ_TREE);\n        pruneObjectList(typesToPrune, Constants.OBJ_BLOB);\n        pruneObjectList(typesToPrune, Constants.OBJ_TAG);\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    countingMonitor.endTask();\n    stats.timeCounting = System.currentTimeMillis() - countingStart;\n}"
    },
    {
      "commit": "c8c4524b6b36c1d97e715de9e1ff1aa18763a390",
      "startLine": 8,
      "endLine": 34,
      "methodCode": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Collection<? extends ObjectId> want, Collection<? extends ObjectId> have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    final long countingStart = System.currentTimeMillis();\n    countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n    if (have == null)\n        have = Collections.emptySet();\n    stats.interestingObjects = Collections.unmodifiableSet(new HashSet(want));\n    stats.uninterestingObjects = Collections.unmodifiableSet(new HashSet(have));\n    List<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final Map<ObjectId, CachedPack> tipToPack = new HashMap<ObjectId, CachedPack>();\n    final RevFlag inCachedPack = walker.newFlag(\"inCachedPack\");\n    final RevFlag include = walker.newFlag(\"include\");\n    final RevFlagSet keepOnRestart = new RevFlagSet();\n    keepOnRestart.add(inCachedPack);\n    walker.setRetainBody(false);\n    walker.carry(include);\n    int haveEst = have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n        if (useCachedPacks && reuseSupport != null) {\n            for (CachedPack pack : reuseSupport.getCachedPacks()) {\n                for (ObjectId id : pack.getTips()) {\n                    tipToPack.put(id, pack);\n                    all.add(id);\n                }\n            }\n            haveEst += tipToPack.size();\n        }\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n    List<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n    AsyncRevObjectQueue q = walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o = q.next();\n                if (o == null)\n                    break;\n                if (tipToPack.containsKey(o))\n                    o.add(inCachedPack);\n                if (have.contains(o)) {\n                    haveObjs.add(o);\n                    walker.markUninteresting(o);\n                } else if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    walker.markStart(o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting && have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    int typesToPrune = 0;\n    final int maxBases = config.getDeltaSearchWindowSize();\n    Set<RevTree> baseTrees = new HashSet<RevTree>();\n    RevObject o;\n    while ((o = walker.next()) != null) {\n        if (o.has(inCachedPack)) {\n            CachedPack pack = tipToPack.get(o);\n            if (includesAllTips(pack, include, walker)) {\n                useCachedPack(walker, keepOnRestart, wantObjs, haveObjs, pack);\n                countingMonitor.endTask();\n                countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n                continue;\n            }\n        }\n        if (o.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() <= maxBases)\n                baseTrees.add(((RevCommit) o).getTree());\n            continue;\n        }\n        addObject(o, 0);\n        countingMonitor.update(1);\n    }\n    for (CachedPack p : cachedPacks) {\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_COMMIT])) {\n            if (baseTrees.size() <= maxBases)\n                baseTrees.add(walker.lookupCommit(d).getTree());\n            objectsMap.get(d).setEdge();\n            typesToPrune |= 1 << Constants.OBJ_COMMIT;\n        }\n    }\n    BaseSearch bases = new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n    while ((o = walker.nextObject()) != null) {\n        if (o.has(RevFlag.UNINTERESTING))\n            continue;\n        int pathHash = walker.getPathHashCode();\n        byte[] pathBuf = walker.getPathBuffer();\n        int pathLen = walker.getPathLength();\n        bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n        addObject(o, pathHash);\n        countingMonitor.update(1);\n    }\n    for (CachedPack p : cachedPacks) {\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TREE])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |= 1 << Constants.OBJ_TREE;\n        }\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_BLOB])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |= 1 << Constants.OBJ_BLOB;\n        }\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TAG])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |= 1 << Constants.OBJ_TAG;\n        }\n    }\n    if (typesToPrune != 0) {\n        pruneObjectList(typesToPrune, Constants.OBJ_COMMIT);\n        pruneObjectList(typesToPrune, Constants.OBJ_TREE);\n        pruneObjectList(typesToPrune, Constants.OBJ_BLOB);\n        pruneObjectList(typesToPrune, Constants.OBJ_TAG);\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    countingMonitor.endTask();\n    stats.timeCounting = System.currentTimeMillis() - countingStart;\n}"
    },
    {
      "commit": "5664fb3bfb63e4db49dc07d13ace419e810186c2",
      "startLine": 5,
      "endLine": 31,
      "methodCode": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Collection<? extends ObjectId> want, Collection<? extends ObjectId> have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n    if (have == null)\n        have = Collections.emptySet();\n    List<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final Map<ObjectId, CachedPack> tipToPack = new HashMap<ObjectId, CachedPack>();\n    final RevFlag inCachedPack = walker.newFlag(\"inCachedPack\");\n    final RevFlag include = walker.newFlag(\"include\");\n    final RevFlagSet keepOnRestart = new RevFlagSet();\n    keepOnRestart.add(inCachedPack);\n    walker.setRetainBody(false);\n    walker.carry(include);\n    int haveEst = have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n        if (useCachedPacks && reuseSupport != null) {\n            for (CachedPack pack : reuseSupport.getCachedPacks()) {\n                for (ObjectId id : pack.getTips()) {\n                    tipToPack.put(id, pack);\n                    all.add(id);\n                }\n            }\n            haveEst += tipToPack.size();\n        }\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n    List<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n    AsyncRevObjectQueue q = walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o = q.next();\n                if (o == null)\n                    break;\n                if (tipToPack.containsKey(o))\n                    o.add(inCachedPack);\n                if (have.contains(o)) {\n                    haveObjs.add(o);\n                    walker.markUninteresting(o);\n                } else if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    walker.markStart(o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting && have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    int typesToPrune = 0;\n    final int maxBases = config.getDeltaSearchWindowSize();\n    Set<RevTree> baseTrees = new HashSet<RevTree>();\n    RevObject o;\n    while ((o = walker.next()) != null) {\n        if (o.has(inCachedPack)) {\n            CachedPack pack = tipToPack.get(o);\n            if (includesAllTips(pack, include, walker)) {\n                useCachedPack(walker, keepOnRestart, wantObjs, haveObjs, pack);\n                countingMonitor.endTask();\n                countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n                continue;\n            }\n        }\n        if (o.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() <= maxBases)\n                baseTrees.add(((RevCommit) o).getTree());\n            continue;\n        }\n        addObject(o, 0);\n        countingMonitor.update(1);\n    }\n    for (CachedPack p : cachedPacks) {\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_COMMIT])) {\n            if (baseTrees.size() <= maxBases)\n                baseTrees.add(walker.lookupCommit(d).getTree());\n            objectsMap.get(d).setEdge();\n            typesToPrune |= 1 << Constants.OBJ_COMMIT;\n        }\n    }\n    BaseSearch bases = new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n    while ((o = walker.nextObject()) != null) {\n        if (o.has(RevFlag.UNINTERESTING))\n            continue;\n        int pathHash = walker.getPathHashCode();\n        byte[] pathBuf = walker.getPathBuffer();\n        int pathLen = walker.getPathLength();\n        bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n        addObject(o, pathHash);\n        countingMonitor.update(1);\n    }\n    for (CachedPack p : cachedPacks) {\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TREE])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |= 1 << Constants.OBJ_TREE;\n        }\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_BLOB])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |= 1 << Constants.OBJ_BLOB;\n        }\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TAG])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |= 1 << Constants.OBJ_TAG;\n        }\n    }\n    if (typesToPrune != 0) {\n        pruneObjectList(typesToPrune, Constants.OBJ_COMMIT);\n        pruneObjectList(typesToPrune, Constants.OBJ_TREE);\n        pruneObjectList(typesToPrune, Constants.OBJ_BLOB);\n        pruneObjectList(typesToPrune, Constants.OBJ_TAG);\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    countingMonitor.endTask();\n}"
    },
    {
      "commit": "461b012e9565af8174e5b9d2b2c3a582011ce77e",
      "startLine": 5,
      "endLine": 32,
      "methodCode": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final Collection<? extends ObjectId> want, Collection<? extends ObjectId> have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n    if (have == null)\n        have = Collections.emptySet();\n    List<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final Map<ObjectId, CachedPack> tipToPack = new HashMap<ObjectId, CachedPack>();\n    final ObjectWalk walker = new ObjectWalk(reader);\n    final RevFlag inCachedPack = walker.newFlag(\"inCachedPack\");\n    final RevFlag include = walker.newFlag(\"include\");\n    final RevFlagSet keepOnRestart = new RevFlagSet();\n    keepOnRestart.add(inCachedPack);\n    walker.setRetainBody(false);\n    walker.carry(include);\n    int haveEst = have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n        if (useCachedPacks && reuseSupport != null) {\n            for (CachedPack pack : reuseSupport.getCachedPacks()) {\n                for (ObjectId id : pack.getTips()) {\n                    tipToPack.put(id, pack);\n                    all.add(id);\n                }\n            }\n            haveEst += tipToPack.size();\n        }\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n    List<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n    AsyncRevObjectQueue q = walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o = q.next();\n                if (o == null)\n                    break;\n                if (tipToPack.containsKey(o))\n                    o.add(inCachedPack);\n                if (have.contains(o)) {\n                    haveObjs.add(o);\n                    walker.markUninteresting(o);\n                } else if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    walker.markStart(o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting && have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    int typesToPrune = 0;\n    final int maxBases = config.getDeltaSearchWindowSize();\n    Set<RevTree> baseTrees = new HashSet<RevTree>();\n    RevObject o;\n    while ((o = walker.next()) != null) {\n        if (o.has(inCachedPack)) {\n            CachedPack pack = tipToPack.get(o);\n            if (includesAllTips(pack, include, walker)) {\n                useCachedPack(walker, keepOnRestart, wantObjs, haveObjs, pack);\n                countingMonitor.endTask();\n                countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n                continue;\n            }\n        }\n        if (o.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() <= maxBases)\n                baseTrees.add(((RevCommit) o).getTree());\n            continue;\n        }\n        addObject(o, 0);\n        countingMonitor.update(1);\n    }\n    for (CachedPack p : cachedPacks) {\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_COMMIT])) {\n            if (baseTrees.size() <= maxBases)\n                baseTrees.add(walker.lookupCommit(d).getTree());\n            objectsMap.get(d).setEdge();\n            typesToPrune |= 1 << Constants.OBJ_COMMIT;\n        }\n    }\n    BaseSearch bases = new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n    while ((o = walker.nextObject()) != null) {\n        if (o.has(RevFlag.UNINTERESTING))\n            continue;\n        int pathHash = walker.getPathHashCode();\n        byte[] pathBuf = walker.getPathBuffer();\n        int pathLen = walker.getPathLength();\n        bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n        addObject(o, pathHash);\n        countingMonitor.update(1);\n    }\n    for (CachedPack p : cachedPacks) {\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TREE])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |= 1 << Constants.OBJ_TREE;\n        }\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_BLOB])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |= 1 << Constants.OBJ_BLOB;\n        }\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TAG])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |= 1 << Constants.OBJ_TAG;\n        }\n    }\n    if (typesToPrune != 0) {\n        pruneObjectList(typesToPrune, Constants.OBJ_COMMIT);\n        pruneObjectList(typesToPrune, Constants.OBJ_TREE);\n        pruneObjectList(typesToPrune, Constants.OBJ_BLOB);\n        pruneObjectList(typesToPrune, Constants.OBJ_TAG);\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    countingMonitor.endTask();\n}"
    },
    {
      "commit": "13bcf05a9ea2d4943faef2c879aac65d37517eb6",
      "startLine": 5,
      "endLine": 16,
      "methodCode": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final Collection<? extends ObjectId> want, Collection<? extends ObjectId> have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n    if (have == null)\n        have = Collections.emptySet();\n    List<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final ObjectWalk walker = new ObjectWalk(reader);\n    walker.setRetainBody(false);\n    if (have.isEmpty())\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n    else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    AsyncRevObjectQueue q = walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o = q.next();\n                if (o == null)\n                    break;\n                if (have.contains(o))\n                    walker.markUninteresting(o);\n                else\n                    walker.markStart(o);\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting && have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    final int maxBases = config.getDeltaSearchWindowSize();\n    Set<RevTree> baseTrees = new HashSet<RevTree>();\n    RevObject o;\n    while ((o = walker.next()) != null) {\n        if (o.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() <= maxBases)\n                baseTrees.add(((RevCommit) o).getTree());\n            continue;\n        }\n        addObject(o, 0);\n        countingMonitor.update(1);\n    }\n    BaseSearch bases = new BaseSearch(countingMonitor, baseTrees, edgeObjects, reader);\n    while ((o = walker.nextObject()) != null) {\n        if (o.has(RevFlag.UNINTERESTING))\n            continue;\n        int pathHash = walker.getPathHashCode();\n        byte[] pathBuf = walker.getPathBuffer();\n        int pathLen = walker.getPathLength();\n        bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n        addObject(o, pathHash);\n        countingMonitor.update(1);\n    }\n    countingMonitor.endTask();\n}"
    },
    {
      "commit": "2fbcba41e365752681f635c706d577e605d3336a",
      "startLine": 5,
      "endLine": 16,
      "methodCode": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final Collection<? extends ObjectId> want, Collection<? extends ObjectId> have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n    if (have == null)\n        have = Collections.emptySet();\n    List<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final ObjectWalk walker = new ObjectWalk(reader);\n    walker.setRetainBody(false);\n    if (have.isEmpty())\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n    else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    AsyncRevObjectQueue q = walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o = q.next();\n                if (o == null)\n                    break;\n                if (have.contains(o))\n                    walker.markUninteresting(o);\n                else\n                    walker.markStart(o);\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting && have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    RevObject o;\n    while ((o = walker.next()) != null) {\n        addObject(o, 0);\n        countingMonitor.update(1);\n    }\n    while ((o = walker.nextObject()) != null) {\n        addObject(o, walker.getPathHashCode());\n        countingMonitor.update(1);\n    }\n    countingMonitor.endTask();\n}"
    }
  ]
}