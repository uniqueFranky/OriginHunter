{
  "statementVersions": [
    {
      "commit": "9e063ffa2577f06d98a9e912bb16d20424df8d6d",
      "startLine": 21,
      "endLine": 33,
      "methodCode": "public RevisionInfoConfigurationResult configure(MetadataImplementor metadata, ReflectionManager reflectionManager) {\n    boolean revisionEntityFound = false;\n    RevisionInfoGenerator revisionInfoGenerator = null;\n    Class<?> revisionInfoClass = null;\n    for (PersistentClass persistentClass : metadata.getEntityBindings()) {\n        if (persistentClass.getClassName() != null) {\n            XClass clazz;\n            try {\n                clazz = reflectionManager.classForName(persistentClass.getClassName());\n            } catch (ClassLoadingException e) {\n                throw new MappingException(e);\n            }\n            final RevisionEntity revisionEntity = clazz.getAnnotation(RevisionEntity.class);\n            if (revisionEntity != null) {\n                if (revisionEntityFound) {\n                    throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                }\n                if (clazz.getAnnotation(Audited.class) != null) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                }\n                revisionEntityFound = true;\n                final MutableBoolean revisionNumberFound = new MutableBoolean();\n                final MutableBoolean revisionTimestampFound = new MutableBoolean();\n                final MutableBoolean modifiedEntityNamesFound = new MutableBoolean();\n                searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n                if (!revisionNumberFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n                }\n                if (!revisionTimestampFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n                }\n                revisionInfoEntityName = persistentClass.getEntityName();\n                revisionInfoClass = persistentClass.getMappedClass();\n                final Class<? extends RevisionListener> revisionListenerClass = getRevisionListenerClass(revisionEntity.value());\n                revisionInfoTimestampType = persistentClass.getProperty(revisionInfoTimestampData.getName()).getType();\n                if (globalCfg.isTrackEntitiesChangedInRevision() || (globalCfg.isUseRevisionEntityWithNativeId() && DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || (!globalCfg.isUseRevisionEntityWithNativeId() && SequenceIdTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || modifiedEntityNamesFound.isSet()) {\n                    revisionInfoGenerator = new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData, metadata.getMetadataBuildingOptions().getServiceRegistry());\n                    globalCfg.setTrackEntitiesChangedInRevision(true);\n                } else {\n                    revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), metadata.getMetadataBuildingOptions().getServiceRegistry());\n                }\n            }\n        }\n    }\n    Document revisionInfoXmlMapping = null;\n    final Class<? extends RevisionListener> revisionListenerClass = getRevisionListenerClass(RevisionListener.class);\n    if (revisionInfoGenerator == null) {\n        if (globalCfg.isTrackEntitiesChangedInRevision()) {\n            revisionInfoClass = globalCfg.isUseRevisionEntityWithNativeId() ? DefaultTrackingModifiedEntitiesRevisionEntity.class : SequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n            revisionInfoEntityName = revisionInfoClass.getName();\n            revisionInfoGenerator = new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData, metadata.getMetadataBuildingOptions().getServiceRegistry());\n        } else {\n            revisionInfoClass = globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class : SequenceIdRevisionEntity.class;\n            revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), metadata.getMetadataBuildingOptions().getServiceRegistry());\n        }\n        revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData, metadata.getMetadataBuildingOptions().getServiceRegistry()), globalCfg.isTrackEntitiesChangedInRevision() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData, metadata.getMetadataBuildingOptions().getServiceRegistry()) : null, revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n}"
    },
    {
      "commit": "410a785dfe40ae030bec31c4c06a5a7998f1feeb",
      "startLine": 21,
      "endLine": 33,
      "methodCode": "public RevisionInfoConfigurationResult configure(MetadataImplementor metadata, ReflectionManager reflectionManager) {\n    boolean revisionEntityFound = false;\n    RevisionInfoGenerator revisionInfoGenerator = null;\n    Class<?> revisionInfoClass = null;\n    for (PersistentClass persistentClass : metadata.getEntityBindings()) {\n        if (persistentClass.getClassName() != null) {\n            XClass clazz;\n            try {\n                clazz = reflectionManager.classForName(persistentClass.getClassName());\n            } catch (ClassLoadingException e) {\n                throw new MappingException(e);\n            }\n            final RevisionEntity revisionEntity = clazz.getAnnotation(RevisionEntity.class);\n            if (revisionEntity != null) {\n                if (revisionEntityFound) {\n                    throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                }\n                if (clazz.getAnnotation(Audited.class) != null) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                }\n                revisionEntityFound = true;\n                final MutableBoolean revisionNumberFound = new MutableBoolean();\n                final MutableBoolean revisionTimestampFound = new MutableBoolean();\n                final MutableBoolean modifiedEntityNamesFound = new MutableBoolean();\n                searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n                if (!revisionNumberFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n                }\n                if (!revisionTimestampFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n                }\n                revisionInfoEntityName = persistentClass.getEntityName();\n                revisionInfoClass = persistentClass.getMappedClass();\n                final Class<? extends RevisionListener> revisionListenerClass = getRevisionListenerClass(revisionEntity.value());\n                revisionInfoTimestampType = persistentClass.getProperty(revisionInfoTimestampData.getName()).getType();\n                if (globalCfg.isTrackEntitiesChangedInRevision() || (globalCfg.isUseRevisionEntityWithNativeId() && DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || (!globalCfg.isUseRevisionEntityWithNativeId() && SequenceIdTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || modifiedEntityNamesFound.isSet()) {\n                    revisionInfoGenerator = new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n                    globalCfg.setTrackEntitiesChangedInRevision(true);\n                } else {\n                    revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n                }\n            }\n        }\n    }\n    Document revisionInfoXmlMapping = null;\n    final Class<? extends RevisionListener> revisionListenerClass = getRevisionListenerClass(RevisionListener.class);\n    if (revisionInfoGenerator == null) {\n        if (globalCfg.isTrackEntitiesChangedInRevision()) {\n            revisionInfoClass = globalCfg.isUseRevisionEntityWithNativeId() ? DefaultTrackingModifiedEntitiesRevisionEntity.class : SequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n            revisionInfoEntityName = revisionInfoClass.getName();\n            revisionInfoGenerator = new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n        } else {\n            revisionInfoClass = globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class : SequenceIdRevisionEntity.class;\n            revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n        }\n        revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), globalCfg.isTrackEntitiesChangedInRevision() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData) : null, revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n}"
    },
    {
      "commit": "b70bc0080e8e206f83debf8f456fe323caccc01b",
      "startLine": 21,
      "endLine": 33,
      "methodCode": "public RevisionInfoConfigurationResult configure(MetadataImplementor metadata, ReflectionManager reflectionManager) {\n    boolean revisionEntityFound = false;\n    RevisionInfoGenerator revisionInfoGenerator = null;\n    Class<?> revisionInfoClass = null;\n    for (PersistentClass persistentClass : metadata.getEntityBindings()) {\n        if (persistentClass.getClassName() != null) {\n            XClass clazz;\n            try {\n                clazz = reflectionManager.classForName(persistentClass.getClassName(), this.getClass());\n            } catch (ClassNotFoundException e) {\n                throw new MappingException(e);\n            }\n            final RevisionEntity revisionEntity = clazz.getAnnotation(RevisionEntity.class);\n            if (revisionEntity != null) {\n                if (revisionEntityFound) {\n                    throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                }\n                if (clazz.getAnnotation(Audited.class) != null) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                }\n                revisionEntityFound = true;\n                final MutableBoolean revisionNumberFound = new MutableBoolean();\n                final MutableBoolean revisionTimestampFound = new MutableBoolean();\n                final MutableBoolean modifiedEntityNamesFound = new MutableBoolean();\n                searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n                if (!revisionNumberFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n                }\n                if (!revisionTimestampFound.isSet()) {\n                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n                }\n                revisionInfoEntityName = persistentClass.getEntityName();\n                revisionInfoClass = persistentClass.getMappedClass();\n                final Class<? extends RevisionListener> revisionListenerClass = getRevisionListenerClass(revisionEntity.value());\n                revisionInfoTimestampType = persistentClass.getProperty(revisionInfoTimestampData.getName()).getType();\n                if (globalCfg.isTrackEntitiesChangedInRevision() || (globalCfg.isUseRevisionEntityWithNativeId() && DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || (!globalCfg.isUseRevisionEntityWithNativeId() && SequenceIdTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || modifiedEntityNamesFound.isSet()) {\n                    revisionInfoGenerator = new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n                    globalCfg.setTrackEntitiesChangedInRevision(true);\n                } else {\n                    revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n                }\n            }\n        }\n    }\n    Document revisionInfoXmlMapping = null;\n    final Class<? extends RevisionListener> revisionListenerClass = getRevisionListenerClass(RevisionListener.class);\n    if (revisionInfoGenerator == null) {\n        if (globalCfg.isTrackEntitiesChangedInRevision()) {\n            revisionInfoClass = globalCfg.isUseRevisionEntityWithNativeId() ? DefaultTrackingModifiedEntitiesRevisionEntity.class : SequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n            revisionInfoEntityName = revisionInfoClass.getName();\n            revisionInfoGenerator = new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n        } else {\n            revisionInfoClass = globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class : SequenceIdRevisionEntity.class;\n            revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n        }\n        revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), globalCfg.isTrackEntitiesChangedInRevision() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData) : null, revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n}"
    },
    {
      "commit": "63a0f03c5ae773f96c92c02fba9d13133d02485b",
      "startLine": 20,
      "endLine": 32,
      "methodCode": "public RevisionInfoConfigurationResult configure(MetadataImplementor metadata, ReflectionManager reflectionManager) {\n    boolean revisionEntityFound = false;\n    RevisionInfoGenerator revisionInfoGenerator = null;\n    Class<?> revisionInfoClass = null;\n    for (PersistentClass persistentClass : metadata.getEntityBindings()) {\n        XClass clazz;\n        try {\n            clazz = reflectionManager.classForName(persistentClass.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        final RevisionEntity revisionEntity = clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity != null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Audited.class) != null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n            }\n            revisionEntityFound = true;\n            final MutableBoolean revisionNumberFound = new MutableBoolean();\n            final MutableBoolean revisionTimestampFound = new MutableBoolean();\n            final MutableBoolean modifiedEntityNamesFound = new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName = persistentClass.getEntityName();\n            revisionInfoClass = persistentClass.getMappedClass();\n            final Class<? extends RevisionListener> revisionListenerClass = getRevisionListenerClass(revisionEntity.value());\n            revisionInfoTimestampType = persistentClass.getProperty(revisionInfoTimestampData.getName()).getType();\n            if (globalCfg.isTrackEntitiesChangedInRevision() || (globalCfg.isUseRevisionEntityWithNativeId() && DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || (!globalCfg.isUseRevisionEntityWithNativeId() && SequenceIdTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || modifiedEntityNamesFound.isSet()) {\n                revisionInfoGenerator = new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n                globalCfg.setTrackEntitiesChangedInRevision(true);\n            } else {\n                revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n            }\n        }\n    }\n    Document revisionInfoXmlMapping = null;\n    final Class<? extends RevisionListener> revisionListenerClass = getRevisionListenerClass(RevisionListener.class);\n    if (revisionInfoGenerator == null) {\n        if (globalCfg.isTrackEntitiesChangedInRevision()) {\n            revisionInfoClass = globalCfg.isUseRevisionEntityWithNativeId() ? DefaultTrackingModifiedEntitiesRevisionEntity.class : SequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n            revisionInfoEntityName = revisionInfoClass.getName();\n            revisionInfoGenerator = new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n        } else {\n            revisionInfoClass = globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class : SequenceIdRevisionEntity.class;\n            revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n        }\n        revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), globalCfg.isTrackEntitiesChangedInRevision() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData) : null, revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n}"
    },
    {
      "commit": "364a47f2c746a5eeb1642102580a9daa8bc27fc9",
      "startLine": 22,
      "endLine": 34,
      "methodCode": "public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n    boolean revisionEntityFound = false;\n    RevisionInfoGenerator revisionInfoGenerator = null;\n    Class<?> revisionInfoClass = null;\n    final Iterator<PersistentClass> classes = cfg.getClassMappings();\n    while (classes.hasNext()) {\n        PersistentClass pc = classes.next();\n        XClass clazz;\n        try {\n            clazz = reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        final RevisionEntity revisionEntity = clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity != null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Audited.class) != null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n            }\n            revisionEntityFound = true;\n            final MutableBoolean revisionNumberFound = new MutableBoolean();\n            final MutableBoolean revisionTimestampFound = new MutableBoolean();\n            final MutableBoolean modifiedEntityNamesFound = new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName = pc.getEntityName();\n            revisionInfoClass = pc.getMappedClass();\n            final Class<? extends RevisionListener> revisionListenerClass = getRevisionListenerClass(revisionEntity.value());\n            revisionInfoTimestampType = pc.getProperty(revisionInfoTimestampData.getName()).getType();\n            if (globalCfg.isTrackEntitiesChangedInRevision() || (globalCfg.isUseRevisionEntityWithNativeId() && DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || (!globalCfg.isUseRevisionEntityWithNativeId() && SequenceIdTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || modifiedEntityNamesFound.isSet()) {\n                revisionInfoGenerator = new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n                globalCfg.setTrackEntitiesChangedInRevision(true);\n            } else {\n                revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n            }\n        }\n    }\n    Document revisionInfoXmlMapping = null;\n    final Class<? extends RevisionListener> revisionListenerClass = getRevisionListenerClass(RevisionListener.class);\n    if (revisionInfoGenerator == null) {\n        if (globalCfg.isTrackEntitiesChangedInRevision()) {\n            revisionInfoClass = globalCfg.isUseRevisionEntityWithNativeId() ? DefaultTrackingModifiedEntitiesRevisionEntity.class : SequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n            revisionInfoEntityName = revisionInfoClass.getName();\n            revisionInfoGenerator = new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n        } else {\n            revisionInfoClass = globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class : SequenceIdRevisionEntity.class;\n            revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n        }\n        revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), globalCfg.isTrackEntitiesChangedInRevision() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData) : null, revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n}"
    },
    {
      "commit": "5cc051e1dfeb5664d8d1eb9a289097d7f9bfb0e2",
      "startLine": 22,
      "endLine": 34,
      "methodCode": "public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n    Iterator<PersistentClass> classes = cfg.getClassMappings();\n    boolean revisionEntityFound = false;\n    RevisionInfoGenerator revisionInfoGenerator = null;\n    Class<?> revisionInfoClass = null;\n    while (classes.hasNext()) {\n        PersistentClass pc = classes.next();\n        XClass clazz;\n        try {\n            clazz = reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        RevisionEntity revisionEntity = clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity != null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Audited.class) != null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n            }\n            revisionEntityFound = true;\n            MutableBoolean revisionNumberFound = new MutableBoolean();\n            MutableBoolean revisionTimestampFound = new MutableBoolean();\n            MutableBoolean modifiedEntityNamesFound = new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName = pc.getEntityName();\n            revisionInfoClass = pc.getMappedClass();\n            Class<? extends RevisionListener> revisionListenerClass = getRevisionListenerClass(revisionEntity.value());\n            revisionInfoTimestampType = pc.getProperty(revisionInfoTimestampData.getName()).getType();\n            if (globalCfg.isTrackEntitiesChangedInRevision() || (globalCfg.isUseRevisionEntityWithNativeId() && DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || (!globalCfg.isUseRevisionEntityWithNativeId() && SequenceIdTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || modifiedEntityNamesFound.isSet()) {\n                revisionInfoGenerator = new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n                globalCfg.setTrackEntitiesChangedInRevision(true);\n            } else {\n                revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n            }\n        }\n    }\n    Document revisionInfoXmlMapping = null;\n    Class<? extends RevisionListener> revisionListenerClass = getRevisionListenerClass(RevisionListener.class);\n    if (revisionInfoGenerator == null) {\n        if (globalCfg.isTrackEntitiesChangedInRevision()) {\n            revisionInfoClass = globalCfg.isUseRevisionEntityWithNativeId() ? DefaultTrackingModifiedEntitiesRevisionEntity.class : SequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n            revisionInfoEntityName = revisionInfoClass.getName();\n            revisionInfoGenerator = new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n        } else {\n            revisionInfoClass = globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class : SequenceIdRevisionEntity.class;\n            revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n        }\n        revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), globalCfg.isTrackEntitiesChangedInRevision() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData) : null, revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n}"
    },
    {
      "commit": "6c6df695350f917fe707b4f830e29c8c52c3f5d0",
      "startLine": 22,
      "endLine": 34,
      "methodCode": "public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n    Iterator<PersistentClass> classes = cfg.getClassMappings();\n    boolean revisionEntityFound = false;\n    RevisionInfoGenerator revisionInfoGenerator = null;\n    Class<?> revisionInfoClass = null;\n    while (classes.hasNext()) {\n        PersistentClass pc = classes.next();\n        XClass clazz;\n        try {\n            clazz = reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        RevisionEntity revisionEntity = clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity != null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Audited.class) != null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n            }\n            revisionEntityFound = true;\n            MutableBoolean revisionNumberFound = new MutableBoolean();\n            MutableBoolean revisionTimestampFound = new MutableBoolean();\n            MutableBoolean modifiedEntityNamesFound = new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName = pc.getEntityName();\n            revisionInfoClass = pc.getMappedClass();\n            Class<? extends RevisionListener> revisionListenerClass = getRevisionListenerClass(revisionEntity.value());\n            revisionInfoTimestampType = pc.getProperty(revisionInfoTimestampData.getName()).getType();\n            if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() || (globalCfg.isUseRevisionEntityWithNativeId() && DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || (!globalCfg.isUseRevisionEntityWithNativeId() && SequenceIdTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || modifiedEntityNamesFound.isSet()) {\n                revisionInfoGenerator = new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n                globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n            } else {\n                revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n            }\n        }\n    }\n    Document revisionInfoXmlMapping = null;\n    Class<? extends RevisionListener> revisionListenerClass = getRevisionListenerClass(RevisionListener.class);\n    if (revisionInfoGenerator == null) {\n        if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n            revisionInfoClass = globalCfg.isUseRevisionEntityWithNativeId() ? DefaultTrackingModifiedEntitiesRevisionEntity.class : SequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n            revisionInfoEntityName = revisionInfoClass.getName();\n            revisionInfoGenerator = new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n        } else {\n            revisionInfoClass = globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class : SequenceIdRevisionEntity.class;\n            revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n        }\n        revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), globalCfg.isTrackEntitiesChangedInRevisionEnabled() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData) : null, revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n}"
    },
    {
      "commit": "95ec3457af961c4116015509180dcca04967604f",
      "startLine": 22,
      "endLine": 34,
      "methodCode": "public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n    Iterator<PersistentClass> classes = (Iterator<PersistentClass>) cfg.getClassMappings();\n    boolean revisionEntityFound = false;\n    RevisionInfoGenerator revisionInfoGenerator = null;\n    Class<?> revisionInfoClass = null;\n    while (classes.hasNext()) {\n        PersistentClass pc = classes.next();\n        XClass clazz;\n        try {\n            clazz = reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        RevisionEntity revisionEntity = clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity != null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Audited.class) != null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n            }\n            revisionEntityFound = true;\n            MutableBoolean revisionNumberFound = new MutableBoolean();\n            MutableBoolean revisionTimestampFound = new MutableBoolean();\n            MutableBoolean modifiedEntityNamesFound = new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName = pc.getEntityName();\n            revisionInfoClass = pc.getMappedClass();\n            Class<? extends RevisionListener> revisionListenerClass = getRevisionListenerClass(revisionEntity.value());\n            revisionInfoTimestampType = pc.getProperty(revisionInfoTimestampData.getName()).getType();\n            if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() || (globalCfg.isUseRevisionEntityWithNativeId() && DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || (!globalCfg.isUseRevisionEntityWithNativeId() && SequenceIdTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || modifiedEntityNamesFound.isSet()) {\n                revisionInfoGenerator = new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n                globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n            } else {\n                revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n            }\n        }\n    }\n    Document revisionInfoXmlMapping = null;\n    Class<? extends RevisionListener> revisionListenerClass = getRevisionListenerClass(RevisionListener.class);\n    if (revisionInfoGenerator == null) {\n        if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n            revisionInfoClass = globalCfg.isUseRevisionEntityWithNativeId() ? DefaultTrackingModifiedEntitiesRevisionEntity.class : SequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n            revisionInfoEntityName = revisionInfoClass.getName();\n            revisionInfoGenerator = new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n        } else {\n            revisionInfoClass = globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class : SequenceIdRevisionEntity.class;\n            revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n        }\n        revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), globalCfg.isTrackEntitiesChangedInRevisionEnabled() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData) : null, revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n}"
    },
    {
      "commit": "c4822556c19a6ea2d7be93b505548e834c83d955",
      "startLine": 22,
      "endLine": 34,
      "methodCode": "public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n    Iterator<PersistentClass> classes = (Iterator<PersistentClass>) cfg.getClassMappings();\n    boolean revisionEntityFound = false;\n    RevisionInfoGenerator revisionInfoGenerator = null;\n    Class<?> revisionInfoClass = null;\n    while (classes.hasNext()) {\n        PersistentClass pc = classes.next();\n        XClass clazz;\n        try {\n            clazz = reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        RevisionEntity revisionEntity = clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity != null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Audited.class) != null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n            }\n            revisionEntityFound = true;\n            MutableBoolean revisionNumberFound = new MutableBoolean();\n            MutableBoolean revisionTimestampFound = new MutableBoolean();\n            MutableBoolean modifiedEntityNamesFound = new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName = pc.getEntityName();\n            revisionInfoClass = pc.getMappedClass();\n            Class<? extends RevisionListener> revisionListenerClass = getRevisionListenerClass(revisionEntity.value());\n            revisionInfoTimestampType = pc.getProperty(revisionInfoTimestampData.getName()).getType();\n            if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() || (!globalCfg.isUseEnhancedRevisionEntity() && DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || (globalCfg.isUseEnhancedRevisionEntity() && org.hibernate.envers.enhanced.DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass)) || modifiedEntityNamesFound.isSet()) {\n                revisionInfoGenerator = new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n                globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n            } else {\n                revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n            }\n        }\n    }\n    Document revisionInfoXmlMapping = null;\n    Class<? extends RevisionListener> revisionListenerClass = getRevisionListenerClass(RevisionListener.class);\n    if (revisionInfoGenerator == null) {\n        if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n            revisionInfoClass = globalCfg.isUseEnhancedRevisionEntity() ? org.hibernate.envers.enhanced.DefaultTrackingModifiedEntitiesRevisionEntity.class : DefaultTrackingModifiedEntitiesRevisionEntity.class;\n            revisionInfoEntityName = revisionInfoClass.getName();\n            revisionInfoGenerator = new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n        } else {\n            revisionInfoClass = globalCfg.isUseEnhancedRevisionEntity() ? org.hibernate.envers.enhanced.DefaultRevisionEntity.class : DefaultRevisionEntity.class;\n            revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n        }\n        revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), globalCfg.isTrackEntitiesChangedInRevisionEnabled() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData) : null, revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n}"
    },
    {
      "commit": "45f3ced6daf96f1a697f350e134512562b48d3fd",
      "startLine": 22,
      "endLine": 34,
      "methodCode": "public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n    Iterator<PersistentClass> classes = (Iterator<PersistentClass>) cfg.getClassMappings();\n    boolean revisionEntityFound = false;\n    RevisionInfoGenerator revisionInfoGenerator = null;\n    Class<?> revisionInfoClass = null;\n    while (classes.hasNext()) {\n        PersistentClass pc = classes.next();\n        XClass clazz;\n        try {\n            clazz = reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        RevisionEntity revisionEntity = clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity != null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Audited.class) != null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n            }\n            revisionEntityFound = true;\n            MutableBoolean revisionNumberFound = new MutableBoolean();\n            MutableBoolean revisionTimestampFound = new MutableBoolean();\n            MutableBoolean modifiedEntityNamesFound = new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName = pc.getEntityName();\n            revisionInfoClass = pc.getMappedClass();\n            Class<? extends RevisionListener> revisionListenerClass = getRevisionListenerClass(revisionEntity.value());\n            revisionInfoTimestampType = pc.getProperty(revisionInfoTimestampData.getName()).getType();\n            if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() || DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass) || modifiedEntityNamesFound.isSet()) {\n                revisionInfoGenerator = new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n                globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n            } else {\n                revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n            }\n        }\n    }\n    Document revisionInfoXmlMapping = null;\n    Class<? extends RevisionListener> revisionListenerClass = getRevisionListenerClass(RevisionListener.class);\n    if (revisionInfoGenerator == null) {\n        if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n            revisionInfoClass = DefaultTrackingModifiedEntitiesRevisionEntity.class;\n            revisionInfoEntityName = DefaultTrackingModifiedEntitiesRevisionEntity.class.getName();\n            revisionInfoGenerator = new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n        } else {\n            revisionInfoClass = DefaultRevisionEntity.class;\n            revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n        }\n        revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), globalCfg.isTrackEntitiesChangedInRevisionEnabled() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData) : null, revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n}"
    },
    {
      "commit": "13c9fd4f9d177fb7d022c72d674f1a23b909c443",
      "startLine": 22,
      "endLine": 34,
      "methodCode": "public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n    Iterator<PersistentClass> classes = (Iterator<PersistentClass>) cfg.getClassMappings();\n    boolean revisionEntityFound = false;\n    RevisionInfoGenerator revisionInfoGenerator = null;\n    Class<?> revisionInfoClass = null;\n    while (classes.hasNext()) {\n        PersistentClass pc = classes.next();\n        XClass clazz;\n        try {\n            clazz = reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        RevisionEntity revisionEntity = clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity != null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Audited.class) != null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n            }\n            revisionEntityFound = true;\n            MutableBoolean revisionNumberFound = new MutableBoolean();\n            MutableBoolean revisionTimestampFound = new MutableBoolean();\n            MutableBoolean modifiedEntityNamesFound = new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName = pc.getEntityName();\n            revisionInfoClass = pc.getMappedClass();\n            revisionInfoTimestampType = pc.getProperty(revisionInfoTimestampData.getName()).getType();\n            if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() || DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass) || modifiedEntityNamesFound.isSet()) {\n                revisionInfoGenerator = new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n                globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n            } else {\n                revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n            }\n        }\n    }\n    Document revisionInfoXmlMapping = null;\n    if (revisionInfoGenerator == null) {\n        if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n            revisionInfoClass = DefaultTrackingModifiedEntitiesRevisionEntity.class;\n            revisionInfoEntityName = DefaultTrackingModifiedEntitiesRevisionEntity.class.getName();\n            revisionInfoGenerator = new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n        } else {\n            revisionInfoClass = DefaultRevisionEntity.class;\n            revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n        }\n        revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), globalCfg.isTrackEntitiesChangedInRevisionEnabled() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData) : null, revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n}"
    },
    {
      "commit": "403b15cae8d19f83c35c9490826d24b0bf5c2fa0",
      "startLine": 22,
      "endLine": 34,
      "methodCode": "public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n    Iterator<PersistentClass> classes = (Iterator<PersistentClass>) cfg.getClassMappings();\n    boolean revisionEntityFound = false;\n    RevisionInfoGenerator revisionInfoGenerator = null;\n    Class<?> revisionInfoClass = null;\n    while (classes.hasNext()) {\n        PersistentClass pc = classes.next();\n        XClass clazz;\n        try {\n            clazz = reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        RevisionEntity revisionEntity = clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity != null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Audited.class) != null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n            }\n            revisionEntityFound = true;\n            MutableBoolean revisionNumberFound = new MutableBoolean();\n            MutableBoolean revisionTimestampFound = new MutableBoolean();\n            MutableBoolean modifiedEntityTypesFound = new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityTypesFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName = pc.getEntityName();\n            revisionInfoClass = pc.getMappedClass();\n            revisionInfoTimestampType = pc.getProperty(revisionInfoTimestampData.getName()).getType();\n            if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() || DefaultTrackingModifiedTypesRevisionEntity.class.isAssignableFrom(revisionInfoClass) || modifiedEntityTypesFound.isSet()) {\n                revisionInfoGenerator = new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityTypesData);\n                globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n            } else {\n                revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n            }\n        }\n    }\n    Document revisionInfoXmlMapping = null;\n    if (revisionInfoGenerator == null) {\n        if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n            revisionInfoClass = DefaultTrackingModifiedTypesRevisionEntity.class;\n            revisionInfoEntityName = DefaultTrackingModifiedTypesRevisionEntity.class.getName();\n            revisionInfoGenerator = new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityTypesData);\n        } else {\n            revisionInfoClass = DefaultRevisionEntity.class;\n            revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n        }\n        revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), globalCfg.isTrackEntitiesChangedInRevisionEnabled() ? new ModifiedEntityTypesReader(revisionInfoClass, modifiedEntityTypesData) : null, revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n}"
    },
    {
      "commit": "1878b238503f3b52a6e7b31f849d7253206c7465",
      "startLine": 22,
      "endLine": 34,
      "methodCode": "public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n    Iterator<PersistentClass> classes = (Iterator<PersistentClass>) cfg.getClassMappings();\n    boolean revisionEntityFound = false;\n    RevisionInfoGenerator revisionInfoGenerator = null;\n    Class<?> revisionInfoClass = null;\n    while (classes.hasNext()) {\n        PersistentClass pc = classes.next();\n        XClass clazz;\n        try {\n            clazz = reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        RevisionEntity revisionEntity = clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity != null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Audited.class) != null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n            }\n            revisionEntityFound = true;\n            MutableBoolean revisionNumberFound = new MutableBoolean();\n            MutableBoolean revisionTimestampFound = new MutableBoolean();\n            MutableBoolean modifiedEntityTypesFound = new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityTypesFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName = pc.getEntityName();\n            revisionInfoClass = pc.getMappedClass();\n            revisionInfoTimestampType = pc.getProperty(revisionInfoTimestampData.getName()).getType();\n            if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() || DefaultTrackingModifiedTypesRevisionEntity.class.isAssignableFrom(revisionInfoClass) || modifiedEntityTypesFound.isSet()) {\n                revisionInfoGenerator = new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityTypesData);\n                globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n            } else {\n                revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n            }\n        }\n    }\n    Document revisionInfoXmlMapping = null;\n    if (revisionInfoGenerator == null) {\n        if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n            revisionInfoClass = DefaultTrackingModifiedTypesRevisionEntity.class;\n            revisionInfoEntityName = DefaultTrackingModifiedTypesRevisionEntity.class.getName();\n            revisionInfoGenerator = new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityTypesData);\n        } else {\n            revisionInfoClass = DefaultRevisionEntity.class;\n            revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n        }\n        revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n}"
    },
    {
      "commit": "dd55a99b00c447e53fe97bdbc423f3e6d7d59557",
      "startLine": 22,
      "endLine": 34,
      "methodCode": "public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n    Iterator<PersistentClass> classes = (Iterator<PersistentClass>) cfg.getClassMappings();\n    boolean revisionEntityFound = false;\n    RevisionInfoGenerator revisionInfoGenerator = null;\n    Class<?> revisionInfoClass = null;\n    while (classes.hasNext()) {\n        PersistentClass pc = classes.next();\n        XClass clazz;\n        try {\n            clazz = reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        RevisionEntity revisionEntity = clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity != null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Audited.class) != null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n            }\n            revisionEntityFound = true;\n            MutableBoolean revisionNumberFound = new MutableBoolean();\n            MutableBoolean revisionTimestampFound = new MutableBoolean();\n            MutableBoolean modifiedEntityNamesFound = new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName = pc.getEntityName();\n            revisionInfoClass = pc.getMappedClass();\n            revisionInfoTimestampType = pc.getProperty(revisionInfoTimestampData.getName()).getType();\n            if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() || DefaultTrackingModifiedTypesRevisionEntity.class.isAssignableFrom(revisionInfoClass) || modifiedEntityNamesFound.isSet()) {\n                revisionInfoGenerator = new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n                globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n            } else {\n                revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n            }\n        }\n    }\n    Document revisionInfoXmlMapping = null;\n    if (revisionInfoGenerator == null) {\n        if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n            revisionInfoClass = DefaultTrackingModifiedTypesRevisionEntity.class;\n            revisionInfoEntityName = DefaultTrackingModifiedTypesRevisionEntity.class.getName();\n            revisionInfoGenerator = new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n        } else {\n            revisionInfoClass = DefaultRevisionEntity.class;\n            revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n        }\n        revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n}"
    },
    {
      "commit": "b36b095c3ce32d2981f5780463bbea8d48105f5a",
      "startLine": 22,
      "endLine": 34,
      "methodCode": "public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n    Iterator<PersistentClass> classes = (Iterator<PersistentClass>) cfg.getClassMappings();\n    boolean revisionEntityFound = false;\n    RevisionInfoGenerator revisionInfoGenerator = null;\n    Class<?> revisionInfoClass = null;\n    while (classes.hasNext()) {\n        PersistentClass pc = classes.next();\n        XClass clazz;\n        try {\n            clazz = reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        RevisionEntity revisionEntity = clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity != null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Audited.class) != null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n            }\n            revisionEntityFound = true;\n            MutableBoolean revisionNumberFound = new MutableBoolean();\n            MutableBoolean revisionTimestampFound = new MutableBoolean();\n            MutableBoolean modifiedEntityNamesFound = new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName = pc.getEntityName();\n            revisionInfoClass = pc.getMappedClass();\n            revisionInfoTimestampType = pc.getProperty(revisionInfoTimestampData.getName()).getType();\n            if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() || DefaultTrackingModifiedTypesRevisionEntity.class.isAssignableFrom(revisionInfoClass) || modifiedEntityNamesFound.isSet()) {\n                revisionInfoGenerator = new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n                globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n            } else {\n                revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n            }\n        }\n    }\n    Document revisionInfoXmlMapping = null;\n    if (revisionInfoGenerator == null) {\n        if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n            revisionInfoClass = DefaultTrackingModifiedTypesRevisionEntity.class;\n            revisionInfoEntityName = DefaultTrackingModifiedTypesRevisionEntity.class.getName();\n            revisionInfoGenerator = new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n        } else {\n            revisionInfoClass = DefaultRevisionEntity.class;\n            revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n        }\n        revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate(), globalCfg.isTrackEntitiesChangedInRevisionEnabled() ? modifiedEntityNamesData.getName() : null), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n}"
    },
    {
      "commit": "53699cecac7477d64ac3dff6c3a24d5658bfc789",
      "startLine": 22,
      "endLine": 34,
      "methodCode": "public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n    Iterator<PersistentClass> classes = (Iterator<PersistentClass>) cfg.getClassMappings();\n    boolean revisionEntityFound = false;\n    RevisionInfoGenerator revisionInfoGenerator = null;\n    Class<?> revisionInfoClass = null;\n    while (classes.hasNext()) {\n        PersistentClass pc = classes.next();\n        XClass clazz;\n        try {\n            clazz = reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        RevisionEntity revisionEntity = clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity != null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Audited.class) != null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n            }\n            revisionEntityFound = true;\n            MutableBoolean revisionNumberFound = new MutableBoolean();\n            MutableBoolean revisionTimestampFound = new MutableBoolean();\n            MutableBoolean modifiedEntityNamesFound = new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName = pc.getEntityName();\n            revisionInfoClass = pc.getMappedClass();\n            revisionInfoTimestampType = pc.getProperty(revisionInfoTimestampData.getName()).getType();\n            if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() || DefaultTrackingModifiedTypesRevisionEntity.class.isAssignableFrom(revisionInfoClass) || modifiedEntityNamesFound.isSet()) {\n                revisionInfoGenerator = new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n                globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n            } else {\n                revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n            }\n        }\n    }\n    Document revisionInfoXmlMapping = null;\n    if (revisionInfoGenerator == null) {\n        if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n            revisionInfoClass = DefaultTrackingModifiedTypesRevisionEntity.class;\n            revisionInfoEntityName = DefaultTrackingModifiedTypesRevisionEntity.class.getName();\n            revisionInfoGenerator = new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n        } else {\n            revisionInfoClass = DefaultRevisionEntity.class;\n            revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n        }\n        revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate(), modifiedEntityNamesData.getName()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n}"
    },
    {
      "commit": "98342a7e2dd54df9b7fcb8e7b63ebd5441bd2217",
      "startLine": 22,
      "endLine": 34,
      "methodCode": "public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n    Iterator<PersistentClass> classes = (Iterator<PersistentClass>) cfg.getClassMappings();\n    boolean revisionEntityFound = false;\n    RevisionInfoGenerator revisionInfoGenerator = null;\n    Class<?> revisionInfoClass = null;\n    while (classes.hasNext()) {\n        PersistentClass pc = classes.next();\n        XClass clazz;\n        try {\n            clazz = reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        RevisionEntity revisionEntity = clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity != null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Audited.class) != null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n            }\n            revisionEntityFound = true;\n            MutableBoolean revisionNumberFound = new MutableBoolean();\n            MutableBoolean revisionTimestampFound = new MutableBoolean();\n            MutableBoolean modifiedEntityNamesFound = new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName = pc.getEntityName();\n            revisionInfoClass = pc.getMappedClass();\n            revisionInfoTimestampType = pc.getProperty(revisionInfoTimestampData.getName()).getType();\n            if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() || DefaultTrackingModifiedTypesRevisionEntity.class.isAssignableFrom(revisionInfoClass) || modifiedEntityNamesFound.isSet()) {\n                revisionInfoGenerator = new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n                globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n            } else {\n                revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n            }\n        }\n    }\n    Document revisionInfoXmlMapping = null;\n    if (revisionInfoGenerator == null) {\n        if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n            revisionInfoClass = DefaultTrackingModifiedTypesRevisionEntity.class;\n            revisionInfoEntityName = DefaultTrackingModifiedTypesRevisionEntity.class.getName();\n            revisionInfoGenerator = new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n        } else {\n            revisionInfoClass = DefaultRevisionEntity.class;\n            revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n        }\n        revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate(), modifiedEntityNamesData.getName()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n}"
    },
    {
      "commit": "86c15fd21234381e2cc713d07e9652f01078613d",
      "startLine": 22,
      "endLine": 33,
      "methodCode": "public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n    Iterator<PersistentClass> classes = (Iterator<PersistentClass>) cfg.getClassMappings();\n    boolean revisionEntityFound = false;\n    RevisionInfoGenerator revisionInfoGenerator = null;\n    Class<?> revisionInfoClass = null;\n    while (classes.hasNext()) {\n        PersistentClass pc = classes.next();\n        XClass clazz;\n        try {\n            clazz = reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        RevisionEntity revisionEntity = clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity != null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Audited.class) != null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n            }\n            revisionEntityFound = true;\n            MutableBoolean revisionNumberFound = new MutableBoolean();\n            MutableBoolean revisionTimestampFound = new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName = pc.getEntityName();\n            revisionInfoClass = pc.getMappedClass();\n            revisionInfoTimestampType = pc.getProperty(revisionInfoTimestampData.getName()).getType();\n            revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n        }\n    }\n    Document revisionInfoXmlMapping = null;\n    if (revisionInfoGenerator == null) {\n        revisionInfoClass = DefaultRevisionEntity.class;\n        revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n        revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n}"
    },
    {
      "commit": "ac49a906e8566f29767927a0dd8dc6b9328115ab",
      "startLine": 22,
      "endLine": 33,
      "methodCode": "public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n    Iterator<PersistentClass> classes = (Iterator<PersistentClass>) cfg.getClassMappings();\n    boolean revisionEntityFound = false;\n    RevisionInfoGenerator revisionInfoGenerator = null;\n    Class<?> revisionInfoClass = null;\n    while (classes.hasNext()) {\n        PersistentClass pc = classes.next();\n        XClass clazz;\n        try {\n            clazz = reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        RevisionEntity revisionEntity = clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity != null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Audited.class) != null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n            }\n            revisionEntityFound = true;\n            MutableBoolean revisionNumberFound = new MutableBoolean();\n            MutableBoolean revisionTimestampFound = new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName = pc.getEntityName();\n            revisionInfoClass = pc.getMappedClass();\n            revisionInfoTimestampType = pc.getProperty(revisionInfoTimestampData.getName()).getType();\n            revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n        }\n    }\n    Document revisionInfoXmlMapping = null;\n    if (revisionInfoGenerator == null) {\n        revisionInfoClass = DefaultRevisionEntity.class;\n        revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n        revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping(cfg);\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n}"
    },
    {
      "commit": "e21fed8304935dc8a1efeee115a4e720b9d2667b",
      "startLine": 22,
      "endLine": 33,
      "methodCode": "public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n    Iterator<PersistentClass> classes = (Iterator<PersistentClass>) cfg.getClassMappings();\n    boolean revisionEntityFound = false;\n    RevisionInfoGenerator revisionInfoGenerator = null;\n    Class<?> revisionInfoClass = null;\n    while (classes.hasNext()) {\n        PersistentClass pc = classes.next();\n        XClass clazz;\n        try {\n            clazz = reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        RevisionEntity revisionEntity = clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity != null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Audited.class) != null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n            }\n            revisionEntityFound = true;\n            MutableBoolean revisionNumberFound = new MutableBoolean();\n            MutableBoolean revisionTimestampFound = new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName = pc.getEntityName();\n            revisionInfoClass = pc.getMappedClass();\n            revisionInfoTimestampType = pc.getProperty(revisionInfoTimestampData.getName()).getType();\n            revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n        }\n    }\n    Document revisionInfoXmlMapping = null;\n    if (revisionInfoGenerator == null) {\n        revisionInfoClass = DefaultRevisionEntity.class;\n        revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n        revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n}"
    },
    {
      "commit": "6c6e6ab193f48ed93d5b76f394e6bef78205921a",
      "startLine": 22,
      "endLine": 33,
      "methodCode": "public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n    Iterator<PersistentClass> classes = (Iterator<PersistentClass>) cfg.getClassMappings();\n    boolean revisionEntityFound = false;\n    RevisionInfoGenerator revisionInfoGenerator = null;\n    Class<?> revisionInfoClass = null;\n    while (classes.hasNext()) {\n        PersistentClass pc = classes.next();\n        XClass clazz;\n        try {\n            clazz = reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        RevisionEntity revisionEntity = clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity != null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Audited.class) != null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n            }\n            revisionEntityFound = true;\n            MutableBoolean revisionNumberFound = new MutableBoolean();\n            MutableBoolean revisionTimestampFound = new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName = pc.getEntityName();\n            revisionInfoClass = pc.getMappedClass();\n            revisionInfoTimestampType = pc.getProperty(revisionInfoTimestampData.getName()).getType();\n            revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n        }\n    }\n    Document revisionInfoXmlMapping = null;\n    if (revisionInfoGenerator == null) {\n        revisionInfoClass = DefaultRevisionEntity.class;\n        revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n        revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n}"
    },
    {
      "commit": "558d9469e018962a2b3159561bcc0996ecfc62fc",
      "startLine": 23,
      "endLine": 34,
      "methodCode": "@SuppressWarnings({ \"unchecked\" })\npublic RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n    Iterator<PersistentClass> classes = (Iterator<PersistentClass>) cfg.getClassMappings();\n    boolean revisionEntityFound = false;\n    RevisionInfoGenerator revisionInfoGenerator = null;\n    Class<?> revisionInfoClass = null;\n    while (classes.hasNext()) {\n        PersistentClass pc = classes.next();\n        XClass clazz;\n        try {\n            clazz = reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        RevisionEntity revisionEntity = clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity != null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Audited.class) != null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n            }\n            revisionEntityFound = true;\n            MutableBoolean revisionNumberFound = new MutableBoolean();\n            MutableBoolean revisionTimestampFound = new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName = pc.getEntityName();\n            revisionInfoClass = pc.getMappedClass();\n            revisionInfoTimestampType = pc.getProperty(revisionInfoTimestampData.getName()).getType();\n            revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n        }\n    }\n    Document revisionInfoXmlMapping = null;\n    if (revisionInfoGenerator == null) {\n        revisionInfoClass = DefaultRevisionEntity.class;\n        revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n        revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName);\n}"
    },
    {
      "commit": "8f8e0fbfe25cdfd78ff5a9853c2f0e1701aafa09",
      "startLine": 22,
      "endLine": 33,
      "methodCode": "public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n    Iterator<PersistentClass> classes = (Iterator<PersistentClass>) cfg.getClassMappings();\n    boolean revisionEntityFound = false;\n    RevisionInfoGenerator revisionInfoGenerator = null;\n    Class<?> revisionInfoClass = null;\n    while (classes.hasNext()) {\n        PersistentClass pc = classes.next();\n        XClass clazz;\n        try {\n            clazz = reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        RevisionEntity revisionEntity = clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity != null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Audited.class) != null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n            }\n            revisionEntityFound = true;\n            MutableBoolean revisionNumberFound = new MutableBoolean();\n            MutableBoolean revisionTimestampFound = new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName = pc.getEntityName();\n            revisionInfoClass = pc.getMappedClass();\n            revisionInfoTimestampType = pc.getProperty(revisionInfoTimestampData.getName()).getType();\n            revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n        }\n    }\n    Document revisionInfoXmlMapping = null;\n    if (revisionInfoGenerator == null) {\n        revisionInfoClass = DefaultRevisionEntity.class;\n        revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n        revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n}"
    },
    {
      "commit": "f39550fff19a72faec27632409b50970d4d9d2da",
      "startLine": 23,
      "endLine": 34,
      "methodCode": "@SuppressWarnings({ \"unchecked\" })\npublic RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n    Iterator<PersistentClass> classes = (Iterator<PersistentClass>) cfg.getClassMappings();\n    boolean revisionEntityFound = false;\n    RevisionInfoGenerator revisionInfoGenerator = null;\n    Class<?> revisionInfoClass = null;\n    while (classes.hasNext()) {\n        PersistentClass pc = classes.next();\n        XClass clazz;\n        try {\n            clazz = reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        RevisionEntity revisionEntity = clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity != null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Audited.class) != null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n            }\n            revisionEntityFound = true;\n            MutableBoolean revisionNumberFound = new MutableBoolean();\n            MutableBoolean revisionTimestampFound = new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName = pc.getEntityName();\n            revisionInfoClass = pc.getMappedClass();\n            revisionInfoTimestampType = pc.getProperty(revisionInfoTimestampData.getName()).getType();\n            revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n        }\n    }\n    Document revisionInfoXmlMapping = null;\n    if (revisionInfoGenerator == null) {\n        revisionInfoClass = DefaultRevisionEntity.class;\n        revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n        revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName(), isTimestampAsDate()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName);\n}"
    },
    {
      "commit": "4603c8a4dd267aab345ec915b932f736d404daa7",
      "startLine": 23,
      "endLine": 34,
      "methodCode": "@SuppressWarnings({ \"unchecked\" })\npublic RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n    Iterator<PersistentClass> classes = (Iterator<PersistentClass>) cfg.getClassMappings();\n    boolean revisionEntityFound = false;\n    RevisionInfoGenerator revisionInfoGenerator = null;\n    Class<?> revisionInfoClass = null;\n    while (classes.hasNext()) {\n        PersistentClass pc = classes.next();\n        XClass clazz;\n        try {\n            clazz = reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        RevisionEntity revisionEntity = clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity != null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Audited.class) != null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n            }\n            revisionEntityFound = true;\n            MutableBoolean revisionNumberFound = new MutableBoolean();\n            MutableBoolean revisionTimestampFound = new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName = pc.getEntityName();\n            revisionInfoClass = pc.getMappedClass();\n            revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData);\n        }\n    }\n    Document revisionInfoXmlMapping = null;\n    if (revisionInfoGenerator == null) {\n        revisionInfoClass = DefaultRevisionEntity.class;\n        revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData);\n        revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName);\n}"
    },
    {
      "commit": "cc03033e59af53aeb49dbba8dd58bdf1fe3a8578",
      "startLine": 23,
      "endLine": 34,
      "methodCode": "@SuppressWarnings({ \"unchecked\" })\npublic RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n    Iterator<PersistentClass> classes = (Iterator<PersistentClass>) cfg.getClassMappings();\n    boolean revisionEntityFound = false;\n    RevisionInfoGenerator revisionInfoGenerator = null;\n    Class<?> revisionInfoClass = null;\n    while (classes.hasNext()) {\n        PersistentClass pc = classes.next();\n        XClass clazz;\n        try {\n            clazz = reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        RevisionEntity revisionEntity = clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity != null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Audited.class) != null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n            }\n            revisionEntityFound = true;\n            MutableBoolean revisionNumberFound = new MutableBoolean();\n            MutableBoolean revisionTimestampFound = new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName = pc.getEntityName();\n            revisionInfoClass = pc.getMappedClass();\n            revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData);\n        }\n    }\n    Document revisionInfoXmlMapping = null;\n    if (revisionInfoGenerator == null) {\n        revisionInfoClass = DefaultRevisionEntity.class;\n        revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampData);\n        revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(), revisionInfoTimestampData.getName()), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName);\n}"
    },
    {
      "commit": "a94515206db0eee8867d399bee6a87aa9e8cb074",
      "startLine": 23,
      "endLine": 34,
      "methodCode": "@SuppressWarnings({ \"unchecked\" })\npublic RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n    Iterator<PersistentClass> classes = (Iterator<PersistentClass>) cfg.getClassMappings();\n    boolean revisionEntityFound = false;\n    RevisionInfoGenerator revisionInfoGenerator = null;\n    Class<?> revisionInfoClass = null;\n    while (classes.hasNext()) {\n        PersistentClass pc = classes.next();\n        XClass clazz;\n        try {\n            clazz = reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        RevisionEntity revisionEntity = clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity != null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Audited.class) != null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be versioned!\");\n            }\n            revisionEntityFound = true;\n            MutableBoolean revisionNumberFound = new MutableBoolean();\n            MutableBoolean revisionTimestampFound = new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName = pc.getEntityName();\n            revisionInfoClass = pc.getMappedClass();\n            revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampName);\n        }\n    }\n    Document revisionInfoXmlMapping = null;\n    if (revisionInfoGenerator == null) {\n        revisionInfoClass = DefaultRevisionEntity.class;\n        revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampName);\n        revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdName, revisionInfoTimestampName), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdName), revisionInfoEntityName);\n}"
    },
    {
      "commit": "90f70231c682e22693f85977497d2dc429ef29da",
      "startLine": 23,
      "endLine": 34,
      "methodCode": "@SuppressWarnings({ \"unchecked\" })\npublic RevisionInfoConfigurationResult configure(Configuration cfg, YReflectionManager reflectionManager) {\n    Iterator<PersistentClass> classes = (Iterator<PersistentClass>) cfg.getClassMappings();\n    boolean revisionEntityFound = false;\n    RevisionInfoGenerator revisionInfoGenerator = null;\n    Class<?> revisionInfoClass = null;\n    while (classes.hasNext()) {\n        PersistentClass pc = classes.next();\n        YClass clazz;\n        try {\n            clazz = reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        RevisionEntity revisionEntity = clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity != null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Audited.class) != null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be versioned!\");\n            }\n            revisionEntityFound = true;\n            MutableBoolean revisionNumberFound = new MutableBoolean();\n            MutableBoolean revisionTimestampFound = new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName = pc.getEntityName();\n            revisionInfoClass = pc.getMappedClass();\n            revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampName);\n        }\n    }\n    Document revisionInfoXmlMapping = null;\n    if (revisionInfoGenerator == null) {\n        revisionInfoClass = DefaultRevisionEntity.class;\n        revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampName);\n        revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdName, revisionInfoTimestampName), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdName), revisionInfoEntityName);\n}"
    },
    {
      "commit": "dd35cf7b1461fc883148b148e5c81731d9c08a35",
      "startLine": 23,
      "endLine": 34,
      "methodCode": "@SuppressWarnings({ \"unchecked\" })\npublic RevisionInfoConfigurationResult configure(Configuration cfg, YReflectionManager reflectionManager) {\n    Iterator<PersistentClass> classes = (Iterator<PersistentClass>) cfg.getClassMappings();\n    boolean revisionEntityFound = false;\n    RevisionInfoGenerator revisionInfoGenerator = null;\n    Class<?> revisionInfoClass = null;\n    while (classes.hasNext()) {\n        PersistentClass pc = classes.next();\n        YClass clazz;\n        try {\n            clazz = reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        RevisionEntity revisionEntity = clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity != null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Versioned.class) != null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be versioned!\");\n            }\n            revisionEntityFound = true;\n            MutableBoolean revisionNumberFound = new MutableBoolean();\n            MutableBoolean revisionTimestampFound = new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName = pc.getEntityName();\n            revisionInfoClass = pc.getMappedClass();\n            revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampName);\n        }\n    }\n    Document revisionInfoXmlMapping = null;\n    if (revisionInfoGenerator == null) {\n        revisionInfoClass = DefaultRevisionEntity.class;\n        revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampName);\n        revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdName, revisionInfoTimestampName), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdName), revisionInfoEntityName);\n}"
    },
    {
      "commit": "78e5d9fd89aa571f8ad5cf5b8a5046b9b74cb09b",
      "startLine": 23,
      "endLine": 34,
      "methodCode": "@SuppressWarnings({ \"unchecked\" })\npublic RevisionInfoConfigurationResult configure(Configuration cfg, YReflectionManager reflectionManager) {\n    Iterator<PersistentClass> classes = (Iterator<PersistentClass>) cfg.getClassMappings();\n    boolean revisionEntityFound = false;\n    RevisionInfoGenerator revisionInfoGenerator = null;\n    Class<?> revisionInfoClass = null;\n    while (classes.hasNext()) {\n        PersistentClass pc = classes.next();\n        YClass clazz;\n        try {\n            clazz = reflectionManager.classForName(pc.getClassName(), this.getClass());\n        } catch (ClassNotFoundException e) {\n            throw new MappingException(e);\n        }\n        RevisionEntity revisionEntity = clazz.getAnnotation(RevisionEntity.class);\n        if (revisionEntity != null) {\n            if (revisionEntityFound) {\n                throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n            }\n            if (clazz.getAnnotation(Versioned.class) != null) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity cannot be versioned!\");\n            }\n            revisionEntityFound = true;\n            MutableBoolean revisionNumberFound = new MutableBoolean();\n            MutableBoolean revisionTimestampFound = new MutableBoolean();\n            searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n            if (!revisionNumberFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionNumber!\");\n            }\n            if (!revisionTimestampFound.isSet()) {\n                throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" + \"with @RevisionTimestamp!\");\n            }\n            revisionInfoEntityName = pc.getEntityName();\n            revisionInfoClass = pc.getMappedClass();\n            revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, revisionEntity.value(), revisionInfoTimestampName);\n        }\n    }\n    Document revisionInfoXmlMapping = null;\n    if (revisionInfoGenerator == null) {\n        revisionInfoClass = DefaultRevisionEntity.class;\n        revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass, RevisionListener.class, revisionInfoTimestampName);\n        revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n    }\n    return new RevisionInfoConfigurationResult(revisionInfoGenerator, revisionInfoXmlMapping, new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdName, revisionInfoTimestampName), generateRevisionInfoRelationMapping(), new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdName), revisionInfoEntityName);\n}"
    }
  ]
}