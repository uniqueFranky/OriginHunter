{
  "statementVersions": [
    {
      "commit": "9441508682b7d7c935dd976e4082cacff4a5efeb",
      "startLine": 6,
      "endLine": 12,
      "methodCode": "@Override\npublic RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException, AbortedByHookException {\n    checkCallable();\n    Collections.sort(only);\n    try (RevWalk rw = new RevWalk(repo)) {\n        RepositoryState state = repo.getRepositoryState();\n        if (!state.canCommit())\n            throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n        if (!noVerify) {\n            Hooks.preCommit(repo, hookOutRedirect.get(PreCommitHook.NAME)).call();\n        }\n        processOptions(state, rw);\n        if (all && !repo.isBare()) {\n            try (Git git = new Git(repo)) {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head = repo.exactRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId == null && amend)\n            throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n        if (headId != null)\n            if (amend) {\n                RevCommit previousCommit = rw.parseCommit(headId);\n                for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                if (author == null)\n                    author = previousCommit.getAuthorIdent();\n            } else {\n                parents.add(0, headId);\n            }\n        if (!noVerify) {\n            message = Hooks.commitMsg(repo, hookOutRedirect.get(CommitMsgHook.NAME)).setCommitMessage(message).call();\n        }\n        DirCache index = repo.lockDirCache();\n        try (ObjectInserter odi = repo.newObjectInserter()) {\n            if (!only.isEmpty())\n                index = createTemporaryIndex(headId, index, rw);\n            ObjectId indexTreeId = index.writeTree(odi);\n            if (insertChangeId)\n                insertChangeId(indexTreeId);\n            if (headId != null && !allowEmpty.booleanValue()) {\n                RevCommit headCommit = rw.parseCommit(headId);\n                headCommit.getTree();\n                if (indexTreeId.equals(headCommit.getTree())) {\n                    throw new EmptyCommitException(JGitText.get().emptyCommit);\n                }\n            }\n            CommitBuilder commit = new CommitBuilder();\n            commit.setCommitter(committer);\n            commit.setAuthor(author);\n            commit.setMessage(message);\n            commit.setParentIds(parents);\n            commit.setTreeId(indexTreeId);\n            ObjectId commitId = odi.insert(commit);\n            odi.flush();\n            RevCommit revCommit = rw.parseCommit(commitId);\n            RefUpdate ru = repo.updateRef(Constants.HEAD);\n            ru.setNewObjectId(commitId);\n            if (!useDefaultReflogMessage) {\n                ru.setRefLogMessage(reflogComment, false);\n            } else {\n                String prefix = amend ? \"commit (amend): \" : parents.size() == 0 ? \"commit (initial): \" : \"commit: \";\n                ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n            }\n            if (headId != null)\n                ru.setExpectedOldObjectId(headId);\n            else\n                ru.setExpectedOldObjectId(ObjectId.zeroId());\n            Result rc = ru.forceUpdate();\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    {\n                        setCallable(false);\n                        if (state == RepositoryState.MERGING_RESOLVED || isMergeDuringRebase(state)) {\n                            repo.writeMergeCommitMsg(null);\n                            repo.writeMergeHeads(null);\n                        } else if (state == RepositoryState.CHERRY_PICKING_RESOLVED) {\n                            repo.writeMergeCommitMsg(null);\n                            repo.writeCherryPickHead(null);\n                        } else if (state == RepositoryState.REVERTING_RESOLVED) {\n                            repo.writeMergeCommitMsg(null);\n                            repo.writeRevertHead(null);\n                        }\n                        Hooks.postCommit(repo, hookOutRedirect.get(PostCommitHook.NAME)).call();\n                        return revCommit;\n                    }\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw new UnmergedPathsException(e);\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}"
    },
    {
      "commit": "0210e0e299bed69176e0a929d0b67f3cf9fb1e37",
      "startLine": 6,
      "endLine": 12,
      "methodCode": "@Override\npublic RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException, AbortedByHookException {\n    checkCallable();\n    Collections.sort(only);\n    try (RevWalk rw = new RevWalk(repo)) {\n        RepositoryState state = repo.getRepositoryState();\n        if (!state.canCommit())\n            throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n        if (!noVerify) {\n            Hooks.preCommit(repo, hookOutRedirect.get(PreCommitHook.NAME)).call();\n        }\n        processOptions(state, rw);\n        if (all && !repo.isBare()) {\n            try (Git git = new Git(repo)) {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head = repo.exactRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId == null && amend)\n            throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n        if (headId != null)\n            if (amend) {\n                RevCommit previousCommit = rw.parseCommit(headId);\n                for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                if (author == null)\n                    author = previousCommit.getAuthorIdent();\n            } else {\n                parents.add(0, headId);\n            }\n        if (!noVerify) {\n            message = Hooks.commitMsg(repo, hookOutRedirect.get(CommitMsgHook.NAME)).setCommitMessage(message).call();\n        }\n        DirCache index = repo.lockDirCache();\n        try (ObjectInserter odi = repo.newObjectInserter()) {\n            if (!only.isEmpty())\n                index = createTemporaryIndex(headId, index, rw);\n            ObjectId indexTreeId = index.writeTree(odi);\n            if (insertChangeId)\n                insertChangeId(indexTreeId);\n            if (headId != null && !allowEmpty.booleanValue()) {\n                RevCommit headCommit = rw.parseCommit(headId);\n                headCommit.getTree();\n                if (indexTreeId.equals(headCommit.getTree())) {\n                    throw new EmtpyCommitException(JGitText.get().emptyCommit);\n                }\n            }\n            CommitBuilder commit = new CommitBuilder();\n            commit.setCommitter(committer);\n            commit.setAuthor(author);\n            commit.setMessage(message);\n            commit.setParentIds(parents);\n            commit.setTreeId(indexTreeId);\n            ObjectId commitId = odi.insert(commit);\n            odi.flush();\n            RevCommit revCommit = rw.parseCommit(commitId);\n            RefUpdate ru = repo.updateRef(Constants.HEAD);\n            ru.setNewObjectId(commitId);\n            if (!useDefaultReflogMessage) {\n                ru.setRefLogMessage(reflogComment, false);\n            } else {\n                String prefix = amend ? \"commit (amend): \" : parents.size() == 0 ? \"commit (initial): \" : \"commit: \";\n                ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n            }\n            if (headId != null)\n                ru.setExpectedOldObjectId(headId);\n            else\n                ru.setExpectedOldObjectId(ObjectId.zeroId());\n            Result rc = ru.forceUpdate();\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    {\n                        setCallable(false);\n                        if (state == RepositoryState.MERGING_RESOLVED || isMergeDuringRebase(state)) {\n                            repo.writeMergeCommitMsg(null);\n                            repo.writeMergeHeads(null);\n                        } else if (state == RepositoryState.CHERRY_PICKING_RESOLVED) {\n                            repo.writeMergeCommitMsg(null);\n                            repo.writeCherryPickHead(null);\n                        } else if (state == RepositoryState.REVERTING_RESOLVED) {\n                            repo.writeMergeCommitMsg(null);\n                            repo.writeRevertHead(null);\n                        }\n                        Hooks.postCommit(repo, hookOutRedirect.get(PostCommitHook.NAME)).call();\n                        return revCommit;\n                    }\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw new UnmergedPathsException(e);\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}"
    },
    {
      "commit": "7ac182f4e427e0d5a986b8ca67a56fc22828b1a0",
      "startLine": 6,
      "endLine": 12,
      "methodCode": "@Override\npublic RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException, AbortedByHookException {\n    checkCallable();\n    Collections.sort(only);\n    try (RevWalk rw = new RevWalk(repo)) {\n        RepositoryState state = repo.getRepositoryState();\n        if (!state.canCommit())\n            throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n        if (!noVerify) {\n            Hooks.preCommit(repo, hookOutRedirect.get(PreCommitHook.NAME)).call();\n        }\n        processOptions(state, rw);\n        if (all && !repo.isBare()) {\n            try (Git git = new Git(repo)) {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head = repo.exactRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId == null && amend)\n            throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n        if (headId != null)\n            if (amend) {\n                RevCommit previousCommit = rw.parseCommit(headId);\n                for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                if (author == null)\n                    author = previousCommit.getAuthorIdent();\n            } else {\n                parents.add(0, headId);\n            }\n        if (!noVerify) {\n            message = Hooks.commitMsg(repo, hookOutRedirect.get(CommitMsgHook.NAME)).setCommitMessage(message).call();\n        }\n        DirCache index = repo.lockDirCache();\n        try (ObjectInserter odi = repo.newObjectInserter()) {\n            if (!only.isEmpty())\n                index = createTemporaryIndex(headId, index, rw);\n            ObjectId indexTreeId = index.writeTree(odi);\n            if (insertChangeId)\n                insertChangeId(indexTreeId);\n            if (headId != null && !allowEmpty.booleanValue()) {\n                RevCommit headCommit = rw.parseCommit(headId);\n                headCommit.getTree();\n                if (indexTreeId.equals(headCommit.getTree())) {\n                    throw new EmtpyCommitException(JGitText.get().emptyCommit);\n                }\n            }\n            CommitBuilder commit = new CommitBuilder();\n            commit.setCommitter(committer);\n            commit.setAuthor(author);\n            commit.setMessage(message);\n            commit.setParentIds(parents);\n            commit.setTreeId(indexTreeId);\n            ObjectId commitId = odi.insert(commit);\n            odi.flush();\n            RevCommit revCommit = rw.parseCommit(commitId);\n            RefUpdate ru = repo.updateRef(Constants.HEAD);\n            ru.setNewObjectId(commitId);\n            if (!useDefaultReflogMessage) {\n                ru.setRefLogMessage(reflogComment, false);\n            } else {\n                String prefix = amend ? \"commit (amend): \" : parents.size() == 0 ? \"commit (initial): \" : \"commit: \";\n                ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n            }\n            if (headId != null)\n                ru.setExpectedOldObjectId(headId);\n            else\n                ru.setExpectedOldObjectId(ObjectId.zeroId());\n            Result rc = ru.forceUpdate();\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    {\n                        setCallable(false);\n                        if (state == RepositoryState.MERGING_RESOLVED || isMergeDuringRebase(state)) {\n                            repo.writeMergeCommitMsg(null);\n                            repo.writeMergeHeads(null);\n                        } else if (state == RepositoryState.CHERRY_PICKING_RESOLVED) {\n                            repo.writeMergeCommitMsg(null);\n                            repo.writeCherryPickHead(null);\n                        } else if (state == RepositoryState.REVERTING_RESOLVED) {\n                            repo.writeMergeCommitMsg(null);\n                            repo.writeRevertHead(null);\n                        }\n                        Hooks.postCommit(repo, hookOutRedirect.get(PostCommitHook.NAME)).call();\n                        return revCommit;\n                    }\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw new UnmergedPathsException(e);\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}"
    },
    {
      "commit": "57a263f1823d164142235a72072154f0568cb61c",
      "startLine": 5,
      "endLine": 11,
      "methodCode": "public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException, AbortedByHookException {\n    checkCallable();\n    Collections.sort(only);\n    try (RevWalk rw = new RevWalk(repo)) {\n        RepositoryState state = repo.getRepositoryState();\n        if (!state.canCommit())\n            throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n        if (!noVerify) {\n            Hooks.preCommit(repo, hookOutRedirect.get(PreCommitHook.NAME)).call();\n        }\n        processOptions(state, rw);\n        if (all && !repo.isBare()) {\n            try (Git git = new Git(repo)) {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head = repo.exactRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId == null && amend)\n            throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n        if (headId != null)\n            if (amend) {\n                RevCommit previousCommit = rw.parseCommit(headId);\n                for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                if (author == null)\n                    author = previousCommit.getAuthorIdent();\n            } else {\n                parents.add(0, headId);\n            }\n        if (!noVerify) {\n            message = Hooks.commitMsg(repo, hookOutRedirect.get(CommitMsgHook.NAME)).setCommitMessage(message).call();\n        }\n        DirCache index = repo.lockDirCache();\n        try (ObjectInserter odi = repo.newObjectInserter()) {\n            if (!only.isEmpty())\n                index = createTemporaryIndex(headId, index, rw);\n            ObjectId indexTreeId = index.writeTree(odi);\n            if (insertChangeId)\n                insertChangeId(indexTreeId);\n            if (headId != null && !allowEmpty.booleanValue()) {\n                RevCommit headCommit = rw.parseCommit(headId);\n                headCommit.getTree();\n                if (indexTreeId.equals(headCommit.getTree())) {\n                    throw new EmtpyCommitException(JGitText.get().emptyCommit);\n                }\n            }\n            CommitBuilder commit = new CommitBuilder();\n            commit.setCommitter(committer);\n            commit.setAuthor(author);\n            commit.setMessage(message);\n            commit.setParentIds(parents);\n            commit.setTreeId(indexTreeId);\n            ObjectId commitId = odi.insert(commit);\n            odi.flush();\n            RevCommit revCommit = rw.parseCommit(commitId);\n            RefUpdate ru = repo.updateRef(Constants.HEAD);\n            ru.setNewObjectId(commitId);\n            if (!useDefaultReflogMessage) {\n                ru.setRefLogMessage(reflogComment, false);\n            } else {\n                String prefix = amend ? \"commit (amend): \" : parents.size() == 0 ? \"commit (initial): \" : \"commit: \";\n                ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n            }\n            if (headId != null)\n                ru.setExpectedOldObjectId(headId);\n            else\n                ru.setExpectedOldObjectId(ObjectId.zeroId());\n            Result rc = ru.forceUpdate();\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    {\n                        setCallable(false);\n                        if (state == RepositoryState.MERGING_RESOLVED || isMergeDuringRebase(state)) {\n                            repo.writeMergeCommitMsg(null);\n                            repo.writeMergeHeads(null);\n                        } else if (state == RepositoryState.CHERRY_PICKING_RESOLVED) {\n                            repo.writeMergeCommitMsg(null);\n                            repo.writeCherryPickHead(null);\n                        } else if (state == RepositoryState.REVERTING_RESOLVED) {\n                            repo.writeMergeCommitMsg(null);\n                            repo.writeRevertHead(null);\n                        }\n                        Hooks.postCommit(repo, hookOutRedirect.get(PostCommitHook.NAME)).call();\n                        return revCommit;\n                    }\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw new UnmergedPathsException(e);\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}"
    },
    {
      "commit": "4c236ff4bbf664fd177a33f42517b0eef52510c8",
      "startLine": 5,
      "endLine": 11,
      "methodCode": "public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException, AbortedByHookException {\n    checkCallable();\n    Collections.sort(only);\n    try (RevWalk rw = new RevWalk(repo)) {\n        RepositoryState state = repo.getRepositoryState();\n        if (!state.canCommit())\n            throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n        if (!noVerify) {\n            Hooks.preCommit(repo, hookOutRedirect).call();\n        }\n        processOptions(state, rw);\n        if (all && !repo.isBare()) {\n            try (Git git = new Git(repo)) {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head = repo.exactRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId == null && amend)\n            throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n        if (headId != null)\n            if (amend) {\n                RevCommit previousCommit = rw.parseCommit(headId);\n                for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                if (author == null)\n                    author = previousCommit.getAuthorIdent();\n            } else {\n                parents.add(0, headId);\n            }\n        if (!noVerify) {\n            message = Hooks.commitMsg(repo, hookOutRedirect).setCommitMessage(message).call();\n        }\n        DirCache index = repo.lockDirCache();\n        try (ObjectInserter odi = repo.newObjectInserter()) {\n            if (!only.isEmpty())\n                index = createTemporaryIndex(headId, index, rw);\n            ObjectId indexTreeId = index.writeTree(odi);\n            if (insertChangeId)\n                insertChangeId(indexTreeId);\n            if (headId != null && !allowEmpty.booleanValue()) {\n                RevCommit headCommit = rw.parseCommit(headId);\n                headCommit.getTree();\n                if (indexTreeId.equals(headCommit.getTree())) {\n                    throw new EmtpyCommitException(JGitText.get().emptyCommit);\n                }\n            }\n            CommitBuilder commit = new CommitBuilder();\n            commit.setCommitter(committer);\n            commit.setAuthor(author);\n            commit.setMessage(message);\n            commit.setParentIds(parents);\n            commit.setTreeId(indexTreeId);\n            ObjectId commitId = odi.insert(commit);\n            odi.flush();\n            RevCommit revCommit = rw.parseCommit(commitId);\n            RefUpdate ru = repo.updateRef(Constants.HEAD);\n            ru.setNewObjectId(commitId);\n            if (!useDefaultReflogMessage) {\n                ru.setRefLogMessage(reflogComment, false);\n            } else {\n                String prefix = amend ? \"commit (amend): \" : parents.size() == 0 ? \"commit (initial): \" : \"commit: \";\n                ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n            }\n            if (headId != null)\n                ru.setExpectedOldObjectId(headId);\n            else\n                ru.setExpectedOldObjectId(ObjectId.zeroId());\n            Result rc = ru.forceUpdate();\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    {\n                        setCallable(false);\n                        if (state == RepositoryState.MERGING_RESOLVED || isMergeDuringRebase(state)) {\n                            repo.writeMergeCommitMsg(null);\n                            repo.writeMergeHeads(null);\n                        } else if (state == RepositoryState.CHERRY_PICKING_RESOLVED) {\n                            repo.writeMergeCommitMsg(null);\n                            repo.writeCherryPickHead(null);\n                        } else if (state == RepositoryState.REVERTING_RESOLVED) {\n                            repo.writeMergeCommitMsg(null);\n                            repo.writeRevertHead(null);\n                        }\n                        return revCommit;\n                    }\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw new UnmergedPathsException(e);\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}"
    },
    {
      "commit": "36a53d1a3cdd66c40b6db241a75a28293f22f5e1",
      "startLine": 5,
      "endLine": 11,
      "methodCode": "public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException, AbortedByHookException {\n    checkCallable();\n    Collections.sort(only);\n    try (RevWalk rw = new RevWalk(repo)) {\n        RepositoryState state = repo.getRepositoryState();\n        if (!state.canCommit())\n            throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n        if (!noVerify) {\n            Hooks.preCommit(repo, hookOutRedirect).call();\n        }\n        processOptions(state, rw);\n        if (all && !repo.isBare()) {\n            try (Git git = new Git(repo)) {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId == null && amend)\n            throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n        if (headId != null)\n            if (amend) {\n                RevCommit previousCommit = rw.parseCommit(headId);\n                for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                if (author == null)\n                    author = previousCommit.getAuthorIdent();\n            } else {\n                parents.add(0, headId);\n            }\n        if (!noVerify) {\n            message = Hooks.commitMsg(repo, hookOutRedirect).setCommitMessage(message).call();\n        }\n        DirCache index = repo.lockDirCache();\n        try (ObjectInserter odi = repo.newObjectInserter()) {\n            if (!only.isEmpty())\n                index = createTemporaryIndex(headId, index, rw);\n            ObjectId indexTreeId = index.writeTree(odi);\n            if (insertChangeId)\n                insertChangeId(indexTreeId);\n            if (headId != null && !allowEmpty.booleanValue()) {\n                RevCommit headCommit = rw.parseCommit(headId);\n                headCommit.getTree();\n                if (indexTreeId.equals(headCommit.getTree())) {\n                    throw new EmtpyCommitException(JGitText.get().emptyCommit);\n                }\n            }\n            CommitBuilder commit = new CommitBuilder();\n            commit.setCommitter(committer);\n            commit.setAuthor(author);\n            commit.setMessage(message);\n            commit.setParentIds(parents);\n            commit.setTreeId(indexTreeId);\n            ObjectId commitId = odi.insert(commit);\n            odi.flush();\n            RevCommit revCommit = rw.parseCommit(commitId);\n            RefUpdate ru = repo.updateRef(Constants.HEAD);\n            ru.setNewObjectId(commitId);\n            if (!useDefaultReflogMessage) {\n                ru.setRefLogMessage(reflogComment, false);\n            } else {\n                String prefix = amend ? \"commit (amend): \" : parents.size() == 0 ? \"commit (initial): \" : \"commit: \";\n                ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n            }\n            if (headId != null)\n                ru.setExpectedOldObjectId(headId);\n            else\n                ru.setExpectedOldObjectId(ObjectId.zeroId());\n            Result rc = ru.forceUpdate();\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    {\n                        setCallable(false);\n                        if (state == RepositoryState.MERGING_RESOLVED || isMergeDuringRebase(state)) {\n                            repo.writeMergeCommitMsg(null);\n                            repo.writeMergeHeads(null);\n                        } else if (state == RepositoryState.CHERRY_PICKING_RESOLVED) {\n                            repo.writeMergeCommitMsg(null);\n                            repo.writeCherryPickHead(null);\n                        } else if (state == RepositoryState.REVERTING_RESOLVED) {\n                            repo.writeMergeCommitMsg(null);\n                            repo.writeRevertHead(null);\n                        }\n                        return revCommit;\n                    }\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw new UnmergedPathsException(e);\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}"
    },
    {
      "commit": "da43d8d79890e561a993a4d90e6a2724a04cd60f",
      "startLine": 5,
      "endLine": 11,
      "methodCode": "public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException, AbortedByHookException {\n    checkCallable();\n    Collections.sort(only);\n    try (RevWalk rw = new RevWalk(repo)) {\n        RepositoryState state = repo.getRepositoryState();\n        if (!state.canCommit())\n            throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n        if (!noVerify) {\n            Hooks.preCommit(repo, hookOutRedirect).call();\n        }\n        processOptions(state, rw);\n        if (all && !repo.isBare()) {\n            try (Git git = new Git(repo)) {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId == null && amend)\n            throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n        if (headId != null)\n            if (amend) {\n                RevCommit previousCommit = rw.parseCommit(headId);\n                for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                if (author == null)\n                    author = previousCommit.getAuthorIdent();\n            } else {\n                parents.add(0, headId);\n            }\n        if (!noVerify) {\n            message = Hooks.commitMsg(repo, hookOutRedirect).setCommitMessage(message).call();\n        }\n        DirCache index = repo.lockDirCache();\n        try (ObjectInserter odi = repo.newObjectInserter()) {\n            if (!only.isEmpty())\n                index = createTemporaryIndex(headId, index, rw);\n            ObjectId indexTreeId = index.writeTree(odi);\n            if (insertChangeId)\n                insertChangeId(indexTreeId);\n            if (headId != null && !allowEmpty.booleanValue()) {\n                RevCommit headCommit = rw.parseCommit(headId);\n                headCommit.getTree();\n                if (indexTreeId.equals(headCommit.getTree())) {\n                    throw new EmtpyCommitException(JGitText.get().emptyCommit);\n                }\n            }\n            CommitBuilder commit = new CommitBuilder();\n            commit.setCommitter(committer);\n            commit.setAuthor(author);\n            commit.setMessage(message);\n            commit.setParentIds(parents);\n            commit.setTreeId(indexTreeId);\n            ObjectId commitId = odi.insert(commit);\n            odi.flush();\n            RevCommit revCommit = rw.parseCommit(commitId);\n            RefUpdate ru = repo.updateRef(Constants.HEAD);\n            ru.setNewObjectId(commitId);\n            if (reflogComment != null) {\n                ru.setRefLogMessage(reflogComment, false);\n            } else {\n                String prefix = amend ? \"commit (amend): \" : parents.size() == 0 ? \"commit (initial): \" : \"commit: \";\n                ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n            }\n            if (headId != null)\n                ru.setExpectedOldObjectId(headId);\n            else\n                ru.setExpectedOldObjectId(ObjectId.zeroId());\n            Result rc = ru.forceUpdate();\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    {\n                        setCallable(false);\n                        if (state == RepositoryState.MERGING_RESOLVED || isMergeDuringRebase(state)) {\n                            repo.writeMergeCommitMsg(null);\n                            repo.writeMergeHeads(null);\n                        } else if (state == RepositoryState.CHERRY_PICKING_RESOLVED) {\n                            repo.writeMergeCommitMsg(null);\n                            repo.writeCherryPickHead(null);\n                        } else if (state == RepositoryState.REVERTING_RESOLVED) {\n                            repo.writeMergeCommitMsg(null);\n                            repo.writeRevertHead(null);\n                        }\n                        return revCommit;\n                    }\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw new UnmergedPathsException(e);\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}"
    },
    {
      "commit": "1ed5382b37453309580e11a11cf4c3bb134813fa",
      "startLine": 5,
      "endLine": 11,
      "methodCode": "public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException, AbortedByHookException {\n    checkCallable();\n    Collections.sort(only);\n    try (RevWalk rw = new RevWalk(repo)) {\n        RepositoryState state = repo.getRepositoryState();\n        if (!state.canCommit())\n            throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n        if (!noVerify) {\n            Hooks.preCommit(repo, hookOutRedirect).call();\n        }\n        processOptions(state, rw);\n        if (all && !repo.isBare()) {\n            try (Git git = new Git(repo)) {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId == null && amend)\n            throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n        if (headId != null)\n            if (amend) {\n                RevCommit previousCommit = rw.parseCommit(headId);\n                for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                if (author == null)\n                    author = previousCommit.getAuthorIdent();\n            } else {\n                parents.add(0, headId);\n            }\n        if (!noVerify) {\n            message = Hooks.commitMsg(repo, hookOutRedirect).setCommitMessage(message).call();\n        }\n        DirCache index = repo.lockDirCache();\n        try (ObjectInserter odi = repo.newObjectInserter()) {\n            if (!only.isEmpty())\n                index = createTemporaryIndex(headId, index, rw);\n            ObjectId indexTreeId = index.writeTree(odi);\n            if (insertChangeId)\n                insertChangeId(indexTreeId);\n            CommitBuilder commit = new CommitBuilder();\n            commit.setCommitter(committer);\n            commit.setAuthor(author);\n            commit.setMessage(message);\n            commit.setParentIds(parents);\n            commit.setTreeId(indexTreeId);\n            ObjectId commitId = odi.insert(commit);\n            odi.flush();\n            RevCommit revCommit = rw.parseCommit(commitId);\n            RefUpdate ru = repo.updateRef(Constants.HEAD);\n            ru.setNewObjectId(commitId);\n            if (reflogComment != null) {\n                ru.setRefLogMessage(reflogComment, false);\n            } else {\n                String prefix = amend ? \"commit (amend): \" : parents.size() == 0 ? \"commit (initial): \" : \"commit: \";\n                ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n            }\n            if (headId != null)\n                ru.setExpectedOldObjectId(headId);\n            else\n                ru.setExpectedOldObjectId(ObjectId.zeroId());\n            Result rc = ru.forceUpdate();\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    {\n                        setCallable(false);\n                        if (state == RepositoryState.MERGING_RESOLVED || isMergeDuringRebase(state)) {\n                            repo.writeMergeCommitMsg(null);\n                            repo.writeMergeHeads(null);\n                        } else if (state == RepositoryState.CHERRY_PICKING_RESOLVED) {\n                            repo.writeMergeCommitMsg(null);\n                            repo.writeCherryPickHead(null);\n                        } else if (state == RepositoryState.REVERTING_RESOLVED) {\n                            repo.writeMergeCommitMsg(null);\n                            repo.writeRevertHead(null);\n                        }\n                        return revCommit;\n                    }\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw new UnmergedPathsException(e);\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}"
    },
    {
      "commit": "d726f0c1e02c196e2dd87de53b54338be15503f1",
      "startLine": 5,
      "endLine": 11,
      "methodCode": "public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException, AbortedByHookException {\n    checkCallable();\n    Collections.sort(only);\n    try (RevWalk rw = new RevWalk(repo)) {\n        RepositoryState state = repo.getRepositoryState();\n        if (!state.canCommit())\n            throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n        if (!noVerify) {\n            Hooks.preCommit(repo, hookOutRedirect).call();\n        }\n        processOptions(state, rw);\n        if (all && !repo.isBare() && repo.getWorkTree() != null) {\n            try (Git git = new Git(repo)) {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId == null && amend)\n            throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n        if (headId != null)\n            if (amend) {\n                RevCommit previousCommit = rw.parseCommit(headId);\n                for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                if (author == null)\n                    author = previousCommit.getAuthorIdent();\n            } else {\n                parents.add(0, headId);\n            }\n        if (!noVerify) {\n            message = Hooks.commitMsg(repo, hookOutRedirect).setCommitMessage(message).call();\n        }\n        DirCache index = repo.lockDirCache();\n        try (ObjectInserter odi = repo.newObjectInserter()) {\n            if (!only.isEmpty())\n                index = createTemporaryIndex(headId, index, rw);\n            ObjectId indexTreeId = index.writeTree(odi);\n            if (insertChangeId)\n                insertChangeId(indexTreeId);\n            CommitBuilder commit = new CommitBuilder();\n            commit.setCommitter(committer);\n            commit.setAuthor(author);\n            commit.setMessage(message);\n            commit.setParentIds(parents);\n            commit.setTreeId(indexTreeId);\n            ObjectId commitId = odi.insert(commit);\n            odi.flush();\n            RevCommit revCommit = rw.parseCommit(commitId);\n            RefUpdate ru = repo.updateRef(Constants.HEAD);\n            ru.setNewObjectId(commitId);\n            if (reflogComment != null) {\n                ru.setRefLogMessage(reflogComment, false);\n            } else {\n                String prefix = amend ? \"commit (amend): \" : parents.size() == 0 ? \"commit (initial): \" : \"commit: \";\n                ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n            }\n            if (headId != null)\n                ru.setExpectedOldObjectId(headId);\n            else\n                ru.setExpectedOldObjectId(ObjectId.zeroId());\n            Result rc = ru.forceUpdate();\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    {\n                        setCallable(false);\n                        if (state == RepositoryState.MERGING_RESOLVED || isMergeDuringRebase(state)) {\n                            repo.writeMergeCommitMsg(null);\n                            repo.writeMergeHeads(null);\n                        } else if (state == RepositoryState.CHERRY_PICKING_RESOLVED) {\n                            repo.writeMergeCommitMsg(null);\n                            repo.writeCherryPickHead(null);\n                        } else if (state == RepositoryState.REVERTING_RESOLVED) {\n                            repo.writeMergeCommitMsg(null);\n                            repo.writeRevertHead(null);\n                        }\n                        return revCommit;\n                    }\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw new UnmergedPathsException(e);\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}"
    },
    {
      "commit": "efeb02bf2bed32ef94d5c4891404f551cdc6957f",
      "startLine": 6,
      "endLine": 12,
      "methodCode": "public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException, AbortedByHookException {\n    checkCallable();\n    Collections.sort(only);\n    RevWalk rw = new RevWalk(repo);\n    try {\n        RepositoryState state = repo.getRepositoryState();\n        if (!state.canCommit())\n            throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n        if (!noVerify) {\n            Hooks.preCommit(repo, hookOutRedirect).call();\n        }\n        processOptions(state, rw);\n        if (all && !repo.isBare() && repo.getWorkTree() != null) {\n            Git git = new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId == null && amend)\n            throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n        if (headId != null)\n            if (amend) {\n                RevCommit previousCommit = rw.parseCommit(headId);\n                for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                if (author == null)\n                    author = previousCommit.getAuthorIdent();\n            } else {\n                parents.add(0, headId);\n            }\n        if (!noVerify) {\n            message = Hooks.commitMsg(repo, hookOutRedirect).setCommitMessage(message).call();\n        }\n        DirCache index = repo.lockDirCache();\n        try {\n            if (!only.isEmpty())\n                index = createTemporaryIndex(headId, index, rw);\n            ObjectInserter odi = repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId = index.writeTree(odi);\n                if (insertChangeId)\n                    insertChangeId(indexTreeId);\n                CommitBuilder commit = new CommitBuilder();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId = odi.insert(commit);\n                odi.flush();\n                RevCommit revCommit = rw.parseCommit(commitId);\n                RefUpdate ru = repo.updateRef(Constants.HEAD);\n                ru.setNewObjectId(commitId);\n                if (reflogComment != null) {\n                    ru.setRefLogMessage(reflogComment, false);\n                } else {\n                    String prefix = amend ? \"commit (amend): \" : parents.size() == 0 ? \"commit (initial): \" : \"commit: \";\n                    ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                }\n                if (headId != null)\n                    ru.setExpectedOldObjectId(headId);\n                else\n                    ru.setExpectedOldObjectId(ObjectId.zeroId());\n                Result rc = ru.forceUpdate();\n                switch(rc) {\n                    case NEW:\n                    case FORCED:\n                    case FAST_FORWARD:\n                        {\n                            setCallable(false);\n                            if (state == RepositoryState.MERGING_RESOLVED || isMergeDuringRebase(state)) {\n                                repo.writeMergeCommitMsg(null);\n                                repo.writeMergeHeads(null);\n                            } else if (state == RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                repo.writeMergeCommitMsg(null);\n                                repo.writeCherryPickHead(null);\n                            } else if (state == RepositoryState.REVERTING_RESOLVED) {\n                                repo.writeMergeCommitMsg(null);\n                                repo.writeRevertHead(null);\n                            }\n                            return revCommit;\n                        }\n                    case REJECTED:\n                    case LOCK_FAILURE:\n                        throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                    default:\n                        throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw new UnmergedPathsException(e);\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    } finally {\n        rw.dispose();\n    }\n}"
    },
    {
      "commit": "26fd56f167e6377777e6d46c14779183e4bcb55a",
      "startLine": 6,
      "endLine": 12,
      "methodCode": "public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException, AbortedByHookException {\n    checkCallable();\n    Collections.sort(only);\n    RevWalk rw = new RevWalk(repo);\n    try {\n        RepositoryState state = repo.getRepositoryState();\n        if (!state.canCommit())\n            throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n        if (!noVerify) {\n            Hooks.preCommit(repo, hookOutRedirect).call();\n        }\n        processOptions(state, rw);\n        if (all && !repo.isBare() && repo.getWorkTree() != null) {\n            Git git = new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId == null && amend)\n            throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n        if (headId != null)\n            if (amend) {\n                RevCommit previousCommit = rw.parseCommit(headId);\n                for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                if (author == null)\n                    author = previousCommit.getAuthorIdent();\n            } else {\n                parents.add(0, headId);\n            }\n        DirCache index = repo.lockDirCache();\n        try {\n            if (!only.isEmpty())\n                index = createTemporaryIndex(headId, index, rw);\n            ObjectInserter odi = repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId = index.writeTree(odi);\n                if (insertChangeId)\n                    insertChangeId(indexTreeId);\n                CommitBuilder commit = new CommitBuilder();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId = odi.insert(commit);\n                odi.flush();\n                RevCommit revCommit = rw.parseCommit(commitId);\n                RefUpdate ru = repo.updateRef(Constants.HEAD);\n                ru.setNewObjectId(commitId);\n                if (reflogComment != null) {\n                    ru.setRefLogMessage(reflogComment, false);\n                } else {\n                    String prefix = amend ? \"commit (amend): \" : parents.size() == 0 ? \"commit (initial): \" : \"commit: \";\n                    ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                }\n                if (headId != null)\n                    ru.setExpectedOldObjectId(headId);\n                else\n                    ru.setExpectedOldObjectId(ObjectId.zeroId());\n                Result rc = ru.forceUpdate();\n                switch(rc) {\n                    case NEW:\n                    case FORCED:\n                    case FAST_FORWARD:\n                        {\n                            setCallable(false);\n                            if (state == RepositoryState.MERGING_RESOLVED || isMergeDuringRebase(state)) {\n                                repo.writeMergeCommitMsg(null);\n                                repo.writeMergeHeads(null);\n                            } else if (state == RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                repo.writeMergeCommitMsg(null);\n                                repo.writeCherryPickHead(null);\n                            } else if (state == RepositoryState.REVERTING_RESOLVED) {\n                                repo.writeMergeCommitMsg(null);\n                                repo.writeRevertHead(null);\n                            }\n                            return revCommit;\n                        }\n                    case REJECTED:\n                    case LOCK_FAILURE:\n                        throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                    default:\n                        throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw new UnmergedPathsException(e);\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    } finally {\n        rw.dispose();\n    }\n}"
    },
    {
      "commit": "494e893c541b5cf465b362c69354c08d7a81c249",
      "startLine": 6,
      "endLine": 18,
      "methodCode": "public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException, RejectCommitException {\n    checkCallable();\n    Collections.sort(only);\n    RevWalk rw = new RevWalk(repo);\n    try {\n        RepositoryState state = repo.getRepositoryState();\n        if (!state.canCommit())\n            throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n        if (!noVerify) {\n            final ByteArrayOutputStream errorByteArray = new ByteArrayOutputStream();\n            final PrintStream hookErrRedirect = new PrintStream(errorByteArray);\n            ProcessResult preCommitHookResult = FS.DETECTED.runIfPresent(repo, Hook.PRE_COMMIT, new String[0], hookOutRedirect, hookErrRedirect, null);\n            if (preCommitHookResult.getStatus() == ProcessResult.Status.OK && preCommitHookResult.getExitCode() != 0) {\n                String errorMessage = MessageFormat.format(JGitText.get().commitRejectedByHook, Hook.PRE_COMMIT.getName(), errorByteArray.toString());\n                throw new RejectCommitException(errorMessage);\n            }\n        }\n        processOptions(state, rw);\n        if (all && !repo.isBare() && repo.getWorkTree() != null) {\n            Git git = new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId == null && amend)\n            throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n        if (headId != null)\n            if (amend) {\n                RevCommit previousCommit = rw.parseCommit(headId);\n                for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                if (author == null)\n                    author = previousCommit.getAuthorIdent();\n            } else {\n                parents.add(0, headId);\n            }\n        DirCache index = repo.lockDirCache();\n        try {\n            if (!only.isEmpty())\n                index = createTemporaryIndex(headId, index, rw);\n            ObjectInserter odi = repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId = index.writeTree(odi);\n                if (insertChangeId)\n                    insertChangeId(indexTreeId);\n                CommitBuilder commit = new CommitBuilder();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId = odi.insert(commit);\n                odi.flush();\n                RevCommit revCommit = rw.parseCommit(commitId);\n                RefUpdate ru = repo.updateRef(Constants.HEAD);\n                ru.setNewObjectId(commitId);\n                if (reflogComment != null) {\n                    ru.setRefLogMessage(reflogComment, false);\n                } else {\n                    String prefix = amend ? \"commit (amend): \" : parents.size() == 0 ? \"commit (initial): \" : \"commit: \";\n                    ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                }\n                if (headId != null)\n                    ru.setExpectedOldObjectId(headId);\n                else\n                    ru.setExpectedOldObjectId(ObjectId.zeroId());\n                Result rc = ru.forceUpdate();\n                switch(rc) {\n                    case NEW:\n                    case FORCED:\n                    case FAST_FORWARD:\n                        {\n                            setCallable(false);\n                            if (state == RepositoryState.MERGING_RESOLVED || isMergeDuringRebase(state)) {\n                                repo.writeMergeCommitMsg(null);\n                                repo.writeMergeHeads(null);\n                            } else if (state == RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                repo.writeMergeCommitMsg(null);\n                                repo.writeCherryPickHead(null);\n                            } else if (state == RepositoryState.REVERTING_RESOLVED) {\n                                repo.writeMergeCommitMsg(null);\n                                repo.writeRevertHead(null);\n                            }\n                            return revCommit;\n                        }\n                    case REJECTED:\n                    case LOCK_FAILURE:\n                        throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                    default:\n                        throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw new UnmergedPathsException(e);\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    } finally {\n        rw.dispose();\n    }\n}"
    },
    {
      "commit": "e0fbae5dc3fc2345383ec373b384fcca10e64f24",
      "startLine": 6,
      "endLine": 9,
      "methodCode": "public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException {\n    checkCallable();\n    Collections.sort(only);\n    RevWalk rw = new RevWalk(repo);\n    try {\n        RepositoryState state = repo.getRepositoryState();\n        if (!state.canCommit())\n            throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n        processOptions(state, rw);\n        if (all && !repo.isBare() && repo.getWorkTree() != null) {\n            Git git = new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId == null && amend)\n            throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n        if (headId != null)\n            if (amend) {\n                RevCommit previousCommit = rw.parseCommit(headId);\n                for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                if (author == null)\n                    author = previousCommit.getAuthorIdent();\n            } else {\n                parents.add(0, headId);\n            }\n        DirCache index = repo.lockDirCache();\n        try {\n            if (!only.isEmpty())\n                index = createTemporaryIndex(headId, index, rw);\n            ObjectInserter odi = repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId = index.writeTree(odi);\n                if (insertChangeId)\n                    insertChangeId(indexTreeId);\n                CommitBuilder commit = new CommitBuilder();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId = odi.insert(commit);\n                odi.flush();\n                RevCommit revCommit = rw.parseCommit(commitId);\n                RefUpdate ru = repo.updateRef(Constants.HEAD);\n                ru.setNewObjectId(commitId);\n                if (reflogComment != null) {\n                    ru.setRefLogMessage(reflogComment, false);\n                } else {\n                    String prefix = amend ? \"commit (amend): \" : parents.size() == 0 ? \"commit (initial): \" : \"commit: \";\n                    ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                }\n                if (headId != null)\n                    ru.setExpectedOldObjectId(headId);\n                else\n                    ru.setExpectedOldObjectId(ObjectId.zeroId());\n                Result rc = ru.forceUpdate();\n                switch(rc) {\n                    case NEW:\n                    case FORCED:\n                    case FAST_FORWARD:\n                        {\n                            setCallable(false);\n                            if (state == RepositoryState.MERGING_RESOLVED || isMergeDuringRebase(state)) {\n                                repo.writeMergeCommitMsg(null);\n                                repo.writeMergeHeads(null);\n                            } else if (state == RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                repo.writeMergeCommitMsg(null);\n                                repo.writeCherryPickHead(null);\n                            } else if (state == RepositoryState.REVERTING_RESOLVED) {\n                                repo.writeMergeCommitMsg(null);\n                                repo.writeRevertHead(null);\n                            }\n                            return revCommit;\n                        }\n                    case REJECTED:\n                    case LOCK_FAILURE:\n                        throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                    default:\n                        throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw new UnmergedPathsException(e);\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    } finally {\n        rw.dispose();\n    }\n}"
    },
    {
      "commit": "a2b33a8ac33c63eea82f300b802a26af54a3d61d",
      "startLine": 6,
      "endLine": 9,
      "methodCode": "public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException {\n    checkCallable();\n    Collections.sort(only);\n    RevWalk rw = new RevWalk(repo);\n    try {\n        RepositoryState state = repo.getRepositoryState();\n        if (!state.canCommit())\n            throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n        processOptions(state, rw);\n        if (all && !repo.isBare() && repo.getWorkTree() != null) {\n            Git git = new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId == null && amend)\n            throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n        if (headId != null)\n            if (amend) {\n                RevCommit previousCommit = rw.parseCommit(headId);\n                for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                if (author == null)\n                    author = previousCommit.getAuthorIdent();\n            } else {\n                parents.add(0, headId);\n            }\n        DirCache index = repo.lockDirCache();\n        try {\n            if (!only.isEmpty())\n                index = createTemporaryIndex(headId, index, rw);\n            ObjectInserter odi = repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId = index.writeTree(odi);\n                if (insertChangeId)\n                    insertChangeId(indexTreeId);\n                CommitBuilder commit = new CommitBuilder();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId = odi.insert(commit);\n                odi.flush();\n                RevCommit revCommit = rw.parseCommit(commitId);\n                RefUpdate ru = repo.updateRef(Constants.HEAD);\n                ru.setNewObjectId(commitId);\n                if (reflogComment != null) {\n                    ru.setRefLogMessage(reflogComment, false);\n                } else {\n                    String prefix = amend ? \"commit (amend): \" : parents.size() == 0 ? \"commit (initial): \" : \"commit: \";\n                    ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                }\n                if (headId != null)\n                    ru.setExpectedOldObjectId(headId);\n                else\n                    ru.setExpectedOldObjectId(ObjectId.zeroId());\n                Result rc = ru.forceUpdate();\n                switch(rc) {\n                    case NEW:\n                    case FORCED:\n                    case FAST_FORWARD:\n                        {\n                            setCallable(false);\n                            if (state == RepositoryState.MERGING_RESOLVED) {\n                                repo.writeMergeCommitMsg(null);\n                                repo.writeMergeHeads(null);\n                            } else if (state == RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                repo.writeMergeCommitMsg(null);\n                                repo.writeCherryPickHead(null);\n                            } else if (state == RepositoryState.REVERTING_RESOLVED) {\n                                repo.writeMergeCommitMsg(null);\n                                repo.writeRevertHead(null);\n                            }\n                            return revCommit;\n                        }\n                    case REJECTED:\n                    case LOCK_FAILURE:\n                        throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                    default:\n                        throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw new UnmergedPathsException(e);\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    } finally {\n        rw.dispose();\n    }\n}"
    },
    {
      "commit": "c93a59330249677cd990820b59558a39f747009f",
      "startLine": 6,
      "endLine": 9,
      "methodCode": "public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException {\n    checkCallable();\n    Collections.sort(only);\n    RevWalk rw = new RevWalk(repo);\n    try {\n        RepositoryState state = repo.getRepositoryState();\n        if (!state.canCommit())\n            throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n        processOptions(state, rw);\n        if (all && !repo.isBare() && repo.getWorkTree() != null) {\n            Git git = new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId == null && amend)\n            throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n        if (headId != null)\n            if (amend) {\n                RevCommit previousCommit = rw.parseCommit(headId);\n                for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                if (author == null)\n                    author = previousCommit.getAuthorIdent();\n            } else {\n                parents.add(0, headId);\n            }\n        DirCache index = repo.lockDirCache();\n        try {\n            if (!only.isEmpty())\n                index = createTemporaryIndex(headId, index, rw);\n            ObjectInserter odi = repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId = index.writeTree(odi);\n                if (insertChangeId)\n                    insertChangeId(indexTreeId);\n                CommitBuilder commit = new CommitBuilder();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId = odi.insert(commit);\n                odi.flush();\n                RevCommit revCommit = rw.parseCommit(commitId);\n                RefUpdate ru = repo.updateRef(Constants.HEAD);\n                ru.setNewObjectId(commitId);\n                if (reflogComment != null) {\n                    ru.setRefLogMessage(reflogComment, false);\n                } else {\n                    String prefix = amend ? \"commit (amend): \" : parents.size() == 0 ? \"commit (initial): \" : \"commit: \";\n                    ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                }\n                if (headId != null)\n                    ru.setExpectedOldObjectId(headId);\n                else\n                    ru.setExpectedOldObjectId(ObjectId.zeroId());\n                Result rc = ru.forceUpdate();\n                switch(rc) {\n                    case NEW:\n                    case FORCED:\n                    case FAST_FORWARD:\n                        {\n                            setCallable(false);\n                            if (state == RepositoryState.MERGING_RESOLVED) {\n                                repo.writeMergeCommitMsg(null);\n                                repo.writeMergeHeads(null);\n                            } else if (state == RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                repo.writeMergeCommitMsg(null);\n                                repo.writeCherryPickHead(null);\n                            } else if (state == RepositoryState.REVERTING_RESOLVED) {\n                                repo.writeMergeCommitMsg(null);\n                                repo.writeRevertHead(null);\n                            }\n                            return revCommit;\n                        }\n                    case REJECTED:\n                    case LOCK_FAILURE:\n                        throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                    default:\n                        throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw new UnmergedPathsException(e);\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    } finally {\n        rw.dispose();\n    }\n}"
    },
    {
      "commit": "65027d8bb429581635f51d0c588493e5c458cc25",
      "startLine": 4,
      "endLine": 7,
      "methodCode": "public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException {\n    checkCallable();\n    Collections.sort(only);\n    RepositoryState state = repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        if (all && !repo.isBare() && repo.getWorkTree() != null) {\n            Git git = new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId == null && amend)\n            throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n        if (headId != null)\n            if (amend) {\n                RevCommit previousCommit = new RevWalk(repo).parseCommit(headId);\n                for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                if (author == null)\n                    author = previousCommit.getAuthorIdent();\n            } else {\n                parents.add(0, headId);\n            }\n        DirCache index = repo.lockDirCache();\n        try {\n            if (!only.isEmpty())\n                index = createTemporaryIndex(headId, index);\n            ObjectInserter odi = repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId = index.writeTree(odi);\n                if (insertChangeId)\n                    insertChangeId(indexTreeId);\n                CommitBuilder commit = new CommitBuilder();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId = odi.insert(commit);\n                odi.flush();\n                RevWalk revWalk = new RevWalk(repo);\n                try {\n                    RevCommit revCommit = revWalk.parseCommit(commitId);\n                    RefUpdate ru = repo.updateRef(Constants.HEAD);\n                    ru.setNewObjectId(commitId);\n                    if (reflogComment != null) {\n                        ru.setRefLogMessage(reflogComment, false);\n                    } else {\n                        String prefix = amend ? \"commit (amend): \" : parents.size() == 0 ? \"commit (initial): \" : \"commit: \";\n                        ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                    }\n                    if (headId != null)\n                        ru.setExpectedOldObjectId(headId);\n                    else\n                        ru.setExpectedOldObjectId(ObjectId.zeroId());\n                    Result rc = ru.forceUpdate();\n                    switch(rc) {\n                        case NEW:\n                        case FORCED:\n                        case FAST_FORWARD:\n                            {\n                                setCallable(false);\n                                if (state == RepositoryState.MERGING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeMergeHeads(null);\n                                } else if (state == RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeCherryPickHead(null);\n                                } else if (state == RepositoryState.REVERTING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeRevertHead(null);\n                                }\n                                return revCommit;\n                            }\n                        case REJECTED:\n                        case LOCK_FAILURE:\n                            throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                        default:\n                            throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                    }\n                } finally {\n                    revWalk.release();\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw new UnmergedPathsException(e);\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}"
    },
    {
      "commit": "1f51aecf95d61e48618d478a693f73dcf1ec1146",
      "startLine": 4,
      "endLine": 7,
      "methodCode": "public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException {\n    checkCallable();\n    Collections.sort(only);\n    RepositoryState state = repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        if (all && !repo.isBare() && repo.getWorkTree() != null) {\n            Git git = new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId == null && amend)\n            throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n        if (headId != null)\n            if (amend) {\n                RevCommit previousCommit = new RevWalk(repo).parseCommit(headId);\n                for (RevCommit p : previousCommit.getParents()) parents.add(p.getId());\n                if (author == null)\n                    author = previousCommit.getAuthorIdent();\n            } else {\n                parents.add(0, headId);\n            }\n        DirCache index = repo.lockDirCache();\n        try {\n            if (!only.isEmpty())\n                index = createTemporaryIndex(headId, index);\n            ObjectInserter odi = repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId = index.writeTree(odi);\n                if (insertChangeId)\n                    insertChangeId(indexTreeId);\n                CommitBuilder commit = new CommitBuilder();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId = odi.insert(commit);\n                odi.flush();\n                RevWalk revWalk = new RevWalk(repo);\n                try {\n                    RevCommit revCommit = revWalk.parseCommit(commitId);\n                    RefUpdate ru = repo.updateRef(Constants.HEAD);\n                    ru.setNewObjectId(commitId);\n                    if (reflogComment != null) {\n                        ru.setRefLogMessage(reflogComment, false);\n                    } else {\n                        String prefix = amend ? \"commit (amend): \" : \"commit: \";\n                        ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                    }\n                    if (headId != null)\n                        ru.setExpectedOldObjectId(headId);\n                    else\n                        ru.setExpectedOldObjectId(ObjectId.zeroId());\n                    Result rc = ru.forceUpdate();\n                    switch(rc) {\n                        case NEW:\n                        case FORCED:\n                        case FAST_FORWARD:\n                            {\n                                setCallable(false);\n                                if (state == RepositoryState.MERGING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeMergeHeads(null);\n                                } else if (state == RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeCherryPickHead(null);\n                                } else if (state == RepositoryState.REVERTING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeRevertHead(null);\n                                }\n                                return revCommit;\n                            }\n                        case REJECTED:\n                        case LOCK_FAILURE:\n                            throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                        default:\n                            throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                    }\n                } finally {\n                    revWalk.release();\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw new UnmergedPathsException(e);\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}"
    },
    {
      "commit": "549034500a55ffc8f401fd73a74d8dc55f096d2f",
      "startLine": 4,
      "endLine": 7,
      "methodCode": "public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException {\n    checkCallable();\n    Collections.sort(only);\n    RepositoryState state = repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        if (all && !repo.isBare() && repo.getWorkTree() != null) {\n            Git git = new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId == null && amend)\n            throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n        if (headId != null)\n            if (amend) {\n                RevCommit previousCommit = new RevWalk(repo).parseCommit(headId);\n                RevCommit[] p = previousCommit.getParents();\n                for (int i = 0; i < p.length; i++) parents.add(0, p[i].getId());\n                if (author == null)\n                    author = previousCommit.getAuthorIdent();\n            } else {\n                parents.add(0, headId);\n            }\n        DirCache index = repo.lockDirCache();\n        try {\n            if (!only.isEmpty())\n                index = createTemporaryIndex(headId, index);\n            ObjectInserter odi = repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId = index.writeTree(odi);\n                if (insertChangeId)\n                    insertChangeId(indexTreeId);\n                CommitBuilder commit = new CommitBuilder();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId = odi.insert(commit);\n                odi.flush();\n                RevWalk revWalk = new RevWalk(repo);\n                try {\n                    RevCommit revCommit = revWalk.parseCommit(commitId);\n                    RefUpdate ru = repo.updateRef(Constants.HEAD);\n                    ru.setNewObjectId(commitId);\n                    if (reflogComment != null) {\n                        ru.setRefLogMessage(reflogComment, false);\n                    } else {\n                        String prefix = amend ? \"commit (amend): \" : \"commit: \";\n                        ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                    }\n                    if (headId != null)\n                        ru.setExpectedOldObjectId(headId);\n                    else\n                        ru.setExpectedOldObjectId(ObjectId.zeroId());\n                    Result rc = ru.forceUpdate();\n                    switch(rc) {\n                        case NEW:\n                        case FORCED:\n                        case FAST_FORWARD:\n                            {\n                                setCallable(false);\n                                if (state == RepositoryState.MERGING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeMergeHeads(null);\n                                } else if (state == RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeCherryPickHead(null);\n                                } else if (state == RepositoryState.REVERTING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeRevertHead(null);\n                                }\n                                return revCommit;\n                            }\n                        case REJECTED:\n                        case LOCK_FAILURE:\n                            throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                        default:\n                            throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                    }\n                } finally {\n                    revWalk.release();\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw new UnmergedPathsException(e);\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}"
    },
    {
      "commit": "315f1cfa5c63f4d3355704c80d00ac1323a36171",
      "startLine": 3,
      "endLine": 6,
      "methodCode": "public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException {\n    checkCallable();\n    RepositoryState state = repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        if (all && !repo.isBare() && repo.getWorkTree() != null) {\n            Git git = new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId == null && amend)\n            throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n        if (headId != null)\n            if (amend) {\n                RevCommit previousCommit = new RevWalk(repo).parseCommit(headId);\n                RevCommit[] p = previousCommit.getParents();\n                for (int i = 0; i < p.length; i++) parents.add(0, p[i].getId());\n                if (author == null)\n                    author = previousCommit.getAuthorIdent();\n            } else {\n                parents.add(0, headId);\n            }\n        DirCache index = repo.lockDirCache();\n        try {\n            if (!only.isEmpty())\n                index = createTemporaryIndex(headId, index);\n            ObjectInserter odi = repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId = index.writeTree(odi);\n                if (insertChangeId)\n                    insertChangeId(indexTreeId);\n                CommitBuilder commit = new CommitBuilder();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId = odi.insert(commit);\n                odi.flush();\n                RevWalk revWalk = new RevWalk(repo);\n                try {\n                    RevCommit revCommit = revWalk.parseCommit(commitId);\n                    RefUpdate ru = repo.updateRef(Constants.HEAD);\n                    ru.setNewObjectId(commitId);\n                    if (reflogComment != null) {\n                        ru.setRefLogMessage(reflogComment, false);\n                    } else {\n                        String prefix = amend ? \"commit (amend): \" : \"commit: \";\n                        ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                    }\n                    if (headId != null)\n                        ru.setExpectedOldObjectId(headId);\n                    else\n                        ru.setExpectedOldObjectId(ObjectId.zeroId());\n                    Result rc = ru.forceUpdate();\n                    switch(rc) {\n                        case NEW:\n                        case FORCED:\n                        case FAST_FORWARD:\n                            {\n                                setCallable(false);\n                                if (state == RepositoryState.MERGING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeMergeHeads(null);\n                                } else if (state == RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeCherryPickHead(null);\n                                } else if (state == RepositoryState.REVERTING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeRevertHead(null);\n                                }\n                                return revCommit;\n                            }\n                        case REJECTED:\n                        case LOCK_FAILURE:\n                            throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                        default:\n                            throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                    }\n                } finally {\n                    revWalk.release();\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw new UnmergedPathsException(e);\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}"
    },
    {
      "commit": "c310fa0c802f40a774edb58641de3ac5bfad0e2c",
      "startLine": 3,
      "endLine": 6,
      "methodCode": "public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException {\n    checkCallable();\n    RepositoryState state = repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        if (all && !repo.isBare() && repo.getWorkTree() != null) {\n            Git git = new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId == null && amend)\n            throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n        if (headId != null)\n            if (amend) {\n                RevCommit previousCommit = new RevWalk(repo).parseCommit(headId);\n                RevCommit[] p = previousCommit.getParents();\n                for (int i = 0; i < p.length; i++) parents.add(0, p[i].getId());\n                if (author == null)\n                    author = previousCommit.getAuthorIdent();\n            } else {\n                parents.add(0, headId);\n            }\n        DirCache index = repo.lockDirCache();\n        try {\n            if (!only.isEmpty())\n                index = createTemporaryIndex(headId, index);\n            ObjectInserter odi = repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId = index.writeTree(odi);\n                if (insertChangeId)\n                    insertChangeId(indexTreeId);\n                CommitBuilder commit = new CommitBuilder();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId = odi.insert(commit);\n                odi.flush();\n                RevWalk revWalk = new RevWalk(repo);\n                try {\n                    RevCommit revCommit = revWalk.parseCommit(commitId);\n                    RefUpdate ru = repo.updateRef(Constants.HEAD);\n                    ru.setNewObjectId(commitId);\n                    if (reflogComment != null) {\n                        ru.setRefLogMessage(reflogComment, false);\n                    } else {\n                        String prefix = amend ? \"commit (amend): \" : \"commit: \";\n                        ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                    }\n                    if (headId != null)\n                        ru.setExpectedOldObjectId(headId);\n                    else\n                        ru.setExpectedOldObjectId(ObjectId.zeroId());\n                    Result rc = ru.forceUpdate();\n                    switch(rc) {\n                        case NEW:\n                        case FORCED:\n                        case FAST_FORWARD:\n                            {\n                                setCallable(false);\n                                if (state == RepositoryState.MERGING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeMergeHeads(null);\n                                } else if (state == RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeCherryPickHead(null);\n                                }\n                                return revCommit;\n                            }\n                        case REJECTED:\n                        case LOCK_FAILURE:\n                            throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                        default:\n                            throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                    }\n                } finally {\n                    revWalk.release();\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw new UnmergedPathsException(e);\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}"
    },
    {
      "commit": "79f33419ec073edf31a1db16ae9b11e69ee997a1",
      "startLine": 3,
      "endLine": 6,
      "methodCode": "public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException {\n    checkCallable();\n    RepositoryState state = repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        if (all && !repo.isBare() && repo.getWorkTree() != null) {\n            Git git = new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId == null && amend)\n            throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n        if (headId != null)\n            if (amend) {\n                RevCommit previousCommit = new RevWalk(repo).parseCommit(headId);\n                RevCommit[] p = previousCommit.getParents();\n                for (int i = 0; i < p.length; i++) parents.add(0, p[i].getId());\n                if (author == null)\n                    author = previousCommit.getAuthorIdent();\n            } else {\n                parents.add(0, headId);\n            }\n        DirCache index = repo.lockDirCache();\n        try {\n            if (!only.isEmpty())\n                index = createTemporaryIndex(headId, index);\n            ObjectInserter odi = repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId = index.writeTree(odi);\n                if (insertChangeId)\n                    insertChangeId(indexTreeId);\n                CommitBuilder commit = new CommitBuilder();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId = odi.insert(commit);\n                odi.flush();\n                RevWalk revWalk = new RevWalk(repo);\n                try {\n                    RevCommit revCommit = revWalk.parseCommit(commitId);\n                    RefUpdate ru = repo.updateRef(Constants.HEAD);\n                    ru.setNewObjectId(commitId);\n                    if (reflogComment != null) {\n                        ru.setRefLogMessage(reflogComment, false);\n                    } else {\n                        String prefix = amend ? \"commit (amend): \" : \"commit: \";\n                        ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                    }\n                    if (headId != null)\n                        ru.setExpectedOldObjectId(headId);\n                    else\n                        ru.setExpectedOldObjectId(ObjectId.zeroId());\n                    Result rc = ru.forceUpdate();\n                    switch(rc) {\n                        case NEW:\n                        case FORCED:\n                        case FAST_FORWARD:\n                            {\n                                setCallable(false);\n                                if (state == RepositoryState.MERGING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeMergeHeads(null);\n                                } else if (state == RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeCherryPickHead(null);\n                                }\n                                return revCommit;\n                            }\n                        case REJECTED:\n                        case LOCK_FAILURE:\n                            throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                        default:\n                            throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                    }\n                } finally {\n                    revWalk.release();\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw new UnmergedPathsException(e);\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}"
    },
    {
      "commit": "c96b40d5921d68edb96afad38b9c171388af4e05",
      "startLine": 3,
      "endLine": 6,
      "methodCode": "public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException {\n    checkCallable();\n    RepositoryState state = repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        if (all && !repo.isBare() && repo.getWorkTree() != null) {\n            Git git = new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId == null && amend)\n            throw new WrongRepositoryStateException(JGitText.get().commitAmendOnInitialNotPossible);\n        if (headId != null)\n            if (amend) {\n                RevCommit previousCommit = new RevWalk(repo).parseCommit(headId);\n                RevCommit[] p = previousCommit.getParents();\n                for (int i = 0; i < p.length; i++) parents.add(0, p[i].getId());\n            } else {\n                parents.add(0, headId);\n            }\n        DirCache index = repo.lockDirCache();\n        try {\n            if (!only.isEmpty())\n                index = createTemporaryIndex(headId, index);\n            ObjectInserter odi = repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId = index.writeTree(odi);\n                if (insertChangeId)\n                    insertChangeId(indexTreeId);\n                CommitBuilder commit = new CommitBuilder();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId = odi.insert(commit);\n                odi.flush();\n                RevWalk revWalk = new RevWalk(repo);\n                try {\n                    RevCommit revCommit = revWalk.parseCommit(commitId);\n                    RefUpdate ru = repo.updateRef(Constants.HEAD);\n                    ru.setNewObjectId(commitId);\n                    if (reflogComment != null) {\n                        ru.setRefLogMessage(reflogComment, false);\n                    } else {\n                        String prefix = amend ? \"commit (amend): \" : \"commit: \";\n                        ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                    }\n                    if (headId != null)\n                        ru.setExpectedOldObjectId(headId);\n                    else\n                        ru.setExpectedOldObjectId(ObjectId.zeroId());\n                    Result rc = ru.forceUpdate();\n                    switch(rc) {\n                        case NEW:\n                        case FORCED:\n                        case FAST_FORWARD:\n                            {\n                                setCallable(false);\n                                if (state == RepositoryState.MERGING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeMergeHeads(null);\n                                } else if (state == RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeCherryPickHead(null);\n                                }\n                                return revCommit;\n                            }\n                        case REJECTED:\n                        case LOCK_FAILURE:\n                            throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                        default:\n                            throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                    }\n                } finally {\n                    revWalk.release();\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw new UnmergedPathsException(e);\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}"
    },
    {
      "commit": "4e1454ded6e2fcf6cb789c004756883c3ea5f77e",
      "startLine": 3,
      "endLine": 6,
      "methodCode": "public RevCommit call() throws GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException {\n    checkCallable();\n    RepositoryState state = repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        if (all && !repo.isBare() && repo.getWorkTree() != null) {\n            Git git = new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId != null)\n            if (amend) {\n                RevCommit previousCommit = new RevWalk(repo).parseCommit(headId);\n                RevCommit[] p = previousCommit.getParents();\n                for (int i = 0; i < p.length; i++) parents.add(0, p[i].getId());\n            } else {\n                parents.add(0, headId);\n            }\n        DirCache index = repo.lockDirCache();\n        try {\n            if (!only.isEmpty())\n                index = createTemporaryIndex(headId, index);\n            ObjectInserter odi = repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId = index.writeTree(odi);\n                if (insertChangeId)\n                    insertChangeId(indexTreeId);\n                CommitBuilder commit = new CommitBuilder();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId = odi.insert(commit);\n                odi.flush();\n                RevWalk revWalk = new RevWalk(repo);\n                try {\n                    RevCommit revCommit = revWalk.parseCommit(commitId);\n                    RefUpdate ru = repo.updateRef(Constants.HEAD);\n                    ru.setNewObjectId(commitId);\n                    if (reflogComment != null) {\n                        ru.setRefLogMessage(reflogComment, false);\n                    } else {\n                        String prefix = amend ? \"commit (amend): \" : \"commit: \";\n                        ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                    }\n                    if (headId != null)\n                        ru.setExpectedOldObjectId(headId);\n                    else\n                        ru.setExpectedOldObjectId(ObjectId.zeroId());\n                    Result rc = ru.forceUpdate();\n                    switch(rc) {\n                        case NEW:\n                        case FORCED:\n                        case FAST_FORWARD:\n                            {\n                                setCallable(false);\n                                if (state == RepositoryState.MERGING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeMergeHeads(null);\n                                } else if (state == RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeCherryPickHead(null);\n                                }\n                                return revCommit;\n                            }\n                        case REJECTED:\n                        case LOCK_FAILURE:\n                            throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                        default:\n                            throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                    }\n                } finally {\n                    revWalk.release();\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw new UnmergedPathsException(e);\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}"
    },
    {
      "commit": "2539b1ee096266b7fcca64545f93d7c08ab30f53",
      "startLine": 3,
      "endLine": 6,
      "methodCode": "public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n    checkCallable();\n    RepositoryState state = repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        if (all && !repo.isBare() && repo.getWorkTree() != null) {\n            Git git = new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId != null)\n            if (amend) {\n                RevCommit previousCommit = new RevWalk(repo).parseCommit(headId);\n                RevCommit[] p = previousCommit.getParents();\n                for (int i = 0; i < p.length; i++) parents.add(0, p[i].getId());\n            } else {\n                parents.add(0, headId);\n            }\n        DirCache index = repo.lockDirCache();\n        try {\n            if (!only.isEmpty())\n                index = createTemporaryIndex(headId, index);\n            ObjectInserter odi = repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId = index.writeTree(odi);\n                if (insertChangeId)\n                    insertChangeId(indexTreeId);\n                CommitBuilder commit = new CommitBuilder();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId = odi.insert(commit);\n                odi.flush();\n                RevWalk revWalk = new RevWalk(repo);\n                try {\n                    RevCommit revCommit = revWalk.parseCommit(commitId);\n                    RefUpdate ru = repo.updateRef(Constants.HEAD);\n                    ru.setNewObjectId(commitId);\n                    if (reflogComment != null) {\n                        ru.setRefLogMessage(reflogComment, false);\n                    } else {\n                        String prefix = amend ? \"commit (amend): \" : \"commit: \";\n                        ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                    }\n                    if (headId != null)\n                        ru.setExpectedOldObjectId(headId);\n                    else\n                        ru.setExpectedOldObjectId(ObjectId.zeroId());\n                    Result rc = ru.forceUpdate();\n                    switch(rc) {\n                        case NEW:\n                        case FORCED:\n                        case FAST_FORWARD:\n                            {\n                                setCallable(false);\n                                if (state == RepositoryState.MERGING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeMergeHeads(null);\n                                } else if (state == RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeCherryPickHead(null);\n                                }\n                                return revCommit;\n                            }\n                        case REJECTED:\n                        case LOCK_FAILURE:\n                            throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                        default:\n                            throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                    }\n                } finally {\n                    revWalk.release();\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw e;\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}"
    },
    {
      "commit": "4f4e468f6f344ed7c106b86b850d2c9171dd1a0f",
      "startLine": 3,
      "endLine": 6,
      "methodCode": "public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n    checkCallable();\n    RepositoryState state = repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        if (all && !repo.isBare() && repo.getWorkTree() != null) {\n            Git git = new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId != null)\n            if (amend) {\n                RevCommit previousCommit = new RevWalk(repo).parseCommit(headId);\n                RevCommit[] p = previousCommit.getParents();\n                for (int i = 0; i < p.length; i++) parents.add(0, p[i].getId());\n            } else {\n                parents.add(0, headId);\n            }\n        DirCache index = repo.lockDirCache();\n        try {\n            if (!only.isEmpty())\n                index = createTemporaryIndex(headId, index);\n            ObjectInserter odi = repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId = index.writeTree(odi);\n                if (insertChangeId)\n                    insertChangeId(indexTreeId);\n                CommitBuilder commit = new CommitBuilder();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId = odi.insert(commit);\n                odi.flush();\n                RevWalk revWalk = new RevWalk(repo);\n                try {\n                    RevCommit revCommit = revWalk.parseCommit(commitId);\n                    RefUpdate ru = repo.updateRef(Constants.HEAD);\n                    ru.setNewObjectId(commitId);\n                    if (reflogComment != null) {\n                        ru.setRefLogMessage(reflogComment, false);\n                    } else {\n                        String prefix = amend ? \"commit (amend): \" : \"commit: \";\n                        ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                    }\n                    ru.setExpectedOldObjectId(headId);\n                    Result rc = ru.forceUpdate();\n                    switch(rc) {\n                        case NEW:\n                        case FORCED:\n                        case FAST_FORWARD:\n                            {\n                                setCallable(false);\n                                if (state == RepositoryState.MERGING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeMergeHeads(null);\n                                } else if (state == RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeCherryPickHead(null);\n                                }\n                                return revCommit;\n                            }\n                        case REJECTED:\n                        case LOCK_FAILURE:\n                            throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                        default:\n                            throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                    }\n                } finally {\n                    revWalk.release();\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw e;\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}"
    },
    {
      "commit": "6e10aa42e90a25b82f00f0c27574f57ffa9e4a25",
      "startLine": 3,
      "endLine": 6,
      "methodCode": "public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n    checkCallable();\n    RepositoryState state = repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        if (all && !repo.isBare() && repo.getWorkTree() != null) {\n            Git git = new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId != null)\n            if (amend) {\n                RevCommit previousCommit = new RevWalk(repo).parseCommit(headId);\n                RevCommit[] p = previousCommit.getParents();\n                for (int i = 0; i < p.length; i++) parents.add(0, p[i].getId());\n            } else {\n                parents.add(0, headId);\n            }\n        DirCache index = repo.lockDirCache();\n        try {\n            if (!only.isEmpty())\n                index = createTemporaryIndex(headId, index);\n            ObjectInserter odi = repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId = index.writeTree(odi);\n                if (insertChangeId)\n                    insertChangeId(indexTreeId);\n                CommitBuilder commit = new CommitBuilder();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId = odi.insert(commit);\n                odi.flush();\n                RevWalk revWalk = new RevWalk(repo);\n                try {\n                    RevCommit revCommit = revWalk.parseCommit(commitId);\n                    RefUpdate ru = repo.updateRef(Constants.HEAD);\n                    ru.setNewObjectId(commitId);\n                    String prefix = amend ? \"commit (amend): \" : \"commit: \";\n                    ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                    ru.setExpectedOldObjectId(headId);\n                    Result rc = ru.forceUpdate();\n                    switch(rc) {\n                        case NEW:\n                        case FORCED:\n                        case FAST_FORWARD:\n                            {\n                                setCallable(false);\n                                if (state == RepositoryState.MERGING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeMergeHeads(null);\n                                } else if (state == RepositoryState.CHERRY_PICKING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeCherryPickHead(null);\n                                }\n                                return revCommit;\n                            }\n                        case REJECTED:\n                        case LOCK_FAILURE:\n                            throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                        default:\n                            throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                    }\n                } finally {\n                    revWalk.release();\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw e;\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}"
    },
    {
      "commit": "fd963a9180af73b6a05a5c1a2af6dd7168899170",
      "startLine": 3,
      "endLine": 6,
      "methodCode": "public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n    checkCallable();\n    RepositoryState state = repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        if (all && !repo.isBare() && repo.getWorkTree() != null) {\n            Git git = new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId != null)\n            if (amend) {\n                RevCommit previousCommit = new RevWalk(repo).parseCommit(headId);\n                RevCommit[] p = previousCommit.getParents();\n                for (int i = 0; i < p.length; i++) parents.add(0, p[i].getId());\n            } else {\n                parents.add(0, headId);\n            }\n        DirCache index = repo.lockDirCache();\n        try {\n            if (!only.isEmpty())\n                index = createTemporaryIndex(headId, index);\n            ObjectInserter odi = repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId = index.writeTree(odi);\n                if (insertChangeId)\n                    insertChangeId(indexTreeId);\n                CommitBuilder commit = new CommitBuilder();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId = odi.insert(commit);\n                odi.flush();\n                RevWalk revWalk = new RevWalk(repo);\n                try {\n                    RevCommit revCommit = revWalk.parseCommit(commitId);\n                    RefUpdate ru = repo.updateRef(Constants.HEAD);\n                    ru.setNewObjectId(commitId);\n                    String prefix = amend ? \"commit (amend): \" : \"commit: \";\n                    ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                    ru.setExpectedOldObjectId(headId);\n                    Result rc = ru.forceUpdate();\n                    switch(rc) {\n                        case NEW:\n                        case FORCED:\n                        case FAST_FORWARD:\n                            {\n                                setCallable(false);\n                                if (state == RepositoryState.MERGING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeMergeHeads(null);\n                                }\n                                return revCommit;\n                            }\n                        case REJECTED:\n                        case LOCK_FAILURE:\n                            throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                        default:\n                            throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                    }\n                } finally {\n                    revWalk.release();\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw e;\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}"
    },
    {
      "commit": "9830baf48dd5b3feb9780a3cc1d83b79e1d4c46b",
      "startLine": 3,
      "endLine": 6,
      "methodCode": "public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n    checkCallable();\n    RepositoryState state = repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        if (all && !repo.isBare() && repo.getWorkTree() != null) {\n            Git git = new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId != null)\n            if (amend) {\n                RevCommit previousCommit = new RevWalk(repo).parseCommit(headId);\n                RevCommit[] p = previousCommit.getParents();\n                for (int i = 0; i < p.length; i++) parents.add(0, p[i].getId());\n            } else {\n                parents.add(0, headId);\n            }\n        DirCache index = repo.lockDirCache();\n        try {\n            if (!only.isEmpty())\n                index = createTemporaryIndex(headId, index);\n            ObjectInserter odi = repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId = index.writeTree(odi);\n                CommitBuilder commit = new CommitBuilder();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId = odi.insert(commit);\n                odi.flush();\n                RevWalk revWalk = new RevWalk(repo);\n                try {\n                    RevCommit revCommit = revWalk.parseCommit(commitId);\n                    RefUpdate ru = repo.updateRef(Constants.HEAD);\n                    ru.setNewObjectId(commitId);\n                    String prefix = amend ? \"commit (amend): \" : \"commit: \";\n                    ru.setRefLogMessage(prefix + revCommit.getShortMessage(), false);\n                    ru.setExpectedOldObjectId(headId);\n                    Result rc = ru.forceUpdate();\n                    switch(rc) {\n                        case NEW:\n                        case FORCED:\n                        case FAST_FORWARD:\n                            {\n                                setCallable(false);\n                                if (state == RepositoryState.MERGING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeMergeHeads(null);\n                                }\n                                return revCommit;\n                            }\n                        case REJECTED:\n                        case LOCK_FAILURE:\n                            throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                        default:\n                            throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                    }\n                } finally {\n                    revWalk.release();\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw e;\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}"
    },
    {
      "commit": "a490afedba12676a53338bc52b729b9bb779f3a1",
      "startLine": 3,
      "endLine": 6,
      "methodCode": "public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n    checkCallable();\n    RepositoryState state = repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        if (all && !repo.isBare() && repo.getWorkTree() != null) {\n            Git git = new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId != null)\n            if (amend) {\n                RevCommit previousCommit = new RevWalk(repo).parseCommit(headId);\n                RevCommit[] p = previousCommit.getParents();\n                for (int i = 0; i < p.length; i++) parents.add(0, p[i].getId());\n            } else {\n                parents.add(0, headId);\n            }\n        DirCache index = repo.lockDirCache();\n        try {\n            if (!only.isEmpty())\n                index = createTemporaryIndex(headId, index);\n            ObjectInserter odi = repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId = index.writeTree(odi);\n                CommitBuilder commit = new CommitBuilder();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId = odi.insert(commit);\n                odi.flush();\n                RevWalk revWalk = new RevWalk(repo);\n                try {\n                    RevCommit revCommit = revWalk.parseCommit(commitId);\n                    RefUpdate ru = repo.updateRef(Constants.HEAD);\n                    ru.setNewObjectId(commitId);\n                    ru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(), false);\n                    ru.setExpectedOldObjectId(headId);\n                    Result rc = ru.forceUpdate();\n                    switch(rc) {\n                        case NEW:\n                        case FORCED:\n                        case FAST_FORWARD:\n                            {\n                                setCallable(false);\n                                if (state == RepositoryState.MERGING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeMergeHeads(null);\n                                }\n                                return revCommit;\n                            }\n                        case REJECTED:\n                        case LOCK_FAILURE:\n                            throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                        default:\n                            throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                    }\n                } finally {\n                    revWalk.release();\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw e;\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}"
    },
    {
      "commit": "cda64073fd45d3056486b96877e4ff6dd12dbaa5",
      "startLine": 3,
      "endLine": 6,
      "methodCode": "public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n    checkCallable();\n    RepositoryState state = repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        if (all && !repo.isBare() && repo.getWorkTree() != null) {\n            Git git = new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId != null)\n            if (amend) {\n                RevCommit previousCommit = new RevWalk(repo).parseCommit(headId);\n                RevCommit[] p = previousCommit.getParents();\n                for (int i = 0; i < p.length; i++) parents.add(0, p[i].getId());\n            } else {\n                parents.add(0, headId);\n            }\n        DirCache index = repo.lockDirCache();\n        try {\n            ObjectInserter odi = repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId = index.writeTree(odi);\n                CommitBuilder commit = new CommitBuilder();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId = odi.insert(commit);\n                odi.flush();\n                RevWalk revWalk = new RevWalk(repo);\n                try {\n                    RevCommit revCommit = revWalk.parseCommit(commitId);\n                    RefUpdate ru = repo.updateRef(Constants.HEAD);\n                    ru.setNewObjectId(commitId);\n                    ru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(), false);\n                    ru.setExpectedOldObjectId(headId);\n                    Result rc = ru.forceUpdate();\n                    switch(rc) {\n                        case NEW:\n                        case FORCED:\n                        case FAST_FORWARD:\n                            {\n                                setCallable(false);\n                                if (state == RepositoryState.MERGING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeMergeHeads(null);\n                                }\n                                return revCommit;\n                            }\n                        case REJECTED:\n                        case LOCK_FAILURE:\n                            throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                        default:\n                            throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                    }\n                } finally {\n                    revWalk.release();\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw e;\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}"
    },
    {
      "commit": "e43887b69e27672b80e55391e0ee255efe715ab9",
      "startLine": 3,
      "endLine": 6,
      "methodCode": "public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n    checkCallable();\n    RepositoryState state = repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        if (all && !repo.isBare() && repo.getWorkTree() != null) {\n            Git git = new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId != null)\n            parents.add(0, headId);\n        DirCache index = repo.lockDirCache();\n        try {\n            ObjectInserter odi = repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId = index.writeTree(odi);\n                CommitBuilder commit = new CommitBuilder();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId = odi.insert(commit);\n                odi.flush();\n                RevWalk revWalk = new RevWalk(repo);\n                try {\n                    RevCommit revCommit = revWalk.parseCommit(commitId);\n                    RefUpdate ru = repo.updateRef(Constants.HEAD);\n                    ru.setNewObjectId(commitId);\n                    ru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(), false);\n                    ru.setExpectedOldObjectId(headId);\n                    Result rc = ru.update();\n                    switch(rc) {\n                        case NEW:\n                        case FAST_FORWARD:\n                            {\n                                setCallable(false);\n                                if (state == RepositoryState.MERGING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeMergeHeads(null);\n                                }\n                                return revCommit;\n                            }\n                        case REJECTED:\n                        case LOCK_FAILURE:\n                            throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                        default:\n                            throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                    }\n                } finally {\n                    revWalk.release();\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw e;\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}"
    },
    {
      "commit": "6df5d3397c5c9354409d21a8e207a061f2e6efc2",
      "startLine": 3,
      "endLine": 6,
      "methodCode": "public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n    checkCallable();\n    RepositoryState state = repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        if (all && !repo.isBare() && repo.getWorkTree() != null) {\n            Git git = new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId != null)\n            parents.add(0, headId);\n        DirCache index = repo.lockDirCache();\n        try {\n            ObjectInserter odi = repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId = index.writeTree(odi);\n                CommitBuilder commit = new CommitBuilder();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId = odi.insert(commit);\n                odi.flush();\n                RevWalk revWalk = new RevWalk(repo);\n                try {\n                    RevCommit revCommit = revWalk.parseCommit(commitId);\n                    RefUpdate ru = repo.updateRef(Constants.HEAD);\n                    ru.setNewObjectId(commitId);\n                    ru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(), false);\n                    ru.setExpectedOldObjectId(headId);\n                    Result rc = ru.update();\n                    switch(rc) {\n                        case NEW:\n                        case FAST_FORWARD:\n                            {\n                                setCallable(false);\n                                if (state == RepositoryState.MERGING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeMergeHeads(null);\n                                }\n                                return revCommit;\n                            }\n                        case REJECTED:\n                        case LOCK_FAILURE:\n                            throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                        default:\n                            throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                    }\n                } finally {\n                    revWalk.release();\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw e;\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}"
    },
    {
      "commit": "22b285695a2980824c15363ef5fec709ebc3d434",
      "startLine": 3,
      "endLine": 6,
      "methodCode": "public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n    checkCallable();\n    RepositoryState state = repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        if (all && !repo.isBare() && repo.getWorkTree() != null) {\n            Git git = new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId != null)\n            parents.add(0, headId);\n        DirCache index = repo.lockDirCache();\n        try {\n            ObjectInserter odi = repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId = index.writeTree(odi);\n                CommitBuilder commit = new CommitBuilder();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId = odi.insert(Constants.OBJ_COMMIT, odi.format(commit));\n                odi.flush();\n                RevWalk revWalk = new RevWalk(repo);\n                try {\n                    RevCommit revCommit = revWalk.parseCommit(commitId);\n                    RefUpdate ru = repo.updateRef(Constants.HEAD);\n                    ru.setNewObjectId(commitId);\n                    ru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(), false);\n                    ru.setExpectedOldObjectId(headId);\n                    Result rc = ru.update();\n                    switch(rc) {\n                        case NEW:\n                        case FAST_FORWARD:\n                            {\n                                setCallable(false);\n                                if (state == RepositoryState.MERGING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeMergeHeads(null);\n                                }\n                                return revCommit;\n                            }\n                        case REJECTED:\n                        case LOCK_FAILURE:\n                            throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                        default:\n                            throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                    }\n                } finally {\n                    revWalk.release();\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw e;\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}"
    },
    {
      "commit": "b46b635c0389e01a55b2f9c490e5b6c54a8ce640",
      "startLine": 3,
      "endLine": 6,
      "methodCode": "public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n    checkCallable();\n    RepositoryState state = repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        if (all && !repo.isBare() && repo.getWorkTree() != null) {\n            Git git = new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId != null)\n            parents.add(0, headId);\n        DirCache index = repo.lockDirCache();\n        try {\n            ObjectInserter odi = repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId = index.writeTree(odi);\n                Commit commit = new Commit();\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents);\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId = odi.insert(Constants.OBJ_COMMIT, odi.format(commit));\n                odi.flush();\n                RevWalk revWalk = new RevWalk(repo);\n                try {\n                    RevCommit revCommit = revWalk.parseCommit(commitId);\n                    RefUpdate ru = repo.updateRef(Constants.HEAD);\n                    ru.setNewObjectId(commitId);\n                    ru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(), false);\n                    ru.setExpectedOldObjectId(headId);\n                    Result rc = ru.update();\n                    switch(rc) {\n                        case NEW:\n                        case FAST_FORWARD:\n                            {\n                                setCallable(false);\n                                if (state == RepositoryState.MERGING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeMergeHeads(null);\n                                }\n                                return revCommit;\n                            }\n                        case REJECTED:\n                        case LOCK_FAILURE:\n                            throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                        default:\n                            throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                    }\n                } finally {\n                    revWalk.release();\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw e;\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}"
    },
    {
      "commit": "ab57af08e83d5d042bb954ad280389b34ca36d0e",
      "startLine": 3,
      "endLine": 6,
      "methodCode": "public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n    checkCallable();\n    RepositoryState state = repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        if (all && !repo.isBare() && repo.getWorkTree() != null) {\n            Git git = new Git(repo);\n            try {\n                git.add().addFilepattern(\".\").setUpdate(true).call();\n            } catch (NoFilepatternException e) {\n                throw new JGitInternalException(e.getMessage(), e);\n            }\n        }\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId != null)\n            parents.add(0, headId);\n        DirCache index = repo.lockDirCache();\n        try {\n            ObjectInserter odi = repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId = index.writeTree(odi);\n                Commit commit = new Commit(repo);\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents.toArray(new ObjectId[] {}));\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId = odi.insert(Constants.OBJ_COMMIT, odi.format(commit));\n                odi.flush();\n                RevWalk revWalk = new RevWalk(repo);\n                try {\n                    RevCommit revCommit = revWalk.parseCommit(commitId);\n                    RefUpdate ru = repo.updateRef(Constants.HEAD);\n                    ru.setNewObjectId(commitId);\n                    ru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(), false);\n                    ru.setExpectedOldObjectId(headId);\n                    Result rc = ru.update();\n                    switch(rc) {\n                        case NEW:\n                        case FAST_FORWARD:\n                            {\n                                setCallable(false);\n                                if (state == RepositoryState.MERGING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeMergeHeads(null);\n                                }\n                                return revCommit;\n                            }\n                        case REJECTED:\n                        case LOCK_FAILURE:\n                            throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                        default:\n                            throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                    }\n                } finally {\n                    revWalk.release();\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw e;\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}"
    },
    {
      "commit": "94207f0a43a44261b8170d3cdba3028059775d9d",
      "startLine": 3,
      "endLine": 6,
      "methodCode": "public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n    checkCallable();\n    RepositoryState state = repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId != null)\n            parents.add(0, headId);\n        DirCache index = repo.lockDirCache();\n        try {\n            ObjectInserter odi = repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId = index.writeTree(odi);\n                Commit commit = new Commit(repo);\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents.toArray(new ObjectId[] {}));\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId = odi.insert(Constants.OBJ_COMMIT, odi.format(commit));\n                odi.flush();\n                RevWalk revWalk = new RevWalk(repo);\n                try {\n                    RevCommit revCommit = revWalk.parseCommit(commitId);\n                    RefUpdate ru = repo.updateRef(Constants.HEAD);\n                    ru.setNewObjectId(commitId);\n                    ru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(), false);\n                    ru.setExpectedOldObjectId(headId);\n                    Result rc = ru.update();\n                    switch(rc) {\n                        case NEW:\n                        case FAST_FORWARD:\n                            {\n                                setCallable(false);\n                                if (state == RepositoryState.MERGING_RESOLVED) {\n                                    repo.writeMergeCommitMsg(null);\n                                    repo.writeMergeHeads(null);\n                                }\n                                return revCommit;\n                            }\n                        case REJECTED:\n                        case LOCK_FAILURE:\n                            throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                        default:\n                            throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                    }\n                } finally {\n                    revWalk.release();\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw e;\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}"
    },
    {
      "commit": "a1d5f5b6b526d086a0963c634a38edb6789a4594",
      "startLine": 3,
      "endLine": 6,
      "methodCode": "public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n    checkCallable();\n    RepositoryState state = repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId != null)\n            parents.add(0, headId);\n        DirCache index = repo.lockDirCache();\n        try {\n            ObjectInserter odi = repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId = index.writeTree(odi);\n                Commit commit = new Commit(repo);\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents.toArray(new ObjectId[] {}));\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId = odi.insert(Constants.OBJ_COMMIT, odi.format(commit));\n                odi.flush();\n                RevWalk revWalk = new RevWalk(repo);\n                try {\n                    RevCommit revCommit = revWalk.parseCommit(commitId);\n                    RefUpdate ru = repo.updateRef(Constants.HEAD);\n                    ru.setNewObjectId(commitId);\n                    ru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(), false);\n                    ru.setExpectedOldObjectId(headId);\n                    Result rc = ru.update();\n                    switch(rc) {\n                        case NEW:\n                        case FAST_FORWARD:\n                            {\n                                setCallable(false);\n                                File meta = repo.getDirectory();\n                                if (state == RepositoryState.MERGING_RESOLVED && meta != null) {\n                                    new File(meta, Constants.MERGE_HEAD).delete();\n                                    new File(meta, Constants.MERGE_MSG).delete();\n                                }\n                                return revCommit;\n                            }\n                        case REJECTED:\n                        case LOCK_FAILURE:\n                            throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                        default:\n                            throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                    }\n                } finally {\n                    revWalk.release();\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw e;\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}"
    },
    {
      "commit": "515deaf7e503738b4c53c3c2dfd6d7acab3bef18",
      "startLine": 3,
      "endLine": 6,
      "methodCode": "public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n    checkCallable();\n    RepositoryState state = repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId != null)\n            parents.add(0, headId);\n        DirCache index = DirCache.lock(repo);\n        try {\n            ObjectInserter odi = repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId = index.writeTree(odi);\n                Commit commit = new Commit(repo);\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents.toArray(new ObjectId[] {}));\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId = odi.insert(Constants.OBJ_COMMIT, odi.format(commit));\n                odi.flush();\n                RevWalk revWalk = new RevWalk(repo);\n                try {\n                    RevCommit revCommit = revWalk.parseCommit(commitId);\n                    RefUpdate ru = repo.updateRef(Constants.HEAD);\n                    ru.setNewObjectId(commitId);\n                    ru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(), false);\n                    ru.setExpectedOldObjectId(headId);\n                    Result rc = ru.update();\n                    switch(rc) {\n                        case NEW:\n                        case FAST_FORWARD:\n                            {\n                                setCallable(false);\n                                File meta = repo.getDirectory();\n                                if (state == RepositoryState.MERGING_RESOLVED && meta != null) {\n                                    new File(meta, Constants.MERGE_HEAD).delete();\n                                    new File(meta, Constants.MERGE_MSG).delete();\n                                }\n                                return revCommit;\n                            }\n                        case REJECTED:\n                        case LOCK_FAILURE:\n                            throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                        default:\n                            throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                    }\n                } finally {\n                    revWalk.release();\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw e;\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}"
    },
    {
      "commit": "ffe0614d4db653cbcd48c19e9f599fd87cdcfaba",
      "startLine": 3,
      "endLine": 6,
      "methodCode": "public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n    checkCallable();\n    RepositoryState state = repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId != null)\n            parents.add(0, headId);\n        DirCache index = DirCache.lock(repo);\n        try {\n            ObjectInserter odi = repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId = index.writeTree(odi);\n                Commit commit = new Commit(repo);\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents.toArray(new ObjectId[] {}));\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId = odi.insert(Constants.OBJ_COMMIT, odi.format(commit));\n                odi.flush();\n                RevCommit revCommit = new RevWalk(repo).parseCommit(commitId);\n                RefUpdate ru = repo.updateRef(Constants.HEAD);\n                ru.setNewObjectId(commitId);\n                ru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(), false);\n                ru.setExpectedOldObjectId(headId);\n                Result rc = ru.update();\n                switch(rc) {\n                    case NEW:\n                    case FAST_FORWARD:\n                        {\n                            setCallable(false);\n                            File meta = repo.getDirectory();\n                            if (state == RepositoryState.MERGING_RESOLVED && meta != null) {\n                                new File(meta, Constants.MERGE_HEAD).delete();\n                                new File(meta, Constants.MERGE_MSG).delete();\n                            }\n                            return revCommit;\n                        }\n                    case REJECTED:\n                    case LOCK_FAILURE:\n                        throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                    default:\n                        throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw e;\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}"
    },
    {
      "commit": "88530a179e2ddfa81de5cc441a27d66521334608",
      "startLine": 3,
      "endLine": 6,
      "methodCode": "public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n    checkCallable();\n    RepositoryState state = repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId != null)\n            parents.add(0, headId);\n        DirCache index = DirCache.lock(repo);\n        try {\n            ObjectInserter odi = repo.newObjectInserter();\n            try {\n                ObjectId indexTreeId = index.writeTree(odi);\n                Commit commit = new Commit(repo);\n                commit.setCommitter(committer);\n                commit.setAuthor(author);\n                commit.setMessage(message);\n                commit.setParentIds(parents.toArray(new ObjectId[] {}));\n                commit.setTreeId(indexTreeId);\n                ObjectId commitId = odi.insert(Constants.OBJ_COMMIT, odi.format(commit));\n                odi.flush();\n                RevCommit revCommit = new RevWalk(repo).parseCommit(commitId);\n                RefUpdate ru = repo.updateRef(Constants.HEAD);\n                ru.setNewObjectId(commitId);\n                ru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(), false);\n                ru.setExpectedOldObjectId(headId);\n                Result rc = ru.update();\n                switch(rc) {\n                    case NEW:\n                    case FAST_FORWARD:\n                        setCallable(false);\n                        if (state == RepositoryState.MERGING_RESOLVED) {\n                            new File(repo.getDirectory(), Constants.MERGE_HEAD).delete();\n                            new File(repo.getDirectory(), Constants.MERGE_MSG).delete();\n                        }\n                        return revCommit;\n                    case REJECTED:\n                    case LOCK_FAILURE:\n                        throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                    default:\n                        throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n                }\n            } finally {\n                odi.release();\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw e;\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}"
    },
    {
      "commit": "6ca9843f3ebbea152969a8b795efce1d4ff15dbf",
      "startLine": 3,
      "endLine": 6,
      "methodCode": "public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {\n    checkCallable();\n    RepositoryState state = repo.getRepositoryState();\n    if (!state.canCommit())\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState, state.name()));\n    processOptions(state);\n    try {\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n        if (headId != null)\n            parents.add(0, headId);\n        DirCache index = DirCache.lock(repo);\n        try {\n            ObjectWriter repoWriter = new ObjectWriter(repo);\n            ObjectId indexTreeId = index.writeTree(repoWriter);\n            Commit commit = new Commit(repo);\n            commit.setCommitter(committer);\n            commit.setAuthor(author);\n            commit.setMessage(message);\n            commit.setParentIds(parents.toArray(new ObjectId[] {}));\n            commit.setTreeId(indexTreeId);\n            ObjectId commitId = repoWriter.writeCommit(commit);\n            RevCommit revCommit = new RevWalk(repo).parseCommit(commitId);\n            RefUpdate ru = repo.updateRef(Constants.HEAD);\n            ru.setNewObjectId(commitId);\n            ru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(), false);\n            ru.setExpectedOldObjectId(headId);\n            Result rc = ru.update();\n            switch(rc) {\n                case NEW:\n                case FAST_FORWARD:\n                    setCallable(false);\n                    if (state == RepositoryState.MERGING_RESOLVED) {\n                        new File(repo.getDirectory(), Constants.MERGE_HEAD).delete();\n                        new File(repo.getDirectory(), Constants.MERGE_MSG).delete();\n                    }\n                    return revCommit;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw e;\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}"
    },
    {
      "commit": "f3d8a8ecad614906a2c4ec0077cdb24129da6c6d",
      "startLine": 3,
      "endLine": 3,
      "methodCode": "public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException {\n    checkCallable();\n    processOptions();\n    try {\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n        ObjectId parentID = repo.resolve(Constants.HEAD + \"^{commit}\");\n        DirCache index = DirCache.lock(repo);\n        try {\n            ObjectWriter repoWriter = new ObjectWriter(repo);\n            ObjectId indexTreeId = index.writeTree(repoWriter);\n            Commit commit = new Commit(repo);\n            commit.setCommitter(committer);\n            commit.setAuthor(author);\n            commit.setMessage(message);\n            if (parentID != null)\n                commit.setParentIds(new ObjectId[] { parentID });\n            commit.setTreeId(indexTreeId);\n            ObjectId commitId = repoWriter.writeCommit(commit);\n            RevCommit revCommit = new RevWalk(repo).parseCommit(commitId);\n            RefUpdate ru = repo.updateRef(Constants.HEAD);\n            ru.setNewObjectId(commitId);\n            ru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(), false);\n            ru.setExpectedOldObjectId(parentID);\n            Result rc = ru.update();\n            switch(rc) {\n                case NEW:\n                case FAST_FORWARD:\n                    setCallable(false);\n                    return revCommit;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.toString(), rc));\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw e;\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n    }\n}"
    },
    {
      "commit": "f3fb5824ba45197787bc4ffb81fafcd576c60291",
      "startLine": 3,
      "endLine": 3,
      "methodCode": "public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException {\n    checkCallable();\n    processOptions();\n    try {\n        Ref head = repo.getRef(Constants.HEAD);\n        if (head == null)\n            throw new NoHeadException(\"Commit on repo without HEAD currently not supported\");\n        ObjectId parentID = repo.resolve(Constants.HEAD + \"^{commit}\");\n        DirCache index = DirCache.lock(repo);\n        try {\n            ObjectWriter repoWriter = new ObjectWriter(repo);\n            ObjectId indexTreeId = index.writeTree(repoWriter);\n            Commit commit = new Commit(repo);\n            commit.setCommitter(committer);\n            commit.setAuthor(author);\n            commit.setMessage(message);\n            if (parentID != null)\n                commit.setParentIds(new ObjectId[] { parentID });\n            commit.setTreeId(indexTreeId);\n            ObjectId commitId = repoWriter.writeCommit(commit);\n            RevCommit revCommit = new RevWalk(repo).parseCommit(commitId);\n            RefUpdate ru = repo.updateRef(Constants.HEAD);\n            ru.setNewObjectId(commitId);\n            ru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(), false);\n            ru.setExpectedOldObjectId(parentID);\n            Result rc = ru.update();\n            switch(rc) {\n                case NEW:\n                case FAST_FORWARD:\n                    setCallable(false);\n                    return revCommit;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(\"Could lock HEAD during commit\", ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(\"Updating the ref \" + Constants.HEAD + \" to \" + commitId.toString() + \" failed. ReturnCode from RefUpdate.update() was \" + rc);\n            }\n        } finally {\n            index.unlock();\n        }\n    } catch (UnmergedPathException e) {\n        throw e;\n    } catch (IOException e) {\n        throw new JGitInternalException(\"Exception caught during execution of commit command\", e);\n    }\n}"
    }
  ]
}